{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Eclipse OpenJ9 Welcome to the user documentation for the Eclipse OpenJ9\u2122 virtual machine (VM). This user documentation supports the configuration, tuning, and diagnosis of the OpenJ9 VM in an OpenJDK runtime. However, due to differences between the Java SE class libraries, specific options might apply only to one Java SE version. Icons are used to indicate where differences apply. For example: This sentence applies only to Java 11 binaries that include the OpenJ9 VM. Icons for LTS releases are this colour. This sentence applies only to Java 16 or later binaries that include the OpenJ9 VM. Icons for feature releases are this colour. To see which Java releases are LTS releases and which are feature releases, and for information about release cadence, supported platforms, and build environments, see Supported environments . Note: Documentation to support OpenJ9 is still under construction. The current content covers some high level information about OpenJ9 components together with the command-line options and environment variables that you can use to configure the VM when you start your application. Because OpenJ9 was contributed to the Eclipse Foundation by IBM, this content contains some links to additional information that forms part of the IBM\u00ae SDK, Java\u2122 Technology Edition product documentation in IBM Documentation. That content supplements the documentation here until a more complete set of user documentation is available. We welcome contributions to the user documentation. If you would like to get involved, please read our Contribution guidelines . If you spot any errors in the documentation, please raise an issue at our GitHub repository. Supported environments OpenJDK binaries that contain the OpenJ9 VM are supported on a range of hardware and operating systems. This range is expanding as work progresses at the Eclipse foundation. See the current list of supported environments for details. Note: This user guide also contains information about configuring, tuning, and debugging OpenJ9 on the z/OS\u00ae platform. Documentation for specific releases Several versions of the documentation are available, covering all releases of OpenJ9: Online documentation for the last release Online, in-progress documentation for the forthcoming release Downloads of earlier releases : to download a zip file, click the filename, then click Download . After downloading a .zip file, extract it, then open the index.html file in your browser. Useful links Eclipse OpenJ9 website home page Eclipse OpenJ9 GitHub repository Eclipse Foundation OpenJ9 project page","title":"About the docs"},{"location":"#eclipse-openj9","text":"Welcome to the user documentation for the Eclipse OpenJ9\u2122 virtual machine (VM). This user documentation supports the configuration, tuning, and diagnosis of the OpenJ9 VM in an OpenJDK runtime. However, due to differences between the Java SE class libraries, specific options might apply only to one Java SE version. Icons are used to indicate where differences apply. For example: This sentence applies only to Java 11 binaries that include the OpenJ9 VM. Icons for LTS releases are this colour. This sentence applies only to Java 16 or later binaries that include the OpenJ9 VM. Icons for feature releases are this colour. To see which Java releases are LTS releases and which are feature releases, and for information about release cadence, supported platforms, and build environments, see Supported environments . Note: Documentation to support OpenJ9 is still under construction. The current content covers some high level information about OpenJ9 components together with the command-line options and environment variables that you can use to configure the VM when you start your application. Because OpenJ9 was contributed to the Eclipse Foundation by IBM, this content contains some links to additional information that forms part of the IBM\u00ae SDK, Java\u2122 Technology Edition product documentation in IBM Documentation. That content supplements the documentation here until a more complete set of user documentation is available. We welcome contributions to the user documentation. If you would like to get involved, please read our Contribution guidelines . If you spot any errors in the documentation, please raise an issue at our GitHub repository.","title":"Eclipse OpenJ9"},{"location":"#supported-environments","text":"OpenJDK binaries that contain the OpenJ9 VM are supported on a range of hardware and operating systems. This range is expanding as work progresses at the Eclipse foundation. See the current list of supported environments for details. Note: This user guide also contains information about configuring, tuning, and debugging OpenJ9 on the z/OS\u00ae platform.","title":"Supported environments"},{"location":"#documentation-for-specific-releases","text":"Several versions of the documentation are available, covering all releases of OpenJ9: Online documentation for the last release Online, in-progress documentation for the forthcoming release Downloads of earlier releases : to download a zip file, click the filename, then click Download . After downloading a .zip file, extract it, then open the index.html file in your browser.","title":"Documentation for specific releases"},{"location":"#useful-links","text":"Eclipse OpenJ9 website home page Eclipse OpenJ9 GitHub repository Eclipse Foundation OpenJ9 project page","title":"Useful links"},{"location":"allocation/","text":"Heap allocation The process of managing memory in the VM is handled by the allocator and the garbage collector. These components operate on an area of memory that is reserved for VM processing called the Java\u2122 heap. The allocator assigns areas of the heap for Java objects. Objects are considered as live when they have a chain of references to them that start from root references, such as those found in thread stacks. When that reference or pointer no longer exists, the objects are considered as garbage . The garbage collector reclaims memory by removing objects when they are no longer required. To find out more about the garbage collector, see Garbage collection . Depending on your application workload or service level agreement, you can choose from a number of Eclipse OpenJ9\u2122 garbage collection (GC) policies . Each GC policy uses a different strategy to manage memory on the heap. The structure of the heap also depends on the strategy in force. For more information about choosing a GC policy, see Garbage collection policies . The allocator The allocator manages pools of free memory and how the free memory is consumed. It is also responsible for allocating areas of storage in the Java heap for objects at the request of applications, class libraries, or the VM. In general, allocation requires a heap lock to synchronize concurrent threads that try to access the same area of memory at the same time. When an object is allocated, the heap lock is released. If there is insufficient space to allocate the object, allocation fails, the heap lock is released, and the garbage collector is called. If GC manages to recover some space on the heap, the allocator can resume operations. If GC does not recover enough space, it returns an OutOfMemoryError exception. Acquiring a heap lock for every allocation would be an intensive operation with an impact to performance. To get around this problem, small objects are allocated to allocation caches. Allocation caches To improve performance, allocation caches are reserved in the heap for different threads. These allocation caches are known as thread local heaps (TLH) and allow each thread to allocate memory from its cache without acquiring the heap lock. Objects are allocated from the TLH unless there is insufficient space remaining in the TLH to satisfy the request. In this situation, the allocation might proceed directly from the heap for larger objects by using a heap lock or the TLH might be refreshed for smaller objects. If a thread allocates a lot of objects, the allocator gives that thread a larger TLH to reduce contention on the heap lock. A TLH is predefined with an initial default size of 2 KB. On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). The requested size can grow up to a predefined maximum (default 128 KB). If a TLH refresh fails to complete, a GC cycle is triggered. After every GC cycle, the requested size of the TLH for each thread is reduced, sometimes by as much as 50%, to take account of threads that reduce their allocation rate and no longer need large TLHs. For very inactive threads, the requested size can even drop below the initial value, down to the predefined minimum (512/768 bytes). For very active threads, the maximum TLH requested size might be reached before the next GC occurs. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilization and increase heap fragmentation. The following options control the requested TLH size: -Xgc:tlhMaximumSize=<bytes> -Xgc:tlhInitialSize=<bytes> -Xgc:tlhIncrementSize=<bytes> Typically, when the maximum TLH size is increased, you should also increase the increment proportionally, so that active threads can reach the maximum requested TLH size more quickly. Heap configuration Depending on the memory management strategy in force, the Java heap can be configured in a number of ways. The simplest configuration consists of a single area of memory, often referred to as a flat heap. Other configurations divide the heap into different areas or regions , which might contain objects of different ages (generations) or sizes. Area-based heaps The default GC policy for OpenJ9 uses a heap configuration that is divided into two main areas: the nursery area for new object allocation, and the tenure area for objects that continue to be reachable for a longer period of time. Most objects have short lifecycles and can be reclaimed by the garbage collector more quickly by focusing only on the nursery area. Global GC cycles that cause application pauses in order to clear and defragment the tenure area are less frequent. SOA and LOA All area-based heaps subdivide part of the heap into the Small Object Area (SOA) and the Large Object Area (LOA). The allocator initially attempts to allocate objects in the SOA, regardless of size. If the allocation cannot be satisfied the following actions are possible, depending on object size: If the object is smaller than 64 KB, an allocation failure occurs, which triggers a GC action. If the object is larger than 64 KB, the allocator attempts to allocate the object in the LOA. If the allocation cannot be satisfied, an allocation failure occurs, which triggers a GC action. The GC action that is triggered by the allocation failure depends on the GC policy in force. The overall size of the LOA is calculated when the heap is initialized, and recalculated at the end of each global GC cycle. The garbage collector can expand or contract the LOA, depending on usage, to avoid allocation failures. You can control the size of the LOA by using the -Xloainitial , -Xloaminimum , and -Xloamaximum command line options. If the LOA is not used, the garbage collector contracts the LOA after a few cycles, down to the value of -Xloaminimum . You can also specify -Xnoloa to prevent an LOA being created. An SOA and LOA are used by the OpenJ9 GC policies: gencon , optavgpause , and optthruput . For the gencon policy, the LOA and SOA are contained within the tenure area, which is designated for ageing objects. For more information about policies, see Garbage collection policies . Region-based heaps The Java heap can also be subdivided into multiple regions. The balanced GC policy uses a heap that is divided into thousands of equal size regions in order to manage multiple generations of objects. The metronome GC policy also uses multiple regions, which are grouped by size-class to manage a singe generation of objects. To learn more about how the regions are configured for each policy, see Garbage collection policies . In addition to regions, the balanced and metronome policies use structures called arraylets to store large arrays in the heap. Arraylets A Java heap that is subdivided into regions might not be able to contain a large enough region for data arrays. This problem is solved by using arraylets . An arraylet has a spine , which contains the class pointer and size, and leaves , which contain the data associated with the array. The spine also contains arrayoids , which are pointers to the respective arraylet leaves, as shown in the following diagram. There are a number of advantages to using arraylets. Because the heap tends to fragment over time, some GC policies might be forced to run a global garbage collection and defragmentation (compaction) to recover sufficient contiguous memory to allocate a large array. By removing the requirement for large arrays to be allocated in contiguous memory, the garbage collector is more likely to be able to satisfy such an allocation without requiring unscheduled garbage collection, particularly a global defragmentation operation. Additionally, the garbage collector never needs to move an arraylet leaf once it has been allocated. The cost of relocating an array is therefore limited to the cost of relocating the spine, so large arrays do not contribute to higher defragmentation times. Note: Despite the general advantage of using arraylets, they can slow down processing when the Java Native Interface (JNI) is being used. The JNI provides flexibility by enabling Java programs to call native code; for example, C or C++, and if direct addressability to the inside of an object is needed, a JNI critical section can be used. However, that requires the object to be in a contiguous region of memory, or at least appear to be so. The JNI, therefore, creates a temporary contiguous array that is the same size as the original array and copies everything, element by element, to the temporary array. After the JNI critical section is finished, everything is copied from the temporary array back to the arraylet, element by element. Heap sizing The overall size of the Java heap is determined by two command-line options, -Xms , which sets the initial size of the heap, and -Xmx , which sets the maximum size of the heap. Finer tuning of the heap depends on the heap configuration that is being used by a GC policy. For example, an LOA within the heap can be sized by using the -Xloainitial , -Xloaminimum , and -Xloamaximum command-line options. A nursery area within the heap can be sized by using the -Xmn , -Xmns , and -Xmnx command-line options. For more information about policies and the heap configurations that are used, see GC policies . To determine the values that are in use for the Java heap, use the -verbose:sizes option when you run your Java application. When the Java heap runs out of space, OutOfMemoryError exceptions are generated. If you are confident that your heap settings are appropriate for your application but are still receiving an OutOfMemoryError exception, check the Java dump file that gets automatically generated when the error occurs. A Java dump file can tell you more about what your application was attempting to do at the time of the error. For example, see the Java OutOfMemoryError scenario. Expansion and contraction At startup, the VM allocates a single contiguous area of virtual storage to match the value of -Xmx . By default, this is 25% of the available memory up to a maximum of 25 GB. The actual Java heap size starts at the value set by -Xms and expands automatically, as required, up to the maximum heap size. The VM can also contract the size of the Java heap. Expansion and contraction occur as part of a GC cycle when the VM has exclusive access to the heap. The only GC policy that does not support heap expansion and contraction is the metronome GC policy, where the heap is always fully expanded. Note: On operating systems that support paging, the VM allocates a single contiguous area that matches the value of -Xms . Additional memory is committed as the heap expands by using the paging process. Expansion occurs to maintain free space on the Java heap for object allocation. By default, the heap is expanded to maintain 30% free space, but this proportion can be adjusted by setting one of the following command-line options: -Xminf determines the minimum proportion of the heap that must be free after garbage is removed. -Xmaxf determines the maximum proportion of the heap that must be free after garbage is removed. If expansion is required, the amount of memory that the heap can expand by is controlled by the following command-line options: -Xmine sets the minimum amount that the heap can expand by. -Xmaxe sets the maximum amount that the heap can expand by. The default is unlimited expansion up to the maximum heap size ( -Xmx ). Expansion can also be triggered if more time is being spent on GC processing than is specified by the -Xmaxt option. In this case, the heap expands by an amount that provides 17% more free space, within the limits imposed by the -Xmine and -Xmaxe values. Heap contraction occurs under certain conditions and might be preceded by heap compaction. If the last three GC cycles caused a heap expansion, contraction does not occur. Otherwise, contraction is triggered when the proportion of free heap space that is specified by the -Xmaxf option is reached. The amount of memory to reduce the heap by is calculated to the nearest 1024-byte boundary, down to the minimum size specified for the initial Java heap ( -Xms ). To prevent heap contraction, set the -Xmaxf value to 1 , which sets the maximum free space allowed on the heap to 100%. When the heap contracts, physical memory is not released unless paging is supported by the underlying operating system. balanced GC policy For the balanced GC policy, if the -Xminf / -Xmaxf and/or -Xmint / -Xmaxt criteria are not being met and this results in a heap resize, then the heap resize that occurs, happens only on non-eden heap (similar to how these options apply to tenure part for gencon). The non-eden heap resizing occurs at the end of a GMP cycle, or global collection. At this point, heap resizing decision is made by observing both -Xmint / -Xmaxt and -Xminf / -Xmaxf and comparing them to the appropriate proportion of time spent in GC, and free heap respectively. If either -Xmint / -Xmaxt and/or -Xminf / -Xmaxf criteria are not being met, there is no guarantee that a heap resize will occur. The heap sizing logic is looking at the following two things: if % of time in GC pauses is between -Xmint / -Xmaxt . If it's greater than -Xmaxt , the VM will try to expand the heap, if it's less than -Xmint , then contract it. if % of free heap is between -Xminf / -Xmaxf . If it's too high, i.e. greater than -Xmaxf (too much free), heap size will contract, if too low, i.e. lesser than -Xminf , it will expand. Since these two criteria may be providing opposite recommendations (for example, lots of free memory, but high % of time in GC) causing oscillations in heap size, the balanced GC heap sizing logic finds a balance between these two criteria. Compressed references On 64-bit systems, the VM can use compressed references to decrease the size of Java objects and make better use of the available space in the Java heap. By storing objects in a 32-bit representation, the object size is identical to that in a 32-bit VM, which creates a smaller memory footprint. These 4 byte (32-bit) compressed references are converted to 64-bit values at runtime with minimal overhead. Smaller objects enable larger heap sizes that result in less frequent garbage collection and improve memory cache utilization. Overall, the performance of 64-bit applications that store compressed rather than uncompressed 64-bit object references is significantly improved. Compressed references are used by default when the maximum Java heap size is in the range 0 - 57 GB on AIX\u00ae, Linux\u00ae, and Windows\u00ae systems. The upper limit is also 57 GB on z/OS\u00ae systems that have APAR OA49416 installed (25 GB without APAR OA49416). All GC policies observe these limits except for the metronome policy, which can support a heap size of up to 25 GB only with compressed references. When the VM uses compressed references, classes, threads, and monitors are stored in the lowest 4 GB of address space. However, this area of memory is also used by native libraries, the operating system, and for small Java heaps. If you receive native memory OutOfMemoryError exceptions in the lowest 4 GB when running with compressed references enabled, these errors might result from the lowest 4 GB of address space becoming full. Try specifying a large heap with the -Xmx option, which puts the Java heap into a higher area of address space or using the -Xmcrs option to reserve space in the lowest 4 GB of address space for compressed references. To turn off compressed references, use the -Xnocompressedrefs command-line option.","title":"Heap allocation"},{"location":"allocation/#heap-allocation","text":"The process of managing memory in the VM is handled by the allocator and the garbage collector. These components operate on an area of memory that is reserved for VM processing called the Java\u2122 heap. The allocator assigns areas of the heap for Java objects. Objects are considered as live when they have a chain of references to them that start from root references, such as those found in thread stacks. When that reference or pointer no longer exists, the objects are considered as garbage . The garbage collector reclaims memory by removing objects when they are no longer required. To find out more about the garbage collector, see Garbage collection . Depending on your application workload or service level agreement, you can choose from a number of Eclipse OpenJ9\u2122 garbage collection (GC) policies . Each GC policy uses a different strategy to manage memory on the heap. The structure of the heap also depends on the strategy in force. For more information about choosing a GC policy, see Garbage collection policies .","title":"Heap allocation"},{"location":"allocation/#the-allocator","text":"The allocator manages pools of free memory and how the free memory is consumed. It is also responsible for allocating areas of storage in the Java heap for objects at the request of applications, class libraries, or the VM. In general, allocation requires a heap lock to synchronize concurrent threads that try to access the same area of memory at the same time. When an object is allocated, the heap lock is released. If there is insufficient space to allocate the object, allocation fails, the heap lock is released, and the garbage collector is called. If GC manages to recover some space on the heap, the allocator can resume operations. If GC does not recover enough space, it returns an OutOfMemoryError exception. Acquiring a heap lock for every allocation would be an intensive operation with an impact to performance. To get around this problem, small objects are allocated to allocation caches.","title":"The allocator"},{"location":"allocation/#allocation-caches","text":"To improve performance, allocation caches are reserved in the heap for different threads. These allocation caches are known as thread local heaps (TLH) and allow each thread to allocate memory from its cache without acquiring the heap lock. Objects are allocated from the TLH unless there is insufficient space remaining in the TLH to satisfy the request. In this situation, the allocation might proceed directly from the heap for larger objects by using a heap lock or the TLH might be refreshed for smaller objects. If a thread allocates a lot of objects, the allocator gives that thread a larger TLH to reduce contention on the heap lock. A TLH is predefined with an initial default size of 2 KB. On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). The requested size can grow up to a predefined maximum (default 128 KB). If a TLH refresh fails to complete, a GC cycle is triggered. After every GC cycle, the requested size of the TLH for each thread is reduced, sometimes by as much as 50%, to take account of threads that reduce their allocation rate and no longer need large TLHs. For very inactive threads, the requested size can even drop below the initial value, down to the predefined minimum (512/768 bytes). For very active threads, the maximum TLH requested size might be reached before the next GC occurs. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilization and increase heap fragmentation. The following options control the requested TLH size: -Xgc:tlhMaximumSize=<bytes> -Xgc:tlhInitialSize=<bytes> -Xgc:tlhIncrementSize=<bytes> Typically, when the maximum TLH size is increased, you should also increase the increment proportionally, so that active threads can reach the maximum requested TLH size more quickly.","title":"Allocation caches"},{"location":"allocation/#heap-configuration","text":"Depending on the memory management strategy in force, the Java heap can be configured in a number of ways. The simplest configuration consists of a single area of memory, often referred to as a flat heap. Other configurations divide the heap into different areas or regions , which might contain objects of different ages (generations) or sizes.","title":"Heap configuration"},{"location":"allocation/#area-based-heaps","text":"The default GC policy for OpenJ9 uses a heap configuration that is divided into two main areas: the nursery area for new object allocation, and the tenure area for objects that continue to be reachable for a longer period of time. Most objects have short lifecycles and can be reclaimed by the garbage collector more quickly by focusing only on the nursery area. Global GC cycles that cause application pauses in order to clear and defragment the tenure area are less frequent.","title":"Area-based heaps"},{"location":"allocation/#soa-and-loa","text":"All area-based heaps subdivide part of the heap into the Small Object Area (SOA) and the Large Object Area (LOA). The allocator initially attempts to allocate objects in the SOA, regardless of size. If the allocation cannot be satisfied the following actions are possible, depending on object size: If the object is smaller than 64 KB, an allocation failure occurs, which triggers a GC action. If the object is larger than 64 KB, the allocator attempts to allocate the object in the LOA. If the allocation cannot be satisfied, an allocation failure occurs, which triggers a GC action. The GC action that is triggered by the allocation failure depends on the GC policy in force. The overall size of the LOA is calculated when the heap is initialized, and recalculated at the end of each global GC cycle. The garbage collector can expand or contract the LOA, depending on usage, to avoid allocation failures. You can control the size of the LOA by using the -Xloainitial , -Xloaminimum , and -Xloamaximum command line options. If the LOA is not used, the garbage collector contracts the LOA after a few cycles, down to the value of -Xloaminimum . You can also specify -Xnoloa to prevent an LOA being created. An SOA and LOA are used by the OpenJ9 GC policies: gencon , optavgpause , and optthruput . For the gencon policy, the LOA and SOA are contained within the tenure area, which is designated for ageing objects. For more information about policies, see Garbage collection policies .","title":"SOA and LOA"},{"location":"allocation/#region-based-heaps","text":"The Java heap can also be subdivided into multiple regions. The balanced GC policy uses a heap that is divided into thousands of equal size regions in order to manage multiple generations of objects. The metronome GC policy also uses multiple regions, which are grouped by size-class to manage a singe generation of objects. To learn more about how the regions are configured for each policy, see Garbage collection policies . In addition to regions, the balanced and metronome policies use structures called arraylets to store large arrays in the heap.","title":"Region-based heaps"},{"location":"allocation/#arraylets","text":"A Java heap that is subdivided into regions might not be able to contain a large enough region for data arrays. This problem is solved by using arraylets . An arraylet has a spine , which contains the class pointer and size, and leaves , which contain the data associated with the array. The spine also contains arrayoids , which are pointers to the respective arraylet leaves, as shown in the following diagram. There are a number of advantages to using arraylets. Because the heap tends to fragment over time, some GC policies might be forced to run a global garbage collection and defragmentation (compaction) to recover sufficient contiguous memory to allocate a large array. By removing the requirement for large arrays to be allocated in contiguous memory, the garbage collector is more likely to be able to satisfy such an allocation without requiring unscheduled garbage collection, particularly a global defragmentation operation. Additionally, the garbage collector never needs to move an arraylet leaf once it has been allocated. The cost of relocating an array is therefore limited to the cost of relocating the spine, so large arrays do not contribute to higher defragmentation times. Note: Despite the general advantage of using arraylets, they can slow down processing when the Java Native Interface (JNI) is being used. The JNI provides flexibility by enabling Java programs to call native code; for example, C or C++, and if direct addressability to the inside of an object is needed, a JNI critical section can be used. However, that requires the object to be in a contiguous region of memory, or at least appear to be so. The JNI, therefore, creates a temporary contiguous array that is the same size as the original array and copies everything, element by element, to the temporary array. After the JNI critical section is finished, everything is copied from the temporary array back to the arraylet, element by element.","title":"Arraylets"},{"location":"allocation/#heap-sizing","text":"The overall size of the Java heap is determined by two command-line options, -Xms , which sets the initial size of the heap, and -Xmx , which sets the maximum size of the heap. Finer tuning of the heap depends on the heap configuration that is being used by a GC policy. For example, an LOA within the heap can be sized by using the -Xloainitial , -Xloaminimum , and -Xloamaximum command-line options. A nursery area within the heap can be sized by using the -Xmn , -Xmns , and -Xmnx command-line options. For more information about policies and the heap configurations that are used, see GC policies . To determine the values that are in use for the Java heap, use the -verbose:sizes option when you run your Java application. When the Java heap runs out of space, OutOfMemoryError exceptions are generated. If you are confident that your heap settings are appropriate for your application but are still receiving an OutOfMemoryError exception, check the Java dump file that gets automatically generated when the error occurs. A Java dump file can tell you more about what your application was attempting to do at the time of the error. For example, see the Java OutOfMemoryError scenario.","title":"Heap sizing"},{"location":"allocation/#expansion-and-contraction","text":"At startup, the VM allocates a single contiguous area of virtual storage to match the value of -Xmx . By default, this is 25% of the available memory up to a maximum of 25 GB. The actual Java heap size starts at the value set by -Xms and expands automatically, as required, up to the maximum heap size. The VM can also contract the size of the Java heap. Expansion and contraction occur as part of a GC cycle when the VM has exclusive access to the heap. The only GC policy that does not support heap expansion and contraction is the metronome GC policy, where the heap is always fully expanded. Note: On operating systems that support paging, the VM allocates a single contiguous area that matches the value of -Xms . Additional memory is committed as the heap expands by using the paging process. Expansion occurs to maintain free space on the Java heap for object allocation. By default, the heap is expanded to maintain 30% free space, but this proportion can be adjusted by setting one of the following command-line options: -Xminf determines the minimum proportion of the heap that must be free after garbage is removed. -Xmaxf determines the maximum proportion of the heap that must be free after garbage is removed. If expansion is required, the amount of memory that the heap can expand by is controlled by the following command-line options: -Xmine sets the minimum amount that the heap can expand by. -Xmaxe sets the maximum amount that the heap can expand by. The default is unlimited expansion up to the maximum heap size ( -Xmx ). Expansion can also be triggered if more time is being spent on GC processing than is specified by the -Xmaxt option. In this case, the heap expands by an amount that provides 17% more free space, within the limits imposed by the -Xmine and -Xmaxe values. Heap contraction occurs under certain conditions and might be preceded by heap compaction. If the last three GC cycles caused a heap expansion, contraction does not occur. Otherwise, contraction is triggered when the proportion of free heap space that is specified by the -Xmaxf option is reached. The amount of memory to reduce the heap by is calculated to the nearest 1024-byte boundary, down to the minimum size specified for the initial Java heap ( -Xms ). To prevent heap contraction, set the -Xmaxf value to 1 , which sets the maximum free space allowed on the heap to 100%. When the heap contracts, physical memory is not released unless paging is supported by the underlying operating system.","title":"Expansion and contraction"},{"location":"allocation/#balanced-gc-policy","text":"For the balanced GC policy, if the -Xminf / -Xmaxf and/or -Xmint / -Xmaxt criteria are not being met and this results in a heap resize, then the heap resize that occurs, happens only on non-eden heap (similar to how these options apply to tenure part for gencon). The non-eden heap resizing occurs at the end of a GMP cycle, or global collection. At this point, heap resizing decision is made by observing both -Xmint / -Xmaxt and -Xminf / -Xmaxf and comparing them to the appropriate proportion of time spent in GC, and free heap respectively. If either -Xmint / -Xmaxt and/or -Xminf / -Xmaxf criteria are not being met, there is no guarantee that a heap resize will occur. The heap sizing logic is looking at the following two things: if % of time in GC pauses is between -Xmint / -Xmaxt . If it's greater than -Xmaxt , the VM will try to expand the heap, if it's less than -Xmint , then contract it. if % of free heap is between -Xminf / -Xmaxf . If it's too high, i.e. greater than -Xmaxf (too much free), heap size will contract, if too low, i.e. lesser than -Xminf , it will expand. Since these two criteria may be providing opposite recommendations (for example, lots of free memory, but high % of time in GC) causing oscillations in heap size, the balanced GC heap sizing logic finds a balance between these two criteria.","title":"balanced GC policy"},{"location":"allocation/#compressed-references","text":"On 64-bit systems, the VM can use compressed references to decrease the size of Java objects and make better use of the available space in the Java heap. By storing objects in a 32-bit representation, the object size is identical to that in a 32-bit VM, which creates a smaller memory footprint. These 4 byte (32-bit) compressed references are converted to 64-bit values at runtime with minimal overhead. Smaller objects enable larger heap sizes that result in less frequent garbage collection and improve memory cache utilization. Overall, the performance of 64-bit applications that store compressed rather than uncompressed 64-bit object references is significantly improved. Compressed references are used by default when the maximum Java heap size is in the range 0 - 57 GB on AIX\u00ae, Linux\u00ae, and Windows\u00ae systems. The upper limit is also 57 GB on z/OS\u00ae systems that have APAR OA49416 installed (25 GB without APAR OA49416). All GC policies observe these limits except for the metronome policy, which can support a heap size of up to 25 GB only with compressed references. When the VM uses compressed references, classes, threads, and monitors are stored in the lowest 4 GB of address space. However, this area of memory is also used by native libraries, the operating system, and for small Java heaps. If you receive native memory OutOfMemoryError exceptions in the lowest 4 GB when running with compressed references enabled, these errors might result from the lowest 4 GB of address space becoming full. Try specifying a large heap with the -Xmx option, which puts the Java heap into a higher area of address space or using the -Xmcrs option to reserve space in the lowest 4 GB of address space for compressed references. To turn off compressed references, use the -Xnocompressedrefs command-line option.","title":"Compressed references"},{"location":"aot/","text":"Ahead-Of-Time (AOT) compiler The AOT compiler dynamically compiles Java methods into native AOT code at runtime and stores them in the shared classes cache. This activity enables the VM to start an application faster the next time it runs because it doesn't need to spend time interpreting Java methods. The VM automatically chooses which methods should be AOT-compiled based on heuristics that identify the start-up phase of large applications. AOT code is always used in combination with class data sharing and is enabled automatically when -Xshareclasses is set on the command line. When a cached AOT method is run it might also be optimized further by the Just-In-Time (JIT) compiler. If you want to turn off AOT compilation and disable the use of AOT-compiled code, set the -Xnoaot suboption. When the AOT compiler is disabled, the JIT compiles frequently used methods into native code. However, because the JIT compiler operates while the application is running, the startup time for an application will increase. See also Diagnosing a JIT or AOT problem JIT compiler Introduction to class data sharing","title":"AOT Compiler"},{"location":"aot/#ahead-of-time-aot-compiler","text":"The AOT compiler dynamically compiles Java methods into native AOT code at runtime and stores them in the shared classes cache. This activity enables the VM to start an application faster the next time it runs because it doesn't need to spend time interpreting Java methods. The VM automatically chooses which methods should be AOT-compiled based on heuristics that identify the start-up phase of large applications. AOT code is always used in combination with class data sharing and is enabled automatically when -Xshareclasses is set on the command line. When a cached AOT method is run it might also be optimized further by the Just-In-Time (JIT) compiler. If you want to turn off AOT compilation and disable the use of AOT-compiled code, set the -Xnoaot suboption. When the AOT compiler is disabled, the JIT compiles frequently used methods into native code. However, because the JIT compiler operates while the application is running, the startup time for an application will increase.","title":"Ahead-Of-Time (AOT) compiler"},{"location":"aot/#see-also","text":"Diagnosing a JIT or AOT problem JIT compiler Introduction to class data sharing","title":"See also"},{"location":"api-conditionhandling/","text":"Condition Handling API documentation","title":"Condition exception handling"},{"location":"api-conditionhandling/#condition-handling-api-documentation","text":"","title":"Condition Handling API documentation"},{"location":"api-cuda/","text":"CUDA4J API documentation","title":"CUDA4J"},{"location":"api-cuda/#cuda4j-api-documentation","text":"","title":"CUDA4J API documentation"},{"location":"api-daa/","text":"Data access acceleration API documentation","title":"Data access acceleration"},{"location":"api-daa/#data-access-acceleration-api-documentation","text":"","title":"Data access acceleration API documentation"},{"location":"api-dtfj/","text":"DTFJ API documentation","title":"DTFJ"},{"location":"api-dtfj/#dtfj-api-documentation","text":"","title":"DTFJ API documentation"},{"location":"api-gpu/","text":"GPU API documentation","title":"GPU"},{"location":"api-gpu/#gpu-api-documentation","text":"","title":"GPU API documentation"},{"location":"api-jdk11/","text":"OpenJ9 JDK 11 API documentation","title":"Java 11 API"},{"location":"api-jdk11/#openj9-jdk-11-api-documentation","text":"","title":"OpenJ9 JDK 11 API documentation"},{"location":"api-jdk17/","text":"OpenJ9 JDK 17 API documentation","title":"Java 17 API"},{"location":"api-jdk17/#openj9-jdk-17-api-documentation","text":"","title":"OpenJ9 JDK 17 API documentation"},{"location":"api-jvm/","text":"JVM diagnostic utilities API documentation","title":"JVM diagnostic utilities"},{"location":"api-jvm/#jvm-diagnostic-utilities-api-documentation","text":"","title":"JVM diagnostic utilities API documentation"},{"location":"api-langmgmt/","text":"Monitoring and management API documentation","title":"Monitoring and management"},{"location":"api-langmgmt/#monitoring-and-management-api-documentation","text":"","title":"Monitoring and management API documentation"},{"location":"api-overview/","text":"API documentation The Eclipse OpenJ9\u2122 VM provides supplementary application programming interfaces and extensions, which can be used to improve performance, assist with problem determination, or help monitor and manage the OpenJ9 VM. The documentation also includes links to the API documentation for the Java\u2122 SE and JDK reference implementation. Native data operations If your Java application manipulates native data, the Data Access Accelerator API package ( com.ibm.dataaccess ) can help improve application performance. Classes are available for the following types of operation: performing arithmetic, comparison, and validation of packed decimal data converting between decimal data types as well as to and from BigDecimal and BigInteger types marshalling Java binary types to and from byte arrays GPU acceleration You can improve the performance of your applications by offloading certain processing functions from your processor (CPU) to a graphics processing unit (GPU). If your application contains code that would benefit from parallel processing, you can use the CUDA4J API package ( com.ibm.cuda ) to specify in your code when to offload processing to the GPU. You can also use the GPU API package ( com.ibm.gpu ) to accelerate certain Java functions, such as sort operations. Problem determination The JVM diagnostic utilities API package ( com.ibm.jvm ) provides classes for controlling dump, log, and trace operations. The Diagnostic Tool Framework for Java (DTFJ) API packages ( com.ibm.dtfj.* ) allow custom applications to be written that can access a wide range of information in a system dump or a Java dump. Monitoring and management The shared classes API package ( com.ibm.oti.shared ) provides a large number of classes for managing permissions, finding and storing classes and byte data, and obtaining statistics about a shared classes cache. Classes are also available to enable class sharing for a custom class loader implementation. OpenJ9 includes MXBean extensions to the java.lang.management API ( com.ibm.lang.management and openj9.lang.management ), which can be used to monitor and manage the VM. These extensions provide access to information about the state of the OpenJ9 VM and the environment in which it is running.","title":"Overview"},{"location":"api-overview/#api-documentation","text":"The Eclipse OpenJ9\u2122 VM provides supplementary application programming interfaces and extensions, which can be used to improve performance, assist with problem determination, or help monitor and manage the OpenJ9 VM. The documentation also includes links to the API documentation for the Java\u2122 SE and JDK reference implementation.","title":"API documentation"},{"location":"api-overview/#native-data-operations","text":"If your Java application manipulates native data, the Data Access Accelerator API package ( com.ibm.dataaccess ) can help improve application performance. Classes are available for the following types of operation: performing arithmetic, comparison, and validation of packed decimal data converting between decimal data types as well as to and from BigDecimal and BigInteger types marshalling Java binary types to and from byte arrays","title":"Native data operations"},{"location":"api-overview/#gpu-acceleration","text":"You can improve the performance of your applications by offloading certain processing functions from your processor (CPU) to a graphics processing unit (GPU). If your application contains code that would benefit from parallel processing, you can use the CUDA4J API package ( com.ibm.cuda ) to specify in your code when to offload processing to the GPU. You can also use the GPU API package ( com.ibm.gpu ) to accelerate certain Java functions, such as sort operations.","title":"GPU acceleration"},{"location":"api-overview/#problem-determination","text":"The JVM diagnostic utilities API package ( com.ibm.jvm ) provides classes for controlling dump, log, and trace operations. The Diagnostic Tool Framework for Java (DTFJ) API packages ( com.ibm.dtfj.* ) allow custom applications to be written that can access a wide range of information in a system dump or a Java dump.","title":"Problem determination"},{"location":"api-overview/#monitoring-and-management","text":"The shared classes API package ( com.ibm.oti.shared ) provides a large number of classes for managing permissions, finding and storing classes and byte data, and obtaining statistics about a shared classes cache. Classes are also available to enable class sharing for a custom class loader implementation. OpenJ9 includes MXBean extensions to the java.lang.management API ( com.ibm.lang.management and openj9.lang.management ), which can be used to monitor and manage the VM. These extensions provide access to information about the state of the OpenJ9 VM and the environment in which it is running.","title":"Monitoring and management"},{"location":"api-shrc/","text":"Shared classes API documentation","title":"Shared classes"},{"location":"api-shrc/#shared-classes-api-documentation","text":"","title":"Shared classes API documentation"},{"location":"attachapi/","text":"Java Attach API With the Attach API, your application can connect to a running VM and load an agent into that VM to run tasks. The typical use case for this feature is to load an agent that can be used to monitor the application that's running in the target VM. For example, if you wanted to start monitoring an application that is already running with the Attach API enabled, you could use a tool such as the IBM Health Center . In this case, a Health Center agent can start in its own VM and attach to the target VM where the application is running to start recording and sending data to the Health Center client. The Eclipse OpenJ9\u2122 implementation of the Attach API is equivalent to the reference implementation (API documentation is available on the Oracle website ). However, you can only use the Attach API to connect to another OpenJ9 VM. When you run a Java\u2122 application, VM support for the Attach API is enabled by default on all platforms except z/OS\u00ae. For security reasons on z/OS, processes that use the default z/OS OMVS segment cannot enable the Attach API. To enable or disable the Attach API, use the -Dcom.ibm.tools.attach.enable=[yes|no] command line option. Securing the Attach API Because the Attach API can be used to connect to a running application, you must control access to it to ensure that only authorized users or processes can use it. Disable the Attach API if you do not intend to use it. On Windows systems, the Attach API uses the system temporary directory, which is typically C:\\Users\\<USERNAME>\\AppData\\Local\\Temp . The Attach API creates a common subdirectory, which is .com_ibm_tools_attach by default. Because files and directories in the system temporary directory are handled by Windows security, only the process owner can connect to their processes. On UNIX systems, the Attach API uses /tmp and creates a common subdirectory, which is .com_ibm_tools_attach by default. The common subdirectory must be on a local drive, not a network drive. Security is handled by POSIX file permissions. The Attach API directory must be owned by root user and must have read, write, and execute file permissions for user , group , and other ( drwxrwxrwx ). The sticky bit is set so that only the owner and root can delete or rename files or directories within it. A process using the Java Attach API must be owned by the same UNIX user ID as the target process. ~/tmp $ ls -al total 0 drwxr-xr-x 3 user_a staff 96 6 Aug 17:11 . drwxr-xr-x+ 89 user_a staff 2848 6 Aug 17:11 .. drwxrwxrwx+ 7 root staff 224 6 Aug 17:22 .com_ibm_tools_attach In the default Attach API directory you can find certain files that start with an underscore _* , which are involved in synchronization. These files can be owned by any user but must have read and write permissions set. The files are empty and are automatically re-created if deleted. When your application attaches to a VM, a process directory is created. ~/tmp/.com_ibm_tools_attach $ ls -l total 3 -rw-rw-rw- 1 user_a staff 0 6 Aug 17:12 _attach_lock -rw-rw-rw- 1 user_a staff 0 6 Aug 17:12 _controller -rw-rw-rw- 1 user_a staff 0 6 Aug 17:12 _notifier drwx--x--x 6 user_b staff 192 6 Aug 17:21 process_a The files in the subdirectory for a process, with the exception of a lock file, are accessible only by the owner of a process. The permissions for these files are rwxr-xr-x with the exception of the attachNotificationSync file, as shown in the following example. ~/tmp/.com_ibm_tools_attach/process_a $ ls -l total 4 -rwxrw-rw- 1 user_b staff 0 6 Aug 17:18 attachNotificationSync -rwxr-xr-x 1 user_b staff 0 6 Aug 17:21 file_a -rwxr-xr-x 1 user_b staff 0 6 Aug 17:21 file_b -rwxr-xr-x 1 user_b staff 0 6 Aug 17:21 file_c Notes for z/OS: z/OS systems must also set POSIX permissions on files and cannot rely on RACF\u00ae or system level security to protect applications. To avoid z/OS console messages reporting security violations in /tmp , add a security exception or specify a different common subdirectory by setting the com.ibm.tools.attach.directory system property. Configuring A number of system properties are available to configure the Attach API when you start a Java application, as shown in the following table: System property Description -Dcom.ibm.tools.attach.directory=<directory_name> Specify a different common directory for Attach API working files. -Dcom.ibm.tools.attach.displayName=<my_display_name> Change the display name recorded by an agent -Dcom.ibm.tools.attach.id=<my_vm_ID> Change the VM identifier recorded by an agent -Dcom.ibm.tools.attach.timeout=<value_in_milliseconds> Change the connection timeout -Dcom.ibm.tools.attach.shutdown_timeout=<value_in_milliseconds> Specify the timeout for ending the Attach API wait loop thread -Dcom.ibm.tools.attach.command_timeout=<value_in_milliseconds> Specify the timeout for sending a command to the target VM after initial attachment To learn more about each property, click the link in the table. Troubleshooting Problems with the Attach API generate one of the following exceptions: com.sun.tools.attach.AgentLoadException com.sun.tools.attach.AgentInitializationException com.sun.tools.attach.AgentNotSupportedException com.sun.tools.attach.AttachOperationFailedException java.io.IOException Exceptions from agents on the target VM go to stderr or stdout for the target VM. These exceptions are not reported in the output of the attaching VM. Here are some problems that you might encounter: On Unix systems, the file permissions are incorrectly set, causing access issues. Resolve these issues by reading and complying with Securing the Attach API . Also check that the Attach API is not disabled. The common directory is deleted, the contents of the common directory are deleted, or permissions of the common directory or subdirectories are changed. As a result, the source VM might not be able list target VMs or attach to them. Deletion of the common directory can also cause semaphore leaks. The system temporary directory is full or inaccessible and the Attach API cannot initialize. Try specifying a different directory in which to create the common subdirectory by using the -Dcom.ibm.tools.attach.directory system property. A short delay between the start of the target VM and the initialization of the Attach API process can cause an AttachNotSupportedException: No provider for virtual machine id issue when the VirtualMachine.attach(String id) method is called. The target process is overloaded, suspended, or no longer running, or the port that is used to connect to the target is subject to a wait time (use the netstat -a command to check for ports in the TIME_WAIT state). These situations can cause an AttachNotSupportedException when the attach method is called. A JVMTI agent is corrupt or attempts to run an operation that is not available after the VM starts. These situations can cause an AgentLoadException or AgentInitializationException when one of the following methods is called: loadAgent() , loadAgentLibrary() , or loadAgentPath() . Depending on the method invoked, try loading the agent at VM startup by using one of the following command-line options -javaagent , -agentlib , or -agentpath . For more information about these options, see Java Virtual Machine Tool Interface . If you have checked for these potential issues but you are still experiencing problems, a number of command line system properties are available to help narrow down the cause. These options are shown in the following table: System property Description -Dcom.ibm.tools.attach.logging=<yes|no> Turn on tracing of attach API events -Dcom.ibm.tools.attach.log.name=<my_log_name> Specify the path and prefix for the log files To learn more about each property, click the link in the table.","title":"Java Attach API"},{"location":"attachapi/#java-attach-api","text":"With the Attach API, your application can connect to a running VM and load an agent into that VM to run tasks. The typical use case for this feature is to load an agent that can be used to monitor the application that's running in the target VM. For example, if you wanted to start monitoring an application that is already running with the Attach API enabled, you could use a tool such as the IBM Health Center . In this case, a Health Center agent can start in its own VM and attach to the target VM where the application is running to start recording and sending data to the Health Center client. The Eclipse OpenJ9\u2122 implementation of the Attach API is equivalent to the reference implementation (API documentation is available on the Oracle website ). However, you can only use the Attach API to connect to another OpenJ9 VM. When you run a Java\u2122 application, VM support for the Attach API is enabled by default on all platforms except z/OS\u00ae. For security reasons on z/OS, processes that use the default z/OS OMVS segment cannot enable the Attach API. To enable or disable the Attach API, use the -Dcom.ibm.tools.attach.enable=[yes|no] command line option.","title":"Java Attach API"},{"location":"attachapi/#securing-the-attach-api","text":"Because the Attach API can be used to connect to a running application, you must control access to it to ensure that only authorized users or processes can use it. Disable the Attach API if you do not intend to use it. On Windows systems, the Attach API uses the system temporary directory, which is typically C:\\Users\\<USERNAME>\\AppData\\Local\\Temp . The Attach API creates a common subdirectory, which is .com_ibm_tools_attach by default. Because files and directories in the system temporary directory are handled by Windows security, only the process owner can connect to their processes. On UNIX systems, the Attach API uses /tmp and creates a common subdirectory, which is .com_ibm_tools_attach by default. The common subdirectory must be on a local drive, not a network drive. Security is handled by POSIX file permissions. The Attach API directory must be owned by root user and must have read, write, and execute file permissions for user , group , and other ( drwxrwxrwx ). The sticky bit is set so that only the owner and root can delete or rename files or directories within it. A process using the Java Attach API must be owned by the same UNIX user ID as the target process. ~/tmp $ ls -al total 0 drwxr-xr-x 3 user_a staff 96 6 Aug 17:11 . drwxr-xr-x+ 89 user_a staff 2848 6 Aug 17:11 .. drwxrwxrwx+ 7 root staff 224 6 Aug 17:22 .com_ibm_tools_attach In the default Attach API directory you can find certain files that start with an underscore _* , which are involved in synchronization. These files can be owned by any user but must have read and write permissions set. The files are empty and are automatically re-created if deleted. When your application attaches to a VM, a process directory is created. ~/tmp/.com_ibm_tools_attach $ ls -l total 3 -rw-rw-rw- 1 user_a staff 0 6 Aug 17:12 _attach_lock -rw-rw-rw- 1 user_a staff 0 6 Aug 17:12 _controller -rw-rw-rw- 1 user_a staff 0 6 Aug 17:12 _notifier drwx--x--x 6 user_b staff 192 6 Aug 17:21 process_a The files in the subdirectory for a process, with the exception of a lock file, are accessible only by the owner of a process. The permissions for these files are rwxr-xr-x with the exception of the attachNotificationSync file, as shown in the following example. ~/tmp/.com_ibm_tools_attach/process_a $ ls -l total 4 -rwxrw-rw- 1 user_b staff 0 6 Aug 17:18 attachNotificationSync -rwxr-xr-x 1 user_b staff 0 6 Aug 17:21 file_a -rwxr-xr-x 1 user_b staff 0 6 Aug 17:21 file_b -rwxr-xr-x 1 user_b staff 0 6 Aug 17:21 file_c Notes for z/OS: z/OS systems must also set POSIX permissions on files and cannot rely on RACF\u00ae or system level security to protect applications. To avoid z/OS console messages reporting security violations in /tmp , add a security exception or specify a different common subdirectory by setting the com.ibm.tools.attach.directory system property.","title":"Securing the Attach API"},{"location":"attachapi/#configuring","text":"A number of system properties are available to configure the Attach API when you start a Java application, as shown in the following table: System property Description -Dcom.ibm.tools.attach.directory=<directory_name> Specify a different common directory for Attach API working files. -Dcom.ibm.tools.attach.displayName=<my_display_name> Change the display name recorded by an agent -Dcom.ibm.tools.attach.id=<my_vm_ID> Change the VM identifier recorded by an agent -Dcom.ibm.tools.attach.timeout=<value_in_milliseconds> Change the connection timeout -Dcom.ibm.tools.attach.shutdown_timeout=<value_in_milliseconds> Specify the timeout for ending the Attach API wait loop thread -Dcom.ibm.tools.attach.command_timeout=<value_in_milliseconds> Specify the timeout for sending a command to the target VM after initial attachment To learn more about each property, click the link in the table.","title":"Configuring"},{"location":"attachapi/#troubleshooting","text":"Problems with the Attach API generate one of the following exceptions: com.sun.tools.attach.AgentLoadException com.sun.tools.attach.AgentInitializationException com.sun.tools.attach.AgentNotSupportedException com.sun.tools.attach.AttachOperationFailedException java.io.IOException Exceptions from agents on the target VM go to stderr or stdout for the target VM. These exceptions are not reported in the output of the attaching VM. Here are some problems that you might encounter: On Unix systems, the file permissions are incorrectly set, causing access issues. Resolve these issues by reading and complying with Securing the Attach API . Also check that the Attach API is not disabled. The common directory is deleted, the contents of the common directory are deleted, or permissions of the common directory or subdirectories are changed. As a result, the source VM might not be able list target VMs or attach to them. Deletion of the common directory can also cause semaphore leaks. The system temporary directory is full or inaccessible and the Attach API cannot initialize. Try specifying a different directory in which to create the common subdirectory by using the -Dcom.ibm.tools.attach.directory system property. A short delay between the start of the target VM and the initialization of the Attach API process can cause an AttachNotSupportedException: No provider for virtual machine id issue when the VirtualMachine.attach(String id) method is called. The target process is overloaded, suspended, or no longer running, or the port that is used to connect to the target is subject to a wait time (use the netstat -a command to check for ports in the TIME_WAIT state). These situations can cause an AttachNotSupportedException when the attach method is called. A JVMTI agent is corrupt or attempts to run an operation that is not available after the VM starts. These situations can cause an AgentLoadException or AgentInitializationException when one of the following methods is called: loadAgent() , loadAgentLibrary() , or loadAgentPath() . Depending on the method invoked, try loading the agent at VM startup by using one of the following command-line options -javaagent , -agentlib , or -agentpath . For more information about these options, see Java Virtual Machine Tool Interface . If you have checked for these potential issues but you are still experiencing problems, a number of command line system properties are available to help narrow down the cause. These options are shown in the following table: System property Description -Dcom.ibm.tools.attach.logging=<yes|no> Turn on tracing of attach API events -Dcom.ibm.tools.attach.log.name=<my_log_name> Specify the path and prefix for the log files To learn more about each property, click the link in the table.","title":"Troubleshooting"},{"location":"builds/","text":"Eclipse OpenJ9 builds Eclipse Foundation projects are not permitted to distribute, market or promote JDK binaries unless they have passed a Java SE Technology Compatibility Kit licensed from Oracle, to which the Eclipse OpenJ9\u2122 project does not currently have access. See the Eclipse Adoptium Project Charter . Supported platforms The community develops and maintains a test infrastructure for the OpenJ9 source across a broad range of platforms. For information about the platforms and minimum operating system levels supported, see the Platform support matrix . Building your own binaries If you want to build your own binaries of OpenJDK with OpenJ9, a complete set of build instructions for several platforms can be found in the OpenJ9 GitHub repository . Installation pre-requisites Note the following: For the best performance, OpenSSL support should be enabled in the build. In builds that aren't configured with --enable-openssl-bundling , the OpenSSL library is expected to be found on the system path. If you want to use OpenSSL cryptographic acceleration, you must install OpenSSL 1.0.2, 1.1.X, or 3.0.x (Linux only) on your system. If the library is not found on the system path, the in-built Java crytographic implementation is used instead, which performs less well. On Linux systems, the fontconfig.x86_64 package should be installed to avoid a NullPointerException error when the AWT font subsystem is initialized. From Eclipse OpenJ9 release 0.16.0 (OpenJDK 13) and release 0.17.0 (OpenJDK 8 and 11), CUDA is now enabled on Windows (x86-64) and Linux (x86-64 and IBM POWER LE) platforms, which allows you to offload certain Java application processing tasks to a general purpose graphics processing unit (GPU). To take advantage of this feature, your system must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0.","title":"OpenJ9 builds"},{"location":"builds/#eclipse-openj9-builds","text":"Eclipse Foundation projects are not permitted to distribute, market or promote JDK binaries unless they have passed a Java SE Technology Compatibility Kit licensed from Oracle, to which the Eclipse OpenJ9\u2122 project does not currently have access. See the Eclipse Adoptium Project Charter .","title":"Eclipse OpenJ9 builds"},{"location":"builds/#supported-platforms","text":"The community develops and maintains a test infrastructure for the OpenJ9 source across a broad range of platforms. For information about the platforms and minimum operating system levels supported, see the Platform support matrix .","title":"Supported platforms"},{"location":"builds/#building-your-own-binaries","text":"If you want to build your own binaries of OpenJDK with OpenJ9, a complete set of build instructions for several platforms can be found in the OpenJ9 GitHub repository .","title":"Building your own binaries"},{"location":"builds/#installation-pre-requisites","text":"Note the following: For the best performance, OpenSSL support should be enabled in the build. In builds that aren't configured with --enable-openssl-bundling , the OpenSSL library is expected to be found on the system path. If you want to use OpenSSL cryptographic acceleration, you must install OpenSSL 1.0.2, 1.1.X, or 3.0.x (Linux only) on your system. If the library is not found on the system path, the in-built Java crytographic implementation is used instead, which performs less well. On Linux systems, the fontconfig.x86_64 package should be installed to avoid a NullPointerException error when the AWT font subsystem is initialized. From Eclipse OpenJ9 release 0.16.0 (OpenJDK 13) and release 0.17.0 (OpenJDK 8 and 11), CUDA is now enabled on Windows (x86-64) and Linux (x86-64 and IBM POWER LE) platforms, which allows you to offload certain Java application processing tasks to a general purpose graphics processing unit (GPU). To take advantage of this feature, your system must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0.","title":"Installation pre-requisites"},{"location":"cmdline_general/","text":"Standard command-line options The Eclipse OpenJ9\u2122 virtual machine supports the standard Java\u2122 options that are common to all Java virtual machine implementations, including Oracle's HotSpot VM. Some of the common options supported are summarised in the following table: Standard option name Purpose -classpath:<resource_name>[:<resource_name>] Sets the search path for application classes and resources (directories and compressed or .jar files). cp can be used instead of classpath . -help , -? Prints a usage message. -fullversion Prints the build and version information for a VM -showversion Prints product version and continues. -verbose:<option>[,<option>] Enables verbose output. Options include class , dynload , gc , init , jni , sizes , stack , and module . (See Notes ) -version Prints the full build and version information a VM Notes: -verbose:class : Writes an entry to stderr for each class that is loaded. -verbose:dynload : Writes detailed class information to stderr as each bootstrap class is loaded by the VM: -verbose:gc : Provides verbose garbage collection information. -verbose:init : Writes information to stderr describing VM initialization and termination. -verbose:jni : Writes information to stderr describing the JNI services called by the application and VM. -verbose:sizes : Writes information to stderr describing the active memory usage settings. -verbose:stack : Writes information to stderr describing the Java and C stack usage for each thread. -verbose:module : Writes information to stderr for each module that is loaded and unloaded. For more information about standard options, see Oracle Java SE Standard Options OpenJ9 extensions OpenJ9 supports the following extension to the -verbose option: -verbose:stacktrace : Writes either the module name or the Classloader name (with the code source location when available) to the end of each line of a Java stack trace.","title":"Standard options"},{"location":"cmdline_general/#standard-command-line-options","text":"The Eclipse OpenJ9\u2122 virtual machine supports the standard Java\u2122 options that are common to all Java virtual machine implementations, including Oracle's HotSpot VM. Some of the common options supported are summarised in the following table: Standard option name Purpose -classpath:<resource_name>[:<resource_name>] Sets the search path for application classes and resources (directories and compressed or .jar files). cp can be used instead of classpath . -help , -? Prints a usage message. -fullversion Prints the build and version information for a VM -showversion Prints product version and continues. -verbose:<option>[,<option>] Enables verbose output. Options include class , dynload , gc , init , jni , sizes , stack , and module . (See Notes ) -version Prints the full build and version information a VM Notes: -verbose:class : Writes an entry to stderr for each class that is loaded. -verbose:dynload : Writes detailed class information to stderr as each bootstrap class is loaded by the VM: -verbose:gc : Provides verbose garbage collection information. -verbose:init : Writes information to stderr describing VM initialization and termination. -verbose:jni : Writes information to stderr describing the JNI services called by the application and VM. -verbose:sizes : Writes information to stderr describing the active memory usage settings. -verbose:stack : Writes information to stderr describing the Java and C stack usage for each thread. -verbose:module : Writes information to stderr for each module that is loaded and unloaded. For more information about standard options, see Oracle Java SE Standard Options","title":"Standard command-line options"},{"location":"cmdline_general/#openj9-extensions","text":"OpenJ9 supports the following extension to the -verbose option: -verbose:stacktrace : Writes either the module name or the Classloader name (with the code source location when available) to the end of each line of a Java stack trace.","title":"OpenJ9 extensions"},{"location":"cmdline_migration/","text":"Switching to Eclipse OpenJ9 If you are already familiar with HotSpot command-line options but want the advantages of Eclipse OpenJ9\u2122, the following information will prove helpful. In all cases, check individual topics for minor discrepancies in the way these options might work. Note: For information about HotSpot equivalences and differences for items other than command-line options, see New to Eclipse OpenJ9? Compatible options You can use the following command-line options in OpenJ9, just as you did in HotSpot; you can continue to use the HotSpot option in OpenJ9 without having to change your code: Option Usage -X Displays help on nonstandard options. -Xbootclasspath Specifies the search path for bootstrap classes and resources. -Xcheck:jni Runs additional checks for JNI functions during VM startup. -Xfuture Turns on strict class-file format checks. -Xint Runs an application in interpreted-only mode. -Xlog Some forms of -Xlog that enable garbage collection logging are recognized. (Equivalent to -Xverbosegclog ). -Xmn Sets the initial and maximum size of the new area when using -Xgcpolicy:gencon. -Xms Sets the initial size of the heap. (Equivalent to -XX:InitialHeapSize ) -Xmx Specifies the maximum size of the object memory allocation pool. (Equivalent to -XX:MaxHeapSize ) -Xnoclassgc Disables class garbage collection (GC). -Xrs Prevents the OpenJ9 run time environment from handling signals. -Xss Sets the Java\u2122 thread stack size. (Equivalent to -XX:ThreadStackSize ). Note: Unlike HotSpot, this option applies only to the Java stack. OpenJ9 has a separate native stack for operating system threads (see -Xmso ) -Xverify:mode Enables or disables the verifier. -XX:ConcGCThreads Configures the number of GC mutator background threads. -XX:[+|-]AlwaysPreTouch Enables/disables committing of memory during initial heap inflation or heap expansion. -XX:[+|-]CompactStrings Enables/disables String compression. Note: Unlike HotSpot, this option is disabled by default in OpenJ9. -XX:DiagnoseSyncOnValueBasedClasses=<number> Configure warnings for value-based classes. -XX:[+|-]DisableExplicitGC Enables/disables explicit System.gc() calls. (Alias for -Xdisableexplicitgc / -Xenableexplicitgc ) -XX:[+|-]ExitOnOutOfMemoryError Triggers VM shutdown on out-of-memory conditions. -XX:[+|-]HeapDumpOnOutOfMemory Enables/disables dumps on out-of-memory conditions. -XX:HeapDumpPath Specifies a directory for all VM dumps including heap dumps, javacores, and system dumps. (Alias for -Xdump:directory ) -XX:[+|-]IgnoreUnrecognizedVMOptions Specifies whether to ignore unrecognized top-level VM options. -XX:InitialHeapSize Sets the initial size of the heap. (Alias for -Xms ) -XX:InitialRAMPercentage Sets the initial size of the Java heap as a percentage of total memory. -XX:MaxDirectMemorySize Sets a limit on the amount of memory that can be reserved for all direct byte buffers. -XX:MaxHeapSize Specifies the maximum size of the object memory allocation pool. (Alias for -Xmx ) -XX:MaxRAMPercentage Sets the maximum size of the Java heap as a percentage of total memory. -XX:OnOutOfMemoryError Runs specified commands when a java.lang.OutOfMemoryError is thrown. (Equivalent to -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec= ) -XX:ParallelCMSThreads Configures the number of GC mutator background threads. -XX:ParallelGCThreads Configures the number of GC threads. -XX:[+|-]PrintCodeCache Prints code cache usage when the application exits. -XX:[+|-]ShowHiddenFrames Specifies whether generated hidden MethodHandle frames are displayed in a stack trace. Note: Unlike HotSpot, this option doesn't require the +UnlockDiagnosticVMOptions option. -XX:[+|-]UseCompressedOops Disables compressed references in 64-bit JVMs. (See also -Xcompressedrefs ) -XX:[+|-]UseContainerSupport Sets a larger fraction of memory to the Java heap when the VM detects that it is running in a container. Equivalent options These HotSpot command-line options have equivalents in OpenJ9 that are not specified in the same way, but perform a related function: HotSpot Option OpenJ9 Option Usage -Xcomp -Xjit:count=0 1 -Xcomp disables interpreted method invocations. -Xgc -Xgcpolicy 2 Configuring your garbage collection policy. -XX:+UseNUMA -Xnuma:none 3 Controls non-uniform memory architecture (NUMA) awareness. Notes: HotSpot uses -Xcomp to force compilation of methods on first invocation. However, this option is deprecated. Whilst it can be used for compatibility, using -Xjit:count=0 is preferred. HotSpot uses -Xgc to both select policies and configure them; OpenJ9 uses -Xgcpolicy to select policies, reserving -Xgc for configuration. In HotSpot, NUMA awareness is turned off by default and is turned on by using the -XX:+UseNUMA option. Conversely, the OpenJ9 VM automatically enables NUMA awareness and uses -Xnuma:none to turn it off . If you were previously using HotSpot in its default mode, you must now explicitly turn off NUMA awareness in OpenJ9. If you are used to using -XX:+UseNUMA in HotSpot, you no longer need to explicitly turn on NUMA awareness; it's on by default. Creating compatible behavior You can set the following options to make OpenJ9 behave in the same way as HotSpot. Option Usage -Djava.lang.string.substring.nocopy=true Avoid String sharing by String.substring() . -Xnuma:none Disable non-uniform memory architecture (NUMA) awareness. -XX:+CompactStrings Enables String compression. -XXHandleSIGABRT Force handling of SIGABRT signals to be compatible with HotSpot. Compatible environment variables The JAVA_TOOL_OPTIONS environment variable can be used to set command line options as described in OpenJ9 command-line options and Environment variables .","title":"Switching to OpenJ9"},{"location":"cmdline_migration/#switching-to-eclipse-openj9","text":"If you are already familiar with HotSpot command-line options but want the advantages of Eclipse OpenJ9\u2122, the following information will prove helpful. In all cases, check individual topics for minor discrepancies in the way these options might work. Note: For information about HotSpot equivalences and differences for items other than command-line options, see New to Eclipse OpenJ9?","title":"Switching to Eclipse OpenJ9"},{"location":"cmdline_migration/#compatible-options","text":"You can use the following command-line options in OpenJ9, just as you did in HotSpot; you can continue to use the HotSpot option in OpenJ9 without having to change your code: Option Usage -X Displays help on nonstandard options. -Xbootclasspath Specifies the search path for bootstrap classes and resources. -Xcheck:jni Runs additional checks for JNI functions during VM startup. -Xfuture Turns on strict class-file format checks. -Xint Runs an application in interpreted-only mode. -Xlog Some forms of -Xlog that enable garbage collection logging are recognized. (Equivalent to -Xverbosegclog ). -Xmn Sets the initial and maximum size of the new area when using -Xgcpolicy:gencon. -Xms Sets the initial size of the heap. (Equivalent to -XX:InitialHeapSize ) -Xmx Specifies the maximum size of the object memory allocation pool. (Equivalent to -XX:MaxHeapSize ) -Xnoclassgc Disables class garbage collection (GC). -Xrs Prevents the OpenJ9 run time environment from handling signals. -Xss Sets the Java\u2122 thread stack size. (Equivalent to -XX:ThreadStackSize ). Note: Unlike HotSpot, this option applies only to the Java stack. OpenJ9 has a separate native stack for operating system threads (see -Xmso ) -Xverify:mode Enables or disables the verifier. -XX:ConcGCThreads Configures the number of GC mutator background threads. -XX:[+|-]AlwaysPreTouch Enables/disables committing of memory during initial heap inflation or heap expansion. -XX:[+|-]CompactStrings Enables/disables String compression. Note: Unlike HotSpot, this option is disabled by default in OpenJ9. -XX:DiagnoseSyncOnValueBasedClasses=<number> Configure warnings for value-based classes. -XX:[+|-]DisableExplicitGC Enables/disables explicit System.gc() calls. (Alias for -Xdisableexplicitgc / -Xenableexplicitgc ) -XX:[+|-]ExitOnOutOfMemoryError Triggers VM shutdown on out-of-memory conditions. -XX:[+|-]HeapDumpOnOutOfMemory Enables/disables dumps on out-of-memory conditions. -XX:HeapDumpPath Specifies a directory for all VM dumps including heap dumps, javacores, and system dumps. (Alias for -Xdump:directory ) -XX:[+|-]IgnoreUnrecognizedVMOptions Specifies whether to ignore unrecognized top-level VM options. -XX:InitialHeapSize Sets the initial size of the heap. (Alias for -Xms ) -XX:InitialRAMPercentage Sets the initial size of the Java heap as a percentage of total memory. -XX:MaxDirectMemorySize Sets a limit on the amount of memory that can be reserved for all direct byte buffers. -XX:MaxHeapSize Specifies the maximum size of the object memory allocation pool. (Alias for -Xmx ) -XX:MaxRAMPercentage Sets the maximum size of the Java heap as a percentage of total memory. -XX:OnOutOfMemoryError Runs specified commands when a java.lang.OutOfMemoryError is thrown. (Equivalent to -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec= ) -XX:ParallelCMSThreads Configures the number of GC mutator background threads. -XX:ParallelGCThreads Configures the number of GC threads. -XX:[+|-]PrintCodeCache Prints code cache usage when the application exits. -XX:[+|-]ShowHiddenFrames Specifies whether generated hidden MethodHandle frames are displayed in a stack trace. Note: Unlike HotSpot, this option doesn't require the +UnlockDiagnosticVMOptions option. -XX:[+|-]UseCompressedOops Disables compressed references in 64-bit JVMs. (See also -Xcompressedrefs ) -XX:[+|-]UseContainerSupport Sets a larger fraction of memory to the Java heap when the VM detects that it is running in a container.","title":"Compatible options"},{"location":"cmdline_migration/#equivalent-options","text":"These HotSpot command-line options have equivalents in OpenJ9 that are not specified in the same way, but perform a related function: HotSpot Option OpenJ9 Option Usage -Xcomp -Xjit:count=0 1 -Xcomp disables interpreted method invocations. -Xgc -Xgcpolicy 2 Configuring your garbage collection policy. -XX:+UseNUMA -Xnuma:none 3 Controls non-uniform memory architecture (NUMA) awareness. Notes: HotSpot uses -Xcomp to force compilation of methods on first invocation. However, this option is deprecated. Whilst it can be used for compatibility, using -Xjit:count=0 is preferred. HotSpot uses -Xgc to both select policies and configure them; OpenJ9 uses -Xgcpolicy to select policies, reserving -Xgc for configuration. In HotSpot, NUMA awareness is turned off by default and is turned on by using the -XX:+UseNUMA option. Conversely, the OpenJ9 VM automatically enables NUMA awareness and uses -Xnuma:none to turn it off . If you were previously using HotSpot in its default mode, you must now explicitly turn off NUMA awareness in OpenJ9. If you are used to using -XX:+UseNUMA in HotSpot, you no longer need to explicitly turn on NUMA awareness; it's on by default.","title":"Equivalent options"},{"location":"cmdline_migration/#creating-compatible-behavior","text":"You can set the following options to make OpenJ9 behave in the same way as HotSpot. Option Usage -Djava.lang.string.substring.nocopy=true Avoid String sharing by String.substring() . -Xnuma:none Disable non-uniform memory architecture (NUMA) awareness. -XX:+CompactStrings Enables String compression. -XXHandleSIGABRT Force handling of SIGABRT signals to be compatible with HotSpot.","title":"Creating compatible behavior"},{"location":"cmdline_migration/#compatible-environment-variables","text":"The JAVA_TOOL_OPTIONS environment variable can be used to set command line options as described in OpenJ9 command-line options and Environment variables .","title":"Compatible environment variables"},{"location":"cmdline_specifying/","text":"Eclipse OpenJ9 command-line options When you start a Java\u2122 application you can specify various options on the command line to configure the runtime environment. These options include: System properties Standard options Nonstandard (or -X) options -XX options Although the command line is the traditional way to specify command-line options, you can also pass options to the Eclipse OpenJ9\u2122 virtual machine (VM) by using a manifest file, options files, and environment variables. Options specified on the command line override the equivalent environment variables. For example, specifying java -cp <dir1> completely overrides setting the environment variable CLASSPATH=<dir2> . Quotation marks Use single or double quotation marks for command-line options only when explicitly directed to do so. Single and double quotation marks have different meanings on different platforms, operating systems, and shells. Do not use '-X<option>' or \"-X<option>\" . Instead, you must use -X<option> . For example, do not use '-Xmx500m' and \"-Xmx500m\" . Write this option as -Xmx500m . Precedence The sequence of the Java options on the command line defines which options take precedence during startup. Rightmost options have precedence over leftmost options. In the following example, the -Xjit option takes precedence: java -Xint -Xjit myClass At startup, the list of VM arguments is constructed in the following order, with the lowest precedence first: Certain options are created automatically by the VM, which specify arguments such as search paths and version information. The VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. You can modify the options.default file to include any options that you want to specify for your application instead of entering these options on the command line. For more information about the path and construction of the file, see -Xoptionsfile . Options can be specified in an executable JAR file by using the META-INF/MANIFEST.MF file. Options are placed in the main section in a header named IBM-Java-Options . Only one IBM-Java-Options header is permitted, but the header can contain multiple options, separated by spaces. A long sequence of options can be split using a header continuation but are treated as a single line. Example manifest file: Manifest-Version: 1.0 Class-Path: . Main-Class: HelloWorld IBM-Java-Options: -Xshareclasses:name=mycache,nonfa tal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.pro perty=\"this is a long system property value to demonstrate long VM arguments in the manifest file\" This example manifest file is parsed as the following string: -Xshareclasses:name=mycache,nonfatal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.property=this is a long system property value to demonstrate long VM arguments in the manifest file Options specified in the manifest file are subject to the same restrictions as options files. For more information, see the -Xoptionsfile topic in the user guide. Environment variables that are described in OpenJ9 environment variables are translated into command-line options. For example, the following environment variable adds the parameter -Xrs to the list of arguments: On Windows\u2122 systems: set IBM_NOSIGHANDLER=<non_null_string> On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: export IBM_NOSIGHANDLER=<non_null_string> The OPENJ9_JAVA_OPTIONS environment variable. You can set command-line options using this environment variable. The options that you specify with this environment variable are added to the command line when a VM starts in that environment. The environment variable can contain multiple blank-delimited argument strings, but must not contain comments. For example: On Windows systems: set OPENJ9_JAVA_OPTIONS=-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump On AIX, Linux, macOS, and z/OS systems: export OPENJ9_JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" Note: The environment variable JAVA_TOOL_OPTIONS is equivalent to OPENJ9_JAVA_OPTIONS and is available for compatibility with JVMTI. The equivalent IBM_JAVA_OPTIONS environment variable is deprecated and will be removed in a future release. Options that are specified on the command line. For example: java -Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump MyJavaClass The Java launcher adds some automatically generated arguments to this list, such as the names of the main class. The _JAVA_OPTIONS environment variable. You can override previous options using this environment variable. The options that you specify with this environment variable are added to the end of the command line when a VM starts in that environment. The environment variable can contain multiple blank-delimited argument strings, but must not contain comments. For example: On Windows systems: set _JAVA_OPTIONS=-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump On AIX, Linux, macOS, and z/OS systems: export _JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" You can also use the -Xoptionsfile parameter to specify VM options. This parameter can be used on the command line, or as part of the OPENJ9_JAVA_OPTIONS environment variable. The contents of an option file are expanded in place during startup. For more information about the structure and contents of this type of file, see -Xoptionsfile . To troubleshoot startup problems, you can check which options are used by the OpenJ9 VM. Append the following command-line option, and inspect the Java core file that is generated: -Xdump:java:events=vmstart Here is an extract from a Java core file that shows the options that are used: 2CIUSERARG -Xdump:java:file=/home/test_javacore.txt,events=vmstop 2CIUSERARG -Dtest.cmdlineOption=1 2CIUSERARG -XXallowvmshutdown:true 2CIUSERARG -Xoptionsfile=test1.test_options_file","title":"Specifying options"},{"location":"cmdline_specifying/#eclipse-openj9-command-line-options","text":"When you start a Java\u2122 application you can specify various options on the command line to configure the runtime environment. These options include: System properties Standard options Nonstandard (or -X) options -XX options Although the command line is the traditional way to specify command-line options, you can also pass options to the Eclipse OpenJ9\u2122 virtual machine (VM) by using a manifest file, options files, and environment variables. Options specified on the command line override the equivalent environment variables. For example, specifying java -cp <dir1> completely overrides setting the environment variable CLASSPATH=<dir2> .","title":"Eclipse OpenJ9 command-line options"},{"location":"cmdline_specifying/#quotation-marks","text":"Use single or double quotation marks for command-line options only when explicitly directed to do so. Single and double quotation marks have different meanings on different platforms, operating systems, and shells. Do not use '-X<option>' or \"-X<option>\" . Instead, you must use -X<option> . For example, do not use '-Xmx500m' and \"-Xmx500m\" . Write this option as -Xmx500m .","title":"Quotation marks"},{"location":"cmdline_specifying/#precedence","text":"The sequence of the Java options on the command line defines which options take precedence during startup. Rightmost options have precedence over leftmost options. In the following example, the -Xjit option takes precedence: java -Xint -Xjit myClass At startup, the list of VM arguments is constructed in the following order, with the lowest precedence first: Certain options are created automatically by the VM, which specify arguments such as search paths and version information. The VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. You can modify the options.default file to include any options that you want to specify for your application instead of entering these options on the command line. For more information about the path and construction of the file, see -Xoptionsfile . Options can be specified in an executable JAR file by using the META-INF/MANIFEST.MF file. Options are placed in the main section in a header named IBM-Java-Options . Only one IBM-Java-Options header is permitted, but the header can contain multiple options, separated by spaces. A long sequence of options can be split using a header continuation but are treated as a single line. Example manifest file: Manifest-Version: 1.0 Class-Path: . Main-Class: HelloWorld IBM-Java-Options: -Xshareclasses:name=mycache,nonfa tal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.pro perty=\"this is a long system property value to demonstrate long VM arguments in the manifest file\" This example manifest file is parsed as the following string: -Xshareclasses:name=mycache,nonfatal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.property=this is a long system property value to demonstrate long VM arguments in the manifest file Options specified in the manifest file are subject to the same restrictions as options files. For more information, see the -Xoptionsfile topic in the user guide. Environment variables that are described in OpenJ9 environment variables are translated into command-line options. For example, the following environment variable adds the parameter -Xrs to the list of arguments: On Windows\u2122 systems: set IBM_NOSIGHANDLER=<non_null_string> On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: export IBM_NOSIGHANDLER=<non_null_string> The OPENJ9_JAVA_OPTIONS environment variable. You can set command-line options using this environment variable. The options that you specify with this environment variable are added to the command line when a VM starts in that environment. The environment variable can contain multiple blank-delimited argument strings, but must not contain comments. For example: On Windows systems: set OPENJ9_JAVA_OPTIONS=-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump On AIX, Linux, macOS, and z/OS systems: export OPENJ9_JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" Note: The environment variable JAVA_TOOL_OPTIONS is equivalent to OPENJ9_JAVA_OPTIONS and is available for compatibility with JVMTI. The equivalent IBM_JAVA_OPTIONS environment variable is deprecated and will be removed in a future release. Options that are specified on the command line. For example: java -Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump MyJavaClass The Java launcher adds some automatically generated arguments to this list, such as the names of the main class. The _JAVA_OPTIONS environment variable. You can override previous options using this environment variable. The options that you specify with this environment variable are added to the end of the command line when a VM starts in that environment. The environment variable can contain multiple blank-delimited argument strings, but must not contain comments. For example: On Windows systems: set _JAVA_OPTIONS=-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump On AIX, Linux, macOS, and z/OS systems: export _JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" You can also use the -Xoptionsfile parameter to specify VM options. This parameter can be used on the command line, or as part of the OPENJ9_JAVA_OPTIONS environment variable. The contents of an option file are expanded in place during startup. For more information about the structure and contents of this type of file, see -Xoptionsfile . To troubleshoot startup problems, you can check which options are used by the OpenJ9 VM. Append the following command-line option, and inspect the Java core file that is generated: -Xdump:java:events=vmstart Here is an extract from a Java core file that shows the options that are used: 2CIUSERARG -Xdump:java:file=/home/test_javacore.txt,events=vmstop 2CIUSERARG -Dtest.cmdlineOption=1 2CIUSERARG -XXallowvmshutdown:true 2CIUSERARG -Xoptionsfile=test1.test_options_file","title":"Precedence"},{"location":"configuring/","text":"Configuring your system Configuring your local system can help you optimize the runtime environment for your Java application. Options include setting operating system environment variables and configuring system resources so that Eclipse OpenJ9\u2122 can exploit the underlying operating system and hardware capabilities. When you install a Java\u2122 runtime environment on your system you can set the PATH environment variable so that the operating system can find the Java programs and utilities to run your application. To tell your application where to find user classes, you can use the -cp option or set the CLASSPATH environment variable. However, if you set CLASSPATH globally, all invocations of Java are affected. How to set these environment variables is covered in many publications about Java, such as The Java Tutorials: PATH and CLASSPATH . On some systems, a further environment variable might be required if your application requires shared libraries but does not specify their exact location. You can set the following environment variables to specify the directory location of the shared libraries, although setting a global value affects all invocations of Java: LIBPATH (AIX\u00ae and z/OS\u00ae) LD_LIBRARY_PATH (Linux\u00ae) DYLD_LIBRARY_PATH (macOS\u00ae) PATH (Windows\u00ae) Although most Java applications should run without changing anything on the underlying system, a unique pre-requisite exists for AIX systems on OpenJDK version 11 and later; you must have the 16.1 XL C++ Runtime installed. Setting resource limits (AIX, Linux, and macOS) The operating system sets resource limits for a shell, and to processes started by the shell, to ensure that a single process cannot consume all available resources. However, these limits can affect certain operations that might need to run for a Java application, such as producing a dump file. Setting ulimit values Some resource limits are controlled by the ulimit command. A soft limit is the value set by the kernel for a resource and a hard limit imposes a maximum value on the soft limit. A privileged process can change either limit, but an unprivileged process can change only its soft limit (between 0 and the hard limit) or irreversibly lower its hard limit. To see the current limits set for a system, run ulimit -a . The output is similar to the following example: core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited file size (blocks, -f) unlimited max locked memory (kbytes, -l) unlimited max memory size (kbytes, -m) unlimited open files (-n) 256 pipe size (512 bytes, -p) 1 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 2784 virtual memory (kbytes, -v) unlimited To show hard limits, use ulimit -Ha . You can change limits for specific resources on a temporary basis by running the ulimit command. Alternatively, you can store limit settings in a configuration file, which is /etc/security/limits for AIX or etc/security/limits.conf for Linux. For more information about configuring resource limits, refer to the documentation for your operating system. The main use case for changing ulimit resources is when enabling a system dump to ensure that all the required data can be collected for analysis. For more information, see Enabling a full system dump . Setting shared memory values Another use case for changing resource limits is to ensure that there is sufficient shared memory allocated for class data sharing. By default, the shared classes cache consists of memory-mapped files that are created on disk and persist when the system is restarted. If you choose to use non-persistent caches by setting the -Xshareclasses:nonpersistent option, caches are not retained on startup and are allocated by using the System V IPC shared memory mechanism. On AIX systems, the kernel dynamically adjusts the shared memory settings as required. No special configuration is required. On Linux systems, the SHMMAX setting limits the amount of shared memory that can be allocated, which affects the shared classes cache size. You can find the value of SHMMAX for your system in the /proc/sys/kernel/shmmax file. For non-persistent caches, set this value to an appropriate size for your applications. To make these changes permanent, edit /etc/sysctl.conf and reboot your system. On macOS systems, you must set kern.sysv.shmmax and kern.sysv.shmall when using a nonpersistent cache. Modify the settings in your /etc/sysctl.conf file and reboot your system. To check the value, run sysctl kern.sysv.shmmax . Note: The virtual address space of a process is shared between the shared classes cache and the Java heap. Increasing the maximum size for the shared classes cache might reduce the size of the Java heap that you can create. Shared memory limits are also important when configuring large page memory allocation on Linux systems. For more information, see Configuring large page memory allocation: Linux systems . Setting resource limits (z/OS) Resource limits imposed by z/OS might affect Java operations. To learn how these resource limits are set, see Customizing the BPXPRMxx member of SYS1.PARMLIB . The OpenJ9 class data sharing feature is implemented by using shared memory segments on z/OS. Special consideration should be given to the following parameters that relate to the shared memory and IPC semaphore settings: IPCSHMSPAGES IPCSHMMPAGES IPCSHMNSEGS Incorrect or suboptimal settings might prevent shared classes from working or impact performance. By default, the VM attempts to create a 16 MB cache. If you set a cache size for your application by specifying the -Xscmx option on the command line, the VM rounds the value up to the nearest megabyte. Ensure that the value set for IPCSHMMPAGES takes this adjustment into consideration. To see the current settings, enter the following z/OS operator command: D OMVS,O The suggested minimum values for Java applications are shown in the following table: Parameter Value MAXPROCSYS 900 MAXPROCUSER 512 MAXUIDS 500 MAXTHREADS 10000 MAXTHREADTASKS 5000 MAXASSIZE 2147483647 MAXCPUTIME 2147483647 MAXMMAPAREA 40960 IPCSHMSPAGES 262144 IPCSHMMPAGES 256 IPCSHMNSEGS 10 IPCSEMNIDS 500 IPCSEMNSEMS 1000 SHRLIBRGNSIZE 67 108 864 Note: The number of threads that can be created by a Java process is limited by the lower of the two values for MAXTHREADS and MAXTHREADSTASKS . You can change these settings dynamically without re-IPLing the system. For example, to set MACPROCUSER to 256, run SETOMVS MAXPROCUSER=256 z/OS uses region sizes to determine the amount of storage available to running programs. For a Java runtime environment, the region size must be sufficiently large to avoid storage related error messages or abends. Rather than restricting region size, allow the VM to use what it needs. Region size can be affected by one of the following parameters: JCL REGION , BPXPRMxx MAXASSIZE , the RACF OMVS segment ASSIZEMAX , or IEFUSI (Step initiation exit). SHRLIBRGNSIZE controls how much storage is reserved in each address space for mapping shared DLLs that have the +l extended attribute set. If this storage space is exceeded, DLLs are loaded into the address space instead of using a single copy of z/OS UNIX System Services storage that is shared between the address spaces. The z/OS command D OMVS,L shows the SHRLIBRGNSIZE size and peak usage. If this size is set to a much higher value than is needed, the Java application might have problems acquiring native storage. These problems can cause a z/OS abend, such as 878-10 , or a Java OutOfMemoryError . Configuring Language Environment runtime options Language Environment\u00ae runtime options affect performance and storage usage. These options can be optimized for your application. Runtime options are typically embedded in programs by using #pragma runopts settings. In many cases, these options provide suitable default values that are known to produce good performance results. However, these options can be overridden to tune the runtime environment of your application. On 64-bit z/OS systems, the following runtime options affect Java applications: HEAP64 : Controls allocation of the user heap. A suggested starting point for an override is HEAP64(512M,4M,KEEP,16M,4M,KEEP,0K,0K,FREE) . HEAPPOOLS64 : Used to manage Java heap storage above the 2 G bar. The Java USS launcher sets HEAPPOOLS64(ALIGN) for more optimal management of multi-threaded applications. Other Java launchers might have different settings. Before you set an override for HEAPPOOLS64 , use RPTOPTS(ON) to confirm the active settings for your environment and RPTSTG(ON) to review storage usage and tuning recommendations. Note that the host product might have already set cell sizes and numbers that are known to produce good performance. STACK64 : Controls the allocation and management of stack storage. A suggested default is STACK64(1M,1M,128M) . THREADSTACK64 : Controls the allocation of thread-level stack storage for both the upward and downward-growing stack. A suggested default is THREADSTACK64(OFF,1M,1M,128M) . A suitable MEMLIMIT value is also required. The OpenJ9 VM requirement is the sum of the following amounts: User heap storage required by the VM and native libraries, as controlled by HEAP64 (minimum 512 M) settings. User stack storage (3 MB multiplied by the expected number of concurrent threads), as controlled by STACK64 settings. -Xmx largest expected VM heap size. The JIT data cache maximum size. The JIT code cache maximum size, if RMODE64 is supported. Note: If you intend to use the Concurrent Scavenge mode of the default Generational Concurrent ( gencon ) garbage collection policy by using hardware-based support, the virtual storage used might exceed the Java maximum heap size. Set the z/OS memory limit to a larger value than the maximum heap size. For more information, see -Xgc:concurrentScavenge . The following guides are available to help you configure Language Environment runtime options and callable services: See z/OS Language Environment Programming Guide for guidance on how to override the default options. Use RPTOPTS (ON) to write the options that are in effect to stderr on termination. See z/OS Language Environment Programming Reference for a full list of the available runtime options. See z/OS Language Environment Debugging Guide for tuning guidance by using RPTSTG (ON) . Warning: Changing the runtime options can often degrade performance. Configuring large page memory allocation If your application allocates a large amount of memory and frequently accesses that memory, you might be able to improve performance by enabling large page support on your system. Some Linux kernels implement Transparent HugePage Support (THP), which automates the provision of large pages to back virtual memory, as described in Linux systems . Alternatively, you can enable large page support by setting the -Xlp:objectheap and -Xlp:codecache options on the command line when you start your application. These options have the following effects: The -Xlp:objectheap option requests that the Java object heap is allocated by using large pages. The -Xlp:codecache option requests that the JIT code cache is allocated by using large pages. You must also enable large pages on your local system. This process differs according to the operating system. AIX systems AIX supports large page sizes of 64 KB and 16 MB, and a huge page size of 16 GB depending on the underlying system P hardware. To determine which page sizes are supported on a particular system, run pagesize -a . To use large pages to back an application's data and heap segments, specify the LDR_CNTRL environment variable. You can set different page sizes for different purposes. The following variables can be used: TEXTPSIZE : Page size to use for text STACKPSIZE : Page size to use for stacks DATAPSIZE : Page size to use for native data or HEAP64 The following example sets 4 KB for text and 64 KB for stack, native data, and heap areas: LDR_CNTRL=TEXTPSIZE=4K@STACKPSIZE=64K@DATAPSIZE=64K For more information, including support considerations, see Large pages and Multiple page size support in the AIX documentation. The 16 MB and 16 GB page sizes, which are intended for very high performance environments, require special user permissions. You must also configure the number of pages that you require, which cannot be adjusted on demand. For 16 MB large pages, you set the number of large pages by using the vmo command. For 16 GB huge pages you must define the number of pages by using the hardware management console. For more information, see Page sizes for very high-performance environments in the AIX documentation. Linux systems Large pages are typically referred to as huge pages on Linux systems. To configure huge page memory allocation, the kernel must support huge pages. If huge pages are supported, the following lines are present in the /proc/meminfo file: HugePages_Total: HugePages_Free: Hugepagesize: If these lines do not exist, update your Linux kernel. If HugePages_Total has a value of 0 , huge pages are available, but not enabled. To enable huge pages, add the following line to your /etc/sysctl.conf file and reload the configuration by running sysctl -p : vm.nr_hugepages=<number> Where <number> is the number of huge pages required. Configure the number of huge pages that you require at boot time to ensure that the VM has access to sufficient contiguous pages. The following kernel parameters must be set appropriately for your system: SHMMAX : The maximum size of the shared memory segment (bytes). SHMALL : The total amount of shared memory in the system (bytes or pages). The user running the Java process must either be ROOT or have permissions to use huge pages. For the appropriate permissions, the user must be a member of a group that has its group identifier (gid) stored in /proc/sys/vm/hugetlb_shm_group . The locked memory limit must also be increased to at least the size of the Java heap by using the ulimit -l command. Where huge page support is available, the following default sizes apply for the object heap: Linux on x86: 2 MB Linux on IBM Power Systems: Varies depending on kernel version, check /proc/meminfo Linux on IBM Z: 1 MB Transparent HugePage Support (THP) is an automated mechanism of using huge pages to back virtual memory. On Linux kernels that support THP, it is typically enabled by default with the madvise option and can be relied on to provide huge pages as required without any user configuration. To disable THP for your application, use the OpenJ9 -XX:-TransparentHugePage option on the command line. To disable THP system-wide, change the sysfs boot time defaults with the command transparent_hugepage=never . For more information about THP see Transparent HugePage Support . Windows systems On Windows systems, large pages are typically 2 MB in size. To use large pages, the VM user must have the Windows Lock pages in memory setting enabled in the Local Security Policy. Applications must also be run with Admin privileges in order to use large page memory allocations. For more information, see the following resources from Microsoft: Large page support GetLargePageMinimum function ( memoryapi.h ) z/OS systems When available, 1 MB pageable pages are the default size for the object heap and the code cache. Other page sizes are available for the object heap, depending on the system architecture as shown in the following table: Large page size System architecture required -Xlp:codecache -Xlp:objectheap 2 GB nonpageable IBM zEnterprise EC12 processor or later Not supported Supported (64-bit VM only) 1 MB nonpageable System z10 processor or later Not supported Supported (64-bit VM only) 1 MB pageable IBM zEnterprise EC12 processor or later (see Note) Supported Supported Note: The Flash Express feature (#0402) helps avoid demoting 1 MB pageable pages to 4 KB pages when there is system paging activity. If a particular page size cannot be allocated, a smaller page size is attempted, in descending order. For example, if 2 GB nonpageable pages are requested but not available, the VM tries to allocate 1MB nonpageable pages. If 1 MB nonpageable pages are not available, the VM tries to allocate 1MB pageable pages. If large pages are not available, 4 KB pages are allocated. If you want to use nonpageable large pages for the object heap, a system programmer must configure z/OS for nonpageable large pages in the IEASYSxx parmlib member. Users who require large pages must also be authorized to the IARRSM.LRGPAGES resource in the RACF FACILITY class with read authority. Use the following z/OS system command to show large page usage for an LPAR: MODIFY AXR,IAXDMEM For more information, see Displaying real storage memory statistics in the z/OS product documentation. For usage information, including examples, see -Xlp:objectheap . Configuring Dynamic LPAR support (AIX only) Dynamic logical partitioning (DLPAR) provides a mechanism to add or remove system resources, such as memory or CPU, to or from the operating system in a logical partition without rebooting. Changing these resources dynamically can have an impact on Java applications that are running on the LPAR. To enable an application to respond to DLPAR events, you can use OpenJ9 MXBean extensions to the java.lang.management API. The following classes are available in the com.ibm.lang.management package: AvailableProcessorsNotificationInfo : Use to listen for changes to the number of available processors. ProcessingCapacityNotificationInfo : Use to listen for changes to processing capacity. TotalPhysicalMemoryNotificationInfo : Use to listen for changes to the total amount of physical memory that is available. These extensions can listen for events and trigger any necessary adjustments to the runtime environment. For example, if a Java VM is running in an LPAR with 2GB of memory, but the available memory might be adjusted between 1GB and 8GB, you might set the following options for the Java heap at run time: \u2013Xms1g \u2013Xsoftmx2g \u2013Xmx8g This command-line string sets an initial heap size of 1 GB, a soft (adjustable) maximum heap size of 2 GB, and a maximum heap size of 8 GB. You can then use the MemoryMXBean API to dynamically respond to changes in memory resources. The following classes can be used: getMaxHeapSize() : Query the maximum heap size. isSetMaxHeapSizeSupported() : Query whether the VM can support dynamic updates. setMaxHeapSize() : Adjust the maximum heap size. For more information about the com.ibm.lang.managment package, which extends the jdk.management module, see the API documentation .","title":"Configuring your system"},{"location":"configuring/#configuring-your-system","text":"Configuring your local system can help you optimize the runtime environment for your Java application. Options include setting operating system environment variables and configuring system resources so that Eclipse OpenJ9\u2122 can exploit the underlying operating system and hardware capabilities. When you install a Java\u2122 runtime environment on your system you can set the PATH environment variable so that the operating system can find the Java programs and utilities to run your application. To tell your application where to find user classes, you can use the -cp option or set the CLASSPATH environment variable. However, if you set CLASSPATH globally, all invocations of Java are affected. How to set these environment variables is covered in many publications about Java, such as The Java Tutorials: PATH and CLASSPATH . On some systems, a further environment variable might be required if your application requires shared libraries but does not specify their exact location. You can set the following environment variables to specify the directory location of the shared libraries, although setting a global value affects all invocations of Java: LIBPATH (AIX\u00ae and z/OS\u00ae) LD_LIBRARY_PATH (Linux\u00ae) DYLD_LIBRARY_PATH (macOS\u00ae) PATH (Windows\u00ae) Although most Java applications should run without changing anything on the underlying system, a unique pre-requisite exists for AIX systems on OpenJDK version 11 and later; you must have the 16.1 XL C++ Runtime installed.","title":"Configuring your system"},{"location":"configuring/#setting-resource-limits-aix-linux-and-macos","text":"The operating system sets resource limits for a shell, and to processes started by the shell, to ensure that a single process cannot consume all available resources. However, these limits can affect certain operations that might need to run for a Java application, such as producing a dump file.","title":"Setting resource limits (AIX, Linux, and macOS)"},{"location":"configuring/#setting-ulimit-values","text":"Some resource limits are controlled by the ulimit command. A soft limit is the value set by the kernel for a resource and a hard limit imposes a maximum value on the soft limit. A privileged process can change either limit, but an unprivileged process can change only its soft limit (between 0 and the hard limit) or irreversibly lower its hard limit. To see the current limits set for a system, run ulimit -a . The output is similar to the following example: core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited file size (blocks, -f) unlimited max locked memory (kbytes, -l) unlimited max memory size (kbytes, -m) unlimited open files (-n) 256 pipe size (512 bytes, -p) 1 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 2784 virtual memory (kbytes, -v) unlimited To show hard limits, use ulimit -Ha . You can change limits for specific resources on a temporary basis by running the ulimit command. Alternatively, you can store limit settings in a configuration file, which is /etc/security/limits for AIX or etc/security/limits.conf for Linux. For more information about configuring resource limits, refer to the documentation for your operating system. The main use case for changing ulimit resources is when enabling a system dump to ensure that all the required data can be collected for analysis. For more information, see Enabling a full system dump .","title":"Setting ulimit values"},{"location":"configuring/#setting-shared-memory-values","text":"Another use case for changing resource limits is to ensure that there is sufficient shared memory allocated for class data sharing. By default, the shared classes cache consists of memory-mapped files that are created on disk and persist when the system is restarted. If you choose to use non-persistent caches by setting the -Xshareclasses:nonpersistent option, caches are not retained on startup and are allocated by using the System V IPC shared memory mechanism. On AIX systems, the kernel dynamically adjusts the shared memory settings as required. No special configuration is required. On Linux systems, the SHMMAX setting limits the amount of shared memory that can be allocated, which affects the shared classes cache size. You can find the value of SHMMAX for your system in the /proc/sys/kernel/shmmax file. For non-persistent caches, set this value to an appropriate size for your applications. To make these changes permanent, edit /etc/sysctl.conf and reboot your system. On macOS systems, you must set kern.sysv.shmmax and kern.sysv.shmall when using a nonpersistent cache. Modify the settings in your /etc/sysctl.conf file and reboot your system. To check the value, run sysctl kern.sysv.shmmax . Note: The virtual address space of a process is shared between the shared classes cache and the Java heap. Increasing the maximum size for the shared classes cache might reduce the size of the Java heap that you can create. Shared memory limits are also important when configuring large page memory allocation on Linux systems. For more information, see Configuring large page memory allocation: Linux systems .","title":"Setting shared memory values"},{"location":"configuring/#setting-resource-limits-zos","text":"Resource limits imposed by z/OS might affect Java operations. To learn how these resource limits are set, see Customizing the BPXPRMxx member of SYS1.PARMLIB . The OpenJ9 class data sharing feature is implemented by using shared memory segments on z/OS. Special consideration should be given to the following parameters that relate to the shared memory and IPC semaphore settings: IPCSHMSPAGES IPCSHMMPAGES IPCSHMNSEGS Incorrect or suboptimal settings might prevent shared classes from working or impact performance. By default, the VM attempts to create a 16 MB cache. If you set a cache size for your application by specifying the -Xscmx option on the command line, the VM rounds the value up to the nearest megabyte. Ensure that the value set for IPCSHMMPAGES takes this adjustment into consideration. To see the current settings, enter the following z/OS operator command: D OMVS,O The suggested minimum values for Java applications are shown in the following table: Parameter Value MAXPROCSYS 900 MAXPROCUSER 512 MAXUIDS 500 MAXTHREADS 10000 MAXTHREADTASKS 5000 MAXASSIZE 2147483647 MAXCPUTIME 2147483647 MAXMMAPAREA 40960 IPCSHMSPAGES 262144 IPCSHMMPAGES 256 IPCSHMNSEGS 10 IPCSEMNIDS 500 IPCSEMNSEMS 1000 SHRLIBRGNSIZE 67 108 864 Note: The number of threads that can be created by a Java process is limited by the lower of the two values for MAXTHREADS and MAXTHREADSTASKS . You can change these settings dynamically without re-IPLing the system. For example, to set MACPROCUSER to 256, run SETOMVS MAXPROCUSER=256 z/OS uses region sizes to determine the amount of storage available to running programs. For a Java runtime environment, the region size must be sufficiently large to avoid storage related error messages or abends. Rather than restricting region size, allow the VM to use what it needs. Region size can be affected by one of the following parameters: JCL REGION , BPXPRMxx MAXASSIZE , the RACF OMVS segment ASSIZEMAX , or IEFUSI (Step initiation exit). SHRLIBRGNSIZE controls how much storage is reserved in each address space for mapping shared DLLs that have the +l extended attribute set. If this storage space is exceeded, DLLs are loaded into the address space instead of using a single copy of z/OS UNIX System Services storage that is shared between the address spaces. The z/OS command D OMVS,L shows the SHRLIBRGNSIZE size and peak usage. If this size is set to a much higher value than is needed, the Java application might have problems acquiring native storage. These problems can cause a z/OS abend, such as 878-10 , or a Java OutOfMemoryError .","title":"Setting resource limits (z/OS)"},{"location":"configuring/#configuring-language-environment-runtime-options","text":"Language Environment\u00ae runtime options affect performance and storage usage. These options can be optimized for your application. Runtime options are typically embedded in programs by using #pragma runopts settings. In many cases, these options provide suitable default values that are known to produce good performance results. However, these options can be overridden to tune the runtime environment of your application. On 64-bit z/OS systems, the following runtime options affect Java applications: HEAP64 : Controls allocation of the user heap. A suggested starting point for an override is HEAP64(512M,4M,KEEP,16M,4M,KEEP,0K,0K,FREE) . HEAPPOOLS64 : Used to manage Java heap storage above the 2 G bar. The Java USS launcher sets HEAPPOOLS64(ALIGN) for more optimal management of multi-threaded applications. Other Java launchers might have different settings. Before you set an override for HEAPPOOLS64 , use RPTOPTS(ON) to confirm the active settings for your environment and RPTSTG(ON) to review storage usage and tuning recommendations. Note that the host product might have already set cell sizes and numbers that are known to produce good performance. STACK64 : Controls the allocation and management of stack storage. A suggested default is STACK64(1M,1M,128M) . THREADSTACK64 : Controls the allocation of thread-level stack storage for both the upward and downward-growing stack. A suggested default is THREADSTACK64(OFF,1M,1M,128M) . A suitable MEMLIMIT value is also required. The OpenJ9 VM requirement is the sum of the following amounts: User heap storage required by the VM and native libraries, as controlled by HEAP64 (minimum 512 M) settings. User stack storage (3 MB multiplied by the expected number of concurrent threads), as controlled by STACK64 settings. -Xmx largest expected VM heap size. The JIT data cache maximum size. The JIT code cache maximum size, if RMODE64 is supported. Note: If you intend to use the Concurrent Scavenge mode of the default Generational Concurrent ( gencon ) garbage collection policy by using hardware-based support, the virtual storage used might exceed the Java maximum heap size. Set the z/OS memory limit to a larger value than the maximum heap size. For more information, see -Xgc:concurrentScavenge . The following guides are available to help you configure Language Environment runtime options and callable services: See z/OS Language Environment Programming Guide for guidance on how to override the default options. Use RPTOPTS (ON) to write the options that are in effect to stderr on termination. See z/OS Language Environment Programming Reference for a full list of the available runtime options. See z/OS Language Environment Debugging Guide for tuning guidance by using RPTSTG (ON) . Warning: Changing the runtime options can often degrade performance.","title":"Configuring Language Environment runtime options"},{"location":"configuring/#configuring-large-page-memory-allocation","text":"If your application allocates a large amount of memory and frequently accesses that memory, you might be able to improve performance by enabling large page support on your system. Some Linux kernels implement Transparent HugePage Support (THP), which automates the provision of large pages to back virtual memory, as described in Linux systems . Alternatively, you can enable large page support by setting the -Xlp:objectheap and -Xlp:codecache options on the command line when you start your application. These options have the following effects: The -Xlp:objectheap option requests that the Java object heap is allocated by using large pages. The -Xlp:codecache option requests that the JIT code cache is allocated by using large pages. You must also enable large pages on your local system. This process differs according to the operating system.","title":"Configuring large page memory allocation"},{"location":"configuring/#aix-systems","text":"AIX supports large page sizes of 64 KB and 16 MB, and a huge page size of 16 GB depending on the underlying system P hardware. To determine which page sizes are supported on a particular system, run pagesize -a . To use large pages to back an application's data and heap segments, specify the LDR_CNTRL environment variable. You can set different page sizes for different purposes. The following variables can be used: TEXTPSIZE : Page size to use for text STACKPSIZE : Page size to use for stacks DATAPSIZE : Page size to use for native data or HEAP64 The following example sets 4 KB for text and 64 KB for stack, native data, and heap areas: LDR_CNTRL=TEXTPSIZE=4K@STACKPSIZE=64K@DATAPSIZE=64K For more information, including support considerations, see Large pages and Multiple page size support in the AIX documentation. The 16 MB and 16 GB page sizes, which are intended for very high performance environments, require special user permissions. You must also configure the number of pages that you require, which cannot be adjusted on demand. For 16 MB large pages, you set the number of large pages by using the vmo command. For 16 GB huge pages you must define the number of pages by using the hardware management console. For more information, see Page sizes for very high-performance environments in the AIX documentation.","title":"AIX systems"},{"location":"configuring/#linux-systems","text":"Large pages are typically referred to as huge pages on Linux systems. To configure huge page memory allocation, the kernel must support huge pages. If huge pages are supported, the following lines are present in the /proc/meminfo file: HugePages_Total: HugePages_Free: Hugepagesize: If these lines do not exist, update your Linux kernel. If HugePages_Total has a value of 0 , huge pages are available, but not enabled. To enable huge pages, add the following line to your /etc/sysctl.conf file and reload the configuration by running sysctl -p : vm.nr_hugepages=<number> Where <number> is the number of huge pages required. Configure the number of huge pages that you require at boot time to ensure that the VM has access to sufficient contiguous pages. The following kernel parameters must be set appropriately for your system: SHMMAX : The maximum size of the shared memory segment (bytes). SHMALL : The total amount of shared memory in the system (bytes or pages). The user running the Java process must either be ROOT or have permissions to use huge pages. For the appropriate permissions, the user must be a member of a group that has its group identifier (gid) stored in /proc/sys/vm/hugetlb_shm_group . The locked memory limit must also be increased to at least the size of the Java heap by using the ulimit -l command. Where huge page support is available, the following default sizes apply for the object heap: Linux on x86: 2 MB Linux on IBM Power Systems: Varies depending on kernel version, check /proc/meminfo Linux on IBM Z: 1 MB Transparent HugePage Support (THP) is an automated mechanism of using huge pages to back virtual memory. On Linux kernels that support THP, it is typically enabled by default with the madvise option and can be relied on to provide huge pages as required without any user configuration. To disable THP for your application, use the OpenJ9 -XX:-TransparentHugePage option on the command line. To disable THP system-wide, change the sysfs boot time defaults with the command transparent_hugepage=never . For more information about THP see Transparent HugePage Support .","title":"Linux systems"},{"location":"configuring/#windows-systems","text":"On Windows systems, large pages are typically 2 MB in size. To use large pages, the VM user must have the Windows Lock pages in memory setting enabled in the Local Security Policy. Applications must also be run with Admin privileges in order to use large page memory allocations. For more information, see the following resources from Microsoft: Large page support GetLargePageMinimum function ( memoryapi.h )","title":"Windows systems"},{"location":"configuring/#zos-systems","text":"When available, 1 MB pageable pages are the default size for the object heap and the code cache. Other page sizes are available for the object heap, depending on the system architecture as shown in the following table: Large page size System architecture required -Xlp:codecache -Xlp:objectheap 2 GB nonpageable IBM zEnterprise EC12 processor or later Not supported Supported (64-bit VM only) 1 MB nonpageable System z10 processor or later Not supported Supported (64-bit VM only) 1 MB pageable IBM zEnterprise EC12 processor or later (see Note) Supported Supported Note: The Flash Express feature (#0402) helps avoid demoting 1 MB pageable pages to 4 KB pages when there is system paging activity. If a particular page size cannot be allocated, a smaller page size is attempted, in descending order. For example, if 2 GB nonpageable pages are requested but not available, the VM tries to allocate 1MB nonpageable pages. If 1 MB nonpageable pages are not available, the VM tries to allocate 1MB pageable pages. If large pages are not available, 4 KB pages are allocated. If you want to use nonpageable large pages for the object heap, a system programmer must configure z/OS for nonpageable large pages in the IEASYSxx parmlib member. Users who require large pages must also be authorized to the IARRSM.LRGPAGES resource in the RACF FACILITY class with read authority. Use the following z/OS system command to show large page usage for an LPAR: MODIFY AXR,IAXDMEM For more information, see Displaying real storage memory statistics in the z/OS product documentation. For usage information, including examples, see -Xlp:objectheap .","title":"z/OS systems"},{"location":"configuring/#configuring-dynamic-lpar-support-aix-only","text":"Dynamic logical partitioning (DLPAR) provides a mechanism to add or remove system resources, such as memory or CPU, to or from the operating system in a logical partition without rebooting. Changing these resources dynamically can have an impact on Java applications that are running on the LPAR. To enable an application to respond to DLPAR events, you can use OpenJ9 MXBean extensions to the java.lang.management API. The following classes are available in the com.ibm.lang.management package: AvailableProcessorsNotificationInfo : Use to listen for changes to the number of available processors. ProcessingCapacityNotificationInfo : Use to listen for changes to processing capacity. TotalPhysicalMemoryNotificationInfo : Use to listen for changes to the total amount of physical memory that is available. These extensions can listen for events and trigger any necessary adjustments to the runtime environment. For example, if a Java VM is running in an LPAR with 2GB of memory, but the available memory might be adjusted between 1GB and 8GB, you might set the following options for the Java heap at run time: \u2013Xms1g \u2013Xsoftmx2g \u2013Xmx8g This command-line string sets an initial heap size of 1 GB, a soft (adjustable) maximum heap size of 2 GB, and a maximum heap size of 8 GB. You can then use the MemoryMXBean API to dynamically respond to changes in memory resources. The following classes can be used: getMaxHeapSize() : Query the maximum heap size. isSetMaxHeapSizeSupported() : Query whether the VM can support dynamic updates. setMaxHeapSize() : Adjust the maximum heap size. For more information about the com.ibm.lang.managment package, which extends the jdk.management module, see the API documentation .","title":"Configuring Dynamic LPAR support (AIX only)"},{"location":"d_jvm_commands/","text":"Using system property command-line options Java\u2122 system properties determine the environment in which a Java program runs by starting a Java virtual machine with a set of values. You can choose to use the default values for Java system properties or you can specify values for them by adding parameters to the command line when you start your application. To set a system property from the command line, use: java -D<property_name>=<value> <program_name> For example, to specify the UTF-8 file encoding for your application MyProgram , use: java -Dfile.encoding=UTF-8 MyProgram","title":"Using System properties"},{"location":"d_jvm_commands/#using-system-property-command-line-options","text":"Java\u2122 system properties determine the environment in which a Java program runs by starting a Java virtual machine with a set of values. You can choose to use the default values for Java system properties or you can specify values for them by adding parameters to the command line when you start your application. To set a system property from the command line, use: java -D<property_name>=<value> <program_name> For example, to specify the UTF-8 file encoding for your application MyProgram , use: java -Dfile.encoding=UTF-8 MyProgram","title":"Using system property command-line options"},{"location":"dcomibmenableclasscaching/","text":"-Dcom.ibm.enableClassCaching Setting this property to true enables caching of the Latest User Defined Class Loader (LUDCL). Syntax -Dcom.ibm.enableClassCaching=[true|false] Setting Effect Default true Enable yes false Disable Explanation By reducing repeated lookups, Java\u2122 applications that use deserialization extensively can see a performance improvement. See also Java Object Serialization Specification","title":"-Dcom.ibm.enableClassCaching"},{"location":"dcomibmenableclasscaching/#-dcomibmenableclasscaching","text":"Setting this property to true enables caching of the Latest User Defined Class Loader (LUDCL).","title":"-Dcom.ibm.enableClassCaching"},{"location":"dcomibmenableclasscaching/#syntax","text":"-Dcom.ibm.enableClassCaching=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenableclasscaching/#explanation","text":"By reducing repeated lookups, Java\u2122 applications that use deserialization extensively can see a performance improvement.","title":"Explanation"},{"location":"dcomibmenableclasscaching/#see-also","text":"Java Object Serialization Specification","title":"See also"},{"location":"dcomibmenablelegacydumpsecurity/","text":"-Dcom.ibm.enableLegacyDumpSecurity To improve security, the security checks in the certain com.ibm.jvm.Dump APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs. Syntax -Dcom.ibm.enableLegacyDumpSecurity=[true|false] Setting Effect Default true Enable yes false Disable Explanation Security checking is enabled in the following APIs: com.ibm.jvm.Dump.JavaDump() com.ibm.jvm.Dump.HeapDump() com.ibm.jvm.Dump.SnapDump() See also -Dcom.ibm.enableLegacyLogSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"-Dcom.ibm.enableLegacyDumpSecurity"},{"location":"dcomibmenablelegacydumpsecurity/#-dcomibmenablelegacydumpsecurity","text":"To improve security, the security checks in the certain com.ibm.jvm.Dump APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs.","title":"-Dcom.ibm.enableLegacyDumpSecurity"},{"location":"dcomibmenablelegacydumpsecurity/#syntax","text":"-Dcom.ibm.enableLegacyDumpSecurity=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenablelegacydumpsecurity/#explanation","text":"Security checking is enabled in the following APIs: com.ibm.jvm.Dump.JavaDump() com.ibm.jvm.Dump.HeapDump() com.ibm.jvm.Dump.SnapDump()","title":"Explanation"},{"location":"dcomibmenablelegacydumpsecurity/#see-also","text":"-Dcom.ibm.enableLegacyLogSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"See also"},{"location":"dcomibmenablelegacylogsecurity/","text":"-Dcom.ibm.enableLegacyLogSecurity To improve security, the security checks in the certain com.ibm.jvm.Log APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs. Syntax -Dcom.ibm.enableLegacyLogSecurity=[true|false] Setting Effect Default true Enable yes false Disable Explanation Security checking is enabled in the following APIs: com.ibm.jvm.Log.QueryOptions() com.ibm.jvm.Log.SetOptions(String) See also -Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"-Dcom.ibm.enableLegacyLogSecurity"},{"location":"dcomibmenablelegacylogsecurity/#-dcomibmenablelegacylogsecurity","text":"To improve security, the security checks in the certain com.ibm.jvm.Log APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs.","title":"-Dcom.ibm.enableLegacyLogSecurity"},{"location":"dcomibmenablelegacylogsecurity/#syntax","text":"-Dcom.ibm.enableLegacyLogSecurity=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenablelegacylogsecurity/#explanation","text":"Security checking is enabled in the following APIs: com.ibm.jvm.Log.QueryOptions() com.ibm.jvm.Log.SetOptions(String)","title":"Explanation"},{"location":"dcomibmenablelegacylogsecurity/#see-also","text":"-Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"See also"},{"location":"dcomibmenablelegacytracesecurity/","text":"-Dcom.ibm.enableLegacyTraceSecurity To improve security, the security checks in certain com.ibm.jvm.Trace APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs. Syntax -Dcom.ibm.enableLegacyTraceSecurity=[true|false] Setting Effect Default true Enable yes false Disable Explanation Security checking is enabled in the following APIs: com.ibm.jvm.Trace.set(String) com.ibm.jvm.Trace.snap() com.ibm.jvm.Trace.suspend() com.ibm.jvm.Trace.suspendThis() com.ibm.jvm.Trace.resume() com.ibm.jvm.Trace.resumeThis() com.ibm.jvm.Trace.registerApplication(String, String[]) See also -Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyLogSecurity","title":"-Dcom.ibm.enableLegacyTraceSecurity"},{"location":"dcomibmenablelegacytracesecurity/#-dcomibmenablelegacytracesecurity","text":"To improve security, the security checks in certain com.ibm.jvm.Trace APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs.","title":"-Dcom.ibm.enableLegacyTraceSecurity"},{"location":"dcomibmenablelegacytracesecurity/#syntax","text":"-Dcom.ibm.enableLegacyTraceSecurity=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenablelegacytracesecurity/#explanation","text":"Security checking is enabled in the following APIs: com.ibm.jvm.Trace.set(String) com.ibm.jvm.Trace.snap() com.ibm.jvm.Trace.suspend() com.ibm.jvm.Trace.suspendThis() com.ibm.jvm.Trace.resume() com.ibm.jvm.Trace.resumeThis() com.ibm.jvm.Trace.registerApplication(String, String[])","title":"Explanation"},{"location":"dcomibmenablelegacytracesecurity/#see-also","text":"-Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyLogSecurity","title":"See also"},{"location":"dcomibmgpudisable/","text":"-Dcom.ibm.gpu.disable Restriction: This system property is supported only on Java\u2122 11 and later. If you have enabled GPU processing with -Dcom.ibm.gpu.enable , use this system property to turn off processing that can be offloaded to a graphics processing unit (GPU). Syntax -Dcom.ibm.gpu.disable Explanation Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. GPU processing is therefore disabled by default. However, if you have enabled GPU processing with -Dcom.ibm.gpu.enable , this property turns GPU processing off. See also Exploiting GPUs -Dcom.ibm.gpu.enable -Dcom.ibm.gpu.verbose","title":"-Dcom.ibm.gpu.disable"},{"location":"dcomibmgpudisable/#-dcomibmgpudisable","text":"Restriction: This system property is supported only on Java\u2122 11 and later. If you have enabled GPU processing with -Dcom.ibm.gpu.enable , use this system property to turn off processing that can be offloaded to a graphics processing unit (GPU).","title":"-Dcom.ibm.gpu.disable"},{"location":"dcomibmgpudisable/#syntax","text":"-Dcom.ibm.gpu.disable","title":"Syntax"},{"location":"dcomibmgpudisable/#explanation","text":"Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. GPU processing is therefore disabled by default. However, if you have enabled GPU processing with -Dcom.ibm.gpu.enable , this property turns GPU processing off.","title":"Explanation"},{"location":"dcomibmgpudisable/#see-also","text":"Exploiting GPUs -Dcom.ibm.gpu.enable -Dcom.ibm.gpu.verbose","title":"See also"},{"location":"dcomibmgpuenable/","text":"-Dcom.ibm.gpu.enable Restriction: This system property is supported only on Java\u2122 11 and later. Use this system property to control the type of processing that can be offloaded to a graphics processing unit (GPU) when processing requirements meet a specific threshold. This feature can improve the performance of certain Java functions. Syntax -Dcom.ibm.gpu.enable=[all|sort] Setting Effect all Turns on GPU processing for all possible Java functions. sort Turns on GPU processing only for the Java sort() function. By default, this property is not set. Explanation Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. When set, this property enables GPU processing for any array that meets a minimum size. See also Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.verbose","title":"-Dcom.ibm.gpu.enable"},{"location":"dcomibmgpuenable/#-dcomibmgpuenable","text":"Restriction: This system property is supported only on Java\u2122 11 and later. Use this system property to control the type of processing that can be offloaded to a graphics processing unit (GPU) when processing requirements meet a specific threshold. This feature can improve the performance of certain Java functions.","title":"-Dcom.ibm.gpu.enable"},{"location":"dcomibmgpuenable/#syntax","text":"-Dcom.ibm.gpu.enable=[all|sort] Setting Effect all Turns on GPU processing for all possible Java functions. sort Turns on GPU processing only for the Java sort() function. By default, this property is not set.","title":"Syntax"},{"location":"dcomibmgpuenable/#explanation","text":"Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. When set, this property enables GPU processing for any array that meets a minimum size.","title":"Explanation"},{"location":"dcomibmgpuenable/#see-also","text":"Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.verbose","title":"See also"},{"location":"dcomibmgpuverbose/","text":"-Dcom.ibm.gpu.verbose Restriction: This system property is supported only on Java\u2122 11 and later. This system property can be used to help identify problems with graphics processing unit (GPU) processing. Syntax -Dcom.ibm.gpu.verbose This property is not set by default. Explanation When specified, this option generates verbose output to STDOUT, which can be piped to a file. See also Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.enable","title":"-Dcom.ibm.gpu.verbose"},{"location":"dcomibmgpuverbose/#-dcomibmgpuverbose","text":"Restriction: This system property is supported only on Java\u2122 11 and later. This system property can be used to help identify problems with graphics processing unit (GPU) processing.","title":"-Dcom.ibm.gpu.verbose"},{"location":"dcomibmgpuverbose/#syntax","text":"-Dcom.ibm.gpu.verbose This property is not set by default.","title":"Syntax"},{"location":"dcomibmgpuverbose/#explanation","text":"When specified, this option generates verbose output to STDOUT, which can be piped to a file.","title":"Explanation"},{"location":"dcomibmgpuverbose/#see-also","text":"Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.enable","title":"See also"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/","text":"-Dcom.ibm.lang.management. OperatingSystemMXBean.isCpuTime100ns Changes the unit of the return value of the OperatingSystemMXBean.getProcessCpuTime() method. Syntax -Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns=[true|false] Setting Effect Default true Enable false Disable yes Explanation The Oracle java.lang.management package includes MBean categories such as Memory , OperatingSystem , and GarbageCollector . The Eclipse OpenJ9\u2122 VM provides additional MXBeans to extend the monitoring and management capabilities. For example, the OperatingSystemMXBean , which monitors operating system settings such as physical and virtual memory size, processor capacity, and processor utilization. The OperatingSystemMXBean.getProcessCpuTime() method returns a value in nanoseconds (10 -9 s), for compatibility with the com.sun.management.OperatingSystemMXBean and UnixOperatingSystemMXBean interfaces. In earlier VM releases, the return value was in hundreds of nanoseconds. If you want to revert to this behavior, set the -Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns property to true . The default value for this property is false . See also Monitoring and management API documentation","title":"-Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#-dcomibmlangmanagementoperatingsystemmxbeaniscputime100ns","text":"Changes the unit of the return value of the OperatingSystemMXBean.getProcessCpuTime() method.","title":"-Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#syntax","text":"-Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns=[true|false] Setting Effect Default true Enable false Disable yes","title":"Syntax"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#explanation","text":"The Oracle java.lang.management package includes MBean categories such as Memory , OperatingSystem , and GarbageCollector . The Eclipse OpenJ9\u2122 VM provides additional MXBeans to extend the monitoring and management capabilities. For example, the OperatingSystemMXBean , which monitors operating system settings such as physical and virtual memory size, processor capacity, and processor utilization. The OperatingSystemMXBean.getProcessCpuTime() method returns a value in nanoseconds (10 -9 s), for compatibility with the com.sun.management.OperatingSystemMXBean and UnixOperatingSystemMXBean interfaces. In earlier VM releases, the return value was in hundreds of nanoseconds. If you want to revert to this behavior, set the -Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns property to true . The default value for this property is false .","title":"Explanation"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#see-also","text":"Monitoring and management API documentation","title":"See also"},{"location":"dcomibmlangmanagementverbose/","text":"-Dcom.ibm.lang.management.verbose Enables verbose information from java.lang.management operations to be written to the output channel during VM operations. Syntax -Dcom.ibm.lang.management.verbose There are no options for this system property.","title":"-Dcom.ibm.lang.management.verbose"},{"location":"dcomibmlangmanagementverbose/#-dcomibmlangmanagementverbose","text":"Enables verbose information from java.lang.management operations to be written to the output channel during VM operations.","title":"-Dcom.ibm.lang.management.verbose"},{"location":"dcomibmlangmanagementverbose/#syntax","text":"-Dcom.ibm.lang.management.verbose There are no options for this system property.","title":"Syntax"},{"location":"dcomibmotisharedsharedclassglobalfilterclass/","text":"-Dcom.ibm.oti.shared.SharedClassGlobalFilterClass This system property applies a global filter to all non-bootstrap class loaders that share classes. Syntax -Dcom.ibm.oti.shared.SharedClassGlobalFilterClass=<filter_class_name> This property is not set by default. Explanation A filter can be used to decide which classes are found and stored by a custom class loader in a shared classes cache. The filter is applied to a particular package by implementing the SharedClassFilter interface. See also The Java shared classes Helper API Shared classes Helper API package: com.ibm.oti.shared","title":"-Dcom.ibm.oti.shared.SharedClassGlobalFilterClass"},{"location":"dcomibmotisharedsharedclassglobalfilterclass/#-dcomibmotisharedsharedclassglobalfilterclass","text":"This system property applies a global filter to all non-bootstrap class loaders that share classes.","title":"-Dcom.ibm.oti.shared.SharedClassGlobalFilterClass"},{"location":"dcomibmotisharedsharedclassglobalfilterclass/#syntax","text":"-Dcom.ibm.oti.shared.SharedClassGlobalFilterClass=<filter_class_name> This property is not set by default.","title":"Syntax"},{"location":"dcomibmotisharedsharedclassglobalfilterclass/#explanation","text":"A filter can be used to decide which classes are found and stored by a custom class loader in a shared classes cache. The filter is applied to a particular package by implementing the SharedClassFilter interface.","title":"Explanation"},{"location":"dcomibmotisharedsharedclassglobalfilterclass/#see-also","text":"The Java shared classes Helper API Shared classes Helper API package: com.ibm.oti.shared","title":"See also"},{"location":"dcomibmtoolsattachcommand_timeout/","text":"-Dcom.ibm.tools.attach.command_timeout Specify the timeout for sending a command to the target VM after the initial attachment. Syntax -Dcom.ibm.tools.attach.command_timeout=<ms> Setting Value Default <ms> [1 millisecond or greater] 0 milliseconds (no timeout) See also Java\u2122 Attach API -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.command_timeout"},{"location":"dcomibmtoolsattachcommand_timeout/#-dcomibmtoolsattachcommand_timeout","text":"Specify the timeout for sending a command to the target VM after the initial attachment.","title":"-Dcom.ibm.tools.attach.command_timeout"},{"location":"dcomibmtoolsattachcommand_timeout/#syntax","text":"-Dcom.ibm.tools.attach.command_timeout=<ms> Setting Value Default <ms> [1 millisecond or greater] 0 milliseconds (no timeout)","title":"Syntax"},{"location":"dcomibmtoolsattachcommand_timeout/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachdirectory/","text":"-Dcom.ibm.tools.attach.directory Specify a different common directory for Attach API working files. Syntax -Dcom.ibm.tools.attach.directory=<directory_name> Setting Value Default <directory_name> [string] .com_ibm_tools_attach To change the value for directory_name , specify a different directory name. If the directory does not exist, it is created. However, if a parent directory is specified, it must exist. The common directory must be on a local drive, not a network drive. See also Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.directory"},{"location":"dcomibmtoolsattachdirectory/#-dcomibmtoolsattachdirectory","text":"Specify a different common directory for Attach API working files.","title":"-Dcom.ibm.tools.attach.directory"},{"location":"dcomibmtoolsattachdirectory/#syntax","text":"-Dcom.ibm.tools.attach.directory=<directory_name> Setting Value Default <directory_name> [string] .com_ibm_tools_attach To change the value for directory_name , specify a different directory name. If the directory does not exist, it is created. However, if a parent directory is specified, it must exist. The common directory must be on a local drive, not a network drive.","title":"Syntax"},{"location":"dcomibmtoolsattachdirectory/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachdisplayname/","text":"-Dcom.ibm.tools.attach.displayName Change the default display name for the target virtual machine. Syntax -Dcom.ibm.tools.attach.displayName=<my_display_name> Setting Value Default <my_display_name> [string] The command line invocation used to start the application To change the value for <my_display_name> that is recorded by an agent, enter a character string of your choice. See also Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.displayName"},{"location":"dcomibmtoolsattachdisplayname/#-dcomibmtoolsattachdisplayname","text":"Change the default display name for the target virtual machine.","title":"-Dcom.ibm.tools.attach.displayName"},{"location":"dcomibmtoolsattachdisplayname/#syntax","text":"-Dcom.ibm.tools.attach.displayName=<my_display_name> Setting Value Default <my_display_name> [string] The command line invocation used to start the application To change the value for <my_display_name> that is recorded by an agent, enter a character string of your choice.","title":"Syntax"},{"location":"dcomibmtoolsattachdisplayname/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachenable/","text":"-Dcom.ibm.tools.attach.enable Enable the Attach API for this application. Syntax -Dcom.ibm.tools.attach.enable=[yes|no] On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 systems, the following default applies: Value Effect Default yes Enable yes no Disable On z/OS\u00ae systems, the following default applies: Value Effect Default yes Enable no Disable yes Explanation A useful reference for information about the Java\u2122 Attach API can be found at http://docs.oracle.com/javase/8/docs/technotes/guides/attach/index.html . The following extract is taken from the Oracle documentation: The Attach API is an extension that provides a mechanism to attach to a Java virtual machine. A tool written in the Java Language, uses this API to attach to a target virtual machine and load its tool agent into that virtual machine. A usage example is to late attach the IBM\u00ae Health Center agent to a virtual machine (VM) that is already running. The Eclipse OpenJ9\u2122 implementation of the Attach API is equivalent to the Oracle implementation. However, the OpenJ9 implementation cannot be used to attach to, or accept attach requests from, other VM implementations. See also Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.enable"},{"location":"dcomibmtoolsattachenable/#-dcomibmtoolsattachenable","text":"Enable the Attach API for this application.","title":"-Dcom.ibm.tools.attach.enable"},{"location":"dcomibmtoolsattachenable/#syntax","text":"-Dcom.ibm.tools.attach.enable=[yes|no] On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 systems, the following default applies: Value Effect Default yes Enable yes no Disable On z/OS\u00ae systems, the following default applies: Value Effect Default yes Enable no Disable yes","title":"Syntax"},{"location":"dcomibmtoolsattachenable/#explanation","text":"A useful reference for information about the Java\u2122 Attach API can be found at http://docs.oracle.com/javase/8/docs/technotes/guides/attach/index.html . The following extract is taken from the Oracle documentation: The Attach API is an extension that provides a mechanism to attach to a Java virtual machine. A tool written in the Java Language, uses this API to attach to a target virtual machine and load its tool agent into that virtual machine. A usage example is to late attach the IBM\u00ae Health Center agent to a virtual machine (VM) that is already running. The Eclipse OpenJ9\u2122 implementation of the Attach API is equivalent to the Oracle implementation. However, the OpenJ9 implementation cannot be used to attach to, or accept attach requests from, other VM implementations.","title":"Explanation"},{"location":"dcomibmtoolsattachenable/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachid/","text":"-Dcom.ibm.tools.attach.id Specify a different virtual machine (VM) identifier. Syntax -Dcom.ibm.tools.attach.id=<my_vm_ID> Setting Value Default <my_vm_ID> [string] Target VM process ID To change the VM identifier recorded by an agent, change the value for <my_vm_ID> . The string must start with an alphabetic character. The remaining characters must be alphanumeric or underscore. Case-sensitivity is system dependent. If the VM identifier is already in use, the attach API modifies it to create a unique value. See also Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.id"},{"location":"dcomibmtoolsattachid/#-dcomibmtoolsattachid","text":"Specify a different virtual machine (VM) identifier.","title":"-Dcom.ibm.tools.attach.id"},{"location":"dcomibmtoolsattachid/#syntax","text":"-Dcom.ibm.tools.attach.id=<my_vm_ID> Setting Value Default <my_vm_ID> [string] Target VM process ID To change the VM identifier recorded by an agent, change the value for <my_vm_ID> . The string must start with an alphabetic character. The remaining characters must be alphanumeric or underscore. Case-sensitivity is system dependent. If the VM identifier is already in use, the attach API modifies it to create a unique value.","title":"Syntax"},{"location":"dcomibmtoolsattachid/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachlogging/","text":"-Dcom.ibm.tools.attach.logging Enable logging for Attach API events. Syntax -Dcom.ibm.tools.attach.logging=[yes|no] Value Effect Default yes Enable no Disable yes Explanation Turn on tracing and logging of Attach API events to help diagnose problems. One timestamped log file is created for each Java\u2122 process in the current directory for the running JVM . See also Java Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.logging"},{"location":"dcomibmtoolsattachlogging/#-dcomibmtoolsattachlogging","text":"Enable logging for Attach API events.","title":"-Dcom.ibm.tools.attach.logging"},{"location":"dcomibmtoolsattachlogging/#syntax","text":"-Dcom.ibm.tools.attach.logging=[yes|no] Value Effect Default yes Enable no Disable yes","title":"Syntax"},{"location":"dcomibmtoolsattachlogging/#explanation","text":"Turn on tracing and logging of Attach API events to help diagnose problems. One timestamped log file is created for each Java\u2122 process in the current directory for the running JVM .","title":"Explanation"},{"location":"dcomibmtoolsattachlogging/#see-also","text":"Java Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachlogname/","text":"-Dcom.ibm.tools.attach.log.name Specify the path and prefix for the log files. Syntax -Dcom.ibm.tools.attach.log.name=<path/prefix> Setting Value Default <path/prefix> [string] VM process directory By default, when -Dcom.ibm.tools.attach.logging=true is set, timestamped log files are written to the current directory for the running VM. Use the -Dcom.ibm.tools.attach.log.name option to change the path and prefix for the logfiles. See also Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.log.name"},{"location":"dcomibmtoolsattachlogname/#-dcomibmtoolsattachlogname","text":"Specify the path and prefix for the log files.","title":"-Dcom.ibm.tools.attach.log.name"},{"location":"dcomibmtoolsattachlogname/#syntax","text":"-Dcom.ibm.tools.attach.log.name=<path/prefix> Setting Value Default <path/prefix> [string] VM process directory By default, when -Dcom.ibm.tools.attach.logging=true is set, timestamped log files are written to the current directory for the running VM. Use the -Dcom.ibm.tools.attach.log.name option to change the path and prefix for the logfiles.","title":"Syntax"},{"location":"dcomibmtoolsattachlogname/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.shutdown_timeout -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachshutdown_timeout/","text":"-Dcom.ibm.tools.attach.shutdown_timeout Specify a timeout before ending the Attach API wait loop thread. Syntax -Dcom.ibm.tools.attach.shutdown_timeout=<ms> Setting Value Default <ms> [1 millisecond or greater] 10000 milliseconds (10 seconds) See also Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.shutdown_timeout"},{"location":"dcomibmtoolsattachshutdown_timeout/#-dcomibmtoolsattachshutdown_timeout","text":"Specify a timeout before ending the Attach API wait loop thread.","title":"-Dcom.ibm.tools.attach.shutdown_timeout"},{"location":"dcomibmtoolsattachshutdown_timeout/#syntax","text":"-Dcom.ibm.tools.attach.shutdown_timeout=<ms> Setting Value Default <ms> [1 millisecond or greater] 10000 milliseconds (10 seconds)","title":"Syntax"},{"location":"dcomibmtoolsattachshutdown_timeout/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachtimeout/","text":"-Dcom.ibm.tools.attach.timeout Specify a time that an application should wait when attempting to connect to a target virtual machine (VM) before ending. Syntax -Dcom.ibm.tools.attach.timeout=<ms> Setting Value Default <ms> [501 milliseconds or greater] 120000 milliseconds (120 seconds) If you specify a value of 500 milliseconds or lower, no connection attempt is made. Example To timeout after 60 seconds, specify: -Dcom.ibm.tools.attach.timeout=60000 See also Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout","title":"-Dcom.ibm.tools.attach.timeout"},{"location":"dcomibmtoolsattachtimeout/#-dcomibmtoolsattachtimeout","text":"Specify a time that an application should wait when attempting to connect to a target virtual machine (VM) before ending.","title":"-Dcom.ibm.tools.attach.timeout"},{"location":"dcomibmtoolsattachtimeout/#syntax","text":"-Dcom.ibm.tools.attach.timeout=<ms> Setting Value Default <ms> [501 milliseconds or greater] 120000 milliseconds (120 seconds) If you specify a value of 500 milliseconds or lower, no connection attempt is made.","title":"Syntax"},{"location":"dcomibmtoolsattachtimeout/#example","text":"To timeout after 60 seconds, specify: -Dcom.ibm.tools.attach.timeout=60000","title":"Example"},{"location":"dcomibmtoolsattachtimeout/#see-also","text":"Java\u2122 Attach API -Dcom.ibm.tools.attach.command_timeout -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.logging -Dcom.ibm.tools.attach.log.name -Dcom.ibm.tools.attach.shutdown_timeout","title":"See also"},{"location":"dfileencoding/","text":"-Dfile.encoding Use this OpenJDK property to define the file encoding that is required. Syntax -Dfile.encoding=<value> Setting Value Default <value> [string] Unicode 3.0 standards where <value> defines the file encoding that is required. Explanation By default the GBK converter follows Unicode 3.0 standards. To force the GBK converter to follow Unicode 2.0 standards, use a value of bestfit936 .","title":"-Dfile.encoding"},{"location":"dfileencoding/#-dfileencoding","text":"Use this OpenJDK property to define the file encoding that is required.","title":"-Dfile.encoding"},{"location":"dfileencoding/#syntax","text":"-Dfile.encoding=<value> Setting Value Default <value> [string] Unicode 3.0 standards where <value> defines the file encoding that is required.","title":"Syntax"},{"location":"dfileencoding/#explanation","text":"By default the GBK converter follows Unicode 3.0 standards. To force the GBK converter to follow Unicode 2.0 standards, use a value of bestfit936 .","title":"Explanation"},{"location":"diag_overview/","text":"Diagnostic data and tooling Eclipse OpenJ9\u2122 contains a broad range of diagnostic capabilities to help identify, isolate, and solve run time problems. These capabilities include dump files, verbose logs, and trace files, which are supported by a variety of diagnostic tools and interfaces. Dumps Various types of dumps are produced by default in response to certain events, such as a GPF fault or an OutOfMemoryError exception. You can also trigger the production of dumps by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. All dumps are produced by dump agents, which are initialized when the OpenJ9 VM starts. Different dumps target different areas of the runtime environment. If you want to generate a dump to diagnose a particular type of problem, you need to understand what data the dump will provide. The following dumps are typically used for problem diagnosis: Java dumps ( -Xdump:java ) contain information that relates to the OpenJ9 VM and the Java\u2122 application, such as the operating environment, locks, threads, hooks, shared classes, and class loaders. Heap dumps ( -Xdump:heap ) show the content of the Java heap. System dumps ( -Xdump:system ) contain a raw process image or address space of an application. Other types of dump include binary JIT dumps, stack dumps, and snap dumps. For a complete list of dump agents and the diagnostic data they produce, see Dump agents . Verbose log files Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination. Class data sharing provides a number of -Xshareclasses suboptions to provide detailed data about the content of a shared classes cache, cache I/O activity, and information about the Java Helper API (where used). For example, the -Xshareclasses:printAllStats suboption lists every class in chronological order with a reference to the location from which it was loaded. For more information, see -Xshareclasses . Garbage collection operations can be analyzed by producing verbose output from the -verbose:gc standard option. This output can be redirected to a file by specifying the -Xverbosegclog option. Information can be obtained about GC initialization, stop-the-world processing, finalization, reference processing, and allocation failures. Even more granular information can be obtained with the -Xtgc option. For more information, see verbose GC logs . The JIT compiler provides verbose logging, which records all compiler operations. To find out how to enable logging, read the JIT troubleshooting content. Class loader operations can be analyzed by producing verbose output from the -verbose:dynload standard option, which shows detailed information as each class is loaded by the VM. Trace files The OpenJ9 trace facility can be used to trace applications, Java methods, or internal JVM operations with minimal impact on performance. Trace is configured by using the -Xtrace command line option, which allows you to control what is traced and when. Trace data is produced in binary format and must be processed by the OpenJ9 trace formatter to convert it to a readable form. For more information, see Trace formatter . Diagnostic tools A number of diagnostic tools are available with OpenJ9 to assist with the analysis of dump and trace files. Dump extractor The dump extractor ( jpackcore ) supports a full analysis of core files on specific platforms by collecting key files from a system and packaging them into an archive along with a core dump. This archive file is extremely useful when reporting issues to the OpenJ9 community, helping to ensure a faster analysis and turnaround. For more information, see Dump extractor . Dump viewer Because system dumps are binary files, OpenJ9 provides a dump viewer tool ( jdmpview ) to analyze the contents. This tool can work with dumps from any platforms independently of a system debugger. For more information, see Dump viewer . Trace formatter The trace formatter tool converts binary trace point data in a trace file into a readable format for analysis. For more information, see Trace formatter . Option builder OpenJ9 contains an extensive set of command-line options to assist with problem diagnosis. Certain options are complex, containing many sub-options with numerous parameters. Whilst these offer a great degree of flexibility, the syntax can be difficult to construct. Option builder tools are available that provide a simple graphical user interface to help you construct your command-line argument. For more information, see Option builder . HotSpot-compatible tools A number of tools are available for compatibility with the reference implementation. These tools are independently implemented by OpenJ9 but have similar functions, allowing users to migrate more easily. The available tools are listed in the Tools section. Note: If you are already familiar with tools that are provided with HotSpot, see Switching to OpenJ9 , which explains some of the differences you might encounter when using OpenJ9. Eclipse marketplace tools OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Eclipse Memory Analyzer\u2122: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center. Interfaces JVM tool interface (JVMTI) OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information, see Java Virtual Machine Tool Interface . DTFJ Interface OpenJ9 includes the Diagnostic Tool Framework for Java (DTFJ) API. Custom applications can be written that use this API to access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer tool (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information, see Diagnostic Tool Framework for Java . Language Management interface OpenJ9 provides MXBean additions and extensions to the standard java.lang.management API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface . JPDA tools OpenJ9 is compliant with the Java Platform Debugging Architecture (JPDA), which means you can use any JPDA tool for diagnosis, including Eclipse JDT Debug .","title":"Overview"},{"location":"diag_overview/#diagnostic-data-and-tooling","text":"Eclipse OpenJ9\u2122 contains a broad range of diagnostic capabilities to help identify, isolate, and solve run time problems. These capabilities include dump files, verbose logs, and trace files, which are supported by a variety of diagnostic tools and interfaces.","title":"Diagnostic data and tooling"},{"location":"diag_overview/#dumps","text":"Various types of dumps are produced by default in response to certain events, such as a GPF fault or an OutOfMemoryError exception. You can also trigger the production of dumps by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. All dumps are produced by dump agents, which are initialized when the OpenJ9 VM starts. Different dumps target different areas of the runtime environment. If you want to generate a dump to diagnose a particular type of problem, you need to understand what data the dump will provide. The following dumps are typically used for problem diagnosis: Java dumps ( -Xdump:java ) contain information that relates to the OpenJ9 VM and the Java\u2122 application, such as the operating environment, locks, threads, hooks, shared classes, and class loaders. Heap dumps ( -Xdump:heap ) show the content of the Java heap. System dumps ( -Xdump:system ) contain a raw process image or address space of an application. Other types of dump include binary JIT dumps, stack dumps, and snap dumps. For a complete list of dump agents and the diagnostic data they produce, see Dump agents .","title":"Dumps"},{"location":"diag_overview/#verbose-log-files","text":"Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination. Class data sharing provides a number of -Xshareclasses suboptions to provide detailed data about the content of a shared classes cache, cache I/O activity, and information about the Java Helper API (where used). For example, the -Xshareclasses:printAllStats suboption lists every class in chronological order with a reference to the location from which it was loaded. For more information, see -Xshareclasses . Garbage collection operations can be analyzed by producing verbose output from the -verbose:gc standard option. This output can be redirected to a file by specifying the -Xverbosegclog option. Information can be obtained about GC initialization, stop-the-world processing, finalization, reference processing, and allocation failures. Even more granular information can be obtained with the -Xtgc option. For more information, see verbose GC logs . The JIT compiler provides verbose logging, which records all compiler operations. To find out how to enable logging, read the JIT troubleshooting content. Class loader operations can be analyzed by producing verbose output from the -verbose:dynload standard option, which shows detailed information as each class is loaded by the VM.","title":"Verbose log files"},{"location":"diag_overview/#trace-files","text":"The OpenJ9 trace facility can be used to trace applications, Java methods, or internal JVM operations with minimal impact on performance. Trace is configured by using the -Xtrace command line option, which allows you to control what is traced and when. Trace data is produced in binary format and must be processed by the OpenJ9 trace formatter to convert it to a readable form. For more information, see Trace formatter .","title":"Trace files"},{"location":"diag_overview/#diagnostic-tools","text":"A number of diagnostic tools are available with OpenJ9 to assist with the analysis of dump and trace files.","title":"Diagnostic tools"},{"location":"diag_overview/#dump-extractor","text":"The dump extractor ( jpackcore ) supports a full analysis of core files on specific platforms by collecting key files from a system and packaging them into an archive along with a core dump. This archive file is extremely useful when reporting issues to the OpenJ9 community, helping to ensure a faster analysis and turnaround. For more information, see Dump extractor .","title":"Dump extractor"},{"location":"diag_overview/#dump-viewer","text":"Because system dumps are binary files, OpenJ9 provides a dump viewer tool ( jdmpview ) to analyze the contents. This tool can work with dumps from any platforms independently of a system debugger. For more information, see Dump viewer .","title":"Dump viewer"},{"location":"diag_overview/#trace-formatter","text":"The trace formatter tool converts binary trace point data in a trace file into a readable format for analysis. For more information, see Trace formatter .","title":"Trace formatter"},{"location":"diag_overview/#option-builder","text":"OpenJ9 contains an extensive set of command-line options to assist with problem diagnosis. Certain options are complex, containing many sub-options with numerous parameters. Whilst these offer a great degree of flexibility, the syntax can be difficult to construct. Option builder tools are available that provide a simple graphical user interface to help you construct your command-line argument. For more information, see Option builder .","title":"Option builder"},{"location":"diag_overview/#hotspot-compatible-tools","text":"A number of tools are available for compatibility with the reference implementation. These tools are independently implemented by OpenJ9 but have similar functions, allowing users to migrate more easily. The available tools are listed in the Tools section. Note: If you are already familiar with tools that are provided with HotSpot, see Switching to OpenJ9 , which explains some of the differences you might encounter when using OpenJ9.","title":"HotSpot-compatible tools"},{"location":"diag_overview/#eclipse-marketplace-tools","text":"OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Eclipse Memory Analyzer\u2122: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center.","title":"Eclipse marketplace tools"},{"location":"diag_overview/#interfaces","text":"","title":"Interfaces"},{"location":"diag_overview/#jvm-tool-interface-jvmti","text":"OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information, see Java Virtual Machine Tool Interface .","title":"JVM tool interface (JVMTI)"},{"location":"diag_overview/#dtfj-interface","text":"OpenJ9 includes the Diagnostic Tool Framework for Java (DTFJ) API. Custom applications can be written that use this API to access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer tool (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information, see Diagnostic Tool Framework for Java .","title":"DTFJ Interface"},{"location":"diag_overview/#language-management-interface","text":"OpenJ9 provides MXBean additions and extensions to the standard java.lang.management API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface .","title":"Language Management interface"},{"location":"diag_overview/#jpda-tools","text":"OpenJ9 is compliant with the Java Platform Debugging Architecture (JPDA), which means you can use any JPDA tool for diagnosis, including Eclipse JDT Debug .","title":"JPDA tools"},{"location":"djavacompiler/","text":"-Djava.compiler This Oracle HotSpot property is used for loading a JIT compiler from a named, native library. This option can be used on the command line to specify the JIT compiler for the Eclipse OpenJ9\u2122 VM. Syntax -Djava.compiler=j9jit29","title":"-Djava.compiler"},{"location":"djavacompiler/#-djavacompiler","text":"This Oracle HotSpot property is used for loading a JIT compiler from a named, native library. This option can be used on the command line to specify the JIT compiler for the Eclipse OpenJ9\u2122 VM.","title":"-Djava.compiler"},{"location":"djavacompiler/#syntax","text":"-Djava.compiler=j9jit29","title":"Syntax"},{"location":"djavalangstringbuffergrowaggressively/","text":"-Djava.lang.stringBuffer.growAggressively Restriction: This system property is supported only on Java\u2122 8. Setting this property to false reverts to the behavior (Eclipse OpenJ9\u2122 0.18 and earlier) of growing a 1 G char[] or larger StringBuffer or StringBuilder only as much as necessary to accommodate the String being added. The default behavior is to immediately grow to the maximum possible size, similarly to Java 11 and later. The default behavior is compatible with the Oracle HotSpot VM. Syntax -Djava.lang.stringBufferAndBuilder.growAggressively=[true|false] Setting Effect Default true Above 1 G, grow to the maximum size yes false Above 1 G, grow only as required","title":"-Djava.lang.stringBuffer.growAggressively"},{"location":"djavalangstringbuffergrowaggressively/#-djavalangstringbuffergrowaggressively","text":"Restriction: This system property is supported only on Java\u2122 8. Setting this property to false reverts to the behavior (Eclipse OpenJ9\u2122 0.18 and earlier) of growing a 1 G char[] or larger StringBuffer or StringBuilder only as much as necessary to accommodate the String being added. The default behavior is to immediately grow to the maximum possible size, similarly to Java 11 and later. The default behavior is compatible with the Oracle HotSpot VM.","title":"-Djava.lang.stringBuffer.growAggressively"},{"location":"djavalangstringbuffergrowaggressively/#syntax","text":"-Djava.lang.stringBufferAndBuilder.growAggressively=[true|false] Setting Effect Default true Above 1 G, grow to the maximum size yes false Above 1 G, grow only as required","title":"Syntax"},{"location":"djavalangstringsubstringnocopy/","text":"-Djava.lang.string.substring.nocopy Restriction: This system property is supported only on Java\u2122 8. String sharing cannot be enabled on Java 11 and later. Setting this property to true avoids sharing a String object when substring() is used to subset a String beginning from offset zero. Avoiding sharing is compatible with the Oracle HotSpot VM. Syntax -Djava.lang.string.substring.nocopy=[true|false] Setting Effect Default true No sharing false Sharing yes","title":"-Djava.lang.string.substring.nocopy"},{"location":"djavalangstringsubstringnocopy/#-djavalangstringsubstringnocopy","text":"Restriction: This system property is supported only on Java\u2122 8. String sharing cannot be enabled on Java 11 and later. Setting this property to true avoids sharing a String object when substring() is used to subset a String beginning from offset zero. Avoiding sharing is compatible with the Oracle HotSpot VM.","title":"-Djava.lang.string.substring.nocopy"},{"location":"djavalangstringsubstringnocopy/#syntax","text":"-Djava.lang.string.substring.nocopy=[true|false] Setting Effect Default true No sharing false Sharing yes","title":"Syntax"},{"location":"djdknativecbc/","text":"-Djdk.nativeCBC This option enables or disables OpenSSL native cryptographic support for the CBC algorithm. Syntax -Djdk.nativeCBC=[true|false] Setting value Default -Djdk.nativeCBC true yes -Djdk.nativeCBC false Explanation OpenSSL support is enabled by default for the CBC algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeCBC"},{"location":"djdknativecbc/#-djdknativecbc","text":"This option enables or disables OpenSSL native cryptographic support for the CBC algorithm.","title":"-Djdk.nativeCBC"},{"location":"djdknativecbc/#syntax","text":"-Djdk.nativeCBC=[true|false] Setting value Default -Djdk.nativeCBC true yes -Djdk.nativeCBC false","title":"Syntax"},{"location":"djdknativecbc/#explanation","text":"OpenSSL support is enabled by default for the CBC algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativechacha20/","text":"-Djdk.nativeChaCha20 This option enables or disables OpenSSL native cryptographic support for the ChaCha20 and ChaCha20-Poly1305 algorithms. Restrictions: These algorithms are not supported on Java\u2122 8. These algorithms are not supported on OpenSSL 1.0.x. Syntax -Djdk.nativeChaCha20=[true|false] Setting value Default -Djdk.nativeChaCha20 true yes -Djdk.nativeChaCha20 false Explanation OpenSSL support is enabled by default for the ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off support for these algorithms only, set this option to false . To turn off support for these and other algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeChaCha20"},{"location":"djdknativechacha20/#-djdknativechacha20","text":"This option enables or disables OpenSSL native cryptographic support for the ChaCha20 and ChaCha20-Poly1305 algorithms. Restrictions: These algorithms are not supported on Java\u2122 8. These algorithms are not supported on OpenSSL 1.0.x.","title":"-Djdk.nativeChaCha20"},{"location":"djdknativechacha20/#syntax","text":"-Djdk.nativeChaCha20=[true|false] Setting value Default -Djdk.nativeChaCha20 true yes -Djdk.nativeChaCha20 false","title":"Syntax"},{"location":"djdknativechacha20/#explanation","text":"OpenSSL support is enabled by default for the ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off support for these algorithms only, set this option to false . To turn off support for these and other algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativecrypto/","text":"-Djdk.nativeCrypto This option controls the use of OpenSSL native cryptographic support. Syntax -Djdk.nativeCrypto=[true|false] Setting value Default -Djdk.nativeCrypto true yes -Djdk.nativeCrypto false Explanation OpenSSL support is enabled by default for the Digest, CBC, GCM, RSA, and ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off the OpenSSL implementation, set this option to false . Restriction: The ChaCha20 and ChaCha20-Poly1305 algorithms are not supported on Java\u2122 8. If you want to turn off the algorithms individually, use the following system properties: -Djdk.nativeCBC -Djdk.nativeChaCha20 ( Not supported on Java 8. ) -Djdk.nativeGCM -Djdk.nativeRSA -Djdk.nativeDigest","title":"-Djdk.nativeCrypto"},{"location":"djdknativecrypto/#-djdknativecrypto","text":"This option controls the use of OpenSSL native cryptographic support.","title":"-Djdk.nativeCrypto"},{"location":"djdknativecrypto/#syntax","text":"-Djdk.nativeCrypto=[true|false] Setting value Default -Djdk.nativeCrypto true yes -Djdk.nativeCrypto false","title":"Syntax"},{"location":"djdknativecrypto/#explanation","text":"OpenSSL support is enabled by default for the Digest, CBC, GCM, RSA, and ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off the OpenSSL implementation, set this option to false . Restriction: The ChaCha20 and ChaCha20-Poly1305 algorithms are not supported on Java\u2122 8. If you want to turn off the algorithms individually, use the following system properties: -Djdk.nativeCBC -Djdk.nativeChaCha20 ( Not supported on Java 8. ) -Djdk.nativeGCM -Djdk.nativeRSA -Djdk.nativeDigest","title":"Explanation"},{"location":"djdknativedigest/","text":"-Djdk.nativeDigest This option enables or disables OpenSSL native cryptographic support for the Digest algorithm. Syntax -Djdk.nativeDigest=[true|false] Setting value Default -Djdk.nativeDigest true yes -Djdk.nativeDigest false Explanation To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeDigest"},{"location":"djdknativedigest/#-djdknativedigest","text":"This option enables or disables OpenSSL native cryptographic support for the Digest algorithm.","title":"-Djdk.nativeDigest"},{"location":"djdknativedigest/#syntax","text":"-Djdk.nativeDigest=[true|false] Setting value Default -Djdk.nativeDigest true yes -Djdk.nativeDigest false","title":"Syntax"},{"location":"djdknativedigest/#explanation","text":"To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativegcm/","text":"-Djdk.nativeGCM This option enables or disables OpenSSL native cryptographic support for the GCM algorithm. Syntax -Djdk.nativeGCM=[true|false] Setting value Default -Djdk.nativeGCM true yes -Djdk.nativeGCM false Explanation OpenSSL support is enabled by default for the GCM algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeGCM"},{"location":"djdknativegcm/#-djdknativegcm","text":"This option enables or disables OpenSSL native cryptographic support for the GCM algorithm.","title":"-Djdk.nativeGCM"},{"location":"djdknativegcm/#syntax","text":"-Djdk.nativeGCM=[true|false] Setting value Default -Djdk.nativeGCM true yes -Djdk.nativeGCM false","title":"Syntax"},{"location":"djdknativegcm/#explanation","text":"OpenSSL support is enabled by default for the GCM algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativersa/","text":"-Djdk.nativeRSA This option enables or disables OpenSSL native cryptographic support for the RSA algorithm. Syntax -Djdk.nativeRSA=[true|false] Setting value Default -Djdk.nativeRSA true yes -Djdk.nativeRSA false Explanation OpenSSL support is enabled by default for the RSA algorithm. If you want to turn off support for this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeRSA"},{"location":"djdknativersa/#-djdknativersa","text":"This option enables or disables OpenSSL native cryptographic support for the RSA algorithm.","title":"-Djdk.nativeRSA"},{"location":"djdknativersa/#syntax","text":"-Djdk.nativeRSA=[true|false] Setting value Default -Djdk.nativeRSA true yes -Djdk.nativeRSA false","title":"Syntax"},{"location":"djdknativersa/#explanation","text":"OpenSSL support is enabled by default for the RSA algorithm. If you want to turn off support for this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"dump_heapdump/","text":"Heap dump Heap dumps contain a snapshot of all the live objects that are being used by a running Java\u2122 application on the Java heap. You can obtain detailed information for each object instance, such as the address, type, class name, or size, and whether the instance has references to other objects. There are two formats for heap dumps; the classic format and the Portable Heap Dump (PHD) format, which is the default. Whilst the classic format is generated in ascii text and can be read, the PHD format is binary and and must be processed for analysis. Obtaining dumps Heap dumps are generated by default in PHD format when the Java heap runs out of space. If you want to trigger the production of a heap dump in response to other situations, or in classic format, you can use one of the following options: Configure the heap dump agent. For more information, see the -Xdump option. Use the com.ibm.jvm.Dump API programmatically in your application code. For more information, see the JVM diagnostic utilities API documentation . Analyzing dumps The best method to analyze a PHD heap dump is to use the Eclipse Memory Analyzer\u2122 tool (MAT) or the IBM Memory Analyzer tool . These tools process the dump file and provide a visual representation of the objects in the Java Heap. Both tools require the Diagnostic Tool Framework for Java (DTFJ) plugin. To install the DTFJ plugin in the Eclipse IDE, select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java The following sections contain detailed information about the content of each type of heap dump file. Portable Heap Dump (PHD) format A PHD format dump file contains a header section and a body section. The body section can contain information about object, array, or class records. Primitive numbers are used to describe the file format, as detailed in the following table: Primitive number Length in bytes byte 1 short 2 int 4 long 8 word 4 (32-bit platforms) or 8 (64-bit platforms) General structure The following structure comprises the header section of a PHD file: A UTF string indicating that the file is a portable heap dump An int containing the PHD version number An int containing flags: 1 indicates that the word length is 64-bit. 2 indicates that all the objects in the dump are hashed. This flag is set for heap dumps that use 16-bit hash codes. Eclipse OpenJ9\u2122 heap dumps use 32-bit hash codes that are created only when used. For example, these hash codes are created when the APIs Object.hashCode() or Object.toString() are called in a Java application. If this flag is not set, the presence of a hash code is indicated by the hash code flag on the individual PHD records. 4 indicates that the dump is from an OpenJ9 VM. A byte containing a tag with a value of 1 that indicates the start of the header. A number of optional header records, each preceded by a one-byte header tag. Header record tags have a different range of values from the body, or object record tags. The end of the header is indicated by the end of header tag. The following tags are included: header tag 1 - not used header tag 2 - indicates the end of the header header tag 3 - not used header tag 4 - indicates the VM version (Variable length UTF string) The body of a PHD file is indicated by a byte that contains a tag with a value of 2, after which there are a number of dump records. Dump records are preceded by a 1 byte tag with the following record types: Short object: 0x80 bit of the tag is set Medium object: 0x40 bit of the tag is set (top bit value is 0) Primitive Array: 0x20 bit if the tag is set (all other tag values have the top 3 bits with a value of 0) Long record: tag value is 4 Class record: tag value is 6 Long primitive array: tag value is 7 Object array: tag value is 8 These records are described in more detail in the sections that follow. The end of the PHD body is indicated by a byte that contains a tag with a value of 3. Object records Object records can be short, medium, or long, depending on the number of object references in the heap dump. 1. Short object record The following information is contained within the tag byte: The 1 byte tag, which consists of the following bits: Bit number Value or description 1 Bit is set (0x80) 2 and 3 Indicates the class cache index. The value represents an index into a cache of the last 4 classes used. 4 and 5 Contain the number of references. Most objects contain 0 - 3 references. If there are 4 - 7 references, the Medium object record is used. If there are more than 7 references, the Long object record is used. 6 Indicates whether the gap is a 1 byte value or a short . The gap is the difference between the address of this object and the previous object. If set, the gap is a short . If the gap does not fit into a short , the Long object record format is used. 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object. The value is signed and represents the number of 32-bit words between the two addresses. Most gaps fit into 1 byte. If all objects are hashed, a short containing the hash code. The array of references, if references exist. The tag shows the number of elements, and the size of each element. The value in each element is the gap between the address of the references and the address of the current object. The value is a signed number of 32-bit words. Null references are not included. 2. Medium object record These records provide the actual address of the class rather than a cache index. The following format is used: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 0 2 Set (0x40) 3, 4, and 5 Contain the number of references 6 Indicates whether the gap is a 1 byte value or a short (see Short object record description) 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object (See the Short object record description) A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. The array of references (See the Short object record description). 3. Long object record This record format is used when there are more than 7 references, or if there are extra flags or a hash code. The following format is used: The 1 byte tag, containing the value 4. A byte containing flags, consisting of the following bits: Bit number Value or description 1 and 2 Indicates whether the gap is a byte , short , int or long format 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code 8 Indicates if the object was hashed A byte , short , int , or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An int containing the length of the array of references. The array of references (See the Short object record description). Array records PHD arrays can be primitive arrays or object arrays, as described in the sections that follow. 1. Primitive array record The following information is contained in an array record: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 and 2 0 3 Set (0x20) 4, 5, and 6 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 7 and 8 Indicates the length of the array size and the length of the gap (0= byte , 1= short , 2= int , 3= long ) byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). byte , short , int or long containing the array length. If all objects are hashed, a short containing the hash code. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 2. Long primitive array record This type of record is used when a primitive array has been hashed. The 1 byte tag with a value of 7. A byte containing the following flags: Bit number Value or description 1, 2, and 3 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 4 Indicates the length of the array size and the length of the gap (0= byte , 1= word ). 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed a byte or word containing the gap between the address of this object and the address of the preceding object (See the Short object record description). a byte or word containing the array length. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 3. Object array record The following format applies: The 1 byte tag with a value of 8. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte , short , int or long . 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed A byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record format description). A word containing the address of the class of the objects in the array. Object array records do not update the class cache. If all objects are hashed, a short containing the hash code. If the hashed and moved bit is set in the records flag, this field contains an int . An int containing the length of the array of references. The array of references (See the Short object record description). An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . An final int value is shown at the end. This int contains the true array length, shown as a number of array elements. The true array length might differ from the length of the array of references because null references are excluded. Class records The PHD class record encodes a class object and contains the following format: The 1 byte tag, containing the value 6. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte, short , int or long 3 and 4 Indicates the size of each static reference (0= byte , 1= short , 2= int , 3= long ) 5 Indicates if the object was hashed A byte, short , int or long containing the gap between the address of this class and the address of the preceding object (See the Short object record description). An int containing the instance size. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. A word containing the address of the superclass. A UTF string containing the name of this class. An int containing the number of static references. The array of static references (See the Short object record description). Classic Heap Dump format Classic heap dumps are produced in ascii text on all platforms except z/OS, which are encoded in EBCDIC. The dump is divided into the following sections: Header record A single string containing information about the runtime environment, platform, and build levels, similar to the following example: // Version: JRE 1.8.0 Linux amd64-64 (build 1.8.0_232-b09) Object records A record of each object instance in the heap with the following format: <object address, in hexadecimal> [<length in bytes of object instance, in decimal>] OBJ <object type> <heap reference, in hexadecimal> <heap reference, in hexadecimal> ... The following object types ( object type ) might be shown: class name (including package name) class array type primitive array type These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found are also listed, excluding references to an object's class or NULL references. The following example shows an object instance (16 bytes in length) of type java/lang/String , with a reference to a char array: 0x00000000E0000AF0 [16] OBJ java/lang/String 0x00000000E0000B00 The object instance (length 32 bytes) of type char array, as referenced from the java/lang/String , is shown in the following example: 0x00000000E0000B00 [32] OBJ [C The following example shows an object instance (24 bytes in length) of type array of java/lang/String : 0x00000000FFF07498 [24] OBJ [Ljava/lang/String; 0x00000000E0005D78 0x00000000E0005D50 0x00000000E0005D28 0x00000000E0005D00 Class records A record of each class in the following format: <class object address, in hexadecimal> [<length in bytes of class object, in decimal>] CLS <class type> <heap reference, in hexadecimal> <heap reference, in hexadecimal>... The following class types ( <class type> ) might be shown: class name (including package name) class array type primitive array types These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found in the class block are also listed, excluding NULL references. The following example shows a class object (80 bytes in length) for java/util/Date , with heap references: 0x00000000E00174F0 [80] CLS java/util/Date 0x00000000FFF1BB60 0x00000000FFF29630 Trailer record 1 A single record containing record counts, in decimal. For example: // Breakdown - Classes: 630, Objects: 3692, ObjectArrays: 576, PrimitiveArrays: 2249 Trailer record 2 A single record containing totals, in decimal. For example: // EOF: Total 'Objects',Refs(null) : 7147,22040(12379) The values in the example reflect the following counts: 7147 total objects 22040 total references (12379) total NULL references as a proportion of the total references count Java VM Type Signatures The following table shows the abbreviations used for different Java types in the heap dump records: Java VM Type Signature Java Type Z boolean B byte C char S short I int J long F float D double L<fully-qualified class>; <fully-qualified class> [<type> <type>[](array of <type>) (<arg-types>)<ret-type> method See also DTFJ interface","title":"Heap dump"},{"location":"dump_heapdump/#heap-dump","text":"Heap dumps contain a snapshot of all the live objects that are being used by a running Java\u2122 application on the Java heap. You can obtain detailed information for each object instance, such as the address, type, class name, or size, and whether the instance has references to other objects. There are two formats for heap dumps; the classic format and the Portable Heap Dump (PHD) format, which is the default. Whilst the classic format is generated in ascii text and can be read, the PHD format is binary and and must be processed for analysis.","title":"Heap dump"},{"location":"dump_heapdump/#obtaining-dumps","text":"Heap dumps are generated by default in PHD format when the Java heap runs out of space. If you want to trigger the production of a heap dump in response to other situations, or in classic format, you can use one of the following options: Configure the heap dump agent. For more information, see the -Xdump option. Use the com.ibm.jvm.Dump API programmatically in your application code. For more information, see the JVM diagnostic utilities API documentation .","title":"Obtaining dumps"},{"location":"dump_heapdump/#analyzing-dumps","text":"The best method to analyze a PHD heap dump is to use the Eclipse Memory Analyzer\u2122 tool (MAT) or the IBM Memory Analyzer tool . These tools process the dump file and provide a visual representation of the objects in the Java Heap. Both tools require the Diagnostic Tool Framework for Java (DTFJ) plugin. To install the DTFJ plugin in the Eclipse IDE, select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java The following sections contain detailed information about the content of each type of heap dump file.","title":"Analyzing dumps"},{"location":"dump_heapdump/#portable-heap-dump-phd-format","text":"A PHD format dump file contains a header section and a body section. The body section can contain information about object, array, or class records. Primitive numbers are used to describe the file format, as detailed in the following table: Primitive number Length in bytes byte 1 short 2 int 4 long 8 word 4 (32-bit platforms) or 8 (64-bit platforms)","title":"Portable Heap Dump (PHD) format"},{"location":"dump_heapdump/#general-structure","text":"The following structure comprises the header section of a PHD file: A UTF string indicating that the file is a portable heap dump An int containing the PHD version number An int containing flags: 1 indicates that the word length is 64-bit. 2 indicates that all the objects in the dump are hashed. This flag is set for heap dumps that use 16-bit hash codes. Eclipse OpenJ9\u2122 heap dumps use 32-bit hash codes that are created only when used. For example, these hash codes are created when the APIs Object.hashCode() or Object.toString() are called in a Java application. If this flag is not set, the presence of a hash code is indicated by the hash code flag on the individual PHD records. 4 indicates that the dump is from an OpenJ9 VM. A byte containing a tag with a value of 1 that indicates the start of the header. A number of optional header records, each preceded by a one-byte header tag. Header record tags have a different range of values from the body, or object record tags. The end of the header is indicated by the end of header tag. The following tags are included: header tag 1 - not used header tag 2 - indicates the end of the header header tag 3 - not used header tag 4 - indicates the VM version (Variable length UTF string) The body of a PHD file is indicated by a byte that contains a tag with a value of 2, after which there are a number of dump records. Dump records are preceded by a 1 byte tag with the following record types: Short object: 0x80 bit of the tag is set Medium object: 0x40 bit of the tag is set (top bit value is 0) Primitive Array: 0x20 bit if the tag is set (all other tag values have the top 3 bits with a value of 0) Long record: tag value is 4 Class record: tag value is 6 Long primitive array: tag value is 7 Object array: tag value is 8 These records are described in more detail in the sections that follow. The end of the PHD body is indicated by a byte that contains a tag with a value of 3.","title":"General structure"},{"location":"dump_heapdump/#object-records","text":"Object records can be short, medium, or long, depending on the number of object references in the heap dump. 1. Short object record The following information is contained within the tag byte: The 1 byte tag, which consists of the following bits: Bit number Value or description 1 Bit is set (0x80) 2 and 3 Indicates the class cache index. The value represents an index into a cache of the last 4 classes used. 4 and 5 Contain the number of references. Most objects contain 0 - 3 references. If there are 4 - 7 references, the Medium object record is used. If there are more than 7 references, the Long object record is used. 6 Indicates whether the gap is a 1 byte value or a short . The gap is the difference between the address of this object and the previous object. If set, the gap is a short . If the gap does not fit into a short , the Long object record format is used. 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object. The value is signed and represents the number of 32-bit words between the two addresses. Most gaps fit into 1 byte. If all objects are hashed, a short containing the hash code. The array of references, if references exist. The tag shows the number of elements, and the size of each element. The value in each element is the gap between the address of the references and the address of the current object. The value is a signed number of 32-bit words. Null references are not included. 2. Medium object record These records provide the actual address of the class rather than a cache index. The following format is used: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 0 2 Set (0x40) 3, 4, and 5 Contain the number of references 6 Indicates whether the gap is a 1 byte value or a short (see Short object record description) 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object (See the Short object record description) A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. The array of references (See the Short object record description). 3. Long object record This record format is used when there are more than 7 references, or if there are extra flags or a hash code. The following format is used: The 1 byte tag, containing the value 4. A byte containing flags, consisting of the following bits: Bit number Value or description 1 and 2 Indicates whether the gap is a byte , short , int or long format 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code 8 Indicates if the object was hashed A byte , short , int , or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An int containing the length of the array of references. The array of references (See the Short object record description).","title":"Object records"},{"location":"dump_heapdump/#array-records","text":"PHD arrays can be primitive arrays or object arrays, as described in the sections that follow. 1. Primitive array record The following information is contained in an array record: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 and 2 0 3 Set (0x20) 4, 5, and 6 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 7 and 8 Indicates the length of the array size and the length of the gap (0= byte , 1= short , 2= int , 3= long ) byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). byte , short , int or long containing the array length. If all objects are hashed, a short containing the hash code. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 2. Long primitive array record This type of record is used when a primitive array has been hashed. The 1 byte tag with a value of 7. A byte containing the following flags: Bit number Value or description 1, 2, and 3 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 4 Indicates the length of the array size and the length of the gap (0= byte , 1= word ). 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed a byte or word containing the gap between the address of this object and the address of the preceding object (See the Short object record description). a byte or word containing the array length. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 3. Object array record The following format applies: The 1 byte tag with a value of 8. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte , short , int or long . 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed A byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record format description). A word containing the address of the class of the objects in the array. Object array records do not update the class cache. If all objects are hashed, a short containing the hash code. If the hashed and moved bit is set in the records flag, this field contains an int . An int containing the length of the array of references. The array of references (See the Short object record description). An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . An final int value is shown at the end. This int contains the true array length, shown as a number of array elements. The true array length might differ from the length of the array of references because null references are excluded.","title":"Array records"},{"location":"dump_heapdump/#class-records","text":"The PHD class record encodes a class object and contains the following format: The 1 byte tag, containing the value 6. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte, short , int or long 3 and 4 Indicates the size of each static reference (0= byte , 1= short , 2= int , 3= long ) 5 Indicates if the object was hashed A byte, short , int or long containing the gap between the address of this class and the address of the preceding object (See the Short object record description). An int containing the instance size. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. A word containing the address of the superclass. A UTF string containing the name of this class. An int containing the number of static references. The array of static references (See the Short object record description).","title":"Class records"},{"location":"dump_heapdump/#classic-heap-dump-format","text":"Classic heap dumps are produced in ascii text on all platforms except z/OS, which are encoded in EBCDIC. The dump is divided into the following sections:","title":"Classic Heap Dump format"},{"location":"dump_heapdump/#header-record","text":"A single string containing information about the runtime environment, platform, and build levels, similar to the following example: // Version: JRE 1.8.0 Linux amd64-64 (build 1.8.0_232-b09)","title":"Header record"},{"location":"dump_heapdump/#object-records_1","text":"A record of each object instance in the heap with the following format: <object address, in hexadecimal> [<length in bytes of object instance, in decimal>] OBJ <object type> <heap reference, in hexadecimal> <heap reference, in hexadecimal> ... The following object types ( object type ) might be shown: class name (including package name) class array type primitive array type These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found are also listed, excluding references to an object's class or NULL references. The following example shows an object instance (16 bytes in length) of type java/lang/String , with a reference to a char array: 0x00000000E0000AF0 [16] OBJ java/lang/String 0x00000000E0000B00 The object instance (length 32 bytes) of type char array, as referenced from the java/lang/String , is shown in the following example: 0x00000000E0000B00 [32] OBJ [C The following example shows an object instance (24 bytes in length) of type array of java/lang/String : 0x00000000FFF07498 [24] OBJ [Ljava/lang/String; 0x00000000E0005D78 0x00000000E0005D50 0x00000000E0005D28 0x00000000E0005D00","title":"Object records"},{"location":"dump_heapdump/#class-records_1","text":"A record of each class in the following format: <class object address, in hexadecimal> [<length in bytes of class object, in decimal>] CLS <class type> <heap reference, in hexadecimal> <heap reference, in hexadecimal>... The following class types ( <class type> ) might be shown: class name (including package name) class array type primitive array types These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found in the class block are also listed, excluding NULL references. The following example shows a class object (80 bytes in length) for java/util/Date , with heap references: 0x00000000E00174F0 [80] CLS java/util/Date 0x00000000FFF1BB60 0x00000000FFF29630","title":"Class records"},{"location":"dump_heapdump/#trailer-record-1","text":"A single record containing record counts, in decimal. For example: // Breakdown - Classes: 630, Objects: 3692, ObjectArrays: 576, PrimitiveArrays: 2249","title":"Trailer record 1"},{"location":"dump_heapdump/#trailer-record-2","text":"A single record containing totals, in decimal. For example: // EOF: Total 'Objects',Refs(null) : 7147,22040(12379) The values in the example reflect the following counts: 7147 total objects 22040 total references (12379) total NULL references as a proportion of the total references count","title":"Trailer record 2"},{"location":"dump_heapdump/#java-vm-type-signatures","text":"The following table shows the abbreviations used for different Java types in the heap dump records: Java VM Type Signature Java Type Z boolean B byte C char S short I int J long F float D double L<fully-qualified class>; <fully-qualified class> [<type> <type>[](array of <type>) (<arg-types>)<ret-type> method","title":"Java VM Type Signatures"},{"location":"dump_heapdump/#see-also","text":"DTFJ interface","title":"See also"},{"location":"dump_javadump/","text":"Java dump Java\u2122 dumps, sometimes referred to as Java cores , are produced when the VM ends unexpectedly because of an operating system signal, OutOfMemoryError , or a user-initiated keystroke combination. You can also generate a Java dump by calling the Dump API programmatically from your application or specifying the -Xdump:java option on the command line. If your Java application crashes or hangs, Java dumps can provide useful information to help you diagnose the root cause. If your application crashes, Java dumps are generated automatically for the following types of failure: the VM receives an unexpected signal or an assertion failure the VM runs out of memory If your application hangs, you can trigger the generation of a Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. Note: On Windows\u00ae, if you started the VM in a console window you can force the VM to produce a Java dump in response to a SIGBREAK signal (Ctrl-Break keyboard combination). If you didn't start in a console window, there is no equivalent to a Linux kill command on Windows for sending signals. The only option here is to trigger a full system dump by finding the VM process in the Processes tab of the Windows Task Manager and clicking Create dump file . To help you understand how a Java dump can help you with problem diagnosis, this topic includes a few scenarios to help you interpret the data: A crash caused by a general protection fault (gpf) A Java heap OutOfMemoryError (OOM) A native OutOfMemoryError (OOM) A deadlock situation A hang Java dump contents Java dumps summarize the state of the VM when the event occurs, with most of the information relating to components of the VM. The file is made up of a number of sections that provide different types of information. TITLE The first section of the Java dump file provides information about the event that triggered the production of the dump. In the following example, you can see that a vmstop event triggered the dump at a specified date and time. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"vmstop\" (00000002) Detail \"#0000000000000000\" received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/doc-javacore/javacore.20210423.140244.1175.0001.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x106 (vm_access+exclusive_vm_access+trace_disabled) GPINFO The GPINFO section provides general information about the system that the VM is running on. The following example is taken from a Java dump that was generated on a Linux system. NULL ------------------------------------------------------------------------ 0SECTION GPINFO subcomponent dump routine NULL ================================ 2XHOSLEVEL OS Level : Linux 3.10.0-862.11.6.el7.x86_64 2XHCPUS Processors - 3XHCPUARCH Architecture : amd64 3XHNUMCPUS How Many : 4 3XHNUMASUP NUMA is either not supported or has been disabled by user NULL 1XHERROR2 Register dump section only produced for SIGSEGV, SIGILL or SIGFPE. NULL The content of this section can vary, depending on the cause of the dump. For example, if the dump was caused by a general protection fault (gpf), the library in which the crash occurred is also recorded, together with a value shown as VM flags . This value can provide some clues about which component of the VM might have been involved. Look for the following line in the output: 1XHFLAGS VM flags:0000000000000000 The hexadecimal number that is recorded for VM flags ends in MSSSS, where M is the VM component and SSSS is component-specific code as shown in the following table: Component Code value INTERPRETER 0x10000 GC 0x20000 GROW_STACK 0x30000 JNI 0x40000 JIT_CODEGEN 0x50000 BCVERIFY 0x60000 RTVERIFY 0x70000 SHAREDCLASSES 0x80000 A value of 0000000000000000 (0x00000) indicates that a crash occurred outside of the VM. ENVINFO This section contains useful information about the environment in which the crash took place, including the following data: Java version ( 1CIJAVAVERSION ) Eclipse OpenJ9\u2122 VM and subcomponent version information ( 1CIVMVERSION , 1CIJ9VMVERSION , 1CIJITVERSION , 1CIOMRVERSION , 1CIJCLVERSION ) VM start time ( 1CISTARTTIME ) and process information ( 1CIPROCESSID ) Java home ( 1CIJAVAHOMEDIR ) and DLL ( 1CIJAVADLLDIR ) directories User arguments passed on the command line ( 1CIUSERARGS ), identifying those that are ignored ( 1CIIGNOREDARGS ) User limits imposed by the system ( 1CIUSERLIMITS ) Environment variables in place ( 1CIENVVARS ) System information ( 1CISYSINFO ) CPU information ( 1CICPUINFO ) Control group (Cgroup) information ( 1CICGRPINFO ) For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION ENVINFO subcomponent dump routine NULL ================================= 1CIJAVAVERSION JRE 9 Linux amd64-64 (build 9.0.4-internal+0-adhoc..openj9-openjdk-jdk9) 1CIVMVERSION 20180830_000000 1CIJ9VMVERSION 8e7c6ec 1CIJITVERSION 8e7c6ec 1CIOMRVERSION 553811b_CMPRSS 1CIJCLVERSION ec1d223 based on jdk-9.0.4+12 1CIJITMODES JIT enabled, AOT enabled, FSD disabled, HCR enabled 1CIRUNNINGAS Running as a standalone JVM 1CIVMIDLESTATE VM Idle State: ACTIVE 1CICONTINFO Running in container : FALSE 1CICGRPINFO JVM support for cgroups enabled : TRUE 1CISTARTTIME JVM start time: 2018/08/30 at 21:55:47:387 1CISTARTNANO JVM start nanotime: 22012135233549 1CIPROCESSID Process ID: 30285 (0x764D) 1CICMDLINE [not available] 1CIJAVAHOMEDIR Java Home Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk 1CIJAVADLLDIR Java DLL Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/bin 1CISYSCP Sys Classpath: 1CIUSERARGS UserArgs: 2CIUSERARG -Xoptionsfile=/home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/options.default ... 1CIIGNOREDARGS Ignored Args: 2CIIGNOREDARG -XX:+UseCompressedOop 2CIIGNOREDARG -XX:CompressedClassSpaceSize=528482304 NULL 1CIUSERLIMITS User Limits (in bytes except for NOFILE and NPROC) NULL ------------------------------------------------------------------------ NULL type soft limit hard limit 2CIUSERLIMIT RLIMIT_AS unlimited unlimited 2CIUSERLIMIT RLIMIT_CORE 0 unlimited 2CIUSERLIMIT RLIMIT_CPU unlimited unlimited 2CIUSERLIMIT RLIMIT_DATA unlimited unlimited 2CIUSERLIMIT RLIMIT_FSIZE unlimited unlimited 2CIUSERLIMIT RLIMIT_LOCKS unlimited unlimited 2CIUSERLIMIT RLIMIT_MEMLOCK 65536 65536 2CIUSERLIMIT RLIMIT_NOFILE 4096 4096 2CIUSERLIMIT RLIMIT_NPROC 4096 30592 2CIUSERLIMIT RLIMIT_RSS unlimited unlimited 2CIUSERLIMIT RLIMIT_STACK 8388608 unlimited 2CIUSERLIMIT RLIMIT_MSGQUEUE 819200 819200 2CIUSERLIMIT RLIMIT_NICE 0 0 2CIUSERLIMIT RLIMIT_RTPRIO 0 0 2CIUSERLIMIT RLIMIT_SIGPENDING 30592 30592 NULL 1CIENVVARS Environment Variables NULL ------------------------------------------------------------------------ 2CIENVVAR XDG_VTNR=1 2CIENVVAR SSH_AGENT_PID=2653 ... NULL 1CISYSINFO System Information NULL ------------------------------------------------------------------------ 2CISYSINFO /proc/sys/kernel/core_pattern = core 2CISYSINFO /proc/sys/kernel/core_uses_pid = 1 NULL 1CICPUINFO CPU Information NULL ------------------------------------------------------------------------ 2CIPHYSCPU Physical CPUs: 8 2CIONLNCPU Online CPUs: 8 2CIBOUNDCPU Bound CPUs: 8 2CIACTIVECPU Active CPUs: 0 2CITARGETCPU Target CPUs: 8 2CIJITFEATURE CPU features (JIT): fpu cx8 cmov mmx sse sse2 ssse3 fma sse4_1 popcnt aesni osxsave avx avx2 rdt_m 2CIAOTFEATURE CPU features (AOT): fpu cx8 cmov mmx sse sse2 ssse3 fma sse4_1 popcnt aesni osxsave avx avx2 rdt_m NULL 1CICGRPINFO Cgroup Information NULL ------------------------------------------------------------------------ 2CICGRPINFO subsystem : cpu 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU Period : 100000 microseconds 3CICGRPINFO CPU Quota : Not Set 3CICGRPINFO CPU Shares : 1024 3CICGRPINFO Period intervals elapsed count : 0 3CICGRPINFO Throttled count : 0 3CICGRPINFO Total throttle time : 0 nanoseconds 2CICGRPINFO subsystem : cpuset 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU exclusive : 1 3CICGRPINFO Mem exclusive : 1 3CICGRPINFO CPUs : 0-7 3CICGRPINFO Mems : 0 2CICGRPINFO subsystem : memory 2CICGRPINFO cgroup name : / 3CICGRPINFO Memory Limit : Not Set 3CICGRPINFO Memory + Swap Limit : Not Set 3CICGRPINFO Memory Usage : 5363396608 bytes 3CICGRPINFO Memory + Swap Usage : 5363396608 bytes 3CICGRPINFO Memory Max Usage : 0 bytes 3CICGRPINFO Memory + Swap Max Usage : 0 bytes 3CICGRPINFO Memory limit exceeded count : 0 3CICGRPINFO Memory + Swap limit exceeded count : 0 3CICGRPINFO OOM Killer Disabled : 0 3CICGRPINFO Under OOM : 0 NULL NATIVEMEMINFO This section records information about native memory that is requested by using library functions such as malloc() and mmap() . Values are provided as a breakdown, per component, indicating the total number of bytes allocated and the number of native memory allocations. In the following example, 4,682,840 bytes of native memory are allocated (but not yet freed) to VM Classes, which correspond to 141 allocations. NULL ------------------------------------------------------------------------ 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 2,569,088,312 bytes / 4653 allocations 1MEMUSER | 2MEMUSER +--VM: 2,280,088,336 bytes / 2423 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 4,682,840 bytes / 141 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 2,054,966,784 bytes / 433 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 2,014,113,792 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 40,852,992 bytes / 432 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,970,016 bytes / 156 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 197,760 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 155,424 bytes / 123 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 180,056 bytes / 263 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,776 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 36,184 bytes / 52 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 208,179,632 bytes / 72 allocations 3MEMUSER | | | 4MEMUSER | | +--Unused <32bit allocation regions: 208,168,752 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,880 bytes / 71 allocations 2MEMUSER | | 3MEMUSER | +--Other: 1,055,048 bytes / 1293 allocations 1MEMUSER | 2MEMUSER +--JIT: 288,472,816 bytes / 140 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 268,435,456 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 2,097,216 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 17,940,144 bytes / 138 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 13,432 bytes / 25 allocations 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 13,432 bytes / 25 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 3,184 bytes / 13 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 1,056 bytes / 12 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Other: 2,128 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,248 bytes / 12 allocations 1MEMUSER | 2MEMUSER +--Unknown: 513,728 bytes / 2065 allocations NULL This section does not record memory that is allocated by application or JNI code and is typically a little less than the value recorded by operating system tools. MEMINFO This section relates to memory management, providing a breakdown of memory usage in the VM for the object heap, internal memory, memory used for classes, the JIT code cache, and JIT data cache in decimal and hexadecimal format. You can also find out which garbage collection policy is in use when the dump is produced. The object memory area ( 1STHEAPTYPE ) records each memory region in use, its start and end address, and region size. Further information is recorded about the memory segments that are used for internal memory, class memory, the JIT code cache, and JIT data cache ( 1STSEGMENT ). This information includes the address of the segment control data structure, the start and end address of the native memory segment, as well as the segment size. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0x00007FF4F00744A0 -- -- -- Generational 1STHEAPREGION 0x00007FF4F0074CE0 0x0000000087F40000 0x0000000088540000 0x0000000000600000 Generational/Tenured Region 1STHEAPREGION 0x00007FF4F0074930 0x00000000FFE00000 0x00000000FFF00000 0x0000000000100000 Generational/Nursery Region 1STHEAPREGION 0x00007FF4F0074580 0x00000000FFF00000 0x0000000100000000 0x0000000000100000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 8388608 (0x0000000000800000) 1STHEAPINUSE Total memory in use: 2030408 (0x00000000001EFB48) 1STHEAPFREE Total memory free: 6358200 (0x00000000006104B8) NULL 1STSEGTYPE Internal Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F004CBC8 0x00007FF4CD33C000 0x00007FF4CD33C000 0x00007FF4CE33C000 0x01000440 0x0000000001000000 1STSEGMENT 0x00007FF4F004CB08 0x00007FF4DE43D030 0x00007FF4DE517770 0x00007FF4DE53D030 0x00800040 0x0000000000100000 NULL 1STSEGTOTAL Total memory: 17825792 (0x0000000001100000) 1STSEGINUSE Total memory in use: 894784 (0x00000000000DA740) 1STSEGFREE Total memory free: 16931008 (0x00000000010258C0) NULL 1STSEGTYPE Class Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F03B5638 0x0000000001053D98 0x000000000105BD98 0x000000000105BD98 0x00010040 0x0000000000008000 1STSEGMENT 0x00007FF4F03B5578 0x0000000001048188 0x0000000001050188 0x0000000001050188 0x00010040 0x0000000000008000 ... NULL 1STSEGTOTAL Total memory: 3512520 (0x00000000003598C8) 1STSEGINUSE Total memory in use: 3433944 (0x00000000003465D8) 1STSEGFREE Total memory free: 78576 (0x00000000000132F0) NULL 1STSEGTYPE JIT Code Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F00961F8 0x00007FF4CE43D000 0x00007FF4CE445790 0x00007FF4DE43D000 0x00000068 0x0000000010000000 NULL 1STSEGTOTAL Total memory: 268435456 (0x0000000010000000) 1STSEGINUSE Total memory in use: 34704 (0x0000000000008790) 1STSEGFREE Total memory free: 268400752 (0x000000000FFF7870) 1STSEGLIMIT Allocation limit: 268435456 (0x0000000010000000) NULL 1STSEGTYPE JIT Data Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F0096668 0x00007FF4CC553030 0x00007FF4CC753030 0x00007FF4CC753030 0x00000048 0x0000000000200000 NULL 1STSEGTOTAL Total memory: 2097152 (0x0000000000200000) 1STSEGINUSE Total memory in use: 2097152 (0x0000000000200000) 1STSEGFREE Total memory free: 0 (0x0000000000000000) 1STSEGLIMIT Allocation limit: 402653184 (0x0000000018000000) NULL 1STGCHTYPE GC History NULL In the example, the GC History ( 1STGCHTYPE ) section is blank. This section is populated if a garbage collection cycle occurred in a VM that is being diagnosed with the trace facility. LOCKS This section of the Java dump provides information about locks, which protect shared resources from being accessed by more than one entity at a time. The information is essential in a deadlock situation, where two threads attempt to synchronize on an object and lock an instance of a class. Precise information is recorded about the threads that are causing the problem, which enables you to identify the root cause. The following example shows a typical LOCKS section, where no deadlocks existed at the time the dump was triggered. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 3 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x00007FF4B0001D78 infl_mon_t: 0x00007FF4B0001DF8: 3LKMONOBJECT java/lang/ref/ReferenceQueue@0x00000000FFE26A10: <unowned> 3LKNOTIFYQ Waiting to be notified: 3LKWAITNOTIFY \"Common-Cleaner\" (J9VMThread:0x0000000000FD0100) NULL 1LKREGMONDUMP JVM System Monitor Dump (registered monitors): 2LKREGMON Thread global lock (0x00007FF4F0004FE8): <unowned> 2LKREGMON &(PPG_mem_mem32_subAllocHeapMem32.monitor) lock (0x00007FF4F0005098): <unowned> 2LKREGMON NLS hash table lock (0x00007FF4F0005148): <unowned> ... NULL THREADS The THREADS section of a Java dump file provides summary information about the VM thread pool and detailed information about Java threads, native threads, and stack traces. Understanding the content of this section can help you diagnose problems that are caused by blocked or waiting threads. A Java thread runs on a native thread. Several lines are recorded for each Java thread in the Thread Details subsection, which include the following key pieces of information: 3XMTHREADINFO : The thread name, address information for the VM thread structures and Java thread object, the thread state, and thread priority. 3XMJAVALTHREAD : The Java thread ID and daemon status from the thread object. 3XMTHREADINFO1 : The native operating system thread ID, priority, scheduling policy, internal VM thread state, and VM thread flags. 3XMTHREADINFO2 : The native stack address range. 3XMTHREADINFO3 : Java call stack information ( 4XESTACKTRACE ) or Native call stack information ( 4XENATIVESTACK ). 5XESTACKTRACE : This line indicates whether locks were taken by a specific method. Java thread priorities are mapped to operating system priority values. Thread states are shown in the following table: Thread state value Status Description R Runnable The thread is able to run CW Condition Wait The thread is waiting S Suspended The thread is suspended by another thread Z Zombie The thread is destroyed P Parked The thread is parked by java.util.concurrent B Blocked The thread is waiting to obtain a lock For threads that are parked (P), blocked (B), or waiting (CW), an additional line ( 3XMTHREADBLOCK ) is included in the output that shows what the thread is parked on, blocked on, or waiting for. For threads that are waiting for a class initialization lock ( java/lang/J9VMInternals$ClassInitializationLock ), this line includes the name of the thread that is currently working to progress the initialization of the class. You can use this information to diagnose deadlocks that are caused by class initialization, which might not be detected and reported in the LOCKS section. For clarity, the following example shows a shortened version of a typical THREADS section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 19 2XMPOOLLIVE Current total number of live threads: 18 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMTHDINFO Thread Details NULL ... 3XMTHREADINFO \"JIT Diagnostic Compilation Thread-007 Suspended\" J9VMThread:0x0000000000035200, omrthread_t:0x00007F3F8C0D02C8, java/lang/Thread:0x00000000FFF42120, state:R, prio=10 3XMJAVALTHREAD (java/lang/Thread getId:0x9, isDaemon:true) 3XMJAVALTHRCCL sun/misc/Launcher$AppClassLoader(0x00000000FFF3BF98) 3XMTHREADINFO1 (native thread ID:0x618F, native priority:0xB, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000081) 3XMTHREADINFO2 (native stack address range from:0x00007F3F879C5000, to:0x00007F3F87AC5000, size:0x100000) 3XMCPUTIME CPU usage total: 0.052410771 secs, current category=\"JIT\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 No Java callstack associated with this thread ... NULL ... 3XMTHREADINFO \"Class Initialization Thread 2\" J9VMThread:0x0000000000124D00, omrthread_t:0x00007F3F8C1494C8, java/lang/Thread:0x00000000FFF53EE8, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMJAVALTHRCCL sun/misc/Launcher$AppClassLoader(0x00000000FFF3BF98) 3XMTHREADINFO1 (native thread ID:0x6199, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000181) 3XMTHREADINFO2 (native stack address range from:0x00007F3F74AB4000, to:0x00007F3F74AF4000, size:0x40000) 3XMCPUTIME CPU usage total: 0.008712260 secs, current category=\"Application\" 3XMTHREADBLOCK Waiting on: java/lang/J9VMInternals$ClassInitializationLock@0x00000000FFF61C90 Owned by: <unowned> Initializing thread: \"Class Initialization Thread 1\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=4096 (0x1000) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Class.forNameImpl(Native Method) 4XESTACKTRACE at java/lang/Class.forName(Class.java:339) 4XESTACKTRACE at ClassInitLockBug$ClassInitThread.run(ClassInitLockBug.java:16) ... NULL ... NULL 3XMTHREADINFO \"Class Initialization Thread 1\" J9VMThread:0x0000000000124100, omrthread_t:0x00007F3F8C148F50, java/lang/Thread:0x00000000FFF53D80, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x12, isDaemon:false) 3XMJAVALTHRCCL sun/misc/Launcher$AppClassLoader(0x00000000FFF3BF98) 3XMTHREADINFO1 (native thread ID:0x6198, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000481) 3XMTHREADINFO2 (native stack address range from:0x00007F3F74AF5000, to:0x00007F3F74B35000, size:0x40000) 3XMCPUTIME CPU usage total: 0.010221701 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=12736 (0x31C0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Thread.sleepImpl(Native Method) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:983) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:966) 4XESTACKTRACE at TestClass.<clinit>(ClassInitLockBug.java:29) 4XESTACKTRACE at java/lang/Class.forNameImpl(Native Method) 4XESTACKTRACE at java/lang/Class.forName(Class.java:339) 4XESTACKTRACE at ClassInitLockBug$ClassInitThread.run(ClassInitLockBug.java:16) ... NULL ... NULL 1XMTHDSUMMARY Threads CPU Usage Summary NULL ========================= NULL 1XMTHDCATINFO Warning: to get more accurate CPU times for the GC, the option -XX:-ReduceCPUMonitorOverhead can be used. See the user guide for more information. NULL 1XMTHDCATEGORY All JVM attached threads: 0.698865000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--System-JVM: 0.653723000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--GC: 0.047248000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--JIT: 0.512971000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--Application: 0.045142000 secs HOOKS This section shows internal VM event callbacks, which are used for diagnosing performance problems in the VM. Multiple hook interfaces are listed, which include their individual hook events. The following example shows data for the J9VMHookInterface , including the total time for all previous events, the call site location (<source file>:<line number>), start time, and duration of the last callback and the longest callback (all times measured in microseconds). The hook data is reset after each Java dump. NULL ------------------------------------------------------------------------ SECTION HOOK subcomponent dump routine NULL ========================= 1NOTE These data are reset every time a javacore is taken 1HKINTERFACE MM_OMRHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_PrivateHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_HookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9VMHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 1 3HKCALLCOUNT 1239 3HKTOTALTIME 219564us 3HKLAST Last Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T00:15:14.664 4HKDURATION Duration : 16us 3HKLONGST Longest Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T21:28:34.895 4HKDURATION Duration : 5012us NULL ... 1HKINTERFACE J9VMZipCachePoolHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9JITHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 3 3HKCALLCOUNT 3113 3HKTOTALTIME 4904us 3HKLAST Last Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:04:15.320 4HKDURATION Duration : 3us 3HKLONGST Longest Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:37:17.633 4HKDURATION Duration : 27us NULL ... SHARED CLASSES If the shared classes cache is enabled at run time, the information that is provided in a Java dump file describes settings that were used when creating the cache, together with summary information about the size and content of the cache. In the following example, the shared classes cache was created with a Class Debug Area ( -Xnolinenumbers=false ). Byte code instrumentation (BCI) is enabled, which is the default, and VMs sharing the cache are allowed to store classpaths, which is also the default. The Cache Summary shows a cache size ( 2SCLTEXTCSZ ) of 16776608 bytes, with a soft maximum size ( 2SCLTEXTSMB ) also of 16776608 bytes, which leaves 12691668 bytes of free space ( 2SCLTEXTFRB ). The size of the Class Debug Area ( 2SCLTEXTDAS ) is 1331200 bytes and only 11% of this space is used. In the Cache Memory Status subsection, the line 2SCLTEXTCMDT indicates the name and location of the shared cache and cr indicates that the cache is a 64-bit compressed references cache. NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = true NULL 2SCLTEXTRCS ROMClass start address = 0x00007F423061C000 2SCLTEXTRCE ROMClass end address = 0x00007F42307B9A28 2SCLTEXTMSA Metadata start address = 0x00007F42313D42FC 2SCLTEXTCEA Cache end address = 0x00007F4231600000 2SCLTEXTRTF Runtime flags = 0x00102001ECA6028B 2SCLTEXTCGN Cache generation = 35 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 12691668 2SCLTEXTRCB ROMClass bytes = 1694248 2SCLTEXTAOB AOT code bytes = 0 2SCLTEXTADB AOT data bytes = 0 2SCLTEXTAHB AOT class hierarchy bytes = 32 2SCLTEXTATB AOT thunk bytes = 0 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJHB JIT hint bytes = 308 2SCLTEXTJPB JIT profile bytes = 2296 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 919328 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 2SCLTEXTMDA Metadata bytes = 23448 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 11% 2SCLTEXTDAN Class LineNumberTable bytes = 156240 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 595 2SCLTEXTNAM Number AOT Methods = 0 2SCLTEXTNAD Number AOT Data Entries = 0 2SCLTEXTNAH Number AOT Class Hierarchy = 1 2SCLTEXTNAT Number AOT Thunks = 0 2SCLTEXTNJH Number JIT Hints = 14 2SCLTEXTNJP Number JIT Profiles = 20 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 5 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0% NULL 2SCLTEXTCPF Cache is 24% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT sharedcc_doc-javacore CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_sharedcc_doc-javacore_G35 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL The following example shows information for a layered cache: NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCSTL Cache Statistics for Top Layer NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = false NULL 2SCLTEXTRCS ROMClass start address = 0x00007F0EDB567000 2SCLTEXTRCE ROMClass end address = 0x00007F0EDB567000 2SCLTEXTMSA Metadata start address = 0x00007F0EDC40241C 2SCLTEXTCEA Cache end address = 0x00007F0EDC54B000 2SCLTEXTRTF Runtime flags = 0x80102001ECA602BB 2SCLTEXTCGN Cache generation = 41 2SCLTEXTCLY Cache layer = 1 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 15315996 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 0% 2SCLTEXTDAN Class LineNumberTable bytes = 0 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTCPF Cache is 8% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT Cache1 CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_Cache1_G41L01 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL 1SCLTEXTCSAL Cache Statistics for All Layers NULL 2SCLTEXTRCB ROMClass bytes = 1459040 2SCLTEXTAOB AOT code bytes = 57624 2SCLTEXTADB AOT data bytes = 272 2SCLTEXTAHB AOT class hierarchy bytes = 1840 2SCLTEXTATB AOT thunk bytes = 632 2SCLTEXTJHB JIT hint bytes = 484 2SCLTEXTJPB JIT profile bytes = 0 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 1134016 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 503 2SCLTEXTNAM Number AOT Methods = 16 2SCLTEXTNAD Number AOT Data Entries = 1 2SCLTEXTNAH Number AOT Class Hierarchy = 28 2SCLTEXTNAT Number AOT Thunks = 11 2SCLTEXTNJH Number JIT Hints = 15 2SCLTEXTNJP Number JIT Profiles = 0 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 21 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0% CLASSES The classes section shows information about class loaders. The first part is a summary that records each available class loader ( 2CLTEXTCLLOADER ) followed by the number of libraries and classes that it loaded. This information is followed by a more detailed list of libraries ( 1CLTEXTCLLIB ) and classes ( 1CLTEXTCLLO ) that are loaded. In the example you can see that the java/lang/InternalAnonymousClassLoader loaded two classes, jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) and jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) . NULL ------------------------------------------------------------------------ 0SECTION CLASSES subcomponent dump routine NULL ================================= 1CLTEXTCLLOS Classloader summaries 1CLTEXTCLLSS 12345678: 1=primordial,2=extension,3=shareable,4=middleware,5=system,6=trusted,7=application,8=delegating 2CLTEXTCLLOADER p---st-- Loader *System*(0x00000000FFE1D258) 3CLNMBRLOADEDLIB Number of loaded libraries 5 3CLNMBRLOADEDCL Number of loaded classes 638 2CLTEXTCLLOADER -x--st-- Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 2CLTEXTCLLOADER ----st-- Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 2 2CLTEXTCLLOADER -----ta- Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0), Parent jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 1CLTEXTCLLIB ClassLoader loaded libraries 2CLTEXTCLLIB Loader *System*(0x00000000FFE1D258) 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/jclse9_29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/java 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/j9jit29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/zip 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/nio 1CLTEXTCLLOD ClassLoader loaded classes 2CLTEXTCLLOAD Loader *System*(0x00000000FFE1D258) 3CLTEXTCLASS [Ljava/lang/Thread$State;(0x0000000001056400) ... 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 2CLTEXTCLLOAD Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0) Scenarios General Protection Fault In this scenario, a Java application has crashed due to a General Protection Fault (GPF), automatically generating a Java dump file. The first section of the file (TITLE) tells you that the GPF triggered the Java dump. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"gpf\" (00002000) received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/test/JNICrasher/javacore.20210423.140244.29399.0002.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x100 (trace_disabled) 1TIPREPINFO Exclusive VM access not taken: data may not be consistent across javacore sections To troubleshoot this problem, you need to know which thread caused the GPF to occur. The thread that was running at the time of the crash is reported as the current thread in the THREADS section of the Java dump. Here is an extract from the THREADS section: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 15 2XMPOOLDAEMON Current total number of live daemon threads: 14 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60E00, omrthread_t:0xB6B049D8, java/lang/Thread:0xB55444D0, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x72D8, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00000000) 3XMTHREADINFO2 (native stack address range from:0xB6CE3000, to:0xB74E4000, size:0x801000) 3XMCPUTIME CPU usage total: 0.319865924 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=778008 (0xBDF18) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at JNICrasher.doSomethingThatCrashes(Native Method) 4XESTACKTRACE at JNICrasher.main(JNICrasher.java:7) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C6F663 [libj9prt29.so+0x3b663]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6F1CE [libj9prt29.so+0x3b1ce]) 4XENATIVESTACK (0xB6C6F2C6 [libj9prt29.so+0x3b2c6]) 4XENATIVESTACK (0xB6C6ED93 [libj9prt29.so+0x3ad93]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6ED07 [libj9prt29.so+0x3ad07]) 4XENATIVESTACK (0xB6C6AA3D [libj9prt29.so+0x36a3d]) 4XENATIVESTACK (0xB6C6C3A4 [libj9prt29.so+0x383a4]) 4XENATIVESTACK (0xB667FA19 [libj9dmp29.so+0xfa19]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66878CF [libj9dmp29.so+0x178cf]) 4XENATIVESTACK (0xB6688083 [libj9dmp29.so+0x18083]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6680C0D [libj9dmp29.so+0x10c0d]) 4XENATIVESTACK (0xB667F9D7 [libj9dmp29.so+0xf9d7]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB668B02F [libj9dmp29.so+0x1b02f]) 4XENATIVESTACK (0xB668B4D3 [libj9dmp29.so+0x1b4d3]) 4XENATIVESTACK (0xB66740F1 [libj9dmp29.so+0x40f1]) 4XENATIVESTACK (0xB66726FA [libj9dmp29.so+0x26fa]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66726A9 [libj9dmp29.so+0x26a9]) 4XENATIVESTACK (0xB6676AE4 [libj9dmp29.so+0x6ae4]) 4XENATIVESTACK (0xB668D75A [libj9dmp29.so+0x1d75a]) 4XENATIVESTACK (0xB6A28DD4 [libj9vm29.so+0x81dd4]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A289EE [libj9vm29.so+0x819ee]) 4XENATIVESTACK (0xB6A29A40 [libj9vm29.so+0x82a40]) 4XENATIVESTACK (0xB6C52B6A [libj9prt29.so+0x1eb6a]) 4XENATIVESTACK __kernel_rt_sigreturn+0x0 (0xB7747410) 4XENATIVESTACK (0xB75330B6 [libffi29.so+0x50b6]) 4XENATIVESTACK ffi_raw_call+0xad (0xB7531C53 [libffi29.so+0x3c53]) 4XENATIVESTACK (0xB69BE4AB [libj9vm29.so+0x174ab]) 4XENATIVESTACK (0xB6A665BC [libj9vm29.so+0xbf5bc]) 4XENATIVESTACK (0xB6A15552 [libj9vm29.so+0x6e552]) 4XENATIVESTACK (0xB6A30894 [libj9vm29.so+0x89894]) 4XENATIVESTACK (0xB6A6F169 [libj9vm29.so+0xc8169]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A6F1FA [libj9vm29.so+0xc81fa]) 4XENATIVESTACK (0xB6A30994 [libj9vm29.so+0x89994]) 4XENATIVESTACK (0xB6A2CE4C [libj9vm29.so+0x85e4c]) 4XENATIVESTACK (0xB770487D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7719F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB763543E [libc.so.6+0xee43e]) The extract tells you that the current thread was java/lang/Thread , and information is provided about the Java call stack and native call stack ( 3XMTHREADINFO3 ) at the point at which the crash occurred. To simulate a crash caused by a bug in an application, this example calls a JNI method whose native implementation causes a crash. The Java call stack shows the call to the JNI native method ( JNIcrasher ), and the native call stack shows the point of failure. In this example, the native call stack does not include any function names to help you isolate the error in the native code. You can get this information from a system dump, which is usually produced alongside the Java dump. Open the system dump with the Dump viewer and use the info thread command to print the Java and native stack for the current thread. The next time you run the application, you can use the -XX:+ShowNativeStackSymbols=all command line option to display the corresponding function names in the native call stack. 4XENATIVESTACK protectedBacktrace+0x12 (0x00007F3F9213E312 [libj9prt29.so+0x25312]) 4XENATIVESTACK omrsig_protect+0x1e3 (0x00007F3F92142AD3 [libj9prt29.so+0x29ad3]) 4XENATIVESTACK omrintrospect_backtrace_thread_raw+0xbf (0x00007F3F9213E80F [libj9prt29.so+0x2580f]) 4XENATIVESTACK omrsig_protect+0x1e3 (0x00007F3F92142AD3 [libj9prt29.so+0x29ad3]) 4XENATIVESTACK omrintrospect_backtrace_thread+0x70 (0x00007F3F9213E1D0 [libj9prt29.so+0x251d0]) 4XENATIVESTACK setup_native_thread+0x1d2 (0x00007F3F9213F652 [libj9prt29.so+0x26652]) 4XENATIVESTACK omrintrospect_threads_startDo_with_signal+0x474 (0x00007F3F921403F4 [libj9prt29.so+0x273f4]) 4XENATIVESTACK omrsig_protect+0x1e3 (0x00007F3F92142AD3 [libj9prt29.so+0x29ad3]) Java OutOfMemoryError In this scenario, the Java heap runs out of memory, causing an OutOfMemoryError , which automatically generates a Java dump file. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for Java heap space. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"Java heap space\" received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20210423.140244.18885.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) The MEMINFO section records how much memory is allocated to the Java heap ( 1STHEAPTYPE Object Memory ), how much is in use, and how much is free. Solving your problem might be as simple as setting a larger heap size when you start your application. If you don't know what size the Java heap was set to, you might find that information in the ENVINFO section, which records the command-line options that were used when the application started. Look or search for the 1CIUSERARGS UserArgs: string and review the entries that are recorded for all lines that start 2CIUSERARG . The Java heap size is set by the -Xmx option. If the size has not been set on the command line by -Xmx , the default value applies, which you can find in Default Settings . In this scenario, the solution to the problem is not an adjustment to the Java heap size. Here is the MEMINFO section: 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0xB6B49D20 -- -- -- Generational 1STHEAPREGION 0xB6B4A078 0x95750000 0xB5470000 0x1FD20000 Generational/Tenured Region 1STHEAPREGION 0xB6B49F10 0xB5470000 0xB54C0000 0x00050000 Generational/Nursery Region 1STHEAPREGION 0xB6B49DA8 0xB54C0000 0xB5750000 0x00290000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 536870912 (0x20000000) 1STHEAPINUSE Total memory in use: 302603160 (0x12095B98) 1STHEAPFREE Total memory free: 234267752 (0x0DF6A468) The output shows that only 56% of the Java heap is in use, so this suggests that the application is trying to do something suboptimal. To investigate further, you need to work out which thread was the current thread when the OOM occurred to see what it was trying to do. As in the previous scenario, you can find the current thread in the THREADS section. Here is an extract from the output: 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60C00, omrthread_t:0xB6B049D8, java/lang/Thread:0x95764520, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x49C6, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6CB5000, to:0xB74B6000, size:0x801000) 3XMCPUTIME CPU usage total: 8.537823831 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/StringBuffer.ensureCapacityImpl(StringBuffer.java:696) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:486(Compiled Code)) 5XESTACKTRACE (entered lock: java/lang/StringBuffer@0x957645B8, entry count: 1) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:428(Compiled Code)) 4XESTACKTRACE at HeapBreaker.main(HeapBreaker.java:34(Compiled Code)) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C535B3 [libj9prt29.so+0x3b5b3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C5311E [libj9prt29.so+0x3b11e]) 4XENATIVESTACK (0xB6C53216 [libj9prt29.so+0x3b216]) 4XENATIVESTACK (0xB6C52CE3 [libj9prt29.so+0x3ace3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C52C57 [libj9prt29.so+0x3ac57]) 4XENATIVESTACK (0xB6C4E9CD [libj9prt29.so+0x369cd]) 4XENATIVESTACK (0xB6C502FA [libj9prt29.so+0x382fa]) To simulate a Java OutOfMemoryError , this example application repeatedly appends characters to a StringBuffer object in an infinite loop. The Java call stack shows the HeapBreaker.main method appending characters ( java/lang/StringGuffer.append ) until the method java/lang/StringBuffer.ensureCapacityImpl() throws the OutOfMemoryError . StringBuffer objects are wrappers for character arrays ( char[] ) and when the capacity of the underlying array is reached, the contents are automatically copied into a new, larger array. The new array is created in the StringBuffer.ensureCapacity() method, which more or less doubles the size of the old array. In this scenario, the array takes up all the remaining space in the Java heap. The MEMINFO section of the Java dump file can also tell you when an unexpectedly large allocation request causes an OOM. Look for the GC History ( 1STGCHTYPE ) section, which details allocation requests that trigger GC activity. In the sample output you can see that a large allocation request ( requestedbytes=603979784 ) triggered a global GC. When the GC could not free up sufficient space in the heap to satisfy the request, the allocation failure generated the OOM. 1STGCHTYPE GC History 3STHSTTYPE 14:29:29:580239000 GMT j9mm.101 - J9AllocateIndexableObject() returning NULL! 0 bytes requested for object of class B6BBC300 from memory space 'Generational' id=B6B49D20 3STHSTTYPE 14:29:29:579916000 GMT j9mm.134 - Allocation failure end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579905000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579859000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:579807000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:579776000 GMT j9mm.137 - Compact end: bytesmoved=301989896 3STHSTTYPE 14:29:29:313899000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:313555000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:310772000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:310765000 GMT j9mm.94 - Class unloading end: classloadersunloaded=0 classesunloaded=0 3STHSTTYPE 14:29:29:310753000 GMT j9mm.60 - Class unloading start 3STHSTTYPE 14:29:29:310750000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:306013000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:305957000 GMT j9mm.474 - GlobalGC start: globalcount=9 3STHSTTYPE 14:29:29:305888000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:305837000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:305808000 GMT j9mm.137 - Compact end: bytesmoved=189784 3STHSTTYPE 14:29:29:298042000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:297695000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:291696000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:291692000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:284994000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:284941000 GMT j9mm.474 - GlobalGC start: globalcount=8 3STHSTTYPE 14:29:29:284916000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:284914000 GMT j9mm.469 - Allocation failure cycle start: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:284893000 GMT j9mm.470 - Allocation failure cycle end: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:284858000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=2 flipbytes=64 newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:284140000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:283160000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=335 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:283123000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:283120000 GMT j9mm.469 - Allocation failure cycle start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:283117000 GMT j9mm.133 - Allocation failure start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:269762000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269751000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269718000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:268981000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:268007000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=334 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:267969000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:267966000 GMT j9mm.469 - Allocation failure cycle start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:267963000 GMT j9mm.133 - Allocation failure start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:249015000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:249003000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:248971000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 Although the Java code that was used in this scenario deliberately triggered an OutOfMemoryError in a pronounced way, similar allocation issues can and do occur when dealing with large data sets such as XML files. The next step in diagnosing the problem is to open the system dump that gets generated automatically when an OutOfMemoryError occurs. Open the dump with the Eclipse Memory Analyzer\u2122 tool (MAT) and search for the StringBuffer object, which should provide further clues about what went wrong. A common example is seeing the same String duplicated over and over again, which might indicate that code is stuck in a loop. Note: If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plug-in in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > If, unlike the previous scenario, you receive an OutOfMemoryError and the MEMINFO section shows that there is very little space left on the Java heap, the current thread information is typically not important. The current thread is simply the thread that happened to be current when the space ran out. In this situation, you might want to increase your Java heap size. For help with this task, see How to do heap sizing . Native OutOfMemoryError In this scenario, the VM runs out of native memory. Native memory is memory that is used by the VM for storing all virtualized resources and data that it needs for VM operations. Native memory that is available to the VM process is limited by the operating system. The native memory available to the VM might also be subject to additional limits imposed by the operating system, for example Unix ulimits . When a NativeOutOfMemoryError occurs, a Java dump is generated by default. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for native memory. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"native memory exhausted\" received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20210423.140244.19708.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) Sometimes, the current thread is responsible for causing the NativeOutOfMemoryError . Information about the current thread can be found in the THREADS section, as shown in the following output. 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6C60C00, omrthread_t:0xB6C049D8, java/lang/Thread:0xB55E3C10, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x4CFD, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6D4E000, to:0xB754F000, size:0x801000) 3XMCPUTIME CPU usage total: 3.654896026 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at sun/misc/Unsafe.allocateDBBMemory(Native Method) 4XESTACKTRACE at java/nio/DirectByteBuffer.<init>(DirectByteBuffer.java:127(Compiled Code)) 4XESTACKTRACE at java/nio/ByteBuffer.allocateDirect(ByteBuffer.java:311) 4XESTACKTRACE at NativeHeapBreaker.main(NativeHeapBreaker.java:9) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6A9F5B3 [libj9prt29.so+0x3b5b3]) ... 4XENATIVESTACK (0xB582CC9C [libjclse7b_29.so+0x40c9c]) 4XENATIVESTACK Java_sun_misc_Unsafe_allocateDBBMemory+0x88 (0xB5827F6B [libjclse7b_29.so+0x3bf6b]) 4XENATIVESTACK (0x94A2084A [<unknown>+0x0]) 4XENATIVESTACK (0xB6B2538B [libj9vm29.so+0x6c38b]) 4XENATIVESTACK (0xB6B4074C [libj9vm29.so+0x8774c]) 4XENATIVESTACK (0xB6B7F299 [libj9vm29.so+0xc6299]) 4XENATIVESTACK (0xB6A82F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6B7F32A [libj9vm29.so+0xc632a]) 4XENATIVESTACK (0xB6B4084C [libj9vm29.so+0x8784c]) 4XENATIVESTACK (0xB6B3CD0C [libj9vm29.so+0x83d0c]) 4XENATIVESTACK (0xB776F87D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7784F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB76A043E [libc.so.6+0xee43e]) For clarity in the Native callstack output, ... indicates that some lines are removed. The Java call stack shows the transition from Java to native code ( sun/misc/Unsafe.allocateDBBMemory(Native Method) ), indicating a request for Direct Byte Buffer (DBB) storage. DBB storage is backed by native memory, with the Java heap containing only a reference to the native heap buffer. In this scenario, DBB storage is the likely culprit for this NativeOutOfMemoryError . The next step is to investigate the NATIVEMEMINFO section of the Java dump file, which reports the amount of memory used by the JRE process, broken down into component areas. 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 3,166,386,688 bytes / 4388 allocations 1MEMUSER | 2MEMUSER +--VM: 563,176,824 bytes / 1518 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 3,104,416 bytes / 120 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 548,181,888 bytes / 398 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 536,932,352 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 11,249,536 bytes / 397 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,817,120 bytes / 147 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 115,584 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 84,704 bytes / 114 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 163,688 bytes / 268 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,320 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 23,296 bytes / 55 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 8,576 bytes / 74 allocations 2MEMUSER | | 3MEMUSER | +--Other: 860,520 bytes / 443 allocations 1MEMUSER | 2MEMUSER +--JIT: 3,744,728 bytes / 122 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 2,097,152 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 524,336 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 1,123,240 bytes / 120 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 2,599,463,024 bytes / 2732 allocations 2MEMUSER | | 3MEMUSER | +--Harmony Class Libraries: 1,024 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 2,599,462,000 bytes / 2731 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 2,598,510,480 bytes / 2484 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 2,598,510,480 bytes / 2484 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 951,520 bytes / 247 allocations 1MEMUSER | 2MEMUSER +--Unknown: 2,112 bytes / 16 allocations NULL In the VM Class Libraries section, the amount of memory allocated for Direct Byte Buffers is shown. Because the NativeOutOfMemoryError was received on a small 32-bit system, a value of 2,598,510,480 bytes indicates that the operating system has run out of memory. On a larger UNIX\u00ae system, the process might have run out of memory because of the ulimit setting. Increasing the value for ulimit might avoid the error, which you can do temporarily by setting ulimit -f unlimited in your current session. The theoretical maximum size for a 32-bit process is the size of the 32-bit address space, which is 4 GB. On most operating systems, a portion of the address space for each process is used by the kernel, such that the real limit for 32-bit processes is actually significantly less than 4 GB. As a result, running out of native memory with a 32-bit VM is quite common. The same 4 GB limit is also important if you are using a 64-bit VM with compressed references. In compressed references mode, all references to objects, classes, threads, and monitors are represented by 32-bit values for performance reasons, so these structures can be allocated only at 32-bit addresses. However, the operating system might place other allocations within this 4 GB of address space, and if this area becomes sufficiently full or fragmented, the VM throws a native NativeOutOfMemoryError error. These errors typically occur when the VM tries to create a new thread or load a class. The Current Thread History section should contain more information about what the thread was doing at the VM level when the NativeOutOfMemoryError error occurred. You can usually avoid this type of problem by using the -Xmcrs option to reserve a contiguous area of memory within the lowest 4 GB of memory at VM startup. Another common cause of a NativeOutOfMemoryError is when an application loads duplicate classes. Classes are allocated outside of the Java heap in native memory. If the value reported for Classes in the NATIVEMEMINFO section is very large, duplicate classes might be the cause of your problem. The Eclipse Memory Analyzer tool (MAT) can tell you if you have duplicate classes by using the Class Loader Explorer feature. Because a system dump is automatically generated as well as a Java dump in response to a NativeOutOfMemoryError , simply open the system dump in MAT to continue your diagnosis. Deadlock Deadlocks occur when two threads attempt to synchronize on an object and lock an instance of a class. When this happens, your application stops responding and hangs. Generating a Java dump file will quickly tell you whether you have a deadlock situation. Trigger the Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. The VM can detect the most common types of deadlock scenario involving Java monitors. If this type of deadlock is detected, information is provided in the LOCKS section. More complex deadlocks, including those that involve a mixture of native mutexes and Java monitors, are not detected. Here is the output from the code that was used to cause a common deadlock scenario: NULL 1LKDEADLOCK Deadlock detected !!! NULL --------------------- NULL 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) 3LKDEADLOCKWTR is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B344 infl_mon_t: 0x08C2B384: 4LKDEADLOCKOBJ java/lang/Object@0xB5666698 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 3\" (0x94507500) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B3A0 infl_mon_t: 0x08C2B3E0: 4LKDEADLOCKOBJ java/lang/Object@0xB5666678 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 1\" (0x92A3EC00) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B2E8 infl_mon_t: 0x08C2B328: 4LKDEADLOCKOBJ java/lang/Object@0xB5666688 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) This output tells you that Worker Thread 2 is waiting for Worker Thread 3 , which is waiting for Worker Thread 1 . Because Worker Thread 1 is also waiting for Worker Thread 2 , there is a deadlock. The next place to look is the output for Java and native stacks, in the THREADS section. By looking at the stack for each of these worker threads, you can trace the problem back to specific lines in your application code. In this example, you can see from the following output that for all worker threads, the stack traces ( 4XESTACKTRACE / 5XESTACKTRACE ) indicate a problem in line 35 of the application DeadLockTest.java : 3XMTHREADINFO \"Worker Thread 1\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C2B0, java/lang/Thread:0xB5666778, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52CF, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004365543 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666688 Owned by: \"Worker Thread 2\" (J9VMThread:0x94501D00, java/lang/Thread:0xB56668D0) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666678, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 2\" J9VMThread:0x94501D00, omrthread_t:0x92A3C8F0, java/lang/Thread:0xB56668D0, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x14, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D0, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x946BF000, to:0x94700000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004555580 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666698 Owned by: \"Worker Thread 3\" (J9VMThread:0x94507500, java/lang/Thread:0xB5666A18) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666688, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 3\" J9VMThread:0x94507500, omrthread_t:0x92A3CC10, java/lang/Thread:0xB5666A18, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x15, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D1, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9467E000, to:0x946BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.003657010 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666678 Owned by: \"Worker Thread 1\" (J9VMThread:0x92A3EC00, java/lang/Thread:0xB5666778) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666698, entry count: 1) Hang An application can hang for a number of reasons but the most common cause is excessive global garbage collection (GC) activity, where your application is repeatedly paused because your Java heap has almost run out of memory. You can identify this problem by looking at verbose GC output. Collect this output by specifying the -verbose:gc option. Deadlock situations can also manifest themselves as hangs. For more information on diagnosing this type of problem from a Java dump, see the deadlock scenario. If you have eliminated verbose GC activity and deadlocks, another common hang scenario involves threads that compete and wait for Java object locks. This type of problem can usually be diagnosed by examining a Java dump. The simplest hang scenario involving Java object locks is where a thread acquires a lock that other threads are waiting for, but it doesn't release the lock for some reason. The first place to look in the Java dump output is the LOCKS section. This section lists all the monitors and shows which threads have acquired a lock and which threads are waiting. If the hang is caused by a thread not releasing a lock that other threads need, you can see a list of waiting threads in the output. In this example scenario, the Java dump LOCKS section shows that Worker Thread 0 ( 3LKMONOBJECT ) has acquired a lock and there are 19 other worker threads waiting to obtain the lock. NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 1 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x92711200 infl_mon_t: 0x92711240: 3LKMONOBJECT java/lang/Object@0xB56658D8: Flat locked by \"Worker Thread 0\" (J9VMThread:0x92A3EC00), entry count 1 3LKWAITERQ Waiting to enter: 3LKWAITER \"Worker Thread 1\" (J9VMThread:0x92703F00) 3LKWAITER \"Worker Thread 2\" (J9VMThread:0x92709C00) 3LKWAITER \"Worker Thread 3\" (J9VMThread:0x92710A00) 3LKWAITER \"Worker Thread 4\" (J9VMThread:0x92717F00) 3LKWAITER \"Worker Thread 5\" (J9VMThread:0x9271DC00) 3LKWAITER \"Worker Thread 6\" (J9VMThread:0x92723A00) 3LKWAITER \"Worker Thread 7\" (J9VMThread:0x92729800) 3LKWAITER \"Worker Thread 8\" (J9VMThread:0x92733700) 3LKWAITER \"Worker Thread 9\" (J9VMThread:0x92739400) 3LKWAITER \"Worker Thread 10\" (J9VMThread:0x92740200) 3LKWAITER \"Worker Thread 11\" (J9VMThread:0x92748100) 3LKWAITER \"Worker Thread 12\" (J9VMThread:0x9274DF00) 3LKWAITER \"Worker Thread 13\" (J9VMThread:0x92754D00) 3LKWAITER \"Worker Thread 14\" (J9VMThread:0x9275AA00) 3LKWAITER \"Worker Thread 15\" (J9VMThread:0x92760800) 3LKWAITER \"Worker Thread 16\" (J9VMThread:0x92766600) 3LKWAITER \"Worker Thread 17\" (J9VMThread:0x9276C300) 3LKWAITER \"Worker Thread 18\" (J9VMThread:0x92773100) 3LKWAITER \"Worker Thread 19\" (J9VMThread:0x92778F00) NULL The next step is to determine why Worker Thread 0 is not releasing the lock. The best place to start is the stack trace for this thread, which you can find by searching on the thread name or J9VMThread ID in the THREADS section. The following extract shows the details for \"Worker Thread 0\" (J9VMThread:0x92A3EC00) : NULL 3XMTHREADINFO \"Worker Thread 0\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C280, java/lang/Thread:0xB56668B8, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x511F, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000401) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.000211878 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Thread.sleep(Native Method) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:941) 4XESTACKTRACE at WorkerThread.doWork(HangTest.java:37) 4XESTACKTRACE at WorkerThread.run(HangTest.java:31) 5XESTACKTRACE (entered lock: java/lang/Object@0xB56658D8, entry count: 1) In the last line of this output, you can see where the thread acquired the lock. Working up from this line, you can see that WorkerThread.run was called, which in turn called WorkerThread.doWork . The stack shows that the thread then entered a call to java/lang/Thread.sleep in HangTest.java on line 37, which is preventing the thread from completing its work and releasing the lock. In this example, the sleep call was added to induce a hang, but in real-world scenarios the cause could be any blocking operation, such as reading from an input stream or socket. Another possibility is that the thread is waiting for another lock owned by yet another thread. It is important to remember that each Java dump represents a single snapshot in time. You should generate at least three Java dumps separated by a short pause, for example 30 seconds, and compare the output. This comparison tells you whether the threads involved are stuck in a fixed state or whether they are moving. In this example, the threads do not move and the investigation needs to focus on the logic in WorkerThread.doWork to understand why Worker Thread 0 entered the java/lang/Thread.sleep call. Another common scenario is where each Java dump shows a number of threads waiting for a lock owned by another thread, but the list of waiting threads and the lock-owning thread change over time. In this case, the cause is likely to be a bottleneck caused by thread contention, where the threads are continually competing for the same lock. In severe cases, the lock is held only for a small amount of time but there are lots of threads trying to obtain it. Because more time is spent handling the lock and scheduling the thread than executing application code, the degradation in performance is manifested as a hang. Thread contention is usually caused by an application design problem. You can use a similar approach to the one used in this scenario to determine which lines of code are responsible for the contention.","title":"Java dump"},{"location":"dump_javadump/#java-dump","text":"Java\u2122 dumps, sometimes referred to as Java cores , are produced when the VM ends unexpectedly because of an operating system signal, OutOfMemoryError , or a user-initiated keystroke combination. You can also generate a Java dump by calling the Dump API programmatically from your application or specifying the -Xdump:java option on the command line. If your Java application crashes or hangs, Java dumps can provide useful information to help you diagnose the root cause. If your application crashes, Java dumps are generated automatically for the following types of failure: the VM receives an unexpected signal or an assertion failure the VM runs out of memory If your application hangs, you can trigger the generation of a Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. Note: On Windows\u00ae, if you started the VM in a console window you can force the VM to produce a Java dump in response to a SIGBREAK signal (Ctrl-Break keyboard combination). If you didn't start in a console window, there is no equivalent to a Linux kill command on Windows for sending signals. The only option here is to trigger a full system dump by finding the VM process in the Processes tab of the Windows Task Manager and clicking Create dump file . To help you understand how a Java dump can help you with problem diagnosis, this topic includes a few scenarios to help you interpret the data: A crash caused by a general protection fault (gpf) A Java heap OutOfMemoryError (OOM) A native OutOfMemoryError (OOM) A deadlock situation A hang","title":"Java dump"},{"location":"dump_javadump/#java-dump-contents","text":"Java dumps summarize the state of the VM when the event occurs, with most of the information relating to components of the VM. The file is made up of a number of sections that provide different types of information.","title":"Java dump contents"},{"location":"dump_javadump/#title","text":"The first section of the Java dump file provides information about the event that triggered the production of the dump. In the following example, you can see that a vmstop event triggered the dump at a specified date and time. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"vmstop\" (00000002) Detail \"#0000000000000000\" received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/doc-javacore/javacore.20210423.140244.1175.0001.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x106 (vm_access+exclusive_vm_access+trace_disabled)","title":"TITLE"},{"location":"dump_javadump/#gpinfo","text":"The GPINFO section provides general information about the system that the VM is running on. The following example is taken from a Java dump that was generated on a Linux system. NULL ------------------------------------------------------------------------ 0SECTION GPINFO subcomponent dump routine NULL ================================ 2XHOSLEVEL OS Level : Linux 3.10.0-862.11.6.el7.x86_64 2XHCPUS Processors - 3XHCPUARCH Architecture : amd64 3XHNUMCPUS How Many : 4 3XHNUMASUP NUMA is either not supported or has been disabled by user NULL 1XHERROR2 Register dump section only produced for SIGSEGV, SIGILL or SIGFPE. NULL The content of this section can vary, depending on the cause of the dump. For example, if the dump was caused by a general protection fault (gpf), the library in which the crash occurred is also recorded, together with a value shown as VM flags . This value can provide some clues about which component of the VM might have been involved. Look for the following line in the output: 1XHFLAGS VM flags:0000000000000000 The hexadecimal number that is recorded for VM flags ends in MSSSS, where M is the VM component and SSSS is component-specific code as shown in the following table: Component Code value INTERPRETER 0x10000 GC 0x20000 GROW_STACK 0x30000 JNI 0x40000 JIT_CODEGEN 0x50000 BCVERIFY 0x60000 RTVERIFY 0x70000 SHAREDCLASSES 0x80000 A value of 0000000000000000 (0x00000) indicates that a crash occurred outside of the VM.","title":"GPINFO"},{"location":"dump_javadump/#envinfo","text":"This section contains useful information about the environment in which the crash took place, including the following data: Java version ( 1CIJAVAVERSION ) Eclipse OpenJ9\u2122 VM and subcomponent version information ( 1CIVMVERSION , 1CIJ9VMVERSION , 1CIJITVERSION , 1CIOMRVERSION , 1CIJCLVERSION ) VM start time ( 1CISTARTTIME ) and process information ( 1CIPROCESSID ) Java home ( 1CIJAVAHOMEDIR ) and DLL ( 1CIJAVADLLDIR ) directories User arguments passed on the command line ( 1CIUSERARGS ), identifying those that are ignored ( 1CIIGNOREDARGS ) User limits imposed by the system ( 1CIUSERLIMITS ) Environment variables in place ( 1CIENVVARS ) System information ( 1CISYSINFO ) CPU information ( 1CICPUINFO ) Control group (Cgroup) information ( 1CICGRPINFO ) For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION ENVINFO subcomponent dump routine NULL ================================= 1CIJAVAVERSION JRE 9 Linux amd64-64 (build 9.0.4-internal+0-adhoc..openj9-openjdk-jdk9) 1CIVMVERSION 20180830_000000 1CIJ9VMVERSION 8e7c6ec 1CIJITVERSION 8e7c6ec 1CIOMRVERSION 553811b_CMPRSS 1CIJCLVERSION ec1d223 based on jdk-9.0.4+12 1CIJITMODES JIT enabled, AOT enabled, FSD disabled, HCR enabled 1CIRUNNINGAS Running as a standalone JVM 1CIVMIDLESTATE VM Idle State: ACTIVE 1CICONTINFO Running in container : FALSE 1CICGRPINFO JVM support for cgroups enabled : TRUE 1CISTARTTIME JVM start time: 2018/08/30 at 21:55:47:387 1CISTARTNANO JVM start nanotime: 22012135233549 1CIPROCESSID Process ID: 30285 (0x764D) 1CICMDLINE [not available] 1CIJAVAHOMEDIR Java Home Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk 1CIJAVADLLDIR Java DLL Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/bin 1CISYSCP Sys Classpath: 1CIUSERARGS UserArgs: 2CIUSERARG -Xoptionsfile=/home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/options.default ... 1CIIGNOREDARGS Ignored Args: 2CIIGNOREDARG -XX:+UseCompressedOop 2CIIGNOREDARG -XX:CompressedClassSpaceSize=528482304 NULL 1CIUSERLIMITS User Limits (in bytes except for NOFILE and NPROC) NULL ------------------------------------------------------------------------ NULL type soft limit hard limit 2CIUSERLIMIT RLIMIT_AS unlimited unlimited 2CIUSERLIMIT RLIMIT_CORE 0 unlimited 2CIUSERLIMIT RLIMIT_CPU unlimited unlimited 2CIUSERLIMIT RLIMIT_DATA unlimited unlimited 2CIUSERLIMIT RLIMIT_FSIZE unlimited unlimited 2CIUSERLIMIT RLIMIT_LOCKS unlimited unlimited 2CIUSERLIMIT RLIMIT_MEMLOCK 65536 65536 2CIUSERLIMIT RLIMIT_NOFILE 4096 4096 2CIUSERLIMIT RLIMIT_NPROC 4096 30592 2CIUSERLIMIT RLIMIT_RSS unlimited unlimited 2CIUSERLIMIT RLIMIT_STACK 8388608 unlimited 2CIUSERLIMIT RLIMIT_MSGQUEUE 819200 819200 2CIUSERLIMIT RLIMIT_NICE 0 0 2CIUSERLIMIT RLIMIT_RTPRIO 0 0 2CIUSERLIMIT RLIMIT_SIGPENDING 30592 30592 NULL 1CIENVVARS Environment Variables NULL ------------------------------------------------------------------------ 2CIENVVAR XDG_VTNR=1 2CIENVVAR SSH_AGENT_PID=2653 ... NULL 1CISYSINFO System Information NULL ------------------------------------------------------------------------ 2CISYSINFO /proc/sys/kernel/core_pattern = core 2CISYSINFO /proc/sys/kernel/core_uses_pid = 1 NULL 1CICPUINFO CPU Information NULL ------------------------------------------------------------------------ 2CIPHYSCPU Physical CPUs: 8 2CIONLNCPU Online CPUs: 8 2CIBOUNDCPU Bound CPUs: 8 2CIACTIVECPU Active CPUs: 0 2CITARGETCPU Target CPUs: 8 2CIJITFEATURE CPU features (JIT): fpu cx8 cmov mmx sse sse2 ssse3 fma sse4_1 popcnt aesni osxsave avx avx2 rdt_m 2CIAOTFEATURE CPU features (AOT): fpu cx8 cmov mmx sse sse2 ssse3 fma sse4_1 popcnt aesni osxsave avx avx2 rdt_m NULL 1CICGRPINFO Cgroup Information NULL ------------------------------------------------------------------------ 2CICGRPINFO subsystem : cpu 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU Period : 100000 microseconds 3CICGRPINFO CPU Quota : Not Set 3CICGRPINFO CPU Shares : 1024 3CICGRPINFO Period intervals elapsed count : 0 3CICGRPINFO Throttled count : 0 3CICGRPINFO Total throttle time : 0 nanoseconds 2CICGRPINFO subsystem : cpuset 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU exclusive : 1 3CICGRPINFO Mem exclusive : 1 3CICGRPINFO CPUs : 0-7 3CICGRPINFO Mems : 0 2CICGRPINFO subsystem : memory 2CICGRPINFO cgroup name : / 3CICGRPINFO Memory Limit : Not Set 3CICGRPINFO Memory + Swap Limit : Not Set 3CICGRPINFO Memory Usage : 5363396608 bytes 3CICGRPINFO Memory + Swap Usage : 5363396608 bytes 3CICGRPINFO Memory Max Usage : 0 bytes 3CICGRPINFO Memory + Swap Max Usage : 0 bytes 3CICGRPINFO Memory limit exceeded count : 0 3CICGRPINFO Memory + Swap limit exceeded count : 0 3CICGRPINFO OOM Killer Disabled : 0 3CICGRPINFO Under OOM : 0 NULL","title":"ENVINFO"},{"location":"dump_javadump/#nativememinfo","text":"This section records information about native memory that is requested by using library functions such as malloc() and mmap() . Values are provided as a breakdown, per component, indicating the total number of bytes allocated and the number of native memory allocations. In the following example, 4,682,840 bytes of native memory are allocated (but not yet freed) to VM Classes, which correspond to 141 allocations. NULL ------------------------------------------------------------------------ 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 2,569,088,312 bytes / 4653 allocations 1MEMUSER | 2MEMUSER +--VM: 2,280,088,336 bytes / 2423 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 4,682,840 bytes / 141 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 2,054,966,784 bytes / 433 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 2,014,113,792 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 40,852,992 bytes / 432 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,970,016 bytes / 156 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 197,760 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 155,424 bytes / 123 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 180,056 bytes / 263 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,776 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 36,184 bytes / 52 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 208,179,632 bytes / 72 allocations 3MEMUSER | | | 4MEMUSER | | +--Unused <32bit allocation regions: 208,168,752 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,880 bytes / 71 allocations 2MEMUSER | | 3MEMUSER | +--Other: 1,055,048 bytes / 1293 allocations 1MEMUSER | 2MEMUSER +--JIT: 288,472,816 bytes / 140 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 268,435,456 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 2,097,216 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 17,940,144 bytes / 138 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 13,432 bytes / 25 allocations 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 13,432 bytes / 25 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 3,184 bytes / 13 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 1,056 bytes / 12 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Other: 2,128 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,248 bytes / 12 allocations 1MEMUSER | 2MEMUSER +--Unknown: 513,728 bytes / 2065 allocations NULL This section does not record memory that is allocated by application or JNI code and is typically a little less than the value recorded by operating system tools.","title":"NATIVEMEMINFO"},{"location":"dump_javadump/#meminfo","text":"This section relates to memory management, providing a breakdown of memory usage in the VM for the object heap, internal memory, memory used for classes, the JIT code cache, and JIT data cache in decimal and hexadecimal format. You can also find out which garbage collection policy is in use when the dump is produced. The object memory area ( 1STHEAPTYPE ) records each memory region in use, its start and end address, and region size. Further information is recorded about the memory segments that are used for internal memory, class memory, the JIT code cache, and JIT data cache ( 1STSEGMENT ). This information includes the address of the segment control data structure, the start and end address of the native memory segment, as well as the segment size. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0x00007FF4F00744A0 -- -- -- Generational 1STHEAPREGION 0x00007FF4F0074CE0 0x0000000087F40000 0x0000000088540000 0x0000000000600000 Generational/Tenured Region 1STHEAPREGION 0x00007FF4F0074930 0x00000000FFE00000 0x00000000FFF00000 0x0000000000100000 Generational/Nursery Region 1STHEAPREGION 0x00007FF4F0074580 0x00000000FFF00000 0x0000000100000000 0x0000000000100000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 8388608 (0x0000000000800000) 1STHEAPINUSE Total memory in use: 2030408 (0x00000000001EFB48) 1STHEAPFREE Total memory free: 6358200 (0x00000000006104B8) NULL 1STSEGTYPE Internal Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F004CBC8 0x00007FF4CD33C000 0x00007FF4CD33C000 0x00007FF4CE33C000 0x01000440 0x0000000001000000 1STSEGMENT 0x00007FF4F004CB08 0x00007FF4DE43D030 0x00007FF4DE517770 0x00007FF4DE53D030 0x00800040 0x0000000000100000 NULL 1STSEGTOTAL Total memory: 17825792 (0x0000000001100000) 1STSEGINUSE Total memory in use: 894784 (0x00000000000DA740) 1STSEGFREE Total memory free: 16931008 (0x00000000010258C0) NULL 1STSEGTYPE Class Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F03B5638 0x0000000001053D98 0x000000000105BD98 0x000000000105BD98 0x00010040 0x0000000000008000 1STSEGMENT 0x00007FF4F03B5578 0x0000000001048188 0x0000000001050188 0x0000000001050188 0x00010040 0x0000000000008000 ... NULL 1STSEGTOTAL Total memory: 3512520 (0x00000000003598C8) 1STSEGINUSE Total memory in use: 3433944 (0x00000000003465D8) 1STSEGFREE Total memory free: 78576 (0x00000000000132F0) NULL 1STSEGTYPE JIT Code Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F00961F8 0x00007FF4CE43D000 0x00007FF4CE445790 0x00007FF4DE43D000 0x00000068 0x0000000010000000 NULL 1STSEGTOTAL Total memory: 268435456 (0x0000000010000000) 1STSEGINUSE Total memory in use: 34704 (0x0000000000008790) 1STSEGFREE Total memory free: 268400752 (0x000000000FFF7870) 1STSEGLIMIT Allocation limit: 268435456 (0x0000000010000000) NULL 1STSEGTYPE JIT Data Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F0096668 0x00007FF4CC553030 0x00007FF4CC753030 0x00007FF4CC753030 0x00000048 0x0000000000200000 NULL 1STSEGTOTAL Total memory: 2097152 (0x0000000000200000) 1STSEGINUSE Total memory in use: 2097152 (0x0000000000200000) 1STSEGFREE Total memory free: 0 (0x0000000000000000) 1STSEGLIMIT Allocation limit: 402653184 (0x0000000018000000) NULL 1STGCHTYPE GC History NULL In the example, the GC History ( 1STGCHTYPE ) section is blank. This section is populated if a garbage collection cycle occurred in a VM that is being diagnosed with the trace facility.","title":"MEMINFO"},{"location":"dump_javadump/#locks","text":"This section of the Java dump provides information about locks, which protect shared resources from being accessed by more than one entity at a time. The information is essential in a deadlock situation, where two threads attempt to synchronize on an object and lock an instance of a class. Precise information is recorded about the threads that are causing the problem, which enables you to identify the root cause. The following example shows a typical LOCKS section, where no deadlocks existed at the time the dump was triggered. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 3 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x00007FF4B0001D78 infl_mon_t: 0x00007FF4B0001DF8: 3LKMONOBJECT java/lang/ref/ReferenceQueue@0x00000000FFE26A10: <unowned> 3LKNOTIFYQ Waiting to be notified: 3LKWAITNOTIFY \"Common-Cleaner\" (J9VMThread:0x0000000000FD0100) NULL 1LKREGMONDUMP JVM System Monitor Dump (registered monitors): 2LKREGMON Thread global lock (0x00007FF4F0004FE8): <unowned> 2LKREGMON &(PPG_mem_mem32_subAllocHeapMem32.monitor) lock (0x00007FF4F0005098): <unowned> 2LKREGMON NLS hash table lock (0x00007FF4F0005148): <unowned> ... NULL","title":"LOCKS"},{"location":"dump_javadump/#threads","text":"The THREADS section of a Java dump file provides summary information about the VM thread pool and detailed information about Java threads, native threads, and stack traces. Understanding the content of this section can help you diagnose problems that are caused by blocked or waiting threads. A Java thread runs on a native thread. Several lines are recorded for each Java thread in the Thread Details subsection, which include the following key pieces of information: 3XMTHREADINFO : The thread name, address information for the VM thread structures and Java thread object, the thread state, and thread priority. 3XMJAVALTHREAD : The Java thread ID and daemon status from the thread object. 3XMTHREADINFO1 : The native operating system thread ID, priority, scheduling policy, internal VM thread state, and VM thread flags. 3XMTHREADINFO2 : The native stack address range. 3XMTHREADINFO3 : Java call stack information ( 4XESTACKTRACE ) or Native call stack information ( 4XENATIVESTACK ). 5XESTACKTRACE : This line indicates whether locks were taken by a specific method. Java thread priorities are mapped to operating system priority values. Thread states are shown in the following table: Thread state value Status Description R Runnable The thread is able to run CW Condition Wait The thread is waiting S Suspended The thread is suspended by another thread Z Zombie The thread is destroyed P Parked The thread is parked by java.util.concurrent B Blocked The thread is waiting to obtain a lock For threads that are parked (P), blocked (B), or waiting (CW), an additional line ( 3XMTHREADBLOCK ) is included in the output that shows what the thread is parked on, blocked on, or waiting for. For threads that are waiting for a class initialization lock ( java/lang/J9VMInternals$ClassInitializationLock ), this line includes the name of the thread that is currently working to progress the initialization of the class. You can use this information to diagnose deadlocks that are caused by class initialization, which might not be detected and reported in the LOCKS section. For clarity, the following example shows a shortened version of a typical THREADS section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 19 2XMPOOLLIVE Current total number of live threads: 18 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMTHDINFO Thread Details NULL ... 3XMTHREADINFO \"JIT Diagnostic Compilation Thread-007 Suspended\" J9VMThread:0x0000000000035200, omrthread_t:0x00007F3F8C0D02C8, java/lang/Thread:0x00000000FFF42120, state:R, prio=10 3XMJAVALTHREAD (java/lang/Thread getId:0x9, isDaemon:true) 3XMJAVALTHRCCL sun/misc/Launcher$AppClassLoader(0x00000000FFF3BF98) 3XMTHREADINFO1 (native thread ID:0x618F, native priority:0xB, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000081) 3XMTHREADINFO2 (native stack address range from:0x00007F3F879C5000, to:0x00007F3F87AC5000, size:0x100000) 3XMCPUTIME CPU usage total: 0.052410771 secs, current category=\"JIT\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 No Java callstack associated with this thread ... NULL ... 3XMTHREADINFO \"Class Initialization Thread 2\" J9VMThread:0x0000000000124D00, omrthread_t:0x00007F3F8C1494C8, java/lang/Thread:0x00000000FFF53EE8, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMJAVALTHRCCL sun/misc/Launcher$AppClassLoader(0x00000000FFF3BF98) 3XMTHREADINFO1 (native thread ID:0x6199, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000181) 3XMTHREADINFO2 (native stack address range from:0x00007F3F74AB4000, to:0x00007F3F74AF4000, size:0x40000) 3XMCPUTIME CPU usage total: 0.008712260 secs, current category=\"Application\" 3XMTHREADBLOCK Waiting on: java/lang/J9VMInternals$ClassInitializationLock@0x00000000FFF61C90 Owned by: <unowned> Initializing thread: \"Class Initialization Thread 1\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=4096 (0x1000) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Class.forNameImpl(Native Method) 4XESTACKTRACE at java/lang/Class.forName(Class.java:339) 4XESTACKTRACE at ClassInitLockBug$ClassInitThread.run(ClassInitLockBug.java:16) ... NULL ... NULL 3XMTHREADINFO \"Class Initialization Thread 1\" J9VMThread:0x0000000000124100, omrthread_t:0x00007F3F8C148F50, java/lang/Thread:0x00000000FFF53D80, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x12, isDaemon:false) 3XMJAVALTHRCCL sun/misc/Launcher$AppClassLoader(0x00000000FFF3BF98) 3XMTHREADINFO1 (native thread ID:0x6198, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000481) 3XMTHREADINFO2 (native stack address range from:0x00007F3F74AF5000, to:0x00007F3F74B35000, size:0x40000) 3XMCPUTIME CPU usage total: 0.010221701 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=12736 (0x31C0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Thread.sleepImpl(Native Method) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:983) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:966) 4XESTACKTRACE at TestClass.<clinit>(ClassInitLockBug.java:29) 4XESTACKTRACE at java/lang/Class.forNameImpl(Native Method) 4XESTACKTRACE at java/lang/Class.forName(Class.java:339) 4XESTACKTRACE at ClassInitLockBug$ClassInitThread.run(ClassInitLockBug.java:16) ... NULL ... NULL 1XMTHDSUMMARY Threads CPU Usage Summary NULL ========================= NULL 1XMTHDCATINFO Warning: to get more accurate CPU times for the GC, the option -XX:-ReduceCPUMonitorOverhead can be used. See the user guide for more information. NULL 1XMTHDCATEGORY All JVM attached threads: 0.698865000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--System-JVM: 0.653723000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--GC: 0.047248000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--JIT: 0.512971000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--Application: 0.045142000 secs","title":"THREADS"},{"location":"dump_javadump/#hooks","text":"This section shows internal VM event callbacks, which are used for diagnosing performance problems in the VM. Multiple hook interfaces are listed, which include their individual hook events. The following example shows data for the J9VMHookInterface , including the total time for all previous events, the call site location (<source file>:<line number>), start time, and duration of the last callback and the longest callback (all times measured in microseconds). The hook data is reset after each Java dump. NULL ------------------------------------------------------------------------ SECTION HOOK subcomponent dump routine NULL ========================= 1NOTE These data are reset every time a javacore is taken 1HKINTERFACE MM_OMRHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_PrivateHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_HookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9VMHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 1 3HKCALLCOUNT 1239 3HKTOTALTIME 219564us 3HKLAST Last Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T00:15:14.664 4HKDURATION Duration : 16us 3HKLONGST Longest Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T21:28:34.895 4HKDURATION Duration : 5012us NULL ... 1HKINTERFACE J9VMZipCachePoolHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9JITHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 3 3HKCALLCOUNT 3113 3HKTOTALTIME 4904us 3HKLAST Last Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:04:15.320 4HKDURATION Duration : 3us 3HKLONGST Longest Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:37:17.633 4HKDURATION Duration : 27us NULL ...","title":"HOOKS"},{"location":"dump_javadump/#shared-classes","text":"If the shared classes cache is enabled at run time, the information that is provided in a Java dump file describes settings that were used when creating the cache, together with summary information about the size and content of the cache. In the following example, the shared classes cache was created with a Class Debug Area ( -Xnolinenumbers=false ). Byte code instrumentation (BCI) is enabled, which is the default, and VMs sharing the cache are allowed to store classpaths, which is also the default. The Cache Summary shows a cache size ( 2SCLTEXTCSZ ) of 16776608 bytes, with a soft maximum size ( 2SCLTEXTSMB ) also of 16776608 bytes, which leaves 12691668 bytes of free space ( 2SCLTEXTFRB ). The size of the Class Debug Area ( 2SCLTEXTDAS ) is 1331200 bytes and only 11% of this space is used. In the Cache Memory Status subsection, the line 2SCLTEXTCMDT indicates the name and location of the shared cache and cr indicates that the cache is a 64-bit compressed references cache. NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = true NULL 2SCLTEXTRCS ROMClass start address = 0x00007F423061C000 2SCLTEXTRCE ROMClass end address = 0x00007F42307B9A28 2SCLTEXTMSA Metadata start address = 0x00007F42313D42FC 2SCLTEXTCEA Cache end address = 0x00007F4231600000 2SCLTEXTRTF Runtime flags = 0x00102001ECA6028B 2SCLTEXTCGN Cache generation = 35 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 12691668 2SCLTEXTRCB ROMClass bytes = 1694248 2SCLTEXTAOB AOT code bytes = 0 2SCLTEXTADB AOT data bytes = 0 2SCLTEXTAHB AOT class hierarchy bytes = 32 2SCLTEXTATB AOT thunk bytes = 0 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJHB JIT hint bytes = 308 2SCLTEXTJPB JIT profile bytes = 2296 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 919328 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 2SCLTEXTMDA Metadata bytes = 23448 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 11% 2SCLTEXTDAN Class LineNumberTable bytes = 156240 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 595 2SCLTEXTNAM Number AOT Methods = 0 2SCLTEXTNAD Number AOT Data Entries = 0 2SCLTEXTNAH Number AOT Class Hierarchy = 1 2SCLTEXTNAT Number AOT Thunks = 0 2SCLTEXTNJH Number JIT Hints = 14 2SCLTEXTNJP Number JIT Profiles = 20 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 5 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0% NULL 2SCLTEXTCPF Cache is 24% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT sharedcc_doc-javacore CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_sharedcc_doc-javacore_G35 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL The following example shows information for a layered cache: NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCSTL Cache Statistics for Top Layer NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = false NULL 2SCLTEXTRCS ROMClass start address = 0x00007F0EDB567000 2SCLTEXTRCE ROMClass end address = 0x00007F0EDB567000 2SCLTEXTMSA Metadata start address = 0x00007F0EDC40241C 2SCLTEXTCEA Cache end address = 0x00007F0EDC54B000 2SCLTEXTRTF Runtime flags = 0x80102001ECA602BB 2SCLTEXTCGN Cache generation = 41 2SCLTEXTCLY Cache layer = 1 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 15315996 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 0% 2SCLTEXTDAN Class LineNumberTable bytes = 0 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTCPF Cache is 8% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT Cache1 CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_Cache1_G41L01 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL 1SCLTEXTCSAL Cache Statistics for All Layers NULL 2SCLTEXTRCB ROMClass bytes = 1459040 2SCLTEXTAOB AOT code bytes = 57624 2SCLTEXTADB AOT data bytes = 272 2SCLTEXTAHB AOT class hierarchy bytes = 1840 2SCLTEXTATB AOT thunk bytes = 632 2SCLTEXTJHB JIT hint bytes = 484 2SCLTEXTJPB JIT profile bytes = 0 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 1134016 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 503 2SCLTEXTNAM Number AOT Methods = 16 2SCLTEXTNAD Number AOT Data Entries = 1 2SCLTEXTNAH Number AOT Class Hierarchy = 28 2SCLTEXTNAT Number AOT Thunks = 11 2SCLTEXTNJH Number JIT Hints = 15 2SCLTEXTNJP Number JIT Profiles = 0 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 21 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0%","title":"SHARED CLASSES"},{"location":"dump_javadump/#classes","text":"The classes section shows information about class loaders. The first part is a summary that records each available class loader ( 2CLTEXTCLLOADER ) followed by the number of libraries and classes that it loaded. This information is followed by a more detailed list of libraries ( 1CLTEXTCLLIB ) and classes ( 1CLTEXTCLLO ) that are loaded. In the example you can see that the java/lang/InternalAnonymousClassLoader loaded two classes, jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) and jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) . NULL ------------------------------------------------------------------------ 0SECTION CLASSES subcomponent dump routine NULL ================================= 1CLTEXTCLLOS Classloader summaries 1CLTEXTCLLSS 12345678: 1=primordial,2=extension,3=shareable,4=middleware,5=system,6=trusted,7=application,8=delegating 2CLTEXTCLLOADER p---st-- Loader *System*(0x00000000FFE1D258) 3CLNMBRLOADEDLIB Number of loaded libraries 5 3CLNMBRLOADEDCL Number of loaded classes 638 2CLTEXTCLLOADER -x--st-- Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 2CLTEXTCLLOADER ----st-- Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 2 2CLTEXTCLLOADER -----ta- Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0), Parent jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 1CLTEXTCLLIB ClassLoader loaded libraries 2CLTEXTCLLIB Loader *System*(0x00000000FFE1D258) 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/jclse9_29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/java 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/j9jit29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/zip 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/nio 1CLTEXTCLLOD ClassLoader loaded classes 2CLTEXTCLLOAD Loader *System*(0x00000000FFE1D258) 3CLTEXTCLASS [Ljava/lang/Thread$State;(0x0000000001056400) ... 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 2CLTEXTCLLOAD Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0)","title":"CLASSES"},{"location":"dump_javadump/#scenarios","text":"","title":"Scenarios"},{"location":"dump_javadump/#general-protection-fault","text":"In this scenario, a Java application has crashed due to a General Protection Fault (GPF), automatically generating a Java dump file. The first section of the file (TITLE) tells you that the GPF triggered the Java dump. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"gpf\" (00002000) received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/test/JNICrasher/javacore.20210423.140244.29399.0002.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x100 (trace_disabled) 1TIPREPINFO Exclusive VM access not taken: data may not be consistent across javacore sections To troubleshoot this problem, you need to know which thread caused the GPF to occur. The thread that was running at the time of the crash is reported as the current thread in the THREADS section of the Java dump. Here is an extract from the THREADS section: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 15 2XMPOOLDAEMON Current total number of live daemon threads: 14 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60E00, omrthread_t:0xB6B049D8, java/lang/Thread:0xB55444D0, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x72D8, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00000000) 3XMTHREADINFO2 (native stack address range from:0xB6CE3000, to:0xB74E4000, size:0x801000) 3XMCPUTIME CPU usage total: 0.319865924 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=778008 (0xBDF18) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at JNICrasher.doSomethingThatCrashes(Native Method) 4XESTACKTRACE at JNICrasher.main(JNICrasher.java:7) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C6F663 [libj9prt29.so+0x3b663]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6F1CE [libj9prt29.so+0x3b1ce]) 4XENATIVESTACK (0xB6C6F2C6 [libj9prt29.so+0x3b2c6]) 4XENATIVESTACK (0xB6C6ED93 [libj9prt29.so+0x3ad93]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6ED07 [libj9prt29.so+0x3ad07]) 4XENATIVESTACK (0xB6C6AA3D [libj9prt29.so+0x36a3d]) 4XENATIVESTACK (0xB6C6C3A4 [libj9prt29.so+0x383a4]) 4XENATIVESTACK (0xB667FA19 [libj9dmp29.so+0xfa19]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66878CF [libj9dmp29.so+0x178cf]) 4XENATIVESTACK (0xB6688083 [libj9dmp29.so+0x18083]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6680C0D [libj9dmp29.so+0x10c0d]) 4XENATIVESTACK (0xB667F9D7 [libj9dmp29.so+0xf9d7]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB668B02F [libj9dmp29.so+0x1b02f]) 4XENATIVESTACK (0xB668B4D3 [libj9dmp29.so+0x1b4d3]) 4XENATIVESTACK (0xB66740F1 [libj9dmp29.so+0x40f1]) 4XENATIVESTACK (0xB66726FA [libj9dmp29.so+0x26fa]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66726A9 [libj9dmp29.so+0x26a9]) 4XENATIVESTACK (0xB6676AE4 [libj9dmp29.so+0x6ae4]) 4XENATIVESTACK (0xB668D75A [libj9dmp29.so+0x1d75a]) 4XENATIVESTACK (0xB6A28DD4 [libj9vm29.so+0x81dd4]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A289EE [libj9vm29.so+0x819ee]) 4XENATIVESTACK (0xB6A29A40 [libj9vm29.so+0x82a40]) 4XENATIVESTACK (0xB6C52B6A [libj9prt29.so+0x1eb6a]) 4XENATIVESTACK __kernel_rt_sigreturn+0x0 (0xB7747410) 4XENATIVESTACK (0xB75330B6 [libffi29.so+0x50b6]) 4XENATIVESTACK ffi_raw_call+0xad (0xB7531C53 [libffi29.so+0x3c53]) 4XENATIVESTACK (0xB69BE4AB [libj9vm29.so+0x174ab]) 4XENATIVESTACK (0xB6A665BC [libj9vm29.so+0xbf5bc]) 4XENATIVESTACK (0xB6A15552 [libj9vm29.so+0x6e552]) 4XENATIVESTACK (0xB6A30894 [libj9vm29.so+0x89894]) 4XENATIVESTACK (0xB6A6F169 [libj9vm29.so+0xc8169]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A6F1FA [libj9vm29.so+0xc81fa]) 4XENATIVESTACK (0xB6A30994 [libj9vm29.so+0x89994]) 4XENATIVESTACK (0xB6A2CE4C [libj9vm29.so+0x85e4c]) 4XENATIVESTACK (0xB770487D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7719F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB763543E [libc.so.6+0xee43e]) The extract tells you that the current thread was java/lang/Thread , and information is provided about the Java call stack and native call stack ( 3XMTHREADINFO3 ) at the point at which the crash occurred. To simulate a crash caused by a bug in an application, this example calls a JNI method whose native implementation causes a crash. The Java call stack shows the call to the JNI native method ( JNIcrasher ), and the native call stack shows the point of failure. In this example, the native call stack does not include any function names to help you isolate the error in the native code. You can get this information from a system dump, which is usually produced alongside the Java dump. Open the system dump with the Dump viewer and use the info thread command to print the Java and native stack for the current thread. The next time you run the application, you can use the -XX:+ShowNativeStackSymbols=all command line option to display the corresponding function names in the native call stack. 4XENATIVESTACK protectedBacktrace+0x12 (0x00007F3F9213E312 [libj9prt29.so+0x25312]) 4XENATIVESTACK omrsig_protect+0x1e3 (0x00007F3F92142AD3 [libj9prt29.so+0x29ad3]) 4XENATIVESTACK omrintrospect_backtrace_thread_raw+0xbf (0x00007F3F9213E80F [libj9prt29.so+0x2580f]) 4XENATIVESTACK omrsig_protect+0x1e3 (0x00007F3F92142AD3 [libj9prt29.so+0x29ad3]) 4XENATIVESTACK omrintrospect_backtrace_thread+0x70 (0x00007F3F9213E1D0 [libj9prt29.so+0x251d0]) 4XENATIVESTACK setup_native_thread+0x1d2 (0x00007F3F9213F652 [libj9prt29.so+0x26652]) 4XENATIVESTACK omrintrospect_threads_startDo_with_signal+0x474 (0x00007F3F921403F4 [libj9prt29.so+0x273f4]) 4XENATIVESTACK omrsig_protect+0x1e3 (0x00007F3F92142AD3 [libj9prt29.so+0x29ad3])","title":"General Protection Fault"},{"location":"dump_javadump/#java-outofmemoryerror","text":"In this scenario, the Java heap runs out of memory, causing an OutOfMemoryError , which automatically generates a Java dump file. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for Java heap space. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"Java heap space\" received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20210423.140244.18885.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) The MEMINFO section records how much memory is allocated to the Java heap ( 1STHEAPTYPE Object Memory ), how much is in use, and how much is free. Solving your problem might be as simple as setting a larger heap size when you start your application. If you don't know what size the Java heap was set to, you might find that information in the ENVINFO section, which records the command-line options that were used when the application started. Look or search for the 1CIUSERARGS UserArgs: string and review the entries that are recorded for all lines that start 2CIUSERARG . The Java heap size is set by the -Xmx option. If the size has not been set on the command line by -Xmx , the default value applies, which you can find in Default Settings . In this scenario, the solution to the problem is not an adjustment to the Java heap size. Here is the MEMINFO section: 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0xB6B49D20 -- -- -- Generational 1STHEAPREGION 0xB6B4A078 0x95750000 0xB5470000 0x1FD20000 Generational/Tenured Region 1STHEAPREGION 0xB6B49F10 0xB5470000 0xB54C0000 0x00050000 Generational/Nursery Region 1STHEAPREGION 0xB6B49DA8 0xB54C0000 0xB5750000 0x00290000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 536870912 (0x20000000) 1STHEAPINUSE Total memory in use: 302603160 (0x12095B98) 1STHEAPFREE Total memory free: 234267752 (0x0DF6A468) The output shows that only 56% of the Java heap is in use, so this suggests that the application is trying to do something suboptimal. To investigate further, you need to work out which thread was the current thread when the OOM occurred to see what it was trying to do. As in the previous scenario, you can find the current thread in the THREADS section. Here is an extract from the output: 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60C00, omrthread_t:0xB6B049D8, java/lang/Thread:0x95764520, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x49C6, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6CB5000, to:0xB74B6000, size:0x801000) 3XMCPUTIME CPU usage total: 8.537823831 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/StringBuffer.ensureCapacityImpl(StringBuffer.java:696) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:486(Compiled Code)) 5XESTACKTRACE (entered lock: java/lang/StringBuffer@0x957645B8, entry count: 1) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:428(Compiled Code)) 4XESTACKTRACE at HeapBreaker.main(HeapBreaker.java:34(Compiled Code)) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C535B3 [libj9prt29.so+0x3b5b3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C5311E [libj9prt29.so+0x3b11e]) 4XENATIVESTACK (0xB6C53216 [libj9prt29.so+0x3b216]) 4XENATIVESTACK (0xB6C52CE3 [libj9prt29.so+0x3ace3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C52C57 [libj9prt29.so+0x3ac57]) 4XENATIVESTACK (0xB6C4E9CD [libj9prt29.so+0x369cd]) 4XENATIVESTACK (0xB6C502FA [libj9prt29.so+0x382fa]) To simulate a Java OutOfMemoryError , this example application repeatedly appends characters to a StringBuffer object in an infinite loop. The Java call stack shows the HeapBreaker.main method appending characters ( java/lang/StringGuffer.append ) until the method java/lang/StringBuffer.ensureCapacityImpl() throws the OutOfMemoryError . StringBuffer objects are wrappers for character arrays ( char[] ) and when the capacity of the underlying array is reached, the contents are automatically copied into a new, larger array. The new array is created in the StringBuffer.ensureCapacity() method, which more or less doubles the size of the old array. In this scenario, the array takes up all the remaining space in the Java heap. The MEMINFO section of the Java dump file can also tell you when an unexpectedly large allocation request causes an OOM. Look for the GC History ( 1STGCHTYPE ) section, which details allocation requests that trigger GC activity. In the sample output you can see that a large allocation request ( requestedbytes=603979784 ) triggered a global GC. When the GC could not free up sufficient space in the heap to satisfy the request, the allocation failure generated the OOM. 1STGCHTYPE GC History 3STHSTTYPE 14:29:29:580239000 GMT j9mm.101 - J9AllocateIndexableObject() returning NULL! 0 bytes requested for object of class B6BBC300 from memory space 'Generational' id=B6B49D20 3STHSTTYPE 14:29:29:579916000 GMT j9mm.134 - Allocation failure end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579905000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579859000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:579807000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:579776000 GMT j9mm.137 - Compact end: bytesmoved=301989896 3STHSTTYPE 14:29:29:313899000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:313555000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:310772000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:310765000 GMT j9mm.94 - Class unloading end: classloadersunloaded=0 classesunloaded=0 3STHSTTYPE 14:29:29:310753000 GMT j9mm.60 - Class unloading start 3STHSTTYPE 14:29:29:310750000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:306013000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:305957000 GMT j9mm.474 - GlobalGC start: globalcount=9 3STHSTTYPE 14:29:29:305888000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:305837000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:305808000 GMT j9mm.137 - Compact end: bytesmoved=189784 3STHSTTYPE 14:29:29:298042000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:297695000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:291696000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:291692000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:284994000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:284941000 GMT j9mm.474 - GlobalGC start: globalcount=8 3STHSTTYPE 14:29:29:284916000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:284914000 GMT j9mm.469 - Allocation failure cycle start: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:284893000 GMT j9mm.470 - Allocation failure cycle end: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:284858000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=2 flipbytes=64 newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:284140000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:283160000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=335 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:283123000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:283120000 GMT j9mm.469 - Allocation failure cycle start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:283117000 GMT j9mm.133 - Allocation failure start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:269762000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269751000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269718000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:268981000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:268007000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=334 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:267969000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:267966000 GMT j9mm.469 - Allocation failure cycle start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:267963000 GMT j9mm.133 - Allocation failure start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:249015000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:249003000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:248971000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 Although the Java code that was used in this scenario deliberately triggered an OutOfMemoryError in a pronounced way, similar allocation issues can and do occur when dealing with large data sets such as XML files. The next step in diagnosing the problem is to open the system dump that gets generated automatically when an OutOfMemoryError occurs. Open the dump with the Eclipse Memory Analyzer\u2122 tool (MAT) and search for the StringBuffer object, which should provide further clues about what went wrong. A common example is seeing the same String duplicated over and over again, which might indicate that code is stuck in a loop. Note: If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plug-in in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > If, unlike the previous scenario, you receive an OutOfMemoryError and the MEMINFO section shows that there is very little space left on the Java heap, the current thread information is typically not important. The current thread is simply the thread that happened to be current when the space ran out. In this situation, you might want to increase your Java heap size. For help with this task, see How to do heap sizing .","title":"Java OutOfMemoryError"},{"location":"dump_javadump/#native-outofmemoryerror","text":"In this scenario, the VM runs out of native memory. Native memory is memory that is used by the VM for storing all virtualized resources and data that it needs for VM operations. Native memory that is available to the VM process is limited by the operating system. The native memory available to the VM might also be subject to additional limits imposed by the operating system, for example Unix ulimits . When a NativeOutOfMemoryError occurs, a Java dump is generated by default. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for native memory. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"native memory exhausted\" received 1TIDATETIMEUTC Date: 2021/04/23 at 18:02:44:017 (UTC) 1TIDATETIME Date: 2021/04/23 at 14:02:44:017 1TITIMEZONE Timezone: UTC-4 (EDT) 1TINANOTIME System nanotime: 379202644260787 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20210423.140244.19708.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) Sometimes, the current thread is responsible for causing the NativeOutOfMemoryError . Information about the current thread can be found in the THREADS section, as shown in the following output. 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6C60C00, omrthread_t:0xB6C049D8, java/lang/Thread:0xB55E3C10, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x4CFD, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6D4E000, to:0xB754F000, size:0x801000) 3XMCPUTIME CPU usage total: 3.654896026 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at sun/misc/Unsafe.allocateDBBMemory(Native Method) 4XESTACKTRACE at java/nio/DirectByteBuffer.<init>(DirectByteBuffer.java:127(Compiled Code)) 4XESTACKTRACE at java/nio/ByteBuffer.allocateDirect(ByteBuffer.java:311) 4XESTACKTRACE at NativeHeapBreaker.main(NativeHeapBreaker.java:9) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6A9F5B3 [libj9prt29.so+0x3b5b3]) ... 4XENATIVESTACK (0xB582CC9C [libjclse7b_29.so+0x40c9c]) 4XENATIVESTACK Java_sun_misc_Unsafe_allocateDBBMemory+0x88 (0xB5827F6B [libjclse7b_29.so+0x3bf6b]) 4XENATIVESTACK (0x94A2084A [<unknown>+0x0]) 4XENATIVESTACK (0xB6B2538B [libj9vm29.so+0x6c38b]) 4XENATIVESTACK (0xB6B4074C [libj9vm29.so+0x8774c]) 4XENATIVESTACK (0xB6B7F299 [libj9vm29.so+0xc6299]) 4XENATIVESTACK (0xB6A82F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6B7F32A [libj9vm29.so+0xc632a]) 4XENATIVESTACK (0xB6B4084C [libj9vm29.so+0x8784c]) 4XENATIVESTACK (0xB6B3CD0C [libj9vm29.so+0x83d0c]) 4XENATIVESTACK (0xB776F87D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7784F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB76A043E [libc.so.6+0xee43e]) For clarity in the Native callstack output, ... indicates that some lines are removed. The Java call stack shows the transition from Java to native code ( sun/misc/Unsafe.allocateDBBMemory(Native Method) ), indicating a request for Direct Byte Buffer (DBB) storage. DBB storage is backed by native memory, with the Java heap containing only a reference to the native heap buffer. In this scenario, DBB storage is the likely culprit for this NativeOutOfMemoryError . The next step is to investigate the NATIVEMEMINFO section of the Java dump file, which reports the amount of memory used by the JRE process, broken down into component areas. 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 3,166,386,688 bytes / 4388 allocations 1MEMUSER | 2MEMUSER +--VM: 563,176,824 bytes / 1518 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 3,104,416 bytes / 120 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 548,181,888 bytes / 398 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 536,932,352 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 11,249,536 bytes / 397 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,817,120 bytes / 147 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 115,584 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 84,704 bytes / 114 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 163,688 bytes / 268 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,320 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 23,296 bytes / 55 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 8,576 bytes / 74 allocations 2MEMUSER | | 3MEMUSER | +--Other: 860,520 bytes / 443 allocations 1MEMUSER | 2MEMUSER +--JIT: 3,744,728 bytes / 122 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 2,097,152 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 524,336 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 1,123,240 bytes / 120 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 2,599,463,024 bytes / 2732 allocations 2MEMUSER | | 3MEMUSER | +--Harmony Class Libraries: 1,024 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 2,599,462,000 bytes / 2731 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 2,598,510,480 bytes / 2484 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 2,598,510,480 bytes / 2484 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 951,520 bytes / 247 allocations 1MEMUSER | 2MEMUSER +--Unknown: 2,112 bytes / 16 allocations NULL In the VM Class Libraries section, the amount of memory allocated for Direct Byte Buffers is shown. Because the NativeOutOfMemoryError was received on a small 32-bit system, a value of 2,598,510,480 bytes indicates that the operating system has run out of memory. On a larger UNIX\u00ae system, the process might have run out of memory because of the ulimit setting. Increasing the value for ulimit might avoid the error, which you can do temporarily by setting ulimit -f unlimited in your current session. The theoretical maximum size for a 32-bit process is the size of the 32-bit address space, which is 4 GB. On most operating systems, a portion of the address space for each process is used by the kernel, such that the real limit for 32-bit processes is actually significantly less than 4 GB. As a result, running out of native memory with a 32-bit VM is quite common. The same 4 GB limit is also important if you are using a 64-bit VM with compressed references. In compressed references mode, all references to objects, classes, threads, and monitors are represented by 32-bit values for performance reasons, so these structures can be allocated only at 32-bit addresses. However, the operating system might place other allocations within this 4 GB of address space, and if this area becomes sufficiently full or fragmented, the VM throws a native NativeOutOfMemoryError error. These errors typically occur when the VM tries to create a new thread or load a class. The Current Thread History section should contain more information about what the thread was doing at the VM level when the NativeOutOfMemoryError error occurred. You can usually avoid this type of problem by using the -Xmcrs option to reserve a contiguous area of memory within the lowest 4 GB of memory at VM startup. Another common cause of a NativeOutOfMemoryError is when an application loads duplicate classes. Classes are allocated outside of the Java heap in native memory. If the value reported for Classes in the NATIVEMEMINFO section is very large, duplicate classes might be the cause of your problem. The Eclipse Memory Analyzer tool (MAT) can tell you if you have duplicate classes by using the Class Loader Explorer feature. Because a system dump is automatically generated as well as a Java dump in response to a NativeOutOfMemoryError , simply open the system dump in MAT to continue your diagnosis.","title":"Native OutOfMemoryError"},{"location":"dump_javadump/#deadlock","text":"Deadlocks occur when two threads attempt to synchronize on an object and lock an instance of a class. When this happens, your application stops responding and hangs. Generating a Java dump file will quickly tell you whether you have a deadlock situation. Trigger the Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. The VM can detect the most common types of deadlock scenario involving Java monitors. If this type of deadlock is detected, information is provided in the LOCKS section. More complex deadlocks, including those that involve a mixture of native mutexes and Java monitors, are not detected. Here is the output from the code that was used to cause a common deadlock scenario: NULL 1LKDEADLOCK Deadlock detected !!! NULL --------------------- NULL 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) 3LKDEADLOCKWTR is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B344 infl_mon_t: 0x08C2B384: 4LKDEADLOCKOBJ java/lang/Object@0xB5666698 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 3\" (0x94507500) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B3A0 infl_mon_t: 0x08C2B3E0: 4LKDEADLOCKOBJ java/lang/Object@0xB5666678 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 1\" (0x92A3EC00) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B2E8 infl_mon_t: 0x08C2B328: 4LKDEADLOCKOBJ java/lang/Object@0xB5666688 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) This output tells you that Worker Thread 2 is waiting for Worker Thread 3 , which is waiting for Worker Thread 1 . Because Worker Thread 1 is also waiting for Worker Thread 2 , there is a deadlock. The next place to look is the output for Java and native stacks, in the THREADS section. By looking at the stack for each of these worker threads, you can trace the problem back to specific lines in your application code. In this example, you can see from the following output that for all worker threads, the stack traces ( 4XESTACKTRACE / 5XESTACKTRACE ) indicate a problem in line 35 of the application DeadLockTest.java : 3XMTHREADINFO \"Worker Thread 1\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C2B0, java/lang/Thread:0xB5666778, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52CF, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004365543 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666688 Owned by: \"Worker Thread 2\" (J9VMThread:0x94501D00, java/lang/Thread:0xB56668D0) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666678, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 2\" J9VMThread:0x94501D00, omrthread_t:0x92A3C8F0, java/lang/Thread:0xB56668D0, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x14, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D0, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x946BF000, to:0x94700000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004555580 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666698 Owned by: \"Worker Thread 3\" (J9VMThread:0x94507500, java/lang/Thread:0xB5666A18) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666688, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 3\" J9VMThread:0x94507500, omrthread_t:0x92A3CC10, java/lang/Thread:0xB5666A18, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x15, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D1, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9467E000, to:0x946BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.003657010 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666678 Owned by: \"Worker Thread 1\" (J9VMThread:0x92A3EC00, java/lang/Thread:0xB5666778) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666698, entry count: 1)","title":"Deadlock"},{"location":"dump_javadump/#hang","text":"An application can hang for a number of reasons but the most common cause is excessive global garbage collection (GC) activity, where your application is repeatedly paused because your Java heap has almost run out of memory. You can identify this problem by looking at verbose GC output. Collect this output by specifying the -verbose:gc option. Deadlock situations can also manifest themselves as hangs. For more information on diagnosing this type of problem from a Java dump, see the deadlock scenario. If you have eliminated verbose GC activity and deadlocks, another common hang scenario involves threads that compete and wait for Java object locks. This type of problem can usually be diagnosed by examining a Java dump. The simplest hang scenario involving Java object locks is where a thread acquires a lock that other threads are waiting for, but it doesn't release the lock for some reason. The first place to look in the Java dump output is the LOCKS section. This section lists all the monitors and shows which threads have acquired a lock and which threads are waiting. If the hang is caused by a thread not releasing a lock that other threads need, you can see a list of waiting threads in the output. In this example scenario, the Java dump LOCKS section shows that Worker Thread 0 ( 3LKMONOBJECT ) has acquired a lock and there are 19 other worker threads waiting to obtain the lock. NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 1 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x92711200 infl_mon_t: 0x92711240: 3LKMONOBJECT java/lang/Object@0xB56658D8: Flat locked by \"Worker Thread 0\" (J9VMThread:0x92A3EC00), entry count 1 3LKWAITERQ Waiting to enter: 3LKWAITER \"Worker Thread 1\" (J9VMThread:0x92703F00) 3LKWAITER \"Worker Thread 2\" (J9VMThread:0x92709C00) 3LKWAITER \"Worker Thread 3\" (J9VMThread:0x92710A00) 3LKWAITER \"Worker Thread 4\" (J9VMThread:0x92717F00) 3LKWAITER \"Worker Thread 5\" (J9VMThread:0x9271DC00) 3LKWAITER \"Worker Thread 6\" (J9VMThread:0x92723A00) 3LKWAITER \"Worker Thread 7\" (J9VMThread:0x92729800) 3LKWAITER \"Worker Thread 8\" (J9VMThread:0x92733700) 3LKWAITER \"Worker Thread 9\" (J9VMThread:0x92739400) 3LKWAITER \"Worker Thread 10\" (J9VMThread:0x92740200) 3LKWAITER \"Worker Thread 11\" (J9VMThread:0x92748100) 3LKWAITER \"Worker Thread 12\" (J9VMThread:0x9274DF00) 3LKWAITER \"Worker Thread 13\" (J9VMThread:0x92754D00) 3LKWAITER \"Worker Thread 14\" (J9VMThread:0x9275AA00) 3LKWAITER \"Worker Thread 15\" (J9VMThread:0x92760800) 3LKWAITER \"Worker Thread 16\" (J9VMThread:0x92766600) 3LKWAITER \"Worker Thread 17\" (J9VMThread:0x9276C300) 3LKWAITER \"Worker Thread 18\" (J9VMThread:0x92773100) 3LKWAITER \"Worker Thread 19\" (J9VMThread:0x92778F00) NULL The next step is to determine why Worker Thread 0 is not releasing the lock. The best place to start is the stack trace for this thread, which you can find by searching on the thread name or J9VMThread ID in the THREADS section. The following extract shows the details for \"Worker Thread 0\" (J9VMThread:0x92A3EC00) : NULL 3XMTHREADINFO \"Worker Thread 0\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C280, java/lang/Thread:0xB56668B8, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x511F, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000401) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.000211878 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Thread.sleep(Native Method) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:941) 4XESTACKTRACE at WorkerThread.doWork(HangTest.java:37) 4XESTACKTRACE at WorkerThread.run(HangTest.java:31) 5XESTACKTRACE (entered lock: java/lang/Object@0xB56658D8, entry count: 1) In the last line of this output, you can see where the thread acquired the lock. Working up from this line, you can see that WorkerThread.run was called, which in turn called WorkerThread.doWork . The stack shows that the thread then entered a call to java/lang/Thread.sleep in HangTest.java on line 37, which is preventing the thread from completing its work and releasing the lock. In this example, the sleep call was added to induce a hang, but in real-world scenarios the cause could be any blocking operation, such as reading from an input stream or socket. Another possibility is that the thread is waiting for another lock owned by yet another thread. It is important to remember that each Java dump represents a single snapshot in time. You should generate at least three Java dumps separated by a short pause, for example 30 seconds, and compare the output. This comparison tells you whether the threads involved are stuck in a fixed state or whether they are moving. In this example, the threads do not move and the investigation needs to focus on the logic in WorkerThread.doWork to understand why Worker Thread 0 entered the java/lang/Thread.sleep call. Another common scenario is where each Java dump shows a number of threads waiting for a lock owned by another thread, but the list of waiting threads and the lock-owning thread change over time. In this case, the cause is likely to be a bottleneck caused by thread contention, where the threads are continually competing for the same lock. In severe cases, the lock is held only for a small amount of time but there are lots of threads trying to obtain it. Because more time is spent handling the lock and scheduling the thread than executing application code, the degradation in performance is manifested as a hang. Thread contention is usually caused by an application design problem. You can use a similar approach to the one used in this scenario to determine which lines of code are responsible for the contention.","title":"Hang"},{"location":"dump_systemdump/","text":"System dump System dumps, often known as core dumps , are platform-specific and contain a raw binary dump of the process memory. This type of dump has a complete copy of the Java heap, including the contents of all Java objects in the application. Obtaining system dumps System dumps are produced in response to specific events. To discover which events generate a dump, run the -Xdump:what command. The following output captures the information shown for a system dump: -Xdump:system: events=gpf+abort+traceassert+corruptcache, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=999, request=serial This output shows that events such as a general protection fault (gpf) or native abort() call can trigger a system dump. For more information about controlling the behavior of dump agents, see Dump agents . Enabling a full system dump (AIX, Linux, and macOS) If you require a system dump that contains details of all the native threads that are running, you must change the resource limits for your operating system. Otherwise, the native thread details that are stored in the dump are only for the native thread that was running when the VM ended. Set the system resource limits by running the following commands: ulimit -c unlimited; ulimit -n unlimited; ulimit -d unlimited; ulimit -f unlimited; Where: -c sets core files -n sets the number of open files -d sets the data limit -f sets the file limit For AIX systems, use the system management interface tool (SMIT) to enable a full CORE dump that is not a pre-430 style CORE dump . You can also set this configuration with the following command line option: chdev -l sys0 -a fullcore='true' -a pre430core='false' Analyzing a system dump To examine a system dump you can use the Dump viewer ( jdmpview ), a platform-specific debugging tool, or the Eclipse Memory Analyzer\u2122 tool (MAT). If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plugin in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java","title":"System dump"},{"location":"dump_systemdump/#system-dump","text":"System dumps, often known as core dumps , are platform-specific and contain a raw binary dump of the process memory. This type of dump has a complete copy of the Java heap, including the contents of all Java objects in the application.","title":"System dump"},{"location":"dump_systemdump/#obtaining-system-dumps","text":"System dumps are produced in response to specific events. To discover which events generate a dump, run the -Xdump:what command. The following output captures the information shown for a system dump: -Xdump:system: events=gpf+abort+traceassert+corruptcache, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=999, request=serial This output shows that events such as a general protection fault (gpf) or native abort() call can trigger a system dump. For more information about controlling the behavior of dump agents, see Dump agents .","title":"Obtaining system dumps"},{"location":"dump_systemdump/#enabling-a-full-system-dump-aix-linux-and-macos","text":"If you require a system dump that contains details of all the native threads that are running, you must change the resource limits for your operating system. Otherwise, the native thread details that are stored in the dump are only for the native thread that was running when the VM ended. Set the system resource limits by running the following commands: ulimit -c unlimited; ulimit -n unlimited; ulimit -d unlimited; ulimit -f unlimited; Where: -c sets core files -n sets the number of open files -d sets the data limit -f sets the file limit For AIX systems, use the system management interface tool (SMIT) to enable a full CORE dump that is not a pre-430 style CORE dump . You can also set this configuration with the following command line option: chdev -l sys0 -a fullcore='true' -a pre430core='false'","title":"Enabling a full system dump (AIX, Linux, and macOS)"},{"location":"dump_systemdump/#analyzing-a-system-dump","text":"To examine a system dump you can use the Dump viewer ( jdmpview ), a platform-specific debugging tool, or the Eclipse Memory Analyzer\u2122 tool (MAT). If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plugin in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java","title":"Analyzing a system dump"},{"location":"env_var/","text":"Environment variables Although the Eclipse OpenJ9\u2122 virtual machine (VM) recognizes many environment variables, most are superseded by command-line arguments. Use command-line arguments rather than environment variables, which are retained only for compatibility. Note: Environment variables are overridden by command-line arguments. Finding and setting environment variables To show the current environment, run: set (Windows\u2122) env (AIX\u00ae, Linux\u00ae, and macOS\u00ae) set (z/OS\u00ae) To show a particular environment variable, run: echo %ENVNAME% (Windows) echo $ENVNAME (AIX, Linux, macOS, and z/OS) Use values exactly as shown in the documentation. The names of environment variables are case-sensitive in AIX, Linux, macOS, and z/OS. To set the environment variable LOGIN_NAME to Fred , run: set LOGIN_NAME=Fred (Windows) export LOGIN_NAME=Fred (AIX/Linux/macOS: ksh or bash shells) setenv LOGIN_NAME Fred (csh shells) These variables are set only for the current shell or command-line session. If you are setting multiple values for an environment variable in a list: On AIX, Linux, macOS, and z/OS the separator is typically a colon (:). On Windows the separator is typically a semicolon (;). General options General VM environment variables are shown in the following table: Environment variable Usage information OPENJ9_JAVA_COMMAND_LINE This variable is set by the VM after it starts. Using this variable, you can find the command-line parameters set when the VM started. See -XX:[+|-]OpenJ9CommandLineEnv for more information. OPENJ9_JAVA_OPTIONS=<option> Set this variable to store default Java options, including -X , -D , or -verbose:gc style options. For example, -Xms256m -Djava.compiler . Any options set are overridden by equivalent options that are specified when Java is started. This variable does not support certain options, see the list in -Xoptionsfile . If you specify the name of a trace output file either directly, or indirectly, by using a properties file, the output file might be accidentally overwritten if you run utilities such as the trace formatter, dump extractor, or dump viewer. To avoid this problem, add %d, %p or %t to the trace file names. See -Xtrace:output . Note: The equivalent to OPENJ9_JAVA_OPTIONS , IBM_JAVA_OPTIONS is deprecated and will be removed in a future release. JAVA_FONTS=<list of directories> Set this environment variable to specify the font directory. Setting this variable is equivalent to setting the property java.awt.fonts on Windows operating systems, and sun.java2d.fontpath on other operating systems. _JAVA_OPTIONS=<option> Set this variable to add Java options to the end of the command line. Supported options and trace file issues are the same as for OPENJ9_JAVA_OPTIONS . Dump agent options The preferred mechanism for controlling the production of dumps is by using the -Xdump option. However, these legacy environment variables are preserved and can still be used. The following table describes dump agent options: Environment Variable Usage Information JAVA_DUMP_OPTS Used to control the conditions under which dumps are produced. If you set agents for a condition by using the JAVA_DUMP_OPTS environment variable, default dump agents for that condition are disabled; however, any -Xdump options that are specified on the command line are used. The JAVA_DUMP_OPTS environment variable uses the following syntax: JAVA_DUMP_OPTS=\"ON<condition>(<agent>[<count>],<agent>[<count>]), ON<condition>(<agent>[<count>],...),...)\" Where: <condition> is one of the following values: ANYSIGNAL DUMP ERROR INTERRUPT EXCEPTION OUTOFMEMORY <agent> is one of the following values: ALL NONE JAVADUMP SYSDUMP HEAPDUMP CEEDUMP (z/OS specific) <count> is the number of times to run the specified agent for the specified condition. This value is optional. By default, the agent runs every time that the condition occurs. JAVA_DUMP_OPTS is parsed by taking the leftmost occurrence of each condition, so duplicates are ignored. The following setting produces a system dump for the first error condition only: ONERROR(SYSDUMP[1]),ONERROR(JAVADUMP) Also, the ONANYSIGNAL condition is parsed before all others, so ONINTERRUPT(NONE),ONANYSIGNAL(SYSDUMP) has the same effect as ONANYSIGNAL(SYSDUMP),ONINTERRUPT(NONE) If the JAVA_DUMP_TOOL environment variable is set, that variable is assumed to specify a valid executable name and is parsed for replaceable fields, such as %pid . If %pid is detected in the string, the string is replaced with the VM's own process ID. The tool that is specified by JAVA_DUMP_TOOL is run after any system dump or heap dump is taken, before anything else. The dump settings are applied in the following order. Settings later in the list take precedence: Default VM dump behavior. -Xdump command-line options that specify -Xdump:<type>:defaults , see OpenJ9 default options . DISABLE_JAVADUMP , IBM_HEAPDUMP , and IBM_HEAP_DUMP environment variables. IBM_JAVADUMP_OUTOFMEMORY and IBM_HEAPDUMP_OUTOFMEMORY environment variables. JAVA_DUMP_OPTS environment variable. Remaining -Xdump command-line options. Setting JAVA_DUMP_OPTS affects only those conditions that you specify. Actions on other conditions are unchanged. Signal mapping When setting the JAVA_DUMP_OPTS environment variable, the mapping of operating system signals to the \"condition\" is shown in the following table: Condition z/OS Windows Linux, macOS, and AIX EXCEPTION SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGSYS, SIGXFSV SIGILL, SIGSEGV, SIGFPE SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGXFSV INTERRUPT SIGINT, SIGTERM, SIGHUP SIGINT, SIGTERM SIGINT, SIGTERM, SIGHUP ERROR SIGABRT SIGABRT SIGABRT DUMP SIGQUIT SIGBREAK SIGQUIT Java dump options The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:java option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information DISABLE_JAVADUMP=[TRUE|FALSE] Setting DISABLE_JAVADUMP to TRUE is the equivalent of using -Xdump:java:none and stops the default production of Java dumps. IBM_JAVACOREDIR=<directory> The default location into which the Java dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_JAVADUMP_OUTOFMEMORY=[TRUE|FALSE] By setting this environment variable to FALSE , you disable Java dumps for an out-of-memory exception. When not set, a Java dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable Java dumps for an out-of-memory exception. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and Heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Java dumps are produced. Heap dump options The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:heap option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information IBM_HEAPDUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAP_DUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAPDUMPDIR=<directory> The default location into which the heap dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_HEAPDUMP_OUTOFMEMORY=[TRUE|FALSE] Controls the generation of a heap dump when an out-of-memory exception is thrown. When not set, a heap dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable heap dump for an out-of-memory exception. IBM_JAVA_HEAPDUMP_TEST Use this environment variable to cause the VM to generate both PHD and text versions of heap dumps. Equivalent to opts=PHD+CLASSIC on the -Xdump:heap option. IBM_JAVA_HEAPDUMP_TEXT Use this environment variable to cause the VM to generate a text (human readable) Heap dump. Equivalent to opts=CLASSIC on the -Xdump:heap option. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Heap dumps are produced. Other diagnostic options The following table lists other environment variables that can be set for diagnostic purposes: Environment variable Usage Instructions IBM_COREDIR=<directory> Set this variable to specify an alternative location for system dumps, JIT dumps, and snap trace. On z/OS, _CEE_DMPTARG is used instead for snap trace, and transaction dumps are written to TSO according to JAVA_DUMP_TDUMP_PATTERN . On Linux and macOS, the dump is written to the directory that is specified directory by the operating system before being moved to the specified location. IBM_JAVA_ABEND_ON_FAILURE=Y (z/OS only) This setting tells the Java launcher to mark the Task Control Block (TCB) with an abend code if the OpenJ9 VM fails to load or is terminated by an uncaught exception. By default, the Java launcher does not mark the TCB. JAVA_DUMP_TDUMP_PATTERN=<string> (z/OS only) The specified <string> is passed to IEATDUMP to use as the data/set name for the Transaction Dump. The default <string> is %uid.JVM.TDUMP.%job.D%y%m%d.T%H%M%S (31-bit) or %uid.JVM.%job.D%y%m%d.T%H%M%S.X&amp;DS (64-bit), where %uid is found from the C code fragment shown in Notes . JAVA_THREAD_MODEL=<string> <string> can be defined as one of the following values: NATIVE (all threads are created as _MEDIUM_WEIGHT ), HEAVY (all threads are created as _HEAVY_WEIGHT ), MEDIUM (same as NATIVE ), or NULL . The default is NATIVE . IBM_XE_COE_NAME=<value> Set this variable to generate a system dump when the specified exception occurs. The value that is supplied is the package description of the exception; for example, java/lang/InternalError . A Signal 11 is followed by a JVMXE message and then the VM ends. JAVA_PLUGIN_TRACE=TRUE When this variable is set to TRUE or 1, a Java plug-in trace is produced for the session when an application runs. Traces are produced from both the Java and Native layer. By default, this variable is set to FALSE , so that a Java plug-in trace is not produced. Notes: C code fragment to discover %uid for JAVA_DUMP_TDUMP_PATTERN=<string> : pwd = getpwuid(getuid()); pwd->pw_name; Deprecated JIT options The following table describes deprecated environment variables for the JIT compiler: Environment Variable Usage Information IBM_MIXED_MODE_THRESHOLD Use -Xjit:count=<value> instead of this variable. JAVA_COMPILER Use -Djava.compiler=<value> instead of this variable.","title":"Environment variables"},{"location":"env_var/#environment-variables","text":"Although the Eclipse OpenJ9\u2122 virtual machine (VM) recognizes many environment variables, most are superseded by command-line arguments. Use command-line arguments rather than environment variables, which are retained only for compatibility. Note: Environment variables are overridden by command-line arguments.","title":"Environment variables"},{"location":"env_var/#finding-and-setting-environment-variables","text":"To show the current environment, run: set (Windows\u2122) env (AIX\u00ae, Linux\u00ae, and macOS\u00ae) set (z/OS\u00ae) To show a particular environment variable, run: echo %ENVNAME% (Windows) echo $ENVNAME (AIX, Linux, macOS, and z/OS) Use values exactly as shown in the documentation. The names of environment variables are case-sensitive in AIX, Linux, macOS, and z/OS. To set the environment variable LOGIN_NAME to Fred , run: set LOGIN_NAME=Fred (Windows) export LOGIN_NAME=Fred (AIX/Linux/macOS: ksh or bash shells) setenv LOGIN_NAME Fred (csh shells) These variables are set only for the current shell or command-line session. If you are setting multiple values for an environment variable in a list: On AIX, Linux, macOS, and z/OS the separator is typically a colon (:). On Windows the separator is typically a semicolon (;).","title":"Finding and setting environment variables"},{"location":"env_var/#general-options","text":"General VM environment variables are shown in the following table: Environment variable Usage information OPENJ9_JAVA_COMMAND_LINE This variable is set by the VM after it starts. Using this variable, you can find the command-line parameters set when the VM started. See -XX:[+|-]OpenJ9CommandLineEnv for more information. OPENJ9_JAVA_OPTIONS=<option> Set this variable to store default Java options, including -X , -D , or -verbose:gc style options. For example, -Xms256m -Djava.compiler . Any options set are overridden by equivalent options that are specified when Java is started. This variable does not support certain options, see the list in -Xoptionsfile . If you specify the name of a trace output file either directly, or indirectly, by using a properties file, the output file might be accidentally overwritten if you run utilities such as the trace formatter, dump extractor, or dump viewer. To avoid this problem, add %d, %p or %t to the trace file names. See -Xtrace:output . Note: The equivalent to OPENJ9_JAVA_OPTIONS , IBM_JAVA_OPTIONS is deprecated and will be removed in a future release. JAVA_FONTS=<list of directories> Set this environment variable to specify the font directory. Setting this variable is equivalent to setting the property java.awt.fonts on Windows operating systems, and sun.java2d.fontpath on other operating systems. _JAVA_OPTIONS=<option> Set this variable to add Java options to the end of the command line. Supported options and trace file issues are the same as for OPENJ9_JAVA_OPTIONS .","title":"General options"},{"location":"env_var/#dump-agent-options","text":"The preferred mechanism for controlling the production of dumps is by using the -Xdump option. However, these legacy environment variables are preserved and can still be used. The following table describes dump agent options: Environment Variable Usage Information JAVA_DUMP_OPTS Used to control the conditions under which dumps are produced. If you set agents for a condition by using the JAVA_DUMP_OPTS environment variable, default dump agents for that condition are disabled; however, any -Xdump options that are specified on the command line are used. The JAVA_DUMP_OPTS environment variable uses the following syntax: JAVA_DUMP_OPTS=\"ON<condition>(<agent>[<count>],<agent>[<count>]), ON<condition>(<agent>[<count>],...),...)\" Where: <condition> is one of the following values: ANYSIGNAL DUMP ERROR INTERRUPT EXCEPTION OUTOFMEMORY <agent> is one of the following values: ALL NONE JAVADUMP SYSDUMP HEAPDUMP CEEDUMP (z/OS specific) <count> is the number of times to run the specified agent for the specified condition. This value is optional. By default, the agent runs every time that the condition occurs. JAVA_DUMP_OPTS is parsed by taking the leftmost occurrence of each condition, so duplicates are ignored. The following setting produces a system dump for the first error condition only: ONERROR(SYSDUMP[1]),ONERROR(JAVADUMP) Also, the ONANYSIGNAL condition is parsed before all others, so ONINTERRUPT(NONE),ONANYSIGNAL(SYSDUMP) has the same effect as ONANYSIGNAL(SYSDUMP),ONINTERRUPT(NONE) If the JAVA_DUMP_TOOL environment variable is set, that variable is assumed to specify a valid executable name and is parsed for replaceable fields, such as %pid . If %pid is detected in the string, the string is replaced with the VM's own process ID. The tool that is specified by JAVA_DUMP_TOOL is run after any system dump or heap dump is taken, before anything else. The dump settings are applied in the following order. Settings later in the list take precedence: Default VM dump behavior. -Xdump command-line options that specify -Xdump:<type>:defaults , see OpenJ9 default options . DISABLE_JAVADUMP , IBM_HEAPDUMP , and IBM_HEAP_DUMP environment variables. IBM_JAVADUMP_OUTOFMEMORY and IBM_HEAPDUMP_OUTOFMEMORY environment variables. JAVA_DUMP_OPTS environment variable. Remaining -Xdump command-line options. Setting JAVA_DUMP_OPTS affects only those conditions that you specify. Actions on other conditions are unchanged.","title":"Dump agent options"},{"location":"env_var/#signal-mapping","text":"When setting the JAVA_DUMP_OPTS environment variable, the mapping of operating system signals to the \"condition\" is shown in the following table: Condition z/OS Windows Linux, macOS, and AIX EXCEPTION SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGSYS, SIGXFSV SIGILL, SIGSEGV, SIGFPE SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGXFSV INTERRUPT SIGINT, SIGTERM, SIGHUP SIGINT, SIGTERM SIGINT, SIGTERM, SIGHUP ERROR SIGABRT SIGABRT SIGABRT DUMP SIGQUIT SIGBREAK SIGQUIT","title":"Signal mapping"},{"location":"env_var/#java-dump-options","text":"The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:java option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information DISABLE_JAVADUMP=[TRUE|FALSE] Setting DISABLE_JAVADUMP to TRUE is the equivalent of using -Xdump:java:none and stops the default production of Java dumps. IBM_JAVACOREDIR=<directory> The default location into which the Java dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_JAVADUMP_OUTOFMEMORY=[TRUE|FALSE] By setting this environment variable to FALSE , you disable Java dumps for an out-of-memory exception. When not set, a Java dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable Java dumps for an out-of-memory exception. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and Heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Java dumps are produced.","title":"Java dump options"},{"location":"env_var/#heap-dump-options","text":"The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:heap option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information IBM_HEAPDUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAP_DUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAPDUMPDIR=<directory> The default location into which the heap dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_HEAPDUMP_OUTOFMEMORY=[TRUE|FALSE] Controls the generation of a heap dump when an out-of-memory exception is thrown. When not set, a heap dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable heap dump for an out-of-memory exception. IBM_JAVA_HEAPDUMP_TEST Use this environment variable to cause the VM to generate both PHD and text versions of heap dumps. Equivalent to opts=PHD+CLASSIC on the -Xdump:heap option. IBM_JAVA_HEAPDUMP_TEXT Use this environment variable to cause the VM to generate a text (human readable) Heap dump. Equivalent to opts=CLASSIC on the -Xdump:heap option. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Heap dumps are produced.","title":"Heap dump options"},{"location":"env_var/#other-diagnostic-options","text":"The following table lists other environment variables that can be set for diagnostic purposes: Environment variable Usage Instructions IBM_COREDIR=<directory> Set this variable to specify an alternative location for system dumps, JIT dumps, and snap trace. On z/OS, _CEE_DMPTARG is used instead for snap trace, and transaction dumps are written to TSO according to JAVA_DUMP_TDUMP_PATTERN . On Linux and macOS, the dump is written to the directory that is specified directory by the operating system before being moved to the specified location. IBM_JAVA_ABEND_ON_FAILURE=Y (z/OS only) This setting tells the Java launcher to mark the Task Control Block (TCB) with an abend code if the OpenJ9 VM fails to load or is terminated by an uncaught exception. By default, the Java launcher does not mark the TCB. JAVA_DUMP_TDUMP_PATTERN=<string> (z/OS only) The specified <string> is passed to IEATDUMP to use as the data/set name for the Transaction Dump. The default <string> is %uid.JVM.TDUMP.%job.D%y%m%d.T%H%M%S (31-bit) or %uid.JVM.%job.D%y%m%d.T%H%M%S.X&amp;DS (64-bit), where %uid is found from the C code fragment shown in Notes . JAVA_THREAD_MODEL=<string> <string> can be defined as one of the following values: NATIVE (all threads are created as _MEDIUM_WEIGHT ), HEAVY (all threads are created as _HEAVY_WEIGHT ), MEDIUM (same as NATIVE ), or NULL . The default is NATIVE . IBM_XE_COE_NAME=<value> Set this variable to generate a system dump when the specified exception occurs. The value that is supplied is the package description of the exception; for example, java/lang/InternalError . A Signal 11 is followed by a JVMXE message and then the VM ends. JAVA_PLUGIN_TRACE=TRUE When this variable is set to TRUE or 1, a Java plug-in trace is produced for the session when an application runs. Traces are produced from both the Java and Native layer. By default, this variable is set to FALSE , so that a Java plug-in trace is not produced. Notes: C code fragment to discover %uid for JAVA_DUMP_TDUMP_PATTERN=<string> : pwd = getpwuid(getuid()); pwd->pw_name;","title":"Other diagnostic options"},{"location":"env_var/#deprecated-jit-options","text":"The following table describes deprecated environment variables for the JIT compiler: Environment Variable Usage Information IBM_MIXED_MODE_THRESHOLD Use -Xjit:count=<value> instead of this variable. JAVA_COMPILER Use -Djava.compiler=<value> instead of this variable.","title":"Deprecated JIT options"},{"location":"gc/","text":"Garbage collection policies Eclipse OpenJ9\u2122 provides several garbage collection (GC) policies that are designed around different application workloads and service level agreements. Each GC policy consists of a set of characteristics and features that aim to optimize one or more performance aspects of a running application. These performance aspects include application throughput, memory footprint, average pause times, worst-case pause times, and startup time. Different policies require a Java heap that is configured in different ways in order to achieve different goals. The simplest configuration consists of a single area of memory, often referred to as a flat heap. Other configurations divide the heap into different areas or regions, which might contain objects of different ages ( generations ) or sizes. A GC cycle is a repeatable process that involves a set of GC operations. These operations process all or parts of the Java heap to complete a discrete function and are discussed in more detail in GC operations . GC policies use different GC cycles to manage different aspects of the heap. For example, the gencon policy runs a partial GC cycle on the nursery area of the heap to complete a scavenge operation. At other times, gencon also runs a global GC cycle on the entire Java heap to complete mark and sweep (and optionally compact ) operations. GC cycles might be divided into increments that run over a period of time to reduce maximum pause times. These increments might involve stop-the-world (STW) pauses that must halt application threads to give certain GC operations exclusive access to the Java heap. Alternatively, increments might include GC operations that can run concurrently with application processing. The following table shows the heap configuration and the GC cycles and operations used by different policies: Policy Heap configuration GC cycles / operations gencon Two areas: nursery and tenure Two generation groups: new/older Global GC cycle: concurrent mark-sweep operations, optionally followed by a compact operation Partial GC cycle: STW scavenge operation or concurrent scavenge operation (if optionally enabled) balanced Multiple regions of equal size Multiple generations Global GC mark cycle: incremental concurrent mark operation ( global mark phase ) Partial GC cycle: STW copy forward operation and optional mark, sweep, or compact operations optavgpause One area: flat One generation Global GC cycle: concurrent mark-sweep operations, optionally followed by a compact operation optthruput One area: flat One generation Global GC cycle: STW mark-sweep operations, optionally followed by a compact operation metronome Multiple regions by size class One generation Global GC cycle: incremental STW mark-sweep operation in small interruptible steps nogc One area: flat No GC cycles Note: All OpenJ9 GC policies support compressed references on 64-bit platforms, which compresses heap pointers to 32 bits if the total heap size does not exceed the theoretical upper bound of 64 GB. Applications that require more heap space can select any heap size within the bounds imposed by the operating system and available system RAM, without using compressed references. For more information, see compressed references . Policy selection and tuning The default policy is the Generational Concurrent ( gencon ) GC policy, which suits a broad spectrum of applications. Choosing a different GC policy should be guided by the application dynamics and an observation of how the application interacts with the heap during startup and at steady state. To help with this analysis, all OpenJ9 GC policies are instrumented to collect a wide range of GC-related metric data for reporting in a GC log file . To enable GC logging for the OpenJ9 Java runtime, include the -verbose:gc option on the command line. By default, this option prints output to stderr but you can send the output to a log file by using -Xverbosegclog . You can then visualize the output by loading the GC log into the Garbage Collector and Memory Visualizer (GCMV) plugin for the Eclipse IDE. OpenJ9 Java GC logs can also be analyzed by some online services, such as GCEasy . The following sections provide more information about each policy and when you might choose it for your application. To select a GC policy other than gencon , specify the -Xgcpolicy option on the command line. To adjust the initial and maximum size of the Java heap, use the -Xms and -Xmx command line options. For generational GC policies, you can also set the -Xmn , -Xmns , and -Xmnx options. gencon policy (default) The Generational Concurrent GC policy ( -Xgcpolicy:gencon ) is probably best suited if you have a transactional application, with many short-lived objects. This policy aims to minimize GC pause times without compromising throughput. This is the default policy employed by the VM, so if you want to use it you don't need to specify it on the command line when you start your application. If your application requires the allocation of objects of very different sizes and liveness on the Java heap, you might experience heap fragmentation, which in turn might lead to global heap compaction. In these circumstances, the Balanced GC policy might be more appropriate. GC processing With the gencon policy, the Java heap is divided into two main areas, the nursery area, where new objects are created and the tenure area, where objects are moved if they have reached tenure age . The nursery area is subdivided into two further areas, the allocate space and the survivor space. A partial GC cycle that involves a GC scavenge operation is used to reclaim memory from the nursery area. This process is illustrated in the following diagram, which shows a sequence of four main events: Objects are created in the allocate space. The allocate space is full. A local GC scavenge process runs and reachable objects are either evacuated (copied) into the survivor space or into the tenure area if they have reached tenure age. Any objects that can't be reached are left untouched and subsequently cleared. The allocate and survivor spaces swap roles. The original survivor space becomes the allocate space where new objects are created, and the original allocate space becomes the survivor space ready for the next local GC scavenge process. The relative sizes of the allocate and survivor spaces are dynamically adjusted by a technique called tilting . When the nursery area is first created, it is evenly divided between the allocate and survivor spaces. If, after a GC scavenge operation runs, the amount of space required for the survivor area is comparatively small, the boundary between the two spaces is adjusted by tilting. For example, if the survivor space requires only 10% of the nursery area, the tilt ratio is adjusted to give 90% of the nursery area to the allocate space. With more space available for new objects, the frequency of scavenge cycles is reduced. The tenure age of an object is determined by the VM and reflects the number of times that an object has been copied between the allocate space and the survivor space. The age is in the range 1 - 14 and is adjusted dynamically by the VM depending on the object survival rate at particular ages. For example, if an object has a tenure age of 5 , it has been copied backwards and forwards between allocate and survivor spaces five times. If the VM sets a tenure age of 5 based on the percentage of space remaining in the nursery area, the next scavenge moves the object from the nursery to the tenure area. You can set an initial tenure age with the -Xgc:scvTenureAge option. You can also prevent the VM dynamically adjusting the tenure age by setting the Xgc:scvNoAdaptiveTenure option so that the initial age is maintained throughout the run time of the VM. Within the tenure area, new objects are allocated into the small object area (SOA), which is illustrated in the earlier diagram (see item 3). A large object area (LOA) is set aside for objects greater than 64 KB that cannot be allocated into the SOA to minimize fragmentation. The LOA is allocated by default but is reduced and removed after a few GC cycles if it isn't populated. To prevent the creation of an LOA, you can specify the -Xnoloa option on the command line when you start your application. When the tenure area is close to full a global GC cycle is triggered. The partial GC cycle (scavenge) reduces pause times by frequently reclaiming memory in the nursery area which, for a transactional application with many short-lived objects, has the most recyclable space. While most of the objects stay in the nursery area after the scavenge operation is complete, a small fraction are moved to the tenure area. Over time the tenure area might become full. So, whilst a partial GC cycle is operating on the nursery area, a concurrent global GC cycle also runs alongside normal program execution to mark and remove unreachable objects from the tenure area. These two GC approaches combine to provide a good trade-off between shorter pause times and consistent throughput. Concurrent Scavenge A special mode of the gencon policy is known as Concurrent Scavenge . This mode aims to further reduce the average time spent in STW pauses by collecting garbage from the nursery area in parallel with running application threads. Whilst aiming to reduce the average time, this mode does not improve the worst case pause time when compared to running gencon without Concurrent Scavenge enabled. To enable Concurrent Scavenge, see -Xgc:concurrentScavenge . This mode can be enabled with hardware-based support and software-based support: Hardware-based support: (Linux on IBM Z\u00ae and z/OS\u00ae) This mode works on the IBM z14\u2122 and later mainframe system with the Guarded Storage (GS) Facility. The GS Facility provides hardware-based support to detect when potentially stale references to objects are accessed by an application. This means that the garbage collector can start processing objects in parts of the heap without halting an application because the GS Facility is on hand to spot accesses to an object and send a notification. The object that was ready to be swept away can be moved, and references to it can be reset. Software-based support: (64-bit: Linux on (x86-64, POWER, IBM Z\u00ae), AIX\u00ae, macOS\u00ae, and z/OS\u00ae) With software-based support, Concurrent Scavenge can be enabled without any pre-requisite hardware although the performance throughput is not as good as hardware-based support. More information about Concurrent Scavenge mode can be found in the blog post Concurrent Scavenge Garbage Collection Policy . balanced policy (64-bit only) The Balanced GC policy ( -Xgcpolicy:balanced ) evens out pause times and reduces the overhead of some of the costlier operations that are typically associated with garbage collection, such as compaction and class unloading. The Java heap is divided into a large number of regions (1,000 - 2,000), which are managed individually by an incremental generational collector to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The aim of the policy is to avoid global garbage collections by matching object allocation and survival rates. When to use The Balanced policy suits applications that require large heaps (>64 MB) on 64-bit platforms. This policy might be a good alternative for applications that experience unacceptable pause times with gencon . If you have problems with application pause times that are caused by global garbage collections, particularly compactions, this policy might improve application performance. If you are using large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER\u2122 platforms only), the Balanced policy might further improve application throughput. However, even though pause times are typically evened out across GC operations, actual pause times are affected by object allocation rates, object survival rates, and fragmentation levels within the heap, and cannot therefore be bound to a certain maximum nor can a certain utilization level be guaranteed. GC processing During VM startup, the GC divides the heap memory into regions of equal size. These regions remain static for the lifetime of the VM and are the basic unit of garbage collection and allocation operations. For example, when the heap is expanded or contracted, the memory committed or released corresponds to a certain number of regions. Although the Java heap is a contiguous range of memory addresses, any region within that range can be committed or released from a pool as required. This enables the Balanced GC to contract the heap more dynamically and aggressively than other garbage collectors, which typically require the committed portion of the heap to be contiguous. Regions impose a maximum object size. Objects are always allocated within the bounds of a single region and are never permitted to span regions. The region size is always a power of two; for example, 512 KB, 1 MB, and so on (where KB is 2 10 bytes and MB is 2 20 bytes). The region size is selected at startup based on the maximum heap size. The collector chooses the smallest power of two which will result in less than 2048 regions, with a minimum region size of 512 KB. Except for small heaps (less than about 512 MB) the VM aims to have between 1024 and 2047 regions. Object ages are tracked for each region with a maximum of 24 possible generations. The following diagram illustrates the structure of the object heap: The eden space is a set of regions of age 0, which contain the newest objects allocated. The size of the eden space is determined by the number of regions that it contains. When the region count for the eden space reaches a predetermined threshold ( taxation threshold), a partial GC cycle runs to reduce the number of used regions, typically by using a copy forward operation. Empty regions can then be assigned to the eden space from the pool. In specific cases, mark and compact operations might be used, for example, when there are not enough free survivor regions available. The partial GC cycle is a STW operation that always includes the eden space, but might include older regions. Objects from collectible regions of age N are moved into another region of the same age N or to an empty region that is assigned an age of N. Then, the ages of all regions across the heap are incremented by 1, except for the maximum age 24 regions. Regions of age 24 are included in partial GC collection sets in order to defragment them. Partial GC cycles work to reclaim free regions in the heap for allocating new objects. Because some objects from eden regions always survive, a partial GC cycle can reclaim only about 90% of this memory. To keep up with object allocation, partial GC cycles also reclaim free regions by defragmenting older regions. For example, a partial GC cycle that moves objects from 5 fragmented older regions into 2 empty regions, reclaims 3 regions for new object allocation. However, over time the overall amount of fragmented memory decreases and records about object liveness in older regions become less accurate. Eventually, the work done by partial GC cycles to reclaim memory cannot keep pace with memory consumption. Free regions become so scarce that a global mark operation (GMP), which is triggered by another taxation threshold, is required to build a new record of object liveness across the heap. A sweep operation uses this record to measure the amount of free memory in fragmented older regions, which later partial GC cycles can act upon to move objects and reclaim free regions. A global sweep operation also runs to reclaim memory so that it can create empty regions. The global sweep operation, while logically associated with the global mark operation, runs in the same STW increment as the first partial GC cycle after the mark operation completes. Because the GC cycle responsible for the global mark operation runs concurrently, it might overlap and interleave with a few partial GC cycles. With the balanced policy, a global GC cycle is sometimes required in addition to the global mark operations and partial GC cycle. This global GC cycle is rare, occurring only in very tight memory conditions when other GC cycles cannot free enough memory on the heap. Most objects are easily contained within the minimum region size of 512 KB. However, to support large arrays, which cannot be contained in a region, the balanced GC policy uses an arraylet representation in the heap. For more information about structure and layout, see Arraylets . Note: With arraylets, JNI access to array data might involve reconstituting arraylets as contiguous arrays, which can significantly slow down processing. To learn about the default heap size and the tuning options that can be used with the balanced policy, see -Xgcpolicy:balanced . optavgpause policy The optimize for pause time policy ( -Xgcpolicy:optavgpause ) uses a global GC to manage a flat heap comprised of a single area and to compact the heap if the heap becomes fragmented. The global GC cycle starts preemptively so that the cycle finishes before the heap is exhausted. By anticipating global collections and initiating some mark operations ahead of collection, the optavgpause policy reduces GC pause times when compared to optthruput . However, the reduction in pause time comes at the expense of some performance throughput. When to use Consider using this policy if you have a large heap size (available on 64-bit platforms), because this policy limits the effect of increasing heap size on the length of the GC pause. Although optavgpause uses a write barrier to support concurrent mark operations, it does not use a generational write barrier. For some application workloads, such as those that frequently change large and old reference arrays, this strategy might be of greater benefit. However, in many situations, the default gencon policy offers better performance. By using a flat heap, optavgpause avoids potential issues with very large objects. With gencon , the heap is divided into areas (nursery and tenure) in order to manage generations of objects. Although there might be sufficient free space on the overall Java heap for a very large object, it might not fit into the nursery area. If the allocator does succeed in allocating a very large object, further GC cycles might be required to create enough contiguous free space. Overall, optavgpause , along with optthruput , is best suited to short-lived applications and to long-running services that involve concurrent sessions with short lifespans. Short-lived applications with adequate heap sizes usually complete without compaction. The flat heap fragments more slowly when session-bound objects are allocated and drop out of the live set in short overlapping clusters. GC processing The optavgpause policy requires a flat Java heap. A global GC cycle runs concurrent mark-sweep operations, optionally followed by compact operations. By running most operations concurrently with application threads, this strategy aims to reduce GC pause times as much as possible. optthruput policy The optimize for throughput policy ( -Xgcpolicy:optthruput ) uses a global GC cycle to manage a flat heap that is comprised of a single area and to compact the heap if the heap becomes fragmented. The global collector runs mark and sweep operations that are triggered by an allocation failure when the heap is exhausted. As a result, applications stop for long pauses while garbage collection takes place. When to use You might consider using this policy when a large heap application can tolerate longer GC pauses to obtain better overall throughput. Unlike gencon , the optthruput policy does not use object access barriers. In some workloads, the cost of these barriers might be high enough to make optthruput preferable. However, in many situations, the default gencon policy offers better performance. By using a flat heap, optthruput avoids potential issues with very large objects. With gencon , the heap is divided into areas (nursery and tenure) in order to manage generations of objects. Although there might be sufficient free space on the overall Java heap for a very large object, it might not fit into the nursery area. If the allocator does succeed in allocating a very large object, further GC cycles might be required to create enough contiguous free space. Overall, optthruput , along with optavgpause , is best suited to short-lived applications and to long-running services that involve concurrent sessions with short lifespans. Short-lived applications with adequate heap sizes usually complete without compaction. The flat heap fragments more slowly when session-bound objects are allocated and drop out of the live set in short overlapping clusters. GC processing The optthruput policy requires a flat Java heap. A global GC cycle runs mark-sweep operations, optionally followed by compact operations. The cycle requires exclusive access to the heap, causing application threads to halt while operations take place. As such, long pauses can occur. metronome policy (Linux on x86-64 and AIX platforms only) The metronome policy ( -Xgcpolicy:metronome ) is an incremental, deterministic garbage collector with short pause times. Applications that are dependent on precise response times can take advantage of this technology by avoiding potentially long delays from GC activity. When to use metronome is designed for applications that require a precise upper bound on collection pause times as well as specified application utilization: the proportion of time that the application is permitted to use, with the remainder being devoted to GC. The metronome GC runs in short interruptible bursts to avoid long STW pauses. GC processing The Java heap is allocated as a contiguous range of memory, partitioned into small regions of equal size (~64 KB). The metronome policy does not dynamically resize the heap; the heap is always fully expanded, even if -Xms is not set to -Xmx . Each region of the heap is either empty, or contains only objects in one of 16 size classes. The heap also supports Arraylets for dealing with large arrays. This organization improves the use of available heap space, reducing the need for heap compaction and defragmentation, and providing more precise control over the incremental sweep operation. Note: With arraylets, JNI access to array data might involve reconstituting arraylets as contiguous arrays, which can significantly slow down processing. Although high application utilization is desirable for optimal throughput, the GC must be able to keep up with the application's memory allocation rate. A higher utilization typically requires a larger heap because the GC isn't allowed to run as much as a lower utilization would permit. The relationship between utilization and heap size is highly application dependent, and striking an appropriate balance requires iterative experimentation with the application and VM parameters. You might need to adjust heap size or pause time or target utilization to achieve an acceptable runtime configuration. To learn about default options and tuning options that can be used with the metronome policy, see -Xgcpolicy:metronome . nogc policy -Xgcpolicy:nogc handles only memory allocation and heap expansion, but doesn't reclaim any memory. The GC impact on runtime performance is therefore minimized, but if the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops. When to use This policy is not suited to the majority of Java applications. However, the following use cases apply: Testing during development GC performance: Use nogc as a baseline when testing the performance of other GC policies, including the provision of a low-latency baseline. Application memory: Use nogc to test your settings for allocated memory. If you use -Xmx to set the heap size that should not be exceeded, your application terminates with a heap dump if it tries to exceed your memory limit. Running applications with minimal or no GC requirements You might use nogc when an application is so short-lived that allocated memory is never exhausted and running a full GC cycle is therefore a waste of resources. Similarly, when memory application is well understood or where there is rarely memory to be reclaimed, you might prefer to avoid unnecessary GC cycles and rely on a failover mechanism to occasionally restart the VM. Note: You should be especially careful when using any of the following techniques with nogc because memory is never released under this policy: Finalization Direct memory access Weak, soft, and phantom references Troubleshooting You can diagnose problems with garbage collection operations by turning on verbose GC logging. By default, the information is printed to STDERR but can be redirected to a file by specifying the -Xverbosegclog option. The log files contain detailed information about all operations, including initialization, STW processing, finalization, reference processing, and allocation failures. For more information, see Verbose GC logs . If verbose logs do not provide enough information to help you diagnose GC problems, you can use GC trace to analyze operations at a more granular level. For more information, see -Xtgc .","title":"GC policies"},{"location":"gc/#garbage-collection-policies","text":"Eclipse OpenJ9\u2122 provides several garbage collection (GC) policies that are designed around different application workloads and service level agreements. Each GC policy consists of a set of characteristics and features that aim to optimize one or more performance aspects of a running application. These performance aspects include application throughput, memory footprint, average pause times, worst-case pause times, and startup time. Different policies require a Java heap that is configured in different ways in order to achieve different goals. The simplest configuration consists of a single area of memory, often referred to as a flat heap. Other configurations divide the heap into different areas or regions, which might contain objects of different ages ( generations ) or sizes. A GC cycle is a repeatable process that involves a set of GC operations. These operations process all or parts of the Java heap to complete a discrete function and are discussed in more detail in GC operations . GC policies use different GC cycles to manage different aspects of the heap. For example, the gencon policy runs a partial GC cycle on the nursery area of the heap to complete a scavenge operation. At other times, gencon also runs a global GC cycle on the entire Java heap to complete mark and sweep (and optionally compact ) operations. GC cycles might be divided into increments that run over a period of time to reduce maximum pause times. These increments might involve stop-the-world (STW) pauses that must halt application threads to give certain GC operations exclusive access to the Java heap. Alternatively, increments might include GC operations that can run concurrently with application processing. The following table shows the heap configuration and the GC cycles and operations used by different policies: Policy Heap configuration GC cycles / operations gencon Two areas: nursery and tenure Two generation groups: new/older Global GC cycle: concurrent mark-sweep operations, optionally followed by a compact operation Partial GC cycle: STW scavenge operation or concurrent scavenge operation (if optionally enabled) balanced Multiple regions of equal size Multiple generations Global GC mark cycle: incremental concurrent mark operation ( global mark phase ) Partial GC cycle: STW copy forward operation and optional mark, sweep, or compact operations optavgpause One area: flat One generation Global GC cycle: concurrent mark-sweep operations, optionally followed by a compact operation optthruput One area: flat One generation Global GC cycle: STW mark-sweep operations, optionally followed by a compact operation metronome Multiple regions by size class One generation Global GC cycle: incremental STW mark-sweep operation in small interruptible steps nogc One area: flat No GC cycles Note: All OpenJ9 GC policies support compressed references on 64-bit platforms, which compresses heap pointers to 32 bits if the total heap size does not exceed the theoretical upper bound of 64 GB. Applications that require more heap space can select any heap size within the bounds imposed by the operating system and available system RAM, without using compressed references. For more information, see compressed references .","title":"Garbage collection policies"},{"location":"gc/#policy-selection-and-tuning","text":"The default policy is the Generational Concurrent ( gencon ) GC policy, which suits a broad spectrum of applications. Choosing a different GC policy should be guided by the application dynamics and an observation of how the application interacts with the heap during startup and at steady state. To help with this analysis, all OpenJ9 GC policies are instrumented to collect a wide range of GC-related metric data for reporting in a GC log file . To enable GC logging for the OpenJ9 Java runtime, include the -verbose:gc option on the command line. By default, this option prints output to stderr but you can send the output to a log file by using -Xverbosegclog . You can then visualize the output by loading the GC log into the Garbage Collector and Memory Visualizer (GCMV) plugin for the Eclipse IDE. OpenJ9 Java GC logs can also be analyzed by some online services, such as GCEasy . The following sections provide more information about each policy and when you might choose it for your application. To select a GC policy other than gencon , specify the -Xgcpolicy option on the command line. To adjust the initial and maximum size of the Java heap, use the -Xms and -Xmx command line options. For generational GC policies, you can also set the -Xmn , -Xmns , and -Xmnx options.","title":"Policy selection and tuning"},{"location":"gc/#gencon-policy-default","text":"The Generational Concurrent GC policy ( -Xgcpolicy:gencon ) is probably best suited if you have a transactional application, with many short-lived objects. This policy aims to minimize GC pause times without compromising throughput. This is the default policy employed by the VM, so if you want to use it you don't need to specify it on the command line when you start your application. If your application requires the allocation of objects of very different sizes and liveness on the Java heap, you might experience heap fragmentation, which in turn might lead to global heap compaction. In these circumstances, the Balanced GC policy might be more appropriate.","title":"gencon policy (default)"},{"location":"gc/#gc-processing","text":"With the gencon policy, the Java heap is divided into two main areas, the nursery area, where new objects are created and the tenure area, where objects are moved if they have reached tenure age . The nursery area is subdivided into two further areas, the allocate space and the survivor space. A partial GC cycle that involves a GC scavenge operation is used to reclaim memory from the nursery area. This process is illustrated in the following diagram, which shows a sequence of four main events: Objects are created in the allocate space. The allocate space is full. A local GC scavenge process runs and reachable objects are either evacuated (copied) into the survivor space or into the tenure area if they have reached tenure age. Any objects that can't be reached are left untouched and subsequently cleared. The allocate and survivor spaces swap roles. The original survivor space becomes the allocate space where new objects are created, and the original allocate space becomes the survivor space ready for the next local GC scavenge process. The relative sizes of the allocate and survivor spaces are dynamically adjusted by a technique called tilting . When the nursery area is first created, it is evenly divided between the allocate and survivor spaces. If, after a GC scavenge operation runs, the amount of space required for the survivor area is comparatively small, the boundary between the two spaces is adjusted by tilting. For example, if the survivor space requires only 10% of the nursery area, the tilt ratio is adjusted to give 90% of the nursery area to the allocate space. With more space available for new objects, the frequency of scavenge cycles is reduced. The tenure age of an object is determined by the VM and reflects the number of times that an object has been copied between the allocate space and the survivor space. The age is in the range 1 - 14 and is adjusted dynamically by the VM depending on the object survival rate at particular ages. For example, if an object has a tenure age of 5 , it has been copied backwards and forwards between allocate and survivor spaces five times. If the VM sets a tenure age of 5 based on the percentage of space remaining in the nursery area, the next scavenge moves the object from the nursery to the tenure area. You can set an initial tenure age with the -Xgc:scvTenureAge option. You can also prevent the VM dynamically adjusting the tenure age by setting the Xgc:scvNoAdaptiveTenure option so that the initial age is maintained throughout the run time of the VM. Within the tenure area, new objects are allocated into the small object area (SOA), which is illustrated in the earlier diagram (see item 3). A large object area (LOA) is set aside for objects greater than 64 KB that cannot be allocated into the SOA to minimize fragmentation. The LOA is allocated by default but is reduced and removed after a few GC cycles if it isn't populated. To prevent the creation of an LOA, you can specify the -Xnoloa option on the command line when you start your application. When the tenure area is close to full a global GC cycle is triggered. The partial GC cycle (scavenge) reduces pause times by frequently reclaiming memory in the nursery area which, for a transactional application with many short-lived objects, has the most recyclable space. While most of the objects stay in the nursery area after the scavenge operation is complete, a small fraction are moved to the tenure area. Over time the tenure area might become full. So, whilst a partial GC cycle is operating on the nursery area, a concurrent global GC cycle also runs alongside normal program execution to mark and remove unreachable objects from the tenure area. These two GC approaches combine to provide a good trade-off between shorter pause times and consistent throughput.","title":"GC processing"},{"location":"gc/#concurrent-scavenge","text":"A special mode of the gencon policy is known as Concurrent Scavenge . This mode aims to further reduce the average time spent in STW pauses by collecting garbage from the nursery area in parallel with running application threads. Whilst aiming to reduce the average time, this mode does not improve the worst case pause time when compared to running gencon without Concurrent Scavenge enabled. To enable Concurrent Scavenge, see -Xgc:concurrentScavenge . This mode can be enabled with hardware-based support and software-based support: Hardware-based support: (Linux on IBM Z\u00ae and z/OS\u00ae) This mode works on the IBM z14\u2122 and later mainframe system with the Guarded Storage (GS) Facility. The GS Facility provides hardware-based support to detect when potentially stale references to objects are accessed by an application. This means that the garbage collector can start processing objects in parts of the heap without halting an application because the GS Facility is on hand to spot accesses to an object and send a notification. The object that was ready to be swept away can be moved, and references to it can be reset. Software-based support: (64-bit: Linux on (x86-64, POWER, IBM Z\u00ae), AIX\u00ae, macOS\u00ae, and z/OS\u00ae) With software-based support, Concurrent Scavenge can be enabled without any pre-requisite hardware although the performance throughput is not as good as hardware-based support. More information about Concurrent Scavenge mode can be found in the blog post Concurrent Scavenge Garbage Collection Policy .","title":"Concurrent Scavenge"},{"location":"gc/#balanced-policy","text":"(64-bit only) The Balanced GC policy ( -Xgcpolicy:balanced ) evens out pause times and reduces the overhead of some of the costlier operations that are typically associated with garbage collection, such as compaction and class unloading. The Java heap is divided into a large number of regions (1,000 - 2,000), which are managed individually by an incremental generational collector to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The aim of the policy is to avoid global garbage collections by matching object allocation and survival rates.","title":"balanced policy"},{"location":"gc/#when-to-use","text":"The Balanced policy suits applications that require large heaps (>64 MB) on 64-bit platforms. This policy might be a good alternative for applications that experience unacceptable pause times with gencon . If you have problems with application pause times that are caused by global garbage collections, particularly compactions, this policy might improve application performance. If you are using large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER\u2122 platforms only), the Balanced policy might further improve application throughput. However, even though pause times are typically evened out across GC operations, actual pause times are affected by object allocation rates, object survival rates, and fragmentation levels within the heap, and cannot therefore be bound to a certain maximum nor can a certain utilization level be guaranteed.","title":"When to use"},{"location":"gc/#gc-processing_1","text":"During VM startup, the GC divides the heap memory into regions of equal size. These regions remain static for the lifetime of the VM and are the basic unit of garbage collection and allocation operations. For example, when the heap is expanded or contracted, the memory committed or released corresponds to a certain number of regions. Although the Java heap is a contiguous range of memory addresses, any region within that range can be committed or released from a pool as required. This enables the Balanced GC to contract the heap more dynamically and aggressively than other garbage collectors, which typically require the committed portion of the heap to be contiguous. Regions impose a maximum object size. Objects are always allocated within the bounds of a single region and are never permitted to span regions. The region size is always a power of two; for example, 512 KB, 1 MB, and so on (where KB is 2 10 bytes and MB is 2 20 bytes). The region size is selected at startup based on the maximum heap size. The collector chooses the smallest power of two which will result in less than 2048 regions, with a minimum region size of 512 KB. Except for small heaps (less than about 512 MB) the VM aims to have between 1024 and 2047 regions. Object ages are tracked for each region with a maximum of 24 possible generations. The following diagram illustrates the structure of the object heap: The eden space is a set of regions of age 0, which contain the newest objects allocated. The size of the eden space is determined by the number of regions that it contains. When the region count for the eden space reaches a predetermined threshold ( taxation threshold), a partial GC cycle runs to reduce the number of used regions, typically by using a copy forward operation. Empty regions can then be assigned to the eden space from the pool. In specific cases, mark and compact operations might be used, for example, when there are not enough free survivor regions available. The partial GC cycle is a STW operation that always includes the eden space, but might include older regions. Objects from collectible regions of age N are moved into another region of the same age N or to an empty region that is assigned an age of N. Then, the ages of all regions across the heap are incremented by 1, except for the maximum age 24 regions. Regions of age 24 are included in partial GC collection sets in order to defragment them. Partial GC cycles work to reclaim free regions in the heap for allocating new objects. Because some objects from eden regions always survive, a partial GC cycle can reclaim only about 90% of this memory. To keep up with object allocation, partial GC cycles also reclaim free regions by defragmenting older regions. For example, a partial GC cycle that moves objects from 5 fragmented older regions into 2 empty regions, reclaims 3 regions for new object allocation. However, over time the overall amount of fragmented memory decreases and records about object liveness in older regions become less accurate. Eventually, the work done by partial GC cycles to reclaim memory cannot keep pace with memory consumption. Free regions become so scarce that a global mark operation (GMP), which is triggered by another taxation threshold, is required to build a new record of object liveness across the heap. A sweep operation uses this record to measure the amount of free memory in fragmented older regions, which later partial GC cycles can act upon to move objects and reclaim free regions. A global sweep operation also runs to reclaim memory so that it can create empty regions. The global sweep operation, while logically associated with the global mark operation, runs in the same STW increment as the first partial GC cycle after the mark operation completes. Because the GC cycle responsible for the global mark operation runs concurrently, it might overlap and interleave with a few partial GC cycles. With the balanced policy, a global GC cycle is sometimes required in addition to the global mark operations and partial GC cycle. This global GC cycle is rare, occurring only in very tight memory conditions when other GC cycles cannot free enough memory on the heap. Most objects are easily contained within the minimum region size of 512 KB. However, to support large arrays, which cannot be contained in a region, the balanced GC policy uses an arraylet representation in the heap. For more information about structure and layout, see Arraylets . Note: With arraylets, JNI access to array data might involve reconstituting arraylets as contiguous arrays, which can significantly slow down processing. To learn about the default heap size and the tuning options that can be used with the balanced policy, see -Xgcpolicy:balanced .","title":"GC processing"},{"location":"gc/#optavgpause-policy","text":"The optimize for pause time policy ( -Xgcpolicy:optavgpause ) uses a global GC to manage a flat heap comprised of a single area and to compact the heap if the heap becomes fragmented. The global GC cycle starts preemptively so that the cycle finishes before the heap is exhausted. By anticipating global collections and initiating some mark operations ahead of collection, the optavgpause policy reduces GC pause times when compared to optthruput . However, the reduction in pause time comes at the expense of some performance throughput.","title":"optavgpause policy"},{"location":"gc/#when-to-use_1","text":"Consider using this policy if you have a large heap size (available on 64-bit platforms), because this policy limits the effect of increasing heap size on the length of the GC pause. Although optavgpause uses a write barrier to support concurrent mark operations, it does not use a generational write barrier. For some application workloads, such as those that frequently change large and old reference arrays, this strategy might be of greater benefit. However, in many situations, the default gencon policy offers better performance. By using a flat heap, optavgpause avoids potential issues with very large objects. With gencon , the heap is divided into areas (nursery and tenure) in order to manage generations of objects. Although there might be sufficient free space on the overall Java heap for a very large object, it might not fit into the nursery area. If the allocator does succeed in allocating a very large object, further GC cycles might be required to create enough contiguous free space. Overall, optavgpause , along with optthruput , is best suited to short-lived applications and to long-running services that involve concurrent sessions with short lifespans. Short-lived applications with adequate heap sizes usually complete without compaction. The flat heap fragments more slowly when session-bound objects are allocated and drop out of the live set in short overlapping clusters.","title":"When to use"},{"location":"gc/#gc-processing_2","text":"The optavgpause policy requires a flat Java heap. A global GC cycle runs concurrent mark-sweep operations, optionally followed by compact operations. By running most operations concurrently with application threads, this strategy aims to reduce GC pause times as much as possible.","title":"GC processing"},{"location":"gc/#optthruput-policy","text":"The optimize for throughput policy ( -Xgcpolicy:optthruput ) uses a global GC cycle to manage a flat heap that is comprised of a single area and to compact the heap if the heap becomes fragmented. The global collector runs mark and sweep operations that are triggered by an allocation failure when the heap is exhausted. As a result, applications stop for long pauses while garbage collection takes place.","title":"optthruput policy"},{"location":"gc/#when-to-use_2","text":"You might consider using this policy when a large heap application can tolerate longer GC pauses to obtain better overall throughput. Unlike gencon , the optthruput policy does not use object access barriers. In some workloads, the cost of these barriers might be high enough to make optthruput preferable. However, in many situations, the default gencon policy offers better performance. By using a flat heap, optthruput avoids potential issues with very large objects. With gencon , the heap is divided into areas (nursery and tenure) in order to manage generations of objects. Although there might be sufficient free space on the overall Java heap for a very large object, it might not fit into the nursery area. If the allocator does succeed in allocating a very large object, further GC cycles might be required to create enough contiguous free space. Overall, optthruput , along with optavgpause , is best suited to short-lived applications and to long-running services that involve concurrent sessions with short lifespans. Short-lived applications with adequate heap sizes usually complete without compaction. The flat heap fragments more slowly when session-bound objects are allocated and drop out of the live set in short overlapping clusters.","title":"When to use"},{"location":"gc/#gc-processing_3","text":"The optthruput policy requires a flat Java heap. A global GC cycle runs mark-sweep operations, optionally followed by compact operations. The cycle requires exclusive access to the heap, causing application threads to halt while operations take place. As such, long pauses can occur.","title":"GC processing"},{"location":"gc/#metronome-policy","text":"(Linux on x86-64 and AIX platforms only) The metronome policy ( -Xgcpolicy:metronome ) is an incremental, deterministic garbage collector with short pause times. Applications that are dependent on precise response times can take advantage of this technology by avoiding potentially long delays from GC activity.","title":"metronome policy"},{"location":"gc/#when-to-use_3","text":"metronome is designed for applications that require a precise upper bound on collection pause times as well as specified application utilization: the proportion of time that the application is permitted to use, with the remainder being devoted to GC. The metronome GC runs in short interruptible bursts to avoid long STW pauses.","title":"When to use"},{"location":"gc/#gc-processing_4","text":"The Java heap is allocated as a contiguous range of memory, partitioned into small regions of equal size (~64 KB). The metronome policy does not dynamically resize the heap; the heap is always fully expanded, even if -Xms is not set to -Xmx . Each region of the heap is either empty, or contains only objects in one of 16 size classes. The heap also supports Arraylets for dealing with large arrays. This organization improves the use of available heap space, reducing the need for heap compaction and defragmentation, and providing more precise control over the incremental sweep operation. Note: With arraylets, JNI access to array data might involve reconstituting arraylets as contiguous arrays, which can significantly slow down processing. Although high application utilization is desirable for optimal throughput, the GC must be able to keep up with the application's memory allocation rate. A higher utilization typically requires a larger heap because the GC isn't allowed to run as much as a lower utilization would permit. The relationship between utilization and heap size is highly application dependent, and striking an appropriate balance requires iterative experimentation with the application and VM parameters. You might need to adjust heap size or pause time or target utilization to achieve an acceptable runtime configuration. To learn about default options and tuning options that can be used with the metronome policy, see -Xgcpolicy:metronome .","title":"GC processing"},{"location":"gc/#nogc-policy","text":"-Xgcpolicy:nogc handles only memory allocation and heap expansion, but doesn't reclaim any memory. The GC impact on runtime performance is therefore minimized, but if the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops.","title":"nogc policy"},{"location":"gc/#when-to-use_4","text":"This policy is not suited to the majority of Java applications. However, the following use cases apply: Testing during development GC performance: Use nogc as a baseline when testing the performance of other GC policies, including the provision of a low-latency baseline. Application memory: Use nogc to test your settings for allocated memory. If you use -Xmx to set the heap size that should not be exceeded, your application terminates with a heap dump if it tries to exceed your memory limit. Running applications with minimal or no GC requirements You might use nogc when an application is so short-lived that allocated memory is never exhausted and running a full GC cycle is therefore a waste of resources. Similarly, when memory application is well understood or where there is rarely memory to be reclaimed, you might prefer to avoid unnecessary GC cycles and rely on a failover mechanism to occasionally restart the VM. Note: You should be especially careful when using any of the following techniques with nogc because memory is never released under this policy: Finalization Direct memory access Weak, soft, and phantom references","title":"When to use"},{"location":"gc/#troubleshooting","text":"You can diagnose problems with garbage collection operations by turning on verbose GC logging. By default, the information is printed to STDERR but can be redirected to a file by specifying the -Xverbosegclog option. The log files contain detailed information about all operations, including initialization, STW processing, finalization, reference processing, and allocation failures. For more information, see Verbose GC logs . If verbose logs do not provide enough information to help you diagnose GC problems, you can use GC trace to analyze operations at a more granular level. For more information, see -Xtgc .","title":"Troubleshooting"},{"location":"gc_overview/","text":"Garbage collection To prevent applications running out of memory, objects in the Java heap that are no longer required must be reclaimed. This process is known as garbage collection (GC). When garbage is collected, the garbage collector must obtain exclusive access to the heap, which causes an application to pause while the cleanup is done. This pause is often referred to as a stop-the-world (STW) pause because an application must halt until the process completes. In general, the first step in the GC process is to mark the objects that are reachable, which means they are still in use. The next step is to sweep away the unmarked objects to reclaim memory. The final step is to compact the heap if the heap is badly fragmented. A GC cycle is a repeatable process that involves a set of GC operations. These operations process all or parts of the Java heap. When operating on the whole of the Java heap, the cycle is referred to as a global GC cycle ; When operating on part of the heap, the cycle is referred to as a partial GC cycle . A global GC cycle can be triggered explicitly or implicitly according to the following rules: A global GC cycle is triggered implicitly if it occurs because of internal mechanisms, such as an allocation failure or a taxation threshold being reached. A global GC cycle is triggered explicitly if it is started directly by an application calling System.gc() or indirectly, for example when requesting a heap dump. Partial GC cycles are triggered only implicitly under the control of a particular GC policy. For more information about the GC policies available with Eclipse OpenJ9\u2122, see Garbage collection policies . The GC process is designed to operate without intervention from an application. Developers should not attempt to predict GC behavior, for example, by making calls to System.gc() to trigger a cycle or by using finalizers to clean up objects in memory. Such actions might degrade the performance of an application. GC operations GC operations run discrete functions on the Java heap. For example, a mark operation traces all objects in the heap to determine which ones are reachable. A sweep operation runs to clear away unreachable objects. Together, a mark and sweep operation are capable of reclaiming used memory as part of a GC cycle. Not all GC cycles include operations to reclaim memory. For example, the balanced GC policy involves a global cycle that includes only a mark operation; reclaiming the memory with a sweep operation occurs as part of a separate partial GC cycle that evacuates younger regions and defragments older regions. A GC operation might complete in one step, or it might involve multiple steps. For example, a mark operation consists of three steps, as described in the following section. GC mark operation A mark operation identifies which objects on the Java heap are reachable from outside of the heap and which objects are unreachable. Reachable objects are in use and must be retained, whereas unreachable objects are not in use and can be cleared away as garbage. The process of marking involves a bit array called a mark map that is allocated by the VM at startup, based on the maximum heap size setting. Each bit in the mark map corresponds to 8 bytes of heap space. When an object is marked , its location in the heap is recorded by setting the appropriate bit in the mark map. A mark operation can be broken down into the following steps: Initial A root object is an object that is accessible from outside of the heap such as a stack, class static field, or JNI reference. For other objects in the heap to be reachable, they must retain a connection from a root object. In the initial step, tracing identifies all root objects by running a root scan. Root objects are pushed onto a work stack for processing in the next step. Main The list of reachable root objects in the work stack is recursively traced for references to other objects in the heap. Objects that are not marked are new objects and these are added to the work stack. If an object is reachable, the appropriate bit is set in the mark map. Final The final step processes weakly reachable roots such as finalizable objects, weak references, monitor sets, and string sets. For more information about the processing of soft , weak , and phantom references, see Weak reference processing . In general, helper threads are used in parallel to speed up mark operations on the heap. The helper threads share the work stack with the application thread and are involved in identifying root objects, tracing objects in the heap, and updating the mark map. By default, the number of helper threads is based on the number of CPUs reported by the operating system. You can control the number of helper threads available by specifying the -Xgcthreads command line option when starting your application. In a verbose GC log, this operation is shown by the <gc-op type=\"mark\"> XML element. For more information, see Verbose GC logs . Concurrent mark processing A mark operation can run with exclusive access to the heap, which requires application threads to pause while processing takes place. Alternatively, it can run concurrently with application threads to avoid pauses in application processing. With concurrent mark, the process of root scanning is handed over to application stack threads, which populate the work stack with root objects in their stack. The root objects in the work stack are then traced by a background thread and by each application thread during a heap lock allocation to find reachable objects and update the mark map. Because the mark operation runs concurrently with application threads, any changes to objects that are already traced must be updated. This process works by using a write barrier that can flag the update and trigger a further scan of part of the heap. To track updates to objects, concurrent mark operations use single-byte cards in a card table . Each card corresponds to a 512-byte section of the Java heap. When an object is updated, the start address for the object in the heap is marked on the appropriate card. These cards are used to determine what must be retraced later in the GC cycle. A GC cycle that includes concurrent mark operations aims to trace all reachable objects and complete processing at the same time as the heap is exhausted. Continuous adjustments are made to the start time of each cycle to get as close to heap exhaustion as possible. When the heap is exhausted a sweep operation is able to reclaim memory. This operation requires a STW pause. Before sweep operations start, the root objects are rescanned and the cards are checked to determine which areas of memory must be retraced. An advantage of concurrent mark operations over STW mark operations is reduced pause times, because the garbage collector is able to identify garbage without halting application threads. Pause times are also more consistent because the collector is able to tune start times to maximize heap usage. Disadvantages of concurrent mark operations include the additional CPU for operating the write barrier and additional work for application threads to trace objects when requesting a heap lock. Concurrent mark operations are used by the gencon GC policy and the optavgpause GC policy . Incremental concurrent mark processing Incremental concurrent mark processing evens out pause times by avoiding global STW garbage collections. This type of marking is also known as the global mark phase , whereby mark operations take place incrementally across the entire heap. The global mark operations are interleaved with a partial GC cycle that is responsible for moving objects and clearing unreachable objects in the heap. These operations also use mark map in a card table to manage updates to objects that occur whilst mark operations are in progress. However, unlike the concurrent mark operations used by other policies, application threads are not involved in tracing objects; only background threads are used to trace objects and update the mark map. Incremental concurrent mark operations are used by the balanced GC policy . GC sweep operation The purpose of a sweep operation is to identify memory that can be reclaimed for object allocation and update a central record, known as the freelist . sweep operations occur in 2 steps: Initial This step analyzes the mark map for free memory. Final Based on the analysis, the sections of the heap are connected to the freelist. As with mark operations, multiple helper threads can be used to sweep the Java heap in parallel to speed up processing times. Because these helper threads are the same ones that are used for parallel mark operations, the number of threads can be controlled by using the -Xgcthreads option. Parallel sweep operations run on 256 KB sections of the heap. Each helper thread scans a section at a time. The results are stored and used to generate a freelist of empty regions. In a verbose GC log, this operation is shown by the <gc-op type=\"sweep\"> XML element. For more information, see Verbose GC logs . Concurrent sweep processing Concurrent sweep processing works in tandem with concurrent mark processing and uses the same mark map. Concurrent sweep operations start after a STW collection and complete a section of the heap before concurrent mark operations continue. Concurrent sweep is used by the optavgpause GC policy. GC scavenge operation A GC scavenge operation is triggered by an allocation failure in the nursery area of the heap. The operation occurs in the following 3 steps: Initial A root object is an object that is accessible from outside of the heap such as a stack, class static field, or JNI reference. For other objects in the heap to be reachable, they must retain a connection from a root object. In the initial step, tracing identifies all root objects by running a root scan. Root objects are pushed onto a work stack for processing in the next step. Main The list of reachable root objects in the work stack is recursively traced for references to other objects in the heap by using the hierarchical scan ordering mode ( -Xgc:hierarchicalScanOrdering ). If new objects are found, they are added to the work stack. If an object is reachable, it is copied from the allocate space to the survivor space in the nursery area or to the tenure area if the object has reached a particular age. Final The final step processes weakly reachable roots such as finalizable objects, weak references, monitor sets, and string sets. For more information about the processing of soft, weak, and phantom references, see Weak reference processing . In a verbose GC log, this operation is shown by the <gc-op type=\"scavenge\"> XML element. For more information, see Verbose GC logs . The scavenge operation is used by the gencon GC policy . GC copy forward operation A GC copy forward operation is similar to a scavenge operation but is triggered by a taxation threshold being reached. The operation occurs in the following 3 steps: Initial A root object is an object that is accessible from outside of the heap such as a stack, class static field, or JNI reference. For other objects in the heap to be reachable, they must retain a connection from a root object. In the initial step, tracing identifies all root objects by running a root scan. Root objects are pushed onto a work stack for processing in the next step. Main The list of reachable root objects in the work stack is recursively traced for references to other objects in the heap by using dynamic breadth first scan ordering mode ( -Xgc:dynamicBreadthFirstScanOrdering ). If new objects are found, they are added to the work stack. If an object is reachable, it is moved to another region of the same age or to an empty region of the same age in the heap. The age of all regions in the heap is then incremented by 1, except for the oldest region (age 24). Final The final step processes weakly reachable roots such as finalizable objects, weak references, monitor sets, and string sets. For more information about the processing of soft, weak, and phantom references, see Weak reference processing . The operation aims to empty or evacuate fragmented regions that can then be reclaimed for new object allocation. In a verbose GC log, this operation is shown by the <gc-op type=\"copy forward\"> XML element. For more information, see Verbose GC logs . The copy forward operation is used by the balanced GC policy . GC classunloading operation The classunloading operation is single threaded, not parallel threaded. In a verbose GC log, this operation is shown by the <gc-op type=\"classunload\"> XML element. For more information, see Verbose GC logs . GC compact operation Compaction of the heap is an expensive operation because when objects are moved to defragment the heap, the references to each object change. Therefore, compact operations do not occur by default but only when the following triggers occur: The -Xcompactgc option is specified on the command line. After sweeping the heap, there is not enough free space available to satisfy an allocation request. A System.gc() is requested and the last allocation failure that triggered a global GC cycle did not compact or -Xcompactexplicitgc is specified. At least half the previously available memory has been consumed by TLH allocations (ensuring an accurate sample) and the average TLH size falls to less than 1024 bytes. The largest object that the gencon GC policy failed to move to the tenure area in the most recent scavenge operation is bigger than the largest free slot in the tenure area. The heap is fully expanded and less than 4% of the tenure area is free. Less than 128 KB of the heap is free. The following two options can be used to control compaction: -Xcompactgc forces compaction of the heap. -Xnocompactgc avoids compaction of the heap as a result of all the triggers shown in the preceding list. However a compaction can still occur in rare circumstances. In a verbose GC log, this operation is shown by the <gc-op type=\"compact\"> XML element. For more information, see Verbose GC logs . Weak reference processing Weak reference processing includes soft references, weak references, and phantom references. These references are created by the user for specific use cases and allow some level of interaction with the garbage collector. For example, a soft reference to an object allows that object to persist in memory for a longer period of time before being cleared. For example, a software cache. The garbage collector handles the reference types in the order shown and with the behavior detailed in the following table: Reference type Class Garbage collector behavior soft java.lang.ref.SoftReference A soft reference is cleared only when its referent is not marked for a number of GC cycles or if space on the heap is likely to cause an out of memory error. Use the -Xsoftrefthreshold option to control the collection of soft reference objects. weak java.lang.ref.WeakReference A weak reference is cleared as soon as its referent is not marked by a GC cycle. phantom java.lang.ref.PhantomReference A phantom reference is cleared automatically as soon as its referent is not marked by a GC cycle. The cleared reference is then added to the associated reference queue at the same time or later. If your application uses the Java Native Interface (JNI) to interact with other application types, you can also create weak JNI object references. These references have a similar life cycle to a weak Java reference. The garbage collector processes weak JNI references after all other Java reference types.","title":"Garbage Collection (GC)"},{"location":"gc_overview/#garbage-collection","text":"To prevent applications running out of memory, objects in the Java heap that are no longer required must be reclaimed. This process is known as garbage collection (GC). When garbage is collected, the garbage collector must obtain exclusive access to the heap, which causes an application to pause while the cleanup is done. This pause is often referred to as a stop-the-world (STW) pause because an application must halt until the process completes. In general, the first step in the GC process is to mark the objects that are reachable, which means they are still in use. The next step is to sweep away the unmarked objects to reclaim memory. The final step is to compact the heap if the heap is badly fragmented. A GC cycle is a repeatable process that involves a set of GC operations. These operations process all or parts of the Java heap. When operating on the whole of the Java heap, the cycle is referred to as a global GC cycle ; When operating on part of the heap, the cycle is referred to as a partial GC cycle . A global GC cycle can be triggered explicitly or implicitly according to the following rules: A global GC cycle is triggered implicitly if it occurs because of internal mechanisms, such as an allocation failure or a taxation threshold being reached. A global GC cycle is triggered explicitly if it is started directly by an application calling System.gc() or indirectly, for example when requesting a heap dump. Partial GC cycles are triggered only implicitly under the control of a particular GC policy. For more information about the GC policies available with Eclipse OpenJ9\u2122, see Garbage collection policies . The GC process is designed to operate without intervention from an application. Developers should not attempt to predict GC behavior, for example, by making calls to System.gc() to trigger a cycle or by using finalizers to clean up objects in memory. Such actions might degrade the performance of an application.","title":"Garbage collection"},{"location":"gc_overview/#gc-operations","text":"GC operations run discrete functions on the Java heap. For example, a mark operation traces all objects in the heap to determine which ones are reachable. A sweep operation runs to clear away unreachable objects. Together, a mark and sweep operation are capable of reclaiming used memory as part of a GC cycle. Not all GC cycles include operations to reclaim memory. For example, the balanced GC policy involves a global cycle that includes only a mark operation; reclaiming the memory with a sweep operation occurs as part of a separate partial GC cycle that evacuates younger regions and defragments older regions. A GC operation might complete in one step, or it might involve multiple steps. For example, a mark operation consists of three steps, as described in the following section.","title":"GC operations"},{"location":"gc_overview/#gc-mark-operation","text":"A mark operation identifies which objects on the Java heap are reachable from outside of the heap and which objects are unreachable. Reachable objects are in use and must be retained, whereas unreachable objects are not in use and can be cleared away as garbage. The process of marking involves a bit array called a mark map that is allocated by the VM at startup, based on the maximum heap size setting. Each bit in the mark map corresponds to 8 bytes of heap space. When an object is marked , its location in the heap is recorded by setting the appropriate bit in the mark map. A mark operation can be broken down into the following steps: Initial A root object is an object that is accessible from outside of the heap such as a stack, class static field, or JNI reference. For other objects in the heap to be reachable, they must retain a connection from a root object. In the initial step, tracing identifies all root objects by running a root scan. Root objects are pushed onto a work stack for processing in the next step. Main The list of reachable root objects in the work stack is recursively traced for references to other objects in the heap. Objects that are not marked are new objects and these are added to the work stack. If an object is reachable, the appropriate bit is set in the mark map. Final The final step processes weakly reachable roots such as finalizable objects, weak references, monitor sets, and string sets. For more information about the processing of soft , weak , and phantom references, see Weak reference processing . In general, helper threads are used in parallel to speed up mark operations on the heap. The helper threads share the work stack with the application thread and are involved in identifying root objects, tracing objects in the heap, and updating the mark map. By default, the number of helper threads is based on the number of CPUs reported by the operating system. You can control the number of helper threads available by specifying the -Xgcthreads command line option when starting your application. In a verbose GC log, this operation is shown by the <gc-op type=\"mark\"> XML element. For more information, see Verbose GC logs .","title":"GC mark operation"},{"location":"gc_overview/#concurrent-mark-processing","text":"A mark operation can run with exclusive access to the heap, which requires application threads to pause while processing takes place. Alternatively, it can run concurrently with application threads to avoid pauses in application processing. With concurrent mark, the process of root scanning is handed over to application stack threads, which populate the work stack with root objects in their stack. The root objects in the work stack are then traced by a background thread and by each application thread during a heap lock allocation to find reachable objects and update the mark map. Because the mark operation runs concurrently with application threads, any changes to objects that are already traced must be updated. This process works by using a write barrier that can flag the update and trigger a further scan of part of the heap. To track updates to objects, concurrent mark operations use single-byte cards in a card table . Each card corresponds to a 512-byte section of the Java heap. When an object is updated, the start address for the object in the heap is marked on the appropriate card. These cards are used to determine what must be retraced later in the GC cycle. A GC cycle that includes concurrent mark operations aims to trace all reachable objects and complete processing at the same time as the heap is exhausted. Continuous adjustments are made to the start time of each cycle to get as close to heap exhaustion as possible. When the heap is exhausted a sweep operation is able to reclaim memory. This operation requires a STW pause. Before sweep operations start, the root objects are rescanned and the cards are checked to determine which areas of memory must be retraced. An advantage of concurrent mark operations over STW mark operations is reduced pause times, because the garbage collector is able to identify garbage without halting application threads. Pause times are also more consistent because the collector is able to tune start times to maximize heap usage. Disadvantages of concurrent mark operations include the additional CPU for operating the write barrier and additional work for application threads to trace objects when requesting a heap lock. Concurrent mark operations are used by the gencon GC policy and the optavgpause GC policy .","title":"Concurrent mark processing"},{"location":"gc_overview/#incremental-concurrent-mark-processing","text":"Incremental concurrent mark processing evens out pause times by avoiding global STW garbage collections. This type of marking is also known as the global mark phase , whereby mark operations take place incrementally across the entire heap. The global mark operations are interleaved with a partial GC cycle that is responsible for moving objects and clearing unreachable objects in the heap. These operations also use mark map in a card table to manage updates to objects that occur whilst mark operations are in progress. However, unlike the concurrent mark operations used by other policies, application threads are not involved in tracing objects; only background threads are used to trace objects and update the mark map. Incremental concurrent mark operations are used by the balanced GC policy .","title":"Incremental concurrent mark processing"},{"location":"gc_overview/#gc-sweep-operation","text":"The purpose of a sweep operation is to identify memory that can be reclaimed for object allocation and update a central record, known as the freelist . sweep operations occur in 2 steps: Initial This step analyzes the mark map for free memory. Final Based on the analysis, the sections of the heap are connected to the freelist. As with mark operations, multiple helper threads can be used to sweep the Java heap in parallel to speed up processing times. Because these helper threads are the same ones that are used for parallel mark operations, the number of threads can be controlled by using the -Xgcthreads option. Parallel sweep operations run on 256 KB sections of the heap. Each helper thread scans a section at a time. The results are stored and used to generate a freelist of empty regions. In a verbose GC log, this operation is shown by the <gc-op type=\"sweep\"> XML element. For more information, see Verbose GC logs .","title":"GC sweep operation"},{"location":"gc_overview/#concurrent-sweep-processing","text":"Concurrent sweep processing works in tandem with concurrent mark processing and uses the same mark map. Concurrent sweep operations start after a STW collection and complete a section of the heap before concurrent mark operations continue. Concurrent sweep is used by the optavgpause GC policy.","title":"Concurrent sweep processing"},{"location":"gc_overview/#gc-scavenge-operation","text":"A GC scavenge operation is triggered by an allocation failure in the nursery area of the heap. The operation occurs in the following 3 steps: Initial A root object is an object that is accessible from outside of the heap such as a stack, class static field, or JNI reference. For other objects in the heap to be reachable, they must retain a connection from a root object. In the initial step, tracing identifies all root objects by running a root scan. Root objects are pushed onto a work stack for processing in the next step. Main The list of reachable root objects in the work stack is recursively traced for references to other objects in the heap by using the hierarchical scan ordering mode ( -Xgc:hierarchicalScanOrdering ). If new objects are found, they are added to the work stack. If an object is reachable, it is copied from the allocate space to the survivor space in the nursery area or to the tenure area if the object has reached a particular age. Final The final step processes weakly reachable roots such as finalizable objects, weak references, monitor sets, and string sets. For more information about the processing of soft, weak, and phantom references, see Weak reference processing . In a verbose GC log, this operation is shown by the <gc-op type=\"scavenge\"> XML element. For more information, see Verbose GC logs . The scavenge operation is used by the gencon GC policy .","title":"GC scavenge operation"},{"location":"gc_overview/#gc-copy-forward-operation","text":"A GC copy forward operation is similar to a scavenge operation but is triggered by a taxation threshold being reached. The operation occurs in the following 3 steps: Initial A root object is an object that is accessible from outside of the heap such as a stack, class static field, or JNI reference. For other objects in the heap to be reachable, they must retain a connection from a root object. In the initial step, tracing identifies all root objects by running a root scan. Root objects are pushed onto a work stack for processing in the next step. Main The list of reachable root objects in the work stack is recursively traced for references to other objects in the heap by using dynamic breadth first scan ordering mode ( -Xgc:dynamicBreadthFirstScanOrdering ). If new objects are found, they are added to the work stack. If an object is reachable, it is moved to another region of the same age or to an empty region of the same age in the heap. The age of all regions in the heap is then incremented by 1, except for the oldest region (age 24). Final The final step processes weakly reachable roots such as finalizable objects, weak references, monitor sets, and string sets. For more information about the processing of soft, weak, and phantom references, see Weak reference processing . The operation aims to empty or evacuate fragmented regions that can then be reclaimed for new object allocation. In a verbose GC log, this operation is shown by the <gc-op type=\"copy forward\"> XML element. For more information, see Verbose GC logs . The copy forward operation is used by the balanced GC policy .","title":"GC copy forward operation"},{"location":"gc_overview/#gc-classunloading-operation","text":"The classunloading operation is single threaded, not parallel threaded. In a verbose GC log, this operation is shown by the <gc-op type=\"classunload\"> XML element. For more information, see Verbose GC logs .","title":"GC classunloading operation"},{"location":"gc_overview/#gc-compact-operation","text":"Compaction of the heap is an expensive operation because when objects are moved to defragment the heap, the references to each object change. Therefore, compact operations do not occur by default but only when the following triggers occur: The -Xcompactgc option is specified on the command line. After sweeping the heap, there is not enough free space available to satisfy an allocation request. A System.gc() is requested and the last allocation failure that triggered a global GC cycle did not compact or -Xcompactexplicitgc is specified. At least half the previously available memory has been consumed by TLH allocations (ensuring an accurate sample) and the average TLH size falls to less than 1024 bytes. The largest object that the gencon GC policy failed to move to the tenure area in the most recent scavenge operation is bigger than the largest free slot in the tenure area. The heap is fully expanded and less than 4% of the tenure area is free. Less than 128 KB of the heap is free. The following two options can be used to control compaction: -Xcompactgc forces compaction of the heap. -Xnocompactgc avoids compaction of the heap as a result of all the triggers shown in the preceding list. However a compaction can still occur in rare circumstances. In a verbose GC log, this operation is shown by the <gc-op type=\"compact\"> XML element. For more information, see Verbose GC logs .","title":"GC compact operation"},{"location":"gc_overview/#weak-reference-processing","text":"Weak reference processing includes soft references, weak references, and phantom references. These references are created by the user for specific use cases and allow some level of interaction with the garbage collector. For example, a soft reference to an object allows that object to persist in memory for a longer period of time before being cleared. For example, a software cache. The garbage collector handles the reference types in the order shown and with the behavior detailed in the following table: Reference type Class Garbage collector behavior soft java.lang.ref.SoftReference A soft reference is cleared only when its referent is not marked for a number of GC cycles or if space on the heap is likely to cause an out of memory error. Use the -Xsoftrefthreshold option to control the collection of soft reference objects. weak java.lang.ref.WeakReference A weak reference is cleared as soon as its referent is not marked by a GC cycle. phantom java.lang.ref.PhantomReference A phantom reference is cleared automatically as soon as its referent is not marked by a GC cycle. The cleared reference is then added to the associated reference queue at the same time or later. If your application uses the Java Native Interface (JNI) to interact with other application types, you can also create weak JNI object references. These references have a similar life cycle to a weak Java reference. The garbage collector processes weak JNI references after all other Java reference types.","title":"Weak reference processing"},{"location":"interface_dtfj/","text":"Diagnostic Tool Framework for Java The Diagnostic Tool Framework for Java\u2122 (DTFJ) is a Java application programming interface (API) that is used to support the building of Java diagnostic tools. DTFJ works with data from a system dump or a Java dump. On Linux and AIX\u00ae operating systems, you can get more information from a system dump if you also have copies of executable files and libraries. You can run the jpackcore utility to collect these files into a single archive for use in subsequent problem diagnosis. For more information, see Dump extractor . The DTFJ API helps diagnostic tools access the following information: Memory locations stored in the dump (System dumps only) Relationships between memory locations and Java internals (System dumps only) Java threads running in the VM Native threads held in the dump (System dumps only) Java classes and their class loaders that were present Java objects that were present in the heap (System dumps only) Java monitors and the objects and threads they are associated with Details of the workstation on which the dump was produced (System dumps only) Details of the Java version that was being used The command line that launched the VM If your DTFJ application requests information that is not available in the Java dump, the API will return null or throw a DataUnavailable exception. You might need to adapt DTFJ applications written to process system dumps to make them work with Java dumps. DTFJ is implemented in pure Java and tools written using DTFJ can be cross-platform. Therefore, you can analyze a dump taken from one workstation on another (remote and more convenient) machine. For example, a dump produced on an AIX\u00ae Power\u00ae system can be analyzed on a Windows laptop. See the DTFJ API documentation . Note: If the code that loads DTFJ is in a module, the module must require the openj9.dtfj module. For example: module MyModule { requires openj9.dtfj; } Using the DTFJ interface To create applications that use DTFJ, you must use the DTFJ interface. Implementations of this interface have been written that work with system dumps and Java dumps. The diagram that follows illustrates the DTFJ interface. The starting point for working with a dump is to obtain an Image instance by using the ImageFactory class supplied with the concrete implementation of the API. Working with a system dump The following example shows how to work with a system dump. In this example, the only section of code that ties the dump to a particular implementation of DTFJ is the generation of the factory class. Change the factory if you want to use a different implementation. If there is a problem with the file that is passed to the getImage() method, an IOException is thrown and an appropriate message is issued. If a missing file is passed to the example shown, the following output is produced: Could not find/use required file(s) java.io.FileNotFoundException: core_file.xml (The system cannot find the file specified.) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.<init>(FileInputStream.java:135) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:47) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:35) at DTFJEX1.main(DTFJEX1.java:23)Copy In this case, the DTFJ implementation is expecting a dump file to exist. Different errors are caught if the file existed but was not recognized as a valid dump file. Example of working with a system dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX1 { public static void main(String[] args) { Image image = null; if (args.length > 0) { File f = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.j9.ImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(f); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } } Working with a Java dump To work with a Java dump, change the factory class to com.ibm.dtfj.image.javacore.JCImageFactory and pass the Java dump file to the getImage() method. Example of working with a Java dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX2 { public static void main(String[] args) { Image image=null; if (args.length > 0) { File javacoreFile = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.javacore.JCImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(javacoreFile); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } } Analyze the dump After you have obtained an Image instance, you can begin analyzing the dump. The Image instance is the second instance in the class hierarchy for DTFJ illustrated by the following diagram: Some things to note from the diagram: The DTFJ interface is separated into two parts: classes with names that start with Image (the dump, a sequence of bytes with different contents on different platforms) and classes with names that start with Java (the Java internal knowledge). Image and Java classes are linked using a ManagedRuntime class (which is extended by JavaRuntime ). An Image object contains one ImageAddressSpace object (or, on z/OS\u00ae, possibly more). An ImageAddressSpace object contains one ImageProcess object (or, on z/OS, possibly more). Conceptually, you can apply the Image model to any program running with the ImageProcess . For the purposes of this document discussion is limited to the Eclipse OpenJ9\u2122 virtual machine implementations. There is a link from a JavaThread object to its corresponding ImageThread object. Use this link to find out about native code associated with a Java thread, for example JNI functions that have been called from Java. If a JavaThread was not running Java code when the dump was taken, the JavaThread object has no JavaStackFrame objects. In these cases, use the link to the corresponding ImageThread object to find out what native code was running in that thread. This situation is typically the case with the JIT compilation thread and Garbage Collection threads. The DTFJ interface enables you to obtain information about native memory. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . When the Java runtime allocates native memory, the memory is associated with a high-level memory category. For more information about native memory detailed in a Java dump, see Java dump: NATIVEMEMINFO DTFJ example application This example is a fully working DTFJ application. Many DTFJ applications will follow a similar model. Sample DTFJ application import java.io.File; import java.util.Iterator; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.CorruptDataException; import com.ibm.dtfj.image.DataUnavailable; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageAddressSpace; import com.ibm.dtfj.image.ImageFactory; import com.ibm.dtfj.image.ImageProcess; import com.ibm.dtfj.java.JavaRuntime; import com.ibm.dtfj.java.JavaThread; import com.ibm.dtfj.image.ImageThread; public class DTFJEX2 { public static void main( String[] args ) { Image image = null; if ( args.length > 0 ) { File f = new File( args[0] ); try { Class factoryClass = Class .forName( \"com.ibm.dtfj.image.j9.ImageFactory\" ); ImageFactory factory = (ImageFactory) factoryClass.newInstance( ); image = factory.getImage( f ); } catch ( Exception ex ) { /* * Should use the error handling as shown in DTFJEX1. */ System.err.println( \"Error in DTFJEX2\" ); ex.printStackTrace( System.err ); } } else { System.err.println( \"No filename specified\" ); } if ( null == image ) { return; } MatchingThreads( image ); } public static void MatchingThreads( Image image ) { ImageThread imgThread = null; Iterator asIt = image.getAddressSpaces( ); while ( asIt.hasNext( ) ) { System.out.println( \"Found ImageAddressSpace...\" ); ImageAddressSpace as = (ImageAddressSpace) asIt.next( ); Iterator prIt = as.getProcesses( ); while ( prIt.hasNext( ) ) { System.out.println( \"Found ImageProcess...\" ); ImageProcess process = (ImageProcess) prIt.next( ); Iterator runTimesIt = process.getRuntimes( ); while ( runTimesIt.hasNext( ) ) { System.out.println( \"Found Runtime...\" ); JavaRuntime javaRT = (JavaRuntime) runTimesIt.next( ); Iterator javaThreadIt = javaRT.getThreads( ); while ( javaThreadIt.hasNext( ) ) { Object tempObj = javaThreadIt.next( ); /* * Should use CorruptData handling for all iterators */ if ( tempObj instanceof CorruptData ) { System.out.println( \"We have some corrupt data\" ); } else { JavaThread javaThread = (JavaThread) tempObj; System.out.println( \"Found JavaThread...\" ); try { imgThread = (ImageThread) javaThread.getImageThread( ); // Now we have a Java thread we can iterator // through the image threads Iterator imgThreadIt = process.getThreads( ); while ( imgThreadIt.hasNext( ) ) { ImageThread imgThread2 = (ImageThread) imgThreadIt .next( ); if ( imgThread.equals( imgThread2 ) ) { System.out.println( \"Found a match:\" ); System.out.println( \"\\tjavaThread \" + javaThread.getName( ) + \" is the same as \" + imgThread2.getID( ) ); } } } catch ( CorruptDataException e ) { System.err.println( \"ImageThread was corrupt: \" + e.getMessage( ) ); } catch ( DataUnavailable e ) { System.out.println( \"DataUnavailable: \" + e.getMessage( ) ); } } } } } } } } For clarity, the example does not perform full error checking when constructing the main Image object and does not perform CorruptData handling in all of the iterators. In a production environment, you use the techniques illustrated in the previous examples under Working with a system dump and Working with a Java dump . In the example, the program iterates through every available Java thread and checks whether it is equal to any of the available image threads. When they are found to be equal, the program displays the following message: \"Found a match\". The example demonstrates: How to iterate down through the class hierarchy. How to handle CorruptData objects from the iterators. The use of the .equals method for testing equality between objects.","title":"DTFJ"},{"location":"interface_dtfj/#diagnostic-tool-framework-for-java","text":"The Diagnostic Tool Framework for Java\u2122 (DTFJ) is a Java application programming interface (API) that is used to support the building of Java diagnostic tools. DTFJ works with data from a system dump or a Java dump. On Linux and AIX\u00ae operating systems, you can get more information from a system dump if you also have copies of executable files and libraries. You can run the jpackcore utility to collect these files into a single archive for use in subsequent problem diagnosis. For more information, see Dump extractor . The DTFJ API helps diagnostic tools access the following information: Memory locations stored in the dump (System dumps only) Relationships between memory locations and Java internals (System dumps only) Java threads running in the VM Native threads held in the dump (System dumps only) Java classes and their class loaders that were present Java objects that were present in the heap (System dumps only) Java monitors and the objects and threads they are associated with Details of the workstation on which the dump was produced (System dumps only) Details of the Java version that was being used The command line that launched the VM If your DTFJ application requests information that is not available in the Java dump, the API will return null or throw a DataUnavailable exception. You might need to adapt DTFJ applications written to process system dumps to make them work with Java dumps. DTFJ is implemented in pure Java and tools written using DTFJ can be cross-platform. Therefore, you can analyze a dump taken from one workstation on another (remote and more convenient) machine. For example, a dump produced on an AIX\u00ae Power\u00ae system can be analyzed on a Windows laptop. See the DTFJ API documentation . Note: If the code that loads DTFJ is in a module, the module must require the openj9.dtfj module. For example: module MyModule { requires openj9.dtfj; }","title":"Diagnostic Tool Framework for Java"},{"location":"interface_dtfj/#using-the-dtfj-interface","text":"To create applications that use DTFJ, you must use the DTFJ interface. Implementations of this interface have been written that work with system dumps and Java dumps. The diagram that follows illustrates the DTFJ interface. The starting point for working with a dump is to obtain an Image instance by using the ImageFactory class supplied with the concrete implementation of the API.","title":"Using the DTFJ interface"},{"location":"interface_dtfj/#working-with-a-system-dump","text":"The following example shows how to work with a system dump. In this example, the only section of code that ties the dump to a particular implementation of DTFJ is the generation of the factory class. Change the factory if you want to use a different implementation. If there is a problem with the file that is passed to the getImage() method, an IOException is thrown and an appropriate message is issued. If a missing file is passed to the example shown, the following output is produced: Could not find/use required file(s) java.io.FileNotFoundException: core_file.xml (The system cannot find the file specified.) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.<init>(FileInputStream.java:135) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:47) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:35) at DTFJEX1.main(DTFJEX1.java:23)Copy In this case, the DTFJ implementation is expecting a dump file to exist. Different errors are caught if the file existed but was not recognized as a valid dump file. Example of working with a system dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX1 { public static void main(String[] args) { Image image = null; if (args.length > 0) { File f = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.j9.ImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(f); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } }","title":"Working with a system dump"},{"location":"interface_dtfj/#working-with-a-java-dump","text":"To work with a Java dump, change the factory class to com.ibm.dtfj.image.javacore.JCImageFactory and pass the Java dump file to the getImage() method. Example of working with a Java dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX2 { public static void main(String[] args) { Image image=null; if (args.length > 0) { File javacoreFile = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.javacore.JCImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(javacoreFile); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } }","title":"Working with a Java dump"},{"location":"interface_dtfj/#analyze-the-dump","text":"After you have obtained an Image instance, you can begin analyzing the dump. The Image instance is the second instance in the class hierarchy for DTFJ illustrated by the following diagram: Some things to note from the diagram: The DTFJ interface is separated into two parts: classes with names that start with Image (the dump, a sequence of bytes with different contents on different platforms) and classes with names that start with Java (the Java internal knowledge). Image and Java classes are linked using a ManagedRuntime class (which is extended by JavaRuntime ). An Image object contains one ImageAddressSpace object (or, on z/OS\u00ae, possibly more). An ImageAddressSpace object contains one ImageProcess object (or, on z/OS, possibly more). Conceptually, you can apply the Image model to any program running with the ImageProcess . For the purposes of this document discussion is limited to the Eclipse OpenJ9\u2122 virtual machine implementations. There is a link from a JavaThread object to its corresponding ImageThread object. Use this link to find out about native code associated with a Java thread, for example JNI functions that have been called from Java. If a JavaThread was not running Java code when the dump was taken, the JavaThread object has no JavaStackFrame objects. In these cases, use the link to the corresponding ImageThread object to find out what native code was running in that thread. This situation is typically the case with the JIT compilation thread and Garbage Collection threads. The DTFJ interface enables you to obtain information about native memory. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . When the Java runtime allocates native memory, the memory is associated with a high-level memory category. For more information about native memory detailed in a Java dump, see Java dump: NATIVEMEMINFO","title":"Analyze the dump"},{"location":"interface_dtfj/#dtfj-example-application","text":"This example is a fully working DTFJ application. Many DTFJ applications will follow a similar model. Sample DTFJ application import java.io.File; import java.util.Iterator; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.CorruptDataException; import com.ibm.dtfj.image.DataUnavailable; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageAddressSpace; import com.ibm.dtfj.image.ImageFactory; import com.ibm.dtfj.image.ImageProcess; import com.ibm.dtfj.java.JavaRuntime; import com.ibm.dtfj.java.JavaThread; import com.ibm.dtfj.image.ImageThread; public class DTFJEX2 { public static void main( String[] args ) { Image image = null; if ( args.length > 0 ) { File f = new File( args[0] ); try { Class factoryClass = Class .forName( \"com.ibm.dtfj.image.j9.ImageFactory\" ); ImageFactory factory = (ImageFactory) factoryClass.newInstance( ); image = factory.getImage( f ); } catch ( Exception ex ) { /* * Should use the error handling as shown in DTFJEX1. */ System.err.println( \"Error in DTFJEX2\" ); ex.printStackTrace( System.err ); } } else { System.err.println( \"No filename specified\" ); } if ( null == image ) { return; } MatchingThreads( image ); } public static void MatchingThreads( Image image ) { ImageThread imgThread = null; Iterator asIt = image.getAddressSpaces( ); while ( asIt.hasNext( ) ) { System.out.println( \"Found ImageAddressSpace...\" ); ImageAddressSpace as = (ImageAddressSpace) asIt.next( ); Iterator prIt = as.getProcesses( ); while ( prIt.hasNext( ) ) { System.out.println( \"Found ImageProcess...\" ); ImageProcess process = (ImageProcess) prIt.next( ); Iterator runTimesIt = process.getRuntimes( ); while ( runTimesIt.hasNext( ) ) { System.out.println( \"Found Runtime...\" ); JavaRuntime javaRT = (JavaRuntime) runTimesIt.next( ); Iterator javaThreadIt = javaRT.getThreads( ); while ( javaThreadIt.hasNext( ) ) { Object tempObj = javaThreadIt.next( ); /* * Should use CorruptData handling for all iterators */ if ( tempObj instanceof CorruptData ) { System.out.println( \"We have some corrupt data\" ); } else { JavaThread javaThread = (JavaThread) tempObj; System.out.println( \"Found JavaThread...\" ); try { imgThread = (ImageThread) javaThread.getImageThread( ); // Now we have a Java thread we can iterator // through the image threads Iterator imgThreadIt = process.getThreads( ); while ( imgThreadIt.hasNext( ) ) { ImageThread imgThread2 = (ImageThread) imgThreadIt .next( ); if ( imgThread.equals( imgThread2 ) ) { System.out.println( \"Found a match:\" ); System.out.println( \"\\tjavaThread \" + javaThread.getName( ) + \" is the same as \" + imgThread2.getID( ) ); } } } catch ( CorruptDataException e ) { System.err.println( \"ImageThread was corrupt: \" + e.getMessage( ) ); } catch ( DataUnavailable e ) { System.out.println( \"DataUnavailable: \" + e.getMessage( ) ); } } } } } } } } For clarity, the example does not perform full error checking when constructing the main Image object and does not perform CorruptData handling in all of the iterators. In a production environment, you use the techniques illustrated in the previous examples under Working with a system dump and Working with a Java dump . In the example, the program iterates through every available Java thread and checks whether it is equal to any of the available image threads. When they are found to be equal, the program displays the following message: \"Found a match\". The example demonstrates: How to iterate down through the class hierarchy. How to handle CorruptData objects from the iterators. The use of the .equals method for testing equality between objects.","title":"DTFJ example application"},{"location":"interface_jvmti/","text":"Java Virtual Machine Tool Interface The Java\u2122 Virtual Machine Tool Interface (JVMTI) is a two-way interface that allows communication between the VM and a native agent. It replaces both the Java Virtual Machine Debug Interface (JVMDI) and Java Virtual Machine Profiler Interface (JVMPI). Overview The JVMTI allows third parties to develop debugging, profiling, and monitoring tools for the VM. The interface contains mechanisms for the agent to notify the VM about the kinds of information it requires, and also provides a means of receiving relevant notifications. Several agents can be attached to a VM at any one time. JVMTI agents can be loaded at startup using short or long forms of the command-line option: -agentlib:<agent-lib-name>=<options> or -agentpath:<path-to-agent>=<options> In the example that follows (see Sample JVMTI agent ), the directory containing the jdwp library is assumed to be on the library path. If you require a specific library, such as jdwp , with your JVMTI agent, you can specify the path at startup, for example: -agentlib:jdwp=<options> For more information about JVMTI, see https://docs.oracle.com/javase/8/docs/technotes/guides/management/index.html . For a guide about writing a JVMTI agent, see http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html . Eclipse OpenJ9 extensions Eclipse OpenJ9\u2122 extensions to the JVMTI allow a JVMTI agent to query or automatically trigger operations in the VM, including the following tasks: Task OpenJ9 extensions Get the OS thread ID GetOSThreadID Query, set, and reset the VM dump options QueryVmDump , SetVmDump , ResetVmDump Trigger a VM dump, and monitor JVMTI event functions when VM dumps start and end TriggerVmDump , VMDumpStart , VMDumpEnd Set VM trace options SetVmTrace Subscribe to and unsubscribe from VM tracepoints RegisterTracePointSubscriber , DeregisterTracePointSubscriber Query runtime environment native memory categories GetMemoryCategories Query and set VM log options QueryVmLogOptions , SetVmLogOptions Search for and remove a shared classes cache IterateSharedCaches , DestroySharedCache Subscribe to and unsubscribe from verbose garbage collection (GC) data logging RegisterVerboseGCSubscriber , DeregisterVerboseGCSubscriber The definitions that you need when you write a JVMTI agent are provided in the header files jvmti.h and ibmjvmti.h , in the include directory. Sample JVMTI agent The following sample shows you how to write a simple JVMTI agent that uses OpenJ9 extensions to the JVMTI. Sample JVMTI agent written in C/C++, which uses the OpenJ9 extensions /* * tiSample.c * * Sample JVMTI agent to demonstrate the OpenJ9 JVMTI dump extensions */ #include \"jvmti.h\" #include \"ibmjvmti.h\" /* Forward declarations for JVMTI callback functions */ void JNICALL VMInitCallback(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread); void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...); /* * Agent_Onload() * * JVMTI agent initialisation function, invoked as agent is loaded by the VM */ JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) { jvmtiEnv *jvmti = NULL; jvmtiError rc; jint extensionEventCount = 0; jvmtiExtensionEventInfo *extensionEvents = NULL; jint extensionFunctionCount = 0; jvmtiExtensionFunctionInfo *extensionFunctions = NULL; int i = 0, j = 0; printf(\"tiSample: Loading JVMTI sample agent\\n\"); /* Get access to JVMTI */ (*jvm)->GetEnv(jvm, (void **)&jvmti, JVMTI_VERSION_1_0); /* Look up all the JVMTI extension events and functions */ (*jvmti)->GetExtensionEvents(jvmti, &extensionEventCount, &extensionEvents); (*jvmti)->GetExtensionFunctions(jvmti, &extensionFunctionCount, &extensionFunctions); printf(\"tiSample: Found %i JVMTI extension events, %i extension functions\\n\", extensionEventCount, extensionFunctionCount); /* Find the JVMTI extension event we want */ while (i++ < extensionEventCount) { if (strcmp(extensionEvents->id, COM_IBM_VM_DUMP_START) == 0) { /* Found the dump start extension event, now set up a callback for it */ rc = (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents->extension_event_index, &DumpStartCallback); printf(\"tiSample: Setting JVMTI event callback %s, rc=%i\\n\", COM_IBM_VM_DUMP_START, rc); break; } extensionEvents++; /* move on to the next extension event */ } /* Find the JVMTI extension function we want */ while (j++ < extensionFunctionCount) { jvmtiExtensionFunction function = extensionFunctions->func; if (strcmp(extensionFunctions->id, COM_IBM_SET_VM_DUMP) == 0) { /* Found the set dump extension function, now set a dump option to generate javadumps on thread starts */ rc = function(jvmti, \"java:events=thrstart\"); printf(\"tiSample: Calling JVMTI extension %s, rc=%i\\n\", COM_IBM_SET_VM_DUMP, rc); break; } extensionFunctions++; /* move on to the next extension function */ } return JNI_OK; } /* * DumpStartCallback() * JVMTI callback for dump start event (IBM JVMTI extension) */ void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...) { printf(\"tiSample: Received JVMTI event callback, for event %s\\n\", event); } The sample JVMTI agent consists of two functions, Agent_OnLoad() and DumpStartCallback() : Agent_OnLoad() This function is called by the VM when the agent is loaded at VM startup, which allows the JVMTI agent to modify VM behavior before initialization is complete. The sample agent obtains access to the JVMTI interface by using the JNI Invocation API function GetEnv() . The agent calls the APIs GetExtensionEvents() and GetExtensionFunctions() to find the JVMTI extensions that are supported by the VM. These APIs provide access to the list of extensions available in the jvmtiExtensionEventInfo and jvmtiExtensionFunctionInfo structures. The sample uses an extension event and an extension function in the following way: Extension event: The sample JVMTI agent searches for the extension event VmDumpStart in the list of jvmtiExtensionEventInfo structures, by using the identifier COM_IBM_VM_DUMP_START provided in ibmjvmti.h . When the event is found, the JVMTI agent calls the JVMTI interface SetExtensionEventCallback() to enable the event, providing a function DumpStartCallback() that is called when the event is triggered. Extension function: Next, the sample JVMTI agent searches for the extension function SetVMDump in the list of jvmtiExtensionFunctionInfo structures, by using the identifier COM_IBM_SET_VM_DUMP provided in ibmjvmti.h . The JVMTI agent calls the function by using the jvmtiExtensionFunction pointer to set a VM dump option java:events=thrstart . This option requests the VM to trigger a Java dump every time a VM thread is started. DumpStartCallback() This callback function issues a message when the associated extension event is called. In the sample code, DumpStartCallback() is used when the VmDumpStart event is triggered. Using the sample JVMTI agent Build the sample JVMTI agent: Windows: cl /I<jre_path>\\include /MD /FetiSample.dll tiSample.c /link /DLL Linux, AIX\u00ae, and z/OS\u00ae: gcc -I<jre_path>/include -o libtiSample.so -shared tiSample.c where <jre_path> is the path to your Java runtime environment installation. To run the sample JVMTI agent, use the command: java -agentlib:tiSample -version When the sample JVMTI agent loads, messages are generated. When the JVMTI agent initiates a Java dump, the message JVMDUMP010 is issued. API reference The following sections provide reference information for the OpenJ9 extensions to the JVMTI. GetOSThreadID You can get the OS thread ID by using the GetOSThreadID() API: jvmtiError GetOSThreadID(jvmtiEnv* jvmti_env, jthread thread, jlong * threadid_ptr); Parameters jvmti_env : A pointer to the JVMTI environment. thread : The thread for which the ID is required. threadid_ptr : A pointer to a variable, used to return the thread ID that corresponds to the thread specified by the thread parameter. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The threadid_ptr parameter is null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_INVALID_THREAD : The thread is not valid. JVMTI_ERROR_THREAD_NOT_ALIVE : The VM state of the thread is not started or has died. JVMTI_ERROR_UNATTACHED_THREAD : The current thread is not attached to the VM. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI start or live phase. Identifiers JVMTI Extension Function identifier: com.ibm.GetOSThreadID Macro declaration in the ibmjvmti.h file: COM_IBM_GET_OS_THREAD_ID QueryVmDump You can query the VM dump options that are set for a VM by using the QueryVmDump() API: jvmtiError QueryVmDump(jvmtiEnv* jvmti_env, jint buffer_size, void* options_buffer, jint* data_size_ptr) This extension returns a set of dump option specifications as ASCII strings. The syntax of the option string is the same as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . The option strings are separated by newline characters. If the memory buffer is too small to contain the current VM dump option strings, you can expect the following results: The error message JVMTI_ERROR_ILLEGAL_ARGUMENT is returned. The variable for data_size_ptr is set to the required buffer size. Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option strings. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options_buffer or data_size_ptr parameters are null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer in options_buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_DUMP SetVmDump You can set VM dump options by using the SetVmDump() API: jvmtiError SetVmDump(jvmtiEnv* jvmti_env, char* option) The dump option is passed in as an ASCII character string. Use the same syntax as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . When dumps are in progress, the dump configuration is locked, and calls to SetVmDump() fail with a return value of JVMTI_ERROR_NOT_AVAILABLE . Parameters jvmti_env : A pointer to the JVMTI environment. option : The VM dump option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xdump string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_DUMP TriggerVmDump You can trigger a VM dump and specify the type of dump you want by using the TriggerVmDump() API: jvmtiError TriggerVmDump(jvmtiEnv* jvmti_env, char* option) Choose the type of dump required by specifying an ASCII string that contains one of the supported dump agent types. See -Xdump . JVMTI events are provided at the start and end of the dump. Parameters jvmti_env : A pointer to the JVMTI environment. option : A pointer to the dump type string, which can be one of the following types: stack java system console tool heap snap ceedump (z/OS only) Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.TriggerVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_TRIGGER_VM_DUMP ResetVmDump You can reset VM dump options to the values at VM initialization by using the ResetVmDump() API: jvmtiError ResetVmDump(jvmtiEnv* jvmti_env) Parameters jvmti_env : The JVMTI environment pointer. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.ResetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_RESET_VM_DUMP VMDumpStart The following JVMTI event function is called when a VM dump starts: void JNICALL VMDumpStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait.\" Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name, such as com.ibm.VmDumpStart . detail : The dump event detail string. The string can be empty. Returns None VMDumpEnd The following JVMTI event function is called when a VM dump ends: void JNICALL VMDumpEnd(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait. Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name com.ibm.VmDumpEnd . detail : The dump event detail string. The string can be empty. Returns None SetVmTrace You can set VM trace options by using the SetVmTrace() API: jvmtiError SetVmTrace(jvmtiEnv* jvmti_env, char* option) The trace option is passed in as an ASCII character string. Use the same syntax as the -Xtrace command-line option, with the initial -Xtrace: omitted. See -Xtrace . Parameters jvmti_env : JVMTI environment pointer. option : Enter the VM trace option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The option parameter contains an invalid -Xtrace string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmTrace Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_TRACE RegisterTracePointSubscriber You can subscribe to VM tracepoints by using the RegisterTracePointSubscriber() API: jvmtiError RegisterTracePointSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiTraceSubscriber subscriber, jvmtiTraceAlarm alarm, void *userData, void **subscriptionID) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiTraceSubscriber . alarm : A function pointer of type jvmtiTraceAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterTracePointSubscriber call if successful. The value must be supplied to a future call to the DeregisterTracePointSubscriber API, which is used to unsubscribe from the VM tracepoint. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : VM trace is not available. JVMTI_ERROR_INTERNAL : An internal error occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_TRACEPOINT_SUBSCRIBER jvmtiTraceSubscriber function The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiTraceSubscriber)(jvmtiEnv *jvmti_env, void *record, jlong length, void *user_data); The subscriber function must be of type jvmtiTraceSubscriber , which is declared in ibmjvmti.h . This function is called with each tracepoint record that is selected through the -Xtrace:external option. The tracepoint record that is supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, the subscription is disconnected, and no further tracepoints are sent to the subscriber. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : A UTF-8 string that contains a tracepoint record. length : The number of UTF-8 characters in the tracepoint record. user_data : User data that is supplied when the subscriber is registered. jvmtiTraceAlarm function The alarm function type is defined as follows: typedef jvmtiError (*jvmtiTraceAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiTraceAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier. user_data : User data that is supplied when the subscriber is registered. DeregisterTracePointSubscriber You can unsubscribe from VM tracepoints by using the DeregisterTracePointSubscriber() API: jvmtiError DeregisterTracePointSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterTracePointSubscriber() API is called, no further calls are made to the subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterTracePointSubscriber API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_TRACEPOINT_SUBSCRIBER GetMemoryCategories You can query runtime environment native memory categories by using the GetMemoryCategories() API: jvmtiError GetMemoryCategories(jvmtiEnv* env, jint version, jint max_categories, jvmtiMemoryCategory * categories_buffer, jint * written_count_ptr, jint * total_categories_ptr); You can query the total native memory consumption of the runtime environment for each memory category by using this API. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . Runtime environment native memory use is grouped under high-level memory categories, as described in the NATIVEMEMINFO section of the Java dump topic. The data returned by the GetMemoryCategories() API is consistent with this format. See Java dump: NATIVEMEMINFO . The extension writes native memory information to a memory buffer specified by the user. Each memory category is recorded as a jvmtiMemoryCategory structure, whose format is defined in ibmjvmti.h . You can use the GetMemoryCategories() API to work out the buffer size you must allocate to hold all memory categories defined inside the VM. To calculate the size, call the API with a null categories_buffer argument and a non-null total_categories_ptr argument. Parameters env : A pointer to the JVMTI environment. version : The version of the jvmtiMemoryCategory structure that you are using. Use COM_IBM_GET_MEMORY_CATEGORIES_VERSION_1 for this argument, unless you must work with an obsolete version of the jvmtiMemoryCategory structure. max_categories : The number of jvmtiMemoryCategory structures that can fit in the categories_buffer memory buffer. categories_buffer : A pointer to the memory buffer for holding the result of the GetMemoryCategories() call. The number of jvmtiMemoryCategory slots available in the categories_buffer memory buffer must be accurately specified with max_categories , otherwise GetMemoryCategories() can overflow the memory buffer. The value can be null. written_count_ptr : A pointer to jint to store the number of jvmtiMemoryCategory structures to be written to the categories_buffer memory buffer. The value can be null. total_categories_ptr : A pointer to jint to store the total number of memory categories declared in the VM. The value can be null. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_UNSUPPORTED_VERSION : Unrecognized value passed for version. JVMTI_ERROR_ILLEGAL_ARGUMENT : Illegal argument; categories_buffer , count_ptr , and total_categories_ptr all have null values. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is invalid. JVMTI_ERROR_OUT_OF_MEMORY : Memory category data is truncated because max_categories is not large enough. Identifiers JVMTI Extension Function identifier: com.ibm.GetMemoryCategories Macro declaration in the ibmjvmti.h file: COM_IBM_GET_MEMORY_CATEGORIES QueryVmLogOptions You can query VM log options by using the QueryVmLogOptions() API: jvmtiError QueryVmLogOptions(jvmtiEnv* jvmti_env, jint buffer_size, void* options, jint* data_size_ptr) This extension returns the current log options as an ASCII string. The syntax of the string is the same as the -Xsyslog command-line option, with the initial -Xsyslog: omitted. For example, the string \"error,warn\" indicates that the VM is set to log error and warning messages only. For more information, see -Xsyslog . Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. If the memory buffer is too small to contain the current VM log option string, the JVMTI_ERROR_ILLEGAL_ARGUMENT error message is returned. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option string. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options or data_size_ptr parameters are null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_LOG_OPTIONS SetVmLogOptions You can set VM log options by using the SetVmLogOptions() API: jvmtiError SetVmLogOptions(jvmtiEnv* jvmti_env, char* options_buffer) The log option is passed in as an ASCII character string. Use the same syntax as the -Xsyslog command-line option, with the initial -Xsyslog: omitted. For example, to set the VM to log error and warning messages, pass in a string containing \"error,warn\". For more information, see -Xsyslog . Parameters jvmti_env : A pointer to the JVMTI environment. options_buffer : A pointer to memory containing the log option. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xsyslog string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_LOG_OPTIONS IterateSharedCaches You can search for shared classes caches that exist in a specified cache directory by using the IterateSharedCaches() API: jvmtiError IterateSharedCaches(jvmtiEnv* env, jint version, const char *cacheDir, jint flags, jboolean useCommandLineValues, jvmtiIterateSharedCachesCallback callback, void *user_data); Information about the caches is returned in a structure that is populated by a user-specified callback function. You can specify the search directory in two ways: Set the value of useCommandLineValues to true and specify the directory on the command line. If the directory is not specified on the command line, the default location for the platform is used. Set the value of useCommandLineValues to false and use the cacheDir parameter. To accept the default location for the platform, specify cacheDir with a null value. Parameters env : A pointer to the JVMTI environment. version : Version information for IterateSharedCaches , which describes the jvmtiSharedCacheInfo structure passed to the jvmtiIterateSharedCachesCallback function. The values allowed are: COM_IBM_ITERATE_SHARED_CACHES_VERSION_1 COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. flags : Reserved for future use. The only value allowed is COM_IBM_ITERATE_SHARED_CACHES_NO_FLAGS . useCommandLineValues : Set this value to true when you want to specify the cache directory on the command line. Set this value to false when you want to use the cacheDir parameter. callback : A function pointer to a user provided callback routine jvmtiIterateSharedCachesCallback . user_data : User supplied data, passed as an argument to the callback function. jint (JNICALL *jvmtiIterateSharedCachesCallback)(jvmtiEnv *env,jvmtiSharedCacheInfo *cache_info, void *user_data); Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_UNSUPPORTED_VERSION : The version parameter is not valid. JVMTI_ERROR_NULL_POINTER : The callback parameter is null. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The flags parameter is not valid. JVMTI_ERROR_INTERNAL : This error is returned when the jvmtiIterateSharedCachesCallback returns JNI_ERR . Identifiers JVMTI Extension Function identifier: com.ibm.IterateSharedCaches Macro declaration in the ibmjvmti.h file: COM_IBM_ITERATE_SHARED_CACHES jvmtiIterateSharedCachesCallback function Callback function parameters env : A pointer to the JVMTI environment when calling COM_IBM_ITERATE_SHARED_CACHES . cache_info : A jvmtiSharedCacheInfo structure containing information about a shared cache. user_data : User-supplied data, passed as an argument to IterateSharedCaches . Callback function returns JNI_OK : Continue iterating. JNI_ERR : Stop iterating, which causes IterateSharedCaches to return JVMTI_ERROR_INTERNAL jvmtiSharedCacheInfo structure The structure of jvmtiSharedCacheInfo typedef struct jvmtiSharedCacheInfo { const char *name; // the name of the shared cache jboolean isCompatible; // if the shared cache is compatible with this VM jboolean isPersistent; // true if the shared cache is persistent, false if its non-persistent jint os_shmid; // the OS shared memory ID associated with a non-persistent cache, -1 otherwise jint os_semid; // the OS shared semaphore ID associated with a non-persistent cache, -1 otherwise jint modLevel; // one of: // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA5 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA6 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA7 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA8 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA9 // from Java 10: the version number of the Java level on which the shared cache is created jint addrMode; // the address mode of the VM creating the shared cache: includes additional // information on whether it is a 64-bit compressedRefs cache when // COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. jboolean isCorrupt; // if the cache is corrupted jlong cacheSize; // the total usable shared classes cache size, or -1 when isCompatible is false jlong freeBytes; // the number of free bytes in the shared classes cache, or -1 when isCompatible is false jlong lastDetach; // the last detach time specified in milliseconds since 00:00:00 on 1 January 1970 UTC, // or -1 when the last detach time is not available jint cacheType; // the type of the cache jlong softMaxBytes; // the soft limit for the available space in the cache jint layer; // the shared cache layer number } jvmtiSharedCacheInfo; Notes: The field cacheType is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 or later is specified. jvmtiSharedCacheInfo.addrMode encodes both address mode and the compressed reference mode when COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. In this case, use the following set of macros to access the address mode and compressed reference mode: To get the address mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_ADDR_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_SHARED_CACHE_ADDRMODE_32 COM_IBM_SHARED_CACHE_ADDRMODE_64 To get the compressed references mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_CMPRSSREF_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_ITERATE_SHARED_CACHES_UNKNOWN_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_NON_COMPRESSED_POINTERS_MODE The field softMaxBytes is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 or later is specified. The field layer is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 or later is specified. If the shared cache does not have a layer number, the value for layer is -1 . DestroySharedCache You can remove a shared classes cache by using the DestroySharedCache() API: jvmtiError DestroySharedCache(jvmtiEnv *env, const char *cacheDir, const char *name, jint persistence, jboolean useCommandLineValues, jint *internalErrorCode); This extension removes a named shared classes cache of a given persistence type, in a given directory. You can specify the cache name, persistence type, and directory in one of these ways: Set useCommandLineValues to true and specify the values on the command line. If a value is not available, the default values for the platform are used. Set useCommandLineValues to false and use the cacheDir , persistence and cacheName parameters to identify the cache to be removed. To accept the default value for cacheDir or cacheName , specify the parameter with a null value. Parameters env : A pointer to the JVMTI environment. cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. cacheName : When the value of useCommandLineValues is false , specify the name of the cache to be removed. If the value is null , the platform-dependent default is used. persistence : When the value of useCommandLineValues is false, specify the type of cache to remove. This parameter must have one of the following values: PERSISTENCE_DEFAULT (The default value for the platform). PERSISTENT NONPERSISTENT useCommandLineValues : Set this value to true when you want to specify the shared classes cache name, persistence type, and directory on the command line. Set this value to false when you want to use the cacheDir , persistence , and cacheName parameters instead. internalErrorCode : If not null , this value is set to one of the following constants when JVMTI_ERROR_INTERNAL is returned: COM_IBM_DESTROYED_ALL_CACHE : Set when JVMTI_ERROR_NONE is returned. COM_IBM_DESTROYED_NONE : Set when the function fails to remove any caches. COM_IBM_DESTROY_FAILED_CURRENT_GEN_CACHE : Set when the function fails to remove the existing current generation cache, irrespective of the state of older generation caches. COM_IBM_DESTROY_FAILED_OLDER_GEN_CACHE : Set when the function fails to remove any older generation caches. The current generation cache does not exist or is successfully removed. Returns JVMTI_ERROR_NONE : Success. No cache exists or all existing caches of all generations are removed. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The persistence parameter is not valid. JVMTI_ERROR_INTERNAL : Failed to remove any existing cache with the given name. See the value of the internalErrorCode parameter for more information about the failure. Identifiers JVMTI Extension Function identifier: com.ibm.DestroySharedCache Macro declaration in the ibmjvmti.h file: COM_IBM_DESTROY_SHARED_CACHE RegisterVerboseGCSubscriber You can subscribe to verbose garbage collection (GC) data logging by using the RegisterVerboseGCSubscriber() API: jvmtiError RegisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiVerboseGCSubscriber subscriber, jvmtiVerboseGCAlarm alarm, void *user_data, void **subscription_id) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiVerboseGCSubscriber . alarm : A function pointer of type jvmtiVerboseGCAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterVerboseGCSubscriber call if successful. The value must be supplied to a future call to DeregisterVerboseGCSubscriber API, which is used to unsubscribe from verbose GC data logging. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : GC verbose logging is not available. JVMTI_ERROR_INTERNAL : An internal error has occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_VERBOSEGC_SUBSCRIBER jvmtiVerboseGCSubscriber function The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCSubscriber)(jvmtiEnv *jvmti_env, const char *record, jlong length, void *user_data); The subscriber function must be of type jvmtiVerboseGCSubscriber , which is declared in ibmjvmti.h . This function is called with each record of verbose logging data produced by the VM. The verbose logging record supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, and the subscription is deregistered. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : An ASCII string that contains a verbose log record. length : The number of ASCII characters in the verbose log record. user_data : User data supplied when the subscriber is registered. jvmtiVerboseGCAlarm function The alarm function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiVerboseGCAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. user_data : User data supplied when the subscriber is registered. subscription_id : The subscription identifier. DeregisterVerboseGCSubscriber You can unsubscribe from verbose Garbage Collection (GC) data logging by using the DeregisterVerboseGCSubscriber() API: jvmtiError DeregisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterVerboseGCSubscriber() API is called, no further calls are made to the previously registered subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterVerboseGCSubscriber() API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_VERBOSEGC_SUBSCRIBER","title":"JVMTI"},{"location":"interface_jvmti/#java-virtual-machine-tool-interface","text":"The Java\u2122 Virtual Machine Tool Interface (JVMTI) is a two-way interface that allows communication between the VM and a native agent. It replaces both the Java Virtual Machine Debug Interface (JVMDI) and Java Virtual Machine Profiler Interface (JVMPI).","title":"Java Virtual Machine Tool Interface"},{"location":"interface_jvmti/#overview","text":"The JVMTI allows third parties to develop debugging, profiling, and monitoring tools for the VM. The interface contains mechanisms for the agent to notify the VM about the kinds of information it requires, and also provides a means of receiving relevant notifications. Several agents can be attached to a VM at any one time. JVMTI agents can be loaded at startup using short or long forms of the command-line option: -agentlib:<agent-lib-name>=<options> or -agentpath:<path-to-agent>=<options> In the example that follows (see Sample JVMTI agent ), the directory containing the jdwp library is assumed to be on the library path. If you require a specific library, such as jdwp , with your JVMTI agent, you can specify the path at startup, for example: -agentlib:jdwp=<options> For more information about JVMTI, see https://docs.oracle.com/javase/8/docs/technotes/guides/management/index.html . For a guide about writing a JVMTI agent, see http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html .","title":"Overview"},{"location":"interface_jvmti/#eclipse-openj9-extensions","text":"Eclipse OpenJ9\u2122 extensions to the JVMTI allow a JVMTI agent to query or automatically trigger operations in the VM, including the following tasks: Task OpenJ9 extensions Get the OS thread ID GetOSThreadID Query, set, and reset the VM dump options QueryVmDump , SetVmDump , ResetVmDump Trigger a VM dump, and monitor JVMTI event functions when VM dumps start and end TriggerVmDump , VMDumpStart , VMDumpEnd Set VM trace options SetVmTrace Subscribe to and unsubscribe from VM tracepoints RegisterTracePointSubscriber , DeregisterTracePointSubscriber Query runtime environment native memory categories GetMemoryCategories Query and set VM log options QueryVmLogOptions , SetVmLogOptions Search for and remove a shared classes cache IterateSharedCaches , DestroySharedCache Subscribe to and unsubscribe from verbose garbage collection (GC) data logging RegisterVerboseGCSubscriber , DeregisterVerboseGCSubscriber The definitions that you need when you write a JVMTI agent are provided in the header files jvmti.h and ibmjvmti.h , in the include directory.","title":"Eclipse OpenJ9 extensions"},{"location":"interface_jvmti/#sample-jvmti-agent","text":"The following sample shows you how to write a simple JVMTI agent that uses OpenJ9 extensions to the JVMTI. Sample JVMTI agent written in C/C++, which uses the OpenJ9 extensions /* * tiSample.c * * Sample JVMTI agent to demonstrate the OpenJ9 JVMTI dump extensions */ #include \"jvmti.h\" #include \"ibmjvmti.h\" /* Forward declarations for JVMTI callback functions */ void JNICALL VMInitCallback(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread); void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...); /* * Agent_Onload() * * JVMTI agent initialisation function, invoked as agent is loaded by the VM */ JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) { jvmtiEnv *jvmti = NULL; jvmtiError rc; jint extensionEventCount = 0; jvmtiExtensionEventInfo *extensionEvents = NULL; jint extensionFunctionCount = 0; jvmtiExtensionFunctionInfo *extensionFunctions = NULL; int i = 0, j = 0; printf(\"tiSample: Loading JVMTI sample agent\\n\"); /* Get access to JVMTI */ (*jvm)->GetEnv(jvm, (void **)&jvmti, JVMTI_VERSION_1_0); /* Look up all the JVMTI extension events and functions */ (*jvmti)->GetExtensionEvents(jvmti, &extensionEventCount, &extensionEvents); (*jvmti)->GetExtensionFunctions(jvmti, &extensionFunctionCount, &extensionFunctions); printf(\"tiSample: Found %i JVMTI extension events, %i extension functions\\n\", extensionEventCount, extensionFunctionCount); /* Find the JVMTI extension event we want */ while (i++ < extensionEventCount) { if (strcmp(extensionEvents->id, COM_IBM_VM_DUMP_START) == 0) { /* Found the dump start extension event, now set up a callback for it */ rc = (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents->extension_event_index, &DumpStartCallback); printf(\"tiSample: Setting JVMTI event callback %s, rc=%i\\n\", COM_IBM_VM_DUMP_START, rc); break; } extensionEvents++; /* move on to the next extension event */ } /* Find the JVMTI extension function we want */ while (j++ < extensionFunctionCount) { jvmtiExtensionFunction function = extensionFunctions->func; if (strcmp(extensionFunctions->id, COM_IBM_SET_VM_DUMP) == 0) { /* Found the set dump extension function, now set a dump option to generate javadumps on thread starts */ rc = function(jvmti, \"java:events=thrstart\"); printf(\"tiSample: Calling JVMTI extension %s, rc=%i\\n\", COM_IBM_SET_VM_DUMP, rc); break; } extensionFunctions++; /* move on to the next extension function */ } return JNI_OK; } /* * DumpStartCallback() * JVMTI callback for dump start event (IBM JVMTI extension) */ void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...) { printf(\"tiSample: Received JVMTI event callback, for event %s\\n\", event); } The sample JVMTI agent consists of two functions, Agent_OnLoad() and DumpStartCallback() :","title":"Sample JVMTI agent"},{"location":"interface_jvmti/#agent_onload","text":"This function is called by the VM when the agent is loaded at VM startup, which allows the JVMTI agent to modify VM behavior before initialization is complete. The sample agent obtains access to the JVMTI interface by using the JNI Invocation API function GetEnv() . The agent calls the APIs GetExtensionEvents() and GetExtensionFunctions() to find the JVMTI extensions that are supported by the VM. These APIs provide access to the list of extensions available in the jvmtiExtensionEventInfo and jvmtiExtensionFunctionInfo structures. The sample uses an extension event and an extension function in the following way: Extension event: The sample JVMTI agent searches for the extension event VmDumpStart in the list of jvmtiExtensionEventInfo structures, by using the identifier COM_IBM_VM_DUMP_START provided in ibmjvmti.h . When the event is found, the JVMTI agent calls the JVMTI interface SetExtensionEventCallback() to enable the event, providing a function DumpStartCallback() that is called when the event is triggered. Extension function: Next, the sample JVMTI agent searches for the extension function SetVMDump in the list of jvmtiExtensionFunctionInfo structures, by using the identifier COM_IBM_SET_VM_DUMP provided in ibmjvmti.h . The JVMTI agent calls the function by using the jvmtiExtensionFunction pointer to set a VM dump option java:events=thrstart . This option requests the VM to trigger a Java dump every time a VM thread is started.","title":"Agent_OnLoad()"},{"location":"interface_jvmti/#dumpstartcallback","text":"This callback function issues a message when the associated extension event is called. In the sample code, DumpStartCallback() is used when the VmDumpStart event is triggered.","title":"DumpStartCallback()"},{"location":"interface_jvmti/#using-the-sample-jvmti-agent","text":"Build the sample JVMTI agent: Windows: cl /I<jre_path>\\include /MD /FetiSample.dll tiSample.c /link /DLL Linux, AIX\u00ae, and z/OS\u00ae: gcc -I<jre_path>/include -o libtiSample.so -shared tiSample.c where <jre_path> is the path to your Java runtime environment installation. To run the sample JVMTI agent, use the command: java -agentlib:tiSample -version When the sample JVMTI agent loads, messages are generated. When the JVMTI agent initiates a Java dump, the message JVMDUMP010 is issued.","title":"Using the sample JVMTI agent"},{"location":"interface_jvmti/#api-reference","text":"The following sections provide reference information for the OpenJ9 extensions to the JVMTI.","title":"API reference"},{"location":"interface_jvmti/#getosthreadid","text":"You can get the OS thread ID by using the GetOSThreadID() API: jvmtiError GetOSThreadID(jvmtiEnv* jvmti_env, jthread thread, jlong * threadid_ptr); Parameters jvmti_env : A pointer to the JVMTI environment. thread : The thread for which the ID is required. threadid_ptr : A pointer to a variable, used to return the thread ID that corresponds to the thread specified by the thread parameter. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The threadid_ptr parameter is null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_INVALID_THREAD : The thread is not valid. JVMTI_ERROR_THREAD_NOT_ALIVE : The VM state of the thread is not started or has died. JVMTI_ERROR_UNATTACHED_THREAD : The current thread is not attached to the VM. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI start or live phase. Identifiers JVMTI Extension Function identifier: com.ibm.GetOSThreadID Macro declaration in the ibmjvmti.h file: COM_IBM_GET_OS_THREAD_ID","title":"GetOSThreadID"},{"location":"interface_jvmti/#queryvmdump","text":"You can query the VM dump options that are set for a VM by using the QueryVmDump() API: jvmtiError QueryVmDump(jvmtiEnv* jvmti_env, jint buffer_size, void* options_buffer, jint* data_size_ptr) This extension returns a set of dump option specifications as ASCII strings. The syntax of the option string is the same as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . The option strings are separated by newline characters. If the memory buffer is too small to contain the current VM dump option strings, you can expect the following results: The error message JVMTI_ERROR_ILLEGAL_ARGUMENT is returned. The variable for data_size_ptr is set to the required buffer size. Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option strings. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options_buffer or data_size_ptr parameters are null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer in options_buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_DUMP","title":"QueryVmDump"},{"location":"interface_jvmti/#setvmdump","text":"You can set VM dump options by using the SetVmDump() API: jvmtiError SetVmDump(jvmtiEnv* jvmti_env, char* option) The dump option is passed in as an ASCII character string. Use the same syntax as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . When dumps are in progress, the dump configuration is locked, and calls to SetVmDump() fail with a return value of JVMTI_ERROR_NOT_AVAILABLE . Parameters jvmti_env : A pointer to the JVMTI environment. option : The VM dump option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xdump string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_DUMP","title":"SetVmDump"},{"location":"interface_jvmti/#triggervmdump","text":"You can trigger a VM dump and specify the type of dump you want by using the TriggerVmDump() API: jvmtiError TriggerVmDump(jvmtiEnv* jvmti_env, char* option) Choose the type of dump required by specifying an ASCII string that contains one of the supported dump agent types. See -Xdump . JVMTI events are provided at the start and end of the dump. Parameters jvmti_env : A pointer to the JVMTI environment. option : A pointer to the dump type string, which can be one of the following types: stack java system console tool heap snap ceedump (z/OS only) Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.TriggerVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_TRIGGER_VM_DUMP","title":"TriggerVmDump"},{"location":"interface_jvmti/#resetvmdump","text":"You can reset VM dump options to the values at VM initialization by using the ResetVmDump() API: jvmtiError ResetVmDump(jvmtiEnv* jvmti_env) Parameters jvmti_env : The JVMTI environment pointer. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.ResetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_RESET_VM_DUMP","title":"ResetVmDump"},{"location":"interface_jvmti/#vmdumpstart","text":"The following JVMTI event function is called when a VM dump starts: void JNICALL VMDumpStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait.\" Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name, such as com.ibm.VmDumpStart . detail : The dump event detail string. The string can be empty. Returns None","title":"VMDumpStart"},{"location":"interface_jvmti/#vmdumpend","text":"The following JVMTI event function is called when a VM dump ends: void JNICALL VMDumpEnd(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait. Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name com.ibm.VmDumpEnd . detail : The dump event detail string. The string can be empty. Returns None","title":"VMDumpEnd"},{"location":"interface_jvmti/#setvmtrace","text":"You can set VM trace options by using the SetVmTrace() API: jvmtiError SetVmTrace(jvmtiEnv* jvmti_env, char* option) The trace option is passed in as an ASCII character string. Use the same syntax as the -Xtrace command-line option, with the initial -Xtrace: omitted. See -Xtrace . Parameters jvmti_env : JVMTI environment pointer. option : Enter the VM trace option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The option parameter contains an invalid -Xtrace string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmTrace Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_TRACE","title":"SetVmTrace"},{"location":"interface_jvmti/#registertracepointsubscriber","text":"You can subscribe to VM tracepoints by using the RegisterTracePointSubscriber() API: jvmtiError RegisterTracePointSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiTraceSubscriber subscriber, jvmtiTraceAlarm alarm, void *userData, void **subscriptionID) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiTraceSubscriber . alarm : A function pointer of type jvmtiTraceAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterTracePointSubscriber call if successful. The value must be supplied to a future call to the DeregisterTracePointSubscriber API, which is used to unsubscribe from the VM tracepoint. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : VM trace is not available. JVMTI_ERROR_INTERNAL : An internal error occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_TRACEPOINT_SUBSCRIBER","title":"RegisterTracePointSubscriber"},{"location":"interface_jvmti/#jvmtitracesubscriber-function","text":"The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiTraceSubscriber)(jvmtiEnv *jvmti_env, void *record, jlong length, void *user_data); The subscriber function must be of type jvmtiTraceSubscriber , which is declared in ibmjvmti.h . This function is called with each tracepoint record that is selected through the -Xtrace:external option. The tracepoint record that is supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, the subscription is disconnected, and no further tracepoints are sent to the subscriber. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : A UTF-8 string that contains a tracepoint record. length : The number of UTF-8 characters in the tracepoint record. user_data : User data that is supplied when the subscriber is registered.","title":"jvmtiTraceSubscriber function"},{"location":"interface_jvmti/#jvmtitracealarm-function","text":"The alarm function type is defined as follows: typedef jvmtiError (*jvmtiTraceAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiTraceAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier. user_data : User data that is supplied when the subscriber is registered.","title":"jvmtiTraceAlarm function"},{"location":"interface_jvmti/#deregistertracepointsubscriber","text":"You can unsubscribe from VM tracepoints by using the DeregisterTracePointSubscriber() API: jvmtiError DeregisterTracePointSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterTracePointSubscriber() API is called, no further calls are made to the subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterTracePointSubscriber API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_TRACEPOINT_SUBSCRIBER","title":"DeregisterTracePointSubscriber"},{"location":"interface_jvmti/#getmemorycategories","text":"You can query runtime environment native memory categories by using the GetMemoryCategories() API: jvmtiError GetMemoryCategories(jvmtiEnv* env, jint version, jint max_categories, jvmtiMemoryCategory * categories_buffer, jint * written_count_ptr, jint * total_categories_ptr); You can query the total native memory consumption of the runtime environment for each memory category by using this API. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . Runtime environment native memory use is grouped under high-level memory categories, as described in the NATIVEMEMINFO section of the Java dump topic. The data returned by the GetMemoryCategories() API is consistent with this format. See Java dump: NATIVEMEMINFO . The extension writes native memory information to a memory buffer specified by the user. Each memory category is recorded as a jvmtiMemoryCategory structure, whose format is defined in ibmjvmti.h . You can use the GetMemoryCategories() API to work out the buffer size you must allocate to hold all memory categories defined inside the VM. To calculate the size, call the API with a null categories_buffer argument and a non-null total_categories_ptr argument. Parameters env : A pointer to the JVMTI environment. version : The version of the jvmtiMemoryCategory structure that you are using. Use COM_IBM_GET_MEMORY_CATEGORIES_VERSION_1 for this argument, unless you must work with an obsolete version of the jvmtiMemoryCategory structure. max_categories : The number of jvmtiMemoryCategory structures that can fit in the categories_buffer memory buffer. categories_buffer : A pointer to the memory buffer for holding the result of the GetMemoryCategories() call. The number of jvmtiMemoryCategory slots available in the categories_buffer memory buffer must be accurately specified with max_categories , otherwise GetMemoryCategories() can overflow the memory buffer. The value can be null. written_count_ptr : A pointer to jint to store the number of jvmtiMemoryCategory structures to be written to the categories_buffer memory buffer. The value can be null. total_categories_ptr : A pointer to jint to store the total number of memory categories declared in the VM. The value can be null. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_UNSUPPORTED_VERSION : Unrecognized value passed for version. JVMTI_ERROR_ILLEGAL_ARGUMENT : Illegal argument; categories_buffer , count_ptr , and total_categories_ptr all have null values. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is invalid. JVMTI_ERROR_OUT_OF_MEMORY : Memory category data is truncated because max_categories is not large enough. Identifiers JVMTI Extension Function identifier: com.ibm.GetMemoryCategories Macro declaration in the ibmjvmti.h file: COM_IBM_GET_MEMORY_CATEGORIES","title":"GetMemoryCategories"},{"location":"interface_jvmti/#queryvmlogoptions","text":"You can query VM log options by using the QueryVmLogOptions() API: jvmtiError QueryVmLogOptions(jvmtiEnv* jvmti_env, jint buffer_size, void* options, jint* data_size_ptr) This extension returns the current log options as an ASCII string. The syntax of the string is the same as the -Xsyslog command-line option, with the initial -Xsyslog: omitted. For example, the string \"error,warn\" indicates that the VM is set to log error and warning messages only. For more information, see -Xsyslog . Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. If the memory buffer is too small to contain the current VM log option string, the JVMTI_ERROR_ILLEGAL_ARGUMENT error message is returned. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option string. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options or data_size_ptr parameters are null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_LOG_OPTIONS","title":"QueryVmLogOptions"},{"location":"interface_jvmti/#setvmlogoptions","text":"You can set VM log options by using the SetVmLogOptions() API: jvmtiError SetVmLogOptions(jvmtiEnv* jvmti_env, char* options_buffer) The log option is passed in as an ASCII character string. Use the same syntax as the -Xsyslog command-line option, with the initial -Xsyslog: omitted. For example, to set the VM to log error and warning messages, pass in a string containing \"error,warn\". For more information, see -Xsyslog . Parameters jvmti_env : A pointer to the JVMTI environment. options_buffer : A pointer to memory containing the log option. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xsyslog string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_LOG_OPTIONS","title":"SetVmLogOptions"},{"location":"interface_jvmti/#iteratesharedcaches","text":"You can search for shared classes caches that exist in a specified cache directory by using the IterateSharedCaches() API: jvmtiError IterateSharedCaches(jvmtiEnv* env, jint version, const char *cacheDir, jint flags, jboolean useCommandLineValues, jvmtiIterateSharedCachesCallback callback, void *user_data); Information about the caches is returned in a structure that is populated by a user-specified callback function. You can specify the search directory in two ways: Set the value of useCommandLineValues to true and specify the directory on the command line. If the directory is not specified on the command line, the default location for the platform is used. Set the value of useCommandLineValues to false and use the cacheDir parameter. To accept the default location for the platform, specify cacheDir with a null value. Parameters env : A pointer to the JVMTI environment. version : Version information for IterateSharedCaches , which describes the jvmtiSharedCacheInfo structure passed to the jvmtiIterateSharedCachesCallback function. The values allowed are: COM_IBM_ITERATE_SHARED_CACHES_VERSION_1 COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. flags : Reserved for future use. The only value allowed is COM_IBM_ITERATE_SHARED_CACHES_NO_FLAGS . useCommandLineValues : Set this value to true when you want to specify the cache directory on the command line. Set this value to false when you want to use the cacheDir parameter. callback : A function pointer to a user provided callback routine jvmtiIterateSharedCachesCallback . user_data : User supplied data, passed as an argument to the callback function. jint (JNICALL *jvmtiIterateSharedCachesCallback)(jvmtiEnv *env,jvmtiSharedCacheInfo *cache_info, void *user_data); Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_UNSUPPORTED_VERSION : The version parameter is not valid. JVMTI_ERROR_NULL_POINTER : The callback parameter is null. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The flags parameter is not valid. JVMTI_ERROR_INTERNAL : This error is returned when the jvmtiIterateSharedCachesCallback returns JNI_ERR . Identifiers JVMTI Extension Function identifier: com.ibm.IterateSharedCaches Macro declaration in the ibmjvmti.h file: COM_IBM_ITERATE_SHARED_CACHES","title":"IterateSharedCaches"},{"location":"interface_jvmti/#jvmtiiteratesharedcachescallback-function","text":"Callback function parameters env : A pointer to the JVMTI environment when calling COM_IBM_ITERATE_SHARED_CACHES . cache_info : A jvmtiSharedCacheInfo structure containing information about a shared cache. user_data : User-supplied data, passed as an argument to IterateSharedCaches . Callback function returns JNI_OK : Continue iterating. JNI_ERR : Stop iterating, which causes IterateSharedCaches to return JVMTI_ERROR_INTERNAL","title":"jvmtiIterateSharedCachesCallback function"},{"location":"interface_jvmti/#jvmtisharedcacheinfo-structure","text":"The structure of jvmtiSharedCacheInfo typedef struct jvmtiSharedCacheInfo { const char *name; // the name of the shared cache jboolean isCompatible; // if the shared cache is compatible with this VM jboolean isPersistent; // true if the shared cache is persistent, false if its non-persistent jint os_shmid; // the OS shared memory ID associated with a non-persistent cache, -1 otherwise jint os_semid; // the OS shared semaphore ID associated with a non-persistent cache, -1 otherwise jint modLevel; // one of: // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA5 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA6 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA7 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA8 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA9 // from Java 10: the version number of the Java level on which the shared cache is created jint addrMode; // the address mode of the VM creating the shared cache: includes additional // information on whether it is a 64-bit compressedRefs cache when // COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. jboolean isCorrupt; // if the cache is corrupted jlong cacheSize; // the total usable shared classes cache size, or -1 when isCompatible is false jlong freeBytes; // the number of free bytes in the shared classes cache, or -1 when isCompatible is false jlong lastDetach; // the last detach time specified in milliseconds since 00:00:00 on 1 January 1970 UTC, // or -1 when the last detach time is not available jint cacheType; // the type of the cache jlong softMaxBytes; // the soft limit for the available space in the cache jint layer; // the shared cache layer number } jvmtiSharedCacheInfo; Notes: The field cacheType is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 or later is specified. jvmtiSharedCacheInfo.addrMode encodes both address mode and the compressed reference mode when COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. In this case, use the following set of macros to access the address mode and compressed reference mode: To get the address mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_ADDR_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_SHARED_CACHE_ADDRMODE_32 COM_IBM_SHARED_CACHE_ADDRMODE_64 To get the compressed references mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_CMPRSSREF_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_ITERATE_SHARED_CACHES_UNKNOWN_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_NON_COMPRESSED_POINTERS_MODE The field softMaxBytes is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 or later is specified. The field layer is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 or later is specified. If the shared cache does not have a layer number, the value for layer is -1 .","title":"jvmtiSharedCacheInfo structure"},{"location":"interface_jvmti/#destroysharedcache","text":"You can remove a shared classes cache by using the DestroySharedCache() API: jvmtiError DestroySharedCache(jvmtiEnv *env, const char *cacheDir, const char *name, jint persistence, jboolean useCommandLineValues, jint *internalErrorCode); This extension removes a named shared classes cache of a given persistence type, in a given directory. You can specify the cache name, persistence type, and directory in one of these ways: Set useCommandLineValues to true and specify the values on the command line. If a value is not available, the default values for the platform are used. Set useCommandLineValues to false and use the cacheDir , persistence and cacheName parameters to identify the cache to be removed. To accept the default value for cacheDir or cacheName , specify the parameter with a null value. Parameters env : A pointer to the JVMTI environment. cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. cacheName : When the value of useCommandLineValues is false , specify the name of the cache to be removed. If the value is null , the platform-dependent default is used. persistence : When the value of useCommandLineValues is false, specify the type of cache to remove. This parameter must have one of the following values: PERSISTENCE_DEFAULT (The default value for the platform). PERSISTENT NONPERSISTENT useCommandLineValues : Set this value to true when you want to specify the shared classes cache name, persistence type, and directory on the command line. Set this value to false when you want to use the cacheDir , persistence , and cacheName parameters instead. internalErrorCode : If not null , this value is set to one of the following constants when JVMTI_ERROR_INTERNAL is returned: COM_IBM_DESTROYED_ALL_CACHE : Set when JVMTI_ERROR_NONE is returned. COM_IBM_DESTROYED_NONE : Set when the function fails to remove any caches. COM_IBM_DESTROY_FAILED_CURRENT_GEN_CACHE : Set when the function fails to remove the existing current generation cache, irrespective of the state of older generation caches. COM_IBM_DESTROY_FAILED_OLDER_GEN_CACHE : Set when the function fails to remove any older generation caches. The current generation cache does not exist or is successfully removed. Returns JVMTI_ERROR_NONE : Success. No cache exists or all existing caches of all generations are removed. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The persistence parameter is not valid. JVMTI_ERROR_INTERNAL : Failed to remove any existing cache with the given name. See the value of the internalErrorCode parameter for more information about the failure. Identifiers JVMTI Extension Function identifier: com.ibm.DestroySharedCache Macro declaration in the ibmjvmti.h file: COM_IBM_DESTROY_SHARED_CACHE","title":"DestroySharedCache"},{"location":"interface_jvmti/#registerverbosegcsubscriber","text":"You can subscribe to verbose garbage collection (GC) data logging by using the RegisterVerboseGCSubscriber() API: jvmtiError RegisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiVerboseGCSubscriber subscriber, jvmtiVerboseGCAlarm alarm, void *user_data, void **subscription_id) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiVerboseGCSubscriber . alarm : A function pointer of type jvmtiVerboseGCAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterVerboseGCSubscriber call if successful. The value must be supplied to a future call to DeregisterVerboseGCSubscriber API, which is used to unsubscribe from verbose GC data logging. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : GC verbose logging is not available. JVMTI_ERROR_INTERNAL : An internal error has occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_VERBOSEGC_SUBSCRIBER","title":"RegisterVerboseGCSubscriber"},{"location":"interface_jvmti/#jvmtiverbosegcsubscriber-function","text":"The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCSubscriber)(jvmtiEnv *jvmti_env, const char *record, jlong length, void *user_data); The subscriber function must be of type jvmtiVerboseGCSubscriber , which is declared in ibmjvmti.h . This function is called with each record of verbose logging data produced by the VM. The verbose logging record supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, and the subscription is deregistered. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : An ASCII string that contains a verbose log record. length : The number of ASCII characters in the verbose log record. user_data : User data supplied when the subscriber is registered.","title":"jvmtiVerboseGCSubscriber function"},{"location":"interface_jvmti/#jvmtiverbosegcalarm-function","text":"The alarm function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiVerboseGCAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. user_data : User data supplied when the subscriber is registered. subscription_id : The subscription identifier.","title":"jvmtiVerboseGCAlarm function"},{"location":"interface_jvmti/#deregisterverbosegcsubscriber","text":"You can unsubscribe from verbose Garbage Collection (GC) data logging by using the DeregisterVerboseGCSubscriber() API: jvmtiError DeregisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterVerboseGCSubscriber() API is called, no further calls are made to the previously registered subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterVerboseGCSubscriber() API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_VERBOSEGC_SUBSCRIBER","title":"DeregisterVerboseGCSubscriber"},{"location":"interface_lang_management/","text":"Language management interface Eclipse OpenJ9\u2122 provides MXBean extensions to the standard java.lang.management API, which can be used to monitor and manage the Java\u2122 virtual machine. These extensions provide access to information about the state of the OpenJ9 VM and the environment in which it is running. The following tables list the MXBeans by package and describe the monitoring or management capabilities. Package: com.ibm.lang.management MXBean Description GarbageCollectorMXBean Discovers Garbage Collection (GC) operations (collection times, compactions, heap memory usage, and freed memory). JvmCpuMonitorMXBean Discovers CPU consumption by category (GC, JIT, or other threads). MemoryMXBean Discovers memory usage (minimum and maximum heap sizes, and shared classes cache sizes). MemoryPoolMXBean Discovers memory pool usage for specific GC policies. OperatingSystemMXBean Discovers information about the operating system (memory, CPU capacity/utilization). RuntimeMXBean Discovers information about the runtime environment (CPU load, Java process ID, and VM state) ThreadMXBean Discovers information about native thread IDs. UnixOperatingSystemMXBean Discovers information for Unix operating systems (memory, file descriptors, processors, processor usage, and hardware) Package: com.ibm.virtualization.management MXBean Description GuestOSMXBean Discovers CPU and memory statistics of a virtual machine or logical partition as seen by the Hypervisor. HypervisorMXBean Discovers whether the operating system is running on a hypervisor and provides information about the hypervisor. Package: openj9.lang.management MXBean Description OpenJ9DiagnosticsMXBean Configures and dynamically triggers dump agents. For more information about using these MXBeans, read the API documentation. For Java 8, see the OpenJ9 Language Management API documentation .","title":"Language Management"},{"location":"interface_lang_management/#language-management-interface","text":"Eclipse OpenJ9\u2122 provides MXBean extensions to the standard java.lang.management API, which can be used to monitor and manage the Java\u2122 virtual machine. These extensions provide access to information about the state of the OpenJ9 VM and the environment in which it is running. The following tables list the MXBeans by package and describe the monitoring or management capabilities. Package: com.ibm.lang.management MXBean Description GarbageCollectorMXBean Discovers Garbage Collection (GC) operations (collection times, compactions, heap memory usage, and freed memory). JvmCpuMonitorMXBean Discovers CPU consumption by category (GC, JIT, or other threads). MemoryMXBean Discovers memory usage (minimum and maximum heap sizes, and shared classes cache sizes). MemoryPoolMXBean Discovers memory pool usage for specific GC policies. OperatingSystemMXBean Discovers information about the operating system (memory, CPU capacity/utilization). RuntimeMXBean Discovers information about the runtime environment (CPU load, Java process ID, and VM state) ThreadMXBean Discovers information about native thread IDs. UnixOperatingSystemMXBean Discovers information for Unix operating systems (memory, file descriptors, processors, processor usage, and hardware) Package: com.ibm.virtualization.management MXBean Description GuestOSMXBean Discovers CPU and memory statistics of a virtual machine or logical partition as seen by the Hypervisor. HypervisorMXBean Discovers whether the operating system is running on a hypervisor and provides information about the hypervisor. Package: openj9.lang.management MXBean Description OpenJ9DiagnosticsMXBean Configures and dynamically triggers dump agents. For more information about using these MXBeans, read the API documentation. For Java 8, see the OpenJ9 Language Management API documentation .","title":"Language management interface"},{"location":"introduction/","text":"Getting started with Eclipse OpenJ9 Eclipse OpenJ9\u2122 is a high performance, scalable, Java\u2122 virtual machine (VM) implementation that is fully compliant with the Java Virtual Machine Specification . At run time, the VM interprets the Java bytecode that is compiled by the Java compiler. The VM acts as a translator between the language and the underlying operating system and hardware. A Java program requires a specific VM to run on a particular platform, such as Linux\u00ae, z/OS\u00ae, or Windows\u2122. This material provides information about the VM configuration and tuning options, together with the default settings. Follow the links provided for more detailed information. Configuring your system Most Java applications should run on an OpenJDK that contains the OpenJ9 VM without changing anything on the underlying system. However, to get the most out of your system you might want to consider some configuration options. Read Configuring your system to learn more about the following options: Setting operating system environment variables, such as PATH and CLASSPATH . Increasing resource limits for running Java applications. Configuring large page memory allocation. Configuring Dynamic LPAR support on AIX\u00ae systems. Performance tuning OpenJ9 is configured to start with a set of default options that provide the optimal runtime environment for Java applications with typical workloads. However, if your application is atypical, you can improve performance by tuning the OpenJ9 VM. You can also improve performance by enabling hardware features or using specific APIs in your application code. Garbage collection policies OpenJ9 includes several garbage collection policies. To learn more about these policies and the types of application workload that can benefit from them, see Garbage collection policies . Class data sharing You can share class data between running VMs, which can reduce the startup time for a VM once the cache has been created. For more information, see Introduction to class data sharing . Native data operations If your Java application manipulates native data, consider writing your application to take advantage of methods in the Data Access Accelerator (DAA) API. The following functions are provided: Arithmetic, comparison, shifting, and validation operations for packed decimal data. Conversion operations between different binary coded decimal and Java binary types. Marshalling operations: marshalling and unmarshalling Java binary types, such as short , int , long , float , and double , to and from byte arrays. You can gain a number of benefits by using the APIs provided: Improved application performance by avoiding object creation and intermediate processing, which can also put pressure on the Java heap. Hardware acceleration by automatically exploiting available hardware features on specific platforms. Platform independence for applications that are developed to take advantage of Data Access Acceleration. For more information, see the API documentation . Cloud optimizations To improve the performance of applications that run in containers, try setting the following tuning options: Use a shared classes cache ( -Xshareclasses -XX:SharedCacheHardLimit=200m -Xscmx60m ) with Ahead-Of-Time (AOT) compilation to improve your startup time. For persistence, store the cache in a volume that you map to your container. For more information, see Inroduction to class data sharing and AOT Compiler . Use the -Xtune:virtualized option, which configures OpenJ9 for typical cloud deployments where VM guests are provisioned with a small number of virtual CPUs to maximize the number of applications that can be run. When enabled, OpenJ9 adapts its internal processes to reduce the amount of CPU consumed and trim down the memory footprint. These changes come at the expense of only a small loss in throughput. The OpenJ9 VM automatically detects when it is running in a docker container and uses a mechanism to detect when the VM is idle. When an idle state is detected, OpenJ9 runs a garbage collection cycle and releases free memory pages back to the operating system. The object heap is also compacted to make best use of the available memory for further application processing. Compaction is triggered by internal heuristics that look into the number of fragmented pages. Typically there is no need to force a compaction. For cloud services that charge based on memory usage, maintaining a small footprint can generate cost savings. For more information about tuning options that control this process, see -XX:IdleTuningMinIdleWaitTime . Cryptographic operations OpenJDK uses the in-built Java cryptographic implementation by default. However, native cryptographic implementations typically provide better performance. OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which is well established and used with many enterprise applications. The OpenSSL V1.0.x, V1.1.x, and V3.0.x implementations are currently supported for the Digest, CBC, GCM, and RSA algorithms. The OpenSSL V1.1.x and V3.0.x implementations are also supported for the ChaCha20 and ChaCha20-Poly1305 algorithms. On Linux and AIX operating systems, the OpenSSL 1.0.x or 1.1.x library is expected to be found on the system path. If you use a package manager to install OpenSSL, the system path will be updated automatically. On other operating systems, the OpenSSL 1.1.x library is typically bundled. Later levels of some Linux operating systems might bundle OpenSSL 3.0.x. If you have multiple versions of OpenSSL on your system, the OpenJ9 VM uses the latest version. Note: OpenSSL 3.0.x does not support initialization vector (IV) sizes above 16 Bytes for the GCM algorithm. (In earlier OpenSSL versions, you can use such sizes but they might cause unpredictable behavior.) If you need to use a larger size, disable OpenSSL support for the GCM algorithm. OpenSSL support is enabled by default for all supported algorithms. If you want to limit support to specific algorithms, a number of system properties are available for tuning the implementation. Each algorithm can be disabled individually by setting the following system properties on the command line: To turn off Digest , set -Djdk.nativeDigest=false To turn off ChaCha20 and ChaCha20-Poly1305 , set -Djdk.nativeChaCha20=false . Note: These algorithms are not supported on Java 8 To turn off CBC , set -Djdk.nativeCBC=false To turn off GCM , set -Djdk.nativeGCM=false To turn off RSA , set -Djdk.nativeRSA=false You can turn off all the algorithms by setting the following system property on the command line: -Djdk.nativeCrypto=false To build a version of OpenJDK with OpenJ9 that includes OpenSSL support, follow the steps in our detailed build instructions: OpenJDK 8 with OpenJ9 . OpenJDK 11 with OpenJ9 . OpenJDK 17 with OpenJ9 . Note: If you obtain an OpenJDK with OpenJ9 build that includes OpenSSL or build a version yourself that includes OpenSSL support, the following acknowledgements apply in accordance with the license terms: This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/). This product includes cryptographic software written by Eric Young (eay@cryptsoft.com). Exploiting GPUs OpenJ9 provides both the CUDA4J API and the GPU API , which enables you to develop applications that can take advantage of graphics processing unit (GPU) processing for suitable functions, such as sorting arrays. You can also enable the JIT compiler to offload certain processing tasks to a GPU by specifying the -Xjit:enableGPU option on the command line. When enabled, the JIT compiler determines when to offload tasks based on performance heuristics. GPU processing is supported only on Linux little-endian systems, such as x86-64 and IBM Power LE, and Windows x86-64 systems. For more information about enabling GPU processing, see Exploiting graphics processing units . Special consideration is needed when using the WDDM driver model for GPUs on Windows. Using the WDDM driver model means the GPU is also used as a display device and as such is subject to the Timeout Detection and Recovery (TDR) mechanism of Windows. If you are running demanding GPU workloads, you should increase the timeout from the default 2 seconds. More detail may be found in NVIDIA's Installation Guide for Windows . Hardware acceleration On AIX\u00ae systems that contain the Nest accelerator (NX) co-processor, OpenJ9 can take advantage of the zlibNX library. This library is an enhanced version of the zlib compression library that supports hardware-accelerated data compression and decompression. The zlibNX library is supported on AIX version 7.2 TL4 and later and must be installed on the system. The Nest accelerator (NX) co-processor is available on IBM POWER9\u00ae systems. To learn more about zlibNX , see Data compression by using the zlibNX library . Runtime options Runtime options are specified on the command line and include system properties, standard options, nonstandard ( -X ) options, and -XX options. For a detailed list of runtime options, see OpenJ9 command-line options Default settings If you do not specify any options on the command line at run time, the OpenJ9 VM starts with default settings that define how it operates. For more information about these settings, see Default settings for the OpenJ9 VM . Using jlink On Java 11 and later, you can use the jlink utility to create a custom OpenJ9 runtime image, which allows you to optimize image size. If you do not require translations from the English language, the translation files can be removed to further optimize the size. You can achieve this by specifying the --exclude-files=**java_**.properties option when you run jlink . The default English java.properties file is unaffected. Using jpackage (Linux, macOS, and Windows only) You can use the jpackage utility to package a Java application into a platform-specific package that includes all of the necessary dependencies. Full details of the tool are available at JEP 392: Packaging Tool . Instructions for using it and the various options available, are documented in the Oracle Tool Specifications: The jpackage Command . Troubleshooting The OpenJ9 diagnostic component contains extensive features to assist with problem determination. Diagnostic data is produced under default conditions, but can also be controlled by starting the VM with the -Xdump option or using the com.ibm.jvm.Dump API. You can also trace Java applications, methods, and VM operations by using the -Xtrace option . To get started, read Diagnostic tools and data .","title":"Getting started"},{"location":"introduction/#getting-started-with-eclipse-openj9","text":"Eclipse OpenJ9\u2122 is a high performance, scalable, Java\u2122 virtual machine (VM) implementation that is fully compliant with the Java Virtual Machine Specification . At run time, the VM interprets the Java bytecode that is compiled by the Java compiler. The VM acts as a translator between the language and the underlying operating system and hardware. A Java program requires a specific VM to run on a particular platform, such as Linux\u00ae, z/OS\u00ae, or Windows\u2122. This material provides information about the VM configuration and tuning options, together with the default settings. Follow the links provided for more detailed information.","title":"Getting started with Eclipse OpenJ9"},{"location":"introduction/#configuring-your-system","text":"Most Java applications should run on an OpenJDK that contains the OpenJ9 VM without changing anything on the underlying system. However, to get the most out of your system you might want to consider some configuration options. Read Configuring your system to learn more about the following options: Setting operating system environment variables, such as PATH and CLASSPATH . Increasing resource limits for running Java applications. Configuring large page memory allocation. Configuring Dynamic LPAR support on AIX\u00ae systems.","title":"Configuring your system"},{"location":"introduction/#performance-tuning","text":"OpenJ9 is configured to start with a set of default options that provide the optimal runtime environment for Java applications with typical workloads. However, if your application is atypical, you can improve performance by tuning the OpenJ9 VM. You can also improve performance by enabling hardware features or using specific APIs in your application code.","title":"Performance tuning"},{"location":"introduction/#garbage-collection-policies","text":"OpenJ9 includes several garbage collection policies. To learn more about these policies and the types of application workload that can benefit from them, see Garbage collection policies .","title":"Garbage collection policies"},{"location":"introduction/#class-data-sharing","text":"You can share class data between running VMs, which can reduce the startup time for a VM once the cache has been created. For more information, see Introduction to class data sharing .","title":"Class data sharing"},{"location":"introduction/#native-data-operations","text":"If your Java application manipulates native data, consider writing your application to take advantage of methods in the Data Access Accelerator (DAA) API. The following functions are provided: Arithmetic, comparison, shifting, and validation operations for packed decimal data. Conversion operations between different binary coded decimal and Java binary types. Marshalling operations: marshalling and unmarshalling Java binary types, such as short , int , long , float , and double , to and from byte arrays. You can gain a number of benefits by using the APIs provided: Improved application performance by avoiding object creation and intermediate processing, which can also put pressure on the Java heap. Hardware acceleration by automatically exploiting available hardware features on specific platforms. Platform independence for applications that are developed to take advantage of Data Access Acceleration. For more information, see the API documentation .","title":"Native data operations"},{"location":"introduction/#cloud-optimizations","text":"To improve the performance of applications that run in containers, try setting the following tuning options: Use a shared classes cache ( -Xshareclasses -XX:SharedCacheHardLimit=200m -Xscmx60m ) with Ahead-Of-Time (AOT) compilation to improve your startup time. For persistence, store the cache in a volume that you map to your container. For more information, see Inroduction to class data sharing and AOT Compiler . Use the -Xtune:virtualized option, which configures OpenJ9 for typical cloud deployments where VM guests are provisioned with a small number of virtual CPUs to maximize the number of applications that can be run. When enabled, OpenJ9 adapts its internal processes to reduce the amount of CPU consumed and trim down the memory footprint. These changes come at the expense of only a small loss in throughput. The OpenJ9 VM automatically detects when it is running in a docker container and uses a mechanism to detect when the VM is idle. When an idle state is detected, OpenJ9 runs a garbage collection cycle and releases free memory pages back to the operating system. The object heap is also compacted to make best use of the available memory for further application processing. Compaction is triggered by internal heuristics that look into the number of fragmented pages. Typically there is no need to force a compaction. For cloud services that charge based on memory usage, maintaining a small footprint can generate cost savings. For more information about tuning options that control this process, see -XX:IdleTuningMinIdleWaitTime .","title":"Cloud optimizations"},{"location":"introduction/#cryptographic-operations","text":"OpenJDK uses the in-built Java cryptographic implementation by default. However, native cryptographic implementations typically provide better performance. OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which is well established and used with many enterprise applications. The OpenSSL V1.0.x, V1.1.x, and V3.0.x implementations are currently supported for the Digest, CBC, GCM, and RSA algorithms. The OpenSSL V1.1.x and V3.0.x implementations are also supported for the ChaCha20 and ChaCha20-Poly1305 algorithms. On Linux and AIX operating systems, the OpenSSL 1.0.x or 1.1.x library is expected to be found on the system path. If you use a package manager to install OpenSSL, the system path will be updated automatically. On other operating systems, the OpenSSL 1.1.x library is typically bundled. Later levels of some Linux operating systems might bundle OpenSSL 3.0.x. If you have multiple versions of OpenSSL on your system, the OpenJ9 VM uses the latest version. Note: OpenSSL 3.0.x does not support initialization vector (IV) sizes above 16 Bytes for the GCM algorithm. (In earlier OpenSSL versions, you can use such sizes but they might cause unpredictable behavior.) If you need to use a larger size, disable OpenSSL support for the GCM algorithm. OpenSSL support is enabled by default for all supported algorithms. If you want to limit support to specific algorithms, a number of system properties are available for tuning the implementation. Each algorithm can be disabled individually by setting the following system properties on the command line: To turn off Digest , set -Djdk.nativeDigest=false To turn off ChaCha20 and ChaCha20-Poly1305 , set -Djdk.nativeChaCha20=false . Note: These algorithms are not supported on Java 8 To turn off CBC , set -Djdk.nativeCBC=false To turn off GCM , set -Djdk.nativeGCM=false To turn off RSA , set -Djdk.nativeRSA=false You can turn off all the algorithms by setting the following system property on the command line: -Djdk.nativeCrypto=false To build a version of OpenJDK with OpenJ9 that includes OpenSSL support, follow the steps in our detailed build instructions: OpenJDK 8 with OpenJ9 . OpenJDK 11 with OpenJ9 . OpenJDK 17 with OpenJ9 . Note: If you obtain an OpenJDK with OpenJ9 build that includes OpenSSL or build a version yourself that includes OpenSSL support, the following acknowledgements apply in accordance with the license terms: This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/). This product includes cryptographic software written by Eric Young (eay@cryptsoft.com).","title":"Cryptographic operations"},{"location":"introduction/#exploiting-gpus","text":"OpenJ9 provides both the CUDA4J API and the GPU API , which enables you to develop applications that can take advantage of graphics processing unit (GPU) processing for suitable functions, such as sorting arrays. You can also enable the JIT compiler to offload certain processing tasks to a GPU by specifying the -Xjit:enableGPU option on the command line. When enabled, the JIT compiler determines when to offload tasks based on performance heuristics. GPU processing is supported only on Linux little-endian systems, such as x86-64 and IBM Power LE, and Windows x86-64 systems. For more information about enabling GPU processing, see Exploiting graphics processing units . Special consideration is needed when using the WDDM driver model for GPUs on Windows. Using the WDDM driver model means the GPU is also used as a display device and as such is subject to the Timeout Detection and Recovery (TDR) mechanism of Windows. If you are running demanding GPU workloads, you should increase the timeout from the default 2 seconds. More detail may be found in NVIDIA's Installation Guide for Windows .","title":"Exploiting GPUs"},{"location":"introduction/#hardware-acceleration","text":"On AIX\u00ae systems that contain the Nest accelerator (NX) co-processor, OpenJ9 can take advantage of the zlibNX library. This library is an enhanced version of the zlib compression library that supports hardware-accelerated data compression and decompression. The zlibNX library is supported on AIX version 7.2 TL4 and later and must be installed on the system. The Nest accelerator (NX) co-processor is available on IBM POWER9\u00ae systems. To learn more about zlibNX , see Data compression by using the zlibNX library .","title":"Hardware acceleration"},{"location":"introduction/#runtime-options","text":"Runtime options are specified on the command line and include system properties, standard options, nonstandard ( -X ) options, and -XX options. For a detailed list of runtime options, see OpenJ9 command-line options","title":"Runtime options"},{"location":"introduction/#default-settings","text":"If you do not specify any options on the command line at run time, the OpenJ9 VM starts with default settings that define how it operates. For more information about these settings, see Default settings for the OpenJ9 VM .","title":"Default settings"},{"location":"introduction/#using-jlink","text":"On Java 11 and later, you can use the jlink utility to create a custom OpenJ9 runtime image, which allows you to optimize image size. If you do not require translations from the English language, the translation files can be removed to further optimize the size. You can achieve this by specifying the --exclude-files=**java_**.properties option when you run jlink . The default English java.properties file is unaffected.","title":"Using jlink"},{"location":"introduction/#using-jpackage","text":"(Linux, macOS, and Windows only) You can use the jpackage utility to package a Java application into a platform-specific package that includes all of the necessary dependencies. Full details of the tool are available at JEP 392: Packaging Tool . Instructions for using it and the various options available, are documented in the Oracle Tool Specifications: The jpackage Command .","title":"Using jpackage"},{"location":"introduction/#troubleshooting","text":"The OpenJ9 diagnostic component contains extensive features to assist with problem determination. Diagnostic data is produced under default conditions, but can also be controlled by starting the VM with the -Xdump option or using the com.ibm.jvm.Dump API. You can also trace Java applications, methods, and VM operations by using the -Xtrace option . To get started, read Diagnostic tools and data .","title":"Troubleshooting"},{"location":"jit/","text":"The JIT compiler The Just-In-Time (JIT) compiler is a key component of the Eclipse OpenJ9\u2122 VM that improves the performance of Java applications by compiling platform-neutral Java bytecode into native machine code at run time. Without the JIT, the VM has to interpret the bytecodes itself - a process that requires extra CPU and memory. The JIT compiler doesn't compile every method that gets called because thousands of methods can be called at startup. Instead, OpenJ9 records the number of times a method is called. When the count reaches a pre-defined invocation threshold , JIT compilation is triggered. Once a method has been compiled by the JIT, the VM can call the compiled method rather than interpreting it. Optimization levels The JIT compiler can compile a method at different optimization levels: cold , warm , hot , very hot (with profiling) , or scorching . The hotter the optimization level, the better the expected performance, but the higher the cost in terms of CPU and memory. cold is used during startup processing for large applications where the goal is to achieve the best compiled code speed for as many methods as possible. warm is the workhorse; after start-up, most methods are compiled when they reach the invocation threshold. For higher optimization levels, the VM uses a sampling thread to identify methods that continue to take a lot of time. Methods that consume more than 1% are compiled at hot. Methods that consume more than 12.5% are scheduled for a scorching compilation. However, before that happens the methods are compiled at very hot with profiling to collect detailed profile data that is used by the scorching compilation. The higher optimization levels use special techniques such as escape analysis and partial redundancy elimination, or loop through certain optimization sequences more times. Although these techniques use more CPU and memory, the improved performance that is delivered by the optimizations can make the tradeoff worthwhile. Troubleshooting The JIT compiler is enabled by default to optimize performance. However, if you experience a problem running your application, temporarily turning off the JIT will tell you whether the JIT is at fault. Because JIT starts at the same time as the VM, you can only modify JIT behavior at startup. There are a number of ways to disable the JIT: Specify -Djava.compiler=NONE on the command line. Specify -Xint on the command line, which turns off the JIT and AOT compiler. To eliminate problems with one or the other you can turn these compilers off selectively with the -Xnojit and -Xnoaot options. Call the java.lang.Compiler API programmatically. Note: java.lang.Compiler is deprecated for removal in Java SE 9. If turning off the JIT solves your problem, you can investigate JIT operations in more detail by using a number of options to control behavior. Turning on verbose logging with the verbose suboption causes the JIT to record all compiler operations. However, the log file can be difficult to read because there are so many complex operations occuring in rapid succession. Follow these steps to simplify operations, which helps you pinpoint the root cause: Turn off multiple compilation threads The JIT compiler can use more than one compilation thread, which typically improves startup performance. The number of threads is determined by the VM, depending on the system configuration. You can turn off multiple threads by using the -XcompilationThreads option, which simplifies the output in the verbose log. Lower the invocation threshold When the invocation count is set to 0 , the JIT compiles every method and your application will fail immediately when the method causing the problem is reached. You can alter the threshold with the count suboption. Turn off inlining Inlining is a complex process that generates larger and more complex code. To eliminate errors caused by these operations, use the disableInlining suboption. Decrease the optimization levels Use the optlevel suboption to gradually decrease the compiler optimization levels to see whether you can isolate the level at which your problem occurs. More information about these suboptions and the command line syntax is covered in -Xjit . Understanding JIT verbose logs At first glance, a JIT verbose log can look very complex. To help you understand the log we'll look at JIT compiler operations when you run the java -version command. The following option turns on verbose logging and directs output to a log file called vlogfile : java -Xjit:verbose,vlog=vlogfile -version The first section of the log includes lines that start with #INFO: , which provides information about the environment that the JIT is operating in. You can determine the version of the JIT and VM that you are using, and the type and number of processors that the JIT has access to. #INFO: _______________________________________ #INFO: Version Information: #INFO: JIT Level - e24e8aa9 #INFO: JVM Level - 20180315_120 #INFO: GC Level - e24e8aa9 #INFO: #INFO: Processor Information: #INFO: Platform Info:X86 Intel P6 #INFO: Vendor:GenuineIntel #INFO: numProc=1 #INFO: #INFO: _______________________________________ #INFO: AOT #INFO: options specified: #INFO: samplingFrequency=2 #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: _______________________________________ #INFO: JIT #INFO: options specified: #INFO: verbose,vlog=vlogfile #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: StartTime: Apr 23 09:49:10 2018 #INFO: Free Physical Memory: 996188 KB #INFO: CPU entitlement = 100.00 This section also shows the AOT and JIT options that are in force. The last few lines detail the start time of the compilation activity, how much free physical memory is available to the process, and the CPU entitlement. The information section is followed by a sequence of lines that describe the methods that are being compiled, as well as other events significant to the operation of the JIT compiler. Here is a typical line from the verbose log: + (cold) sun/reflect/Reflection.getCallerClass()Ljava/lang/Class; @ 00007FCACED1303C-00007FCACED13182 OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=00000000011E7EA8 bcsz=2 JNI compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% In this example: The method compiled is sun/reflect/Reflection.getCallerClass()Ljava/lang/Class . The + indicates that this method is successfully compiled. Failed compilations are marked by a ! . (cold) tells you the optimization level that was applied. Other examples might be (warm) or (scorching) . 00007FCACED1303C-00007FCACED13182 is the code range where the compiled code was generated. Q values provide information about the state of the compilation queues when the compilation occurred. bcsz shows the bytecode size. In this case it is small because this is a native method, so the JIT is simply providing an accelerated JNI transition into the native getCallerClass method. Each line of output represents a method that is compiled. The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the values time and mem into each line, as shown in the following example: + (cold) java/lang/System.getEncoding(I)Ljava/lang/String; @ 00007F29183A921C-00007F29183A936D OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=0000000000F13A70 bcsz=3 JNI time=311us mem=[region=704 system=16384]KB compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% time=311us reflects the amount of time taken to do the compilation. mem=[region=704 system=16384]KB reflects the amount of memory that was allocated during the compilation. The following example can be used to create verbose output that includes lines to show when compilation for a method starts and ends, and any methods that are inlined during the compilation. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version Note: The suboptions count and -XcompilationThreads1 are included only to simplify the output for this example and are not recommended for production. The following section is taken from the output and describes the compilation and inlining of one method java/lang/String.equals : (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB #INL: 7 methods inlined into 4dce72bd java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40 #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The first line is included as a result of setting the compileStart suboption and shows the start of the warm method compilation: (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB Similarly, the last line shows the successful compilation of this method, as denoted by the + : + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The lines inbetween that start with #INL describe the inlining operations that took place. A total of 7 methods were inlined into java/lang/String.equals : The first three methods ( #0 , #1 , #2 ) are inlined into the top level method, denoted as #-1 : #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z The next four methods ( #3 , #4 , #5 , #6 ) are inlined into the method denoted by #2 . #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C Here's how to interpret the line for #INL: #0: : The method is inlined into 4dce72bd , where 4dce72bd is an internal pointer that corresponds to this method (in this case, java/lang/String.equals(Ljava/lang/Object;)Z ). The value @22 at the end of the pointer is a bytecode index, which describes the bytecode index of the call that is being inlined. The call is 81670d20 bcsz=37 java/lang/String.lengthInternal()I , which shows the corresponding internal pointer, bytecode size (bcsz) and the name of the method that got inlined. Going through the #INL output line by line then: java/lang/String.lengthInternal()I got inlined into its caller 4dce72bd at bytecode index @22. java/lang/String.lengthInternal()I also got inlined into its caller 4dce72bd at bytecode index @28. java/lang/String.regionMatchesInternal(...) got inlined at call reference 4dce72bd at bytecode index @104. Then 4 distinct calls to java/lang/String.charAtInternal(I[C)C were also inlined into java/lang/String.regionMatchesInternal(...) : #3 at bytecode index @121 of regionMatchesInternal #4 at bytecode index @131 of regionMatchesInternal #5 at bytecode index @156 of regionMatchesInternal #6 at bytecode index @166 of regionMatchesInternal These were all the calls that the inliner decided to inline into the method being compiled. There is some additional output that describes calls to methods that weren't inlined: #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z While the output does not specifically say why these methods were not inlined, the relatively larger bytecode size ( bcsz=233 ) probably prevented the first method from being inlined. It's possible that, at a higher optimization level than cold, this deduplicateStrings method may get inlined. The coldCalled label on the last two lines, however, indicate that these calls are located in a part of the method that has not ever been executed, so the JIT decided that inlining those last two methods will probably increase compile time without much promise that it will improve performance. By reading the log in this way you can reconstruct the tree of inlines that are taking place as the compilation proceeds. You can see which methods are being inlined and which methods are not being inlined. See also Diagnosing a JIT or AOT problem","title":"JIT Compiler"},{"location":"jit/#the-jit-compiler","text":"The Just-In-Time (JIT) compiler is a key component of the Eclipse OpenJ9\u2122 VM that improves the performance of Java applications by compiling platform-neutral Java bytecode into native machine code at run time. Without the JIT, the VM has to interpret the bytecodes itself - a process that requires extra CPU and memory. The JIT compiler doesn't compile every method that gets called because thousands of methods can be called at startup. Instead, OpenJ9 records the number of times a method is called. When the count reaches a pre-defined invocation threshold , JIT compilation is triggered. Once a method has been compiled by the JIT, the VM can call the compiled method rather than interpreting it.","title":"The JIT compiler"},{"location":"jit/#optimization-levels","text":"The JIT compiler can compile a method at different optimization levels: cold , warm , hot , very hot (with profiling) , or scorching . The hotter the optimization level, the better the expected performance, but the higher the cost in terms of CPU and memory. cold is used during startup processing for large applications where the goal is to achieve the best compiled code speed for as many methods as possible. warm is the workhorse; after start-up, most methods are compiled when they reach the invocation threshold. For higher optimization levels, the VM uses a sampling thread to identify methods that continue to take a lot of time. Methods that consume more than 1% are compiled at hot. Methods that consume more than 12.5% are scheduled for a scorching compilation. However, before that happens the methods are compiled at very hot with profiling to collect detailed profile data that is used by the scorching compilation. The higher optimization levels use special techniques such as escape analysis and partial redundancy elimination, or loop through certain optimization sequences more times. Although these techniques use more CPU and memory, the improved performance that is delivered by the optimizations can make the tradeoff worthwhile.","title":"Optimization levels"},{"location":"jit/#troubleshooting","text":"The JIT compiler is enabled by default to optimize performance. However, if you experience a problem running your application, temporarily turning off the JIT will tell you whether the JIT is at fault. Because JIT starts at the same time as the VM, you can only modify JIT behavior at startup. There are a number of ways to disable the JIT: Specify -Djava.compiler=NONE on the command line. Specify -Xint on the command line, which turns off the JIT and AOT compiler. To eliminate problems with one or the other you can turn these compilers off selectively with the -Xnojit and -Xnoaot options. Call the java.lang.Compiler API programmatically. Note: java.lang.Compiler is deprecated for removal in Java SE 9. If turning off the JIT solves your problem, you can investigate JIT operations in more detail by using a number of options to control behavior. Turning on verbose logging with the verbose suboption causes the JIT to record all compiler operations. However, the log file can be difficult to read because there are so many complex operations occuring in rapid succession. Follow these steps to simplify operations, which helps you pinpoint the root cause: Turn off multiple compilation threads The JIT compiler can use more than one compilation thread, which typically improves startup performance. The number of threads is determined by the VM, depending on the system configuration. You can turn off multiple threads by using the -XcompilationThreads option, which simplifies the output in the verbose log. Lower the invocation threshold When the invocation count is set to 0 , the JIT compiles every method and your application will fail immediately when the method causing the problem is reached. You can alter the threshold with the count suboption. Turn off inlining Inlining is a complex process that generates larger and more complex code. To eliminate errors caused by these operations, use the disableInlining suboption. Decrease the optimization levels Use the optlevel suboption to gradually decrease the compiler optimization levels to see whether you can isolate the level at which your problem occurs. More information about these suboptions and the command line syntax is covered in -Xjit .","title":"Troubleshooting"},{"location":"jit/#understanding-jit-verbose-logs","text":"At first glance, a JIT verbose log can look very complex. To help you understand the log we'll look at JIT compiler operations when you run the java -version command. The following option turns on verbose logging and directs output to a log file called vlogfile : java -Xjit:verbose,vlog=vlogfile -version The first section of the log includes lines that start with #INFO: , which provides information about the environment that the JIT is operating in. You can determine the version of the JIT and VM that you are using, and the type and number of processors that the JIT has access to. #INFO: _______________________________________ #INFO: Version Information: #INFO: JIT Level - e24e8aa9 #INFO: JVM Level - 20180315_120 #INFO: GC Level - e24e8aa9 #INFO: #INFO: Processor Information: #INFO: Platform Info:X86 Intel P6 #INFO: Vendor:GenuineIntel #INFO: numProc=1 #INFO: #INFO: _______________________________________ #INFO: AOT #INFO: options specified: #INFO: samplingFrequency=2 #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: _______________________________________ #INFO: JIT #INFO: options specified: #INFO: verbose,vlog=vlogfile #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: StartTime: Apr 23 09:49:10 2018 #INFO: Free Physical Memory: 996188 KB #INFO: CPU entitlement = 100.00 This section also shows the AOT and JIT options that are in force. The last few lines detail the start time of the compilation activity, how much free physical memory is available to the process, and the CPU entitlement. The information section is followed by a sequence of lines that describe the methods that are being compiled, as well as other events significant to the operation of the JIT compiler. Here is a typical line from the verbose log: + (cold) sun/reflect/Reflection.getCallerClass()Ljava/lang/Class; @ 00007FCACED1303C-00007FCACED13182 OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=00000000011E7EA8 bcsz=2 JNI compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% In this example: The method compiled is sun/reflect/Reflection.getCallerClass()Ljava/lang/Class . The + indicates that this method is successfully compiled. Failed compilations are marked by a ! . (cold) tells you the optimization level that was applied. Other examples might be (warm) or (scorching) . 00007FCACED1303C-00007FCACED13182 is the code range where the compiled code was generated. Q values provide information about the state of the compilation queues when the compilation occurred. bcsz shows the bytecode size. In this case it is small because this is a native method, so the JIT is simply providing an accelerated JNI transition into the native getCallerClass method. Each line of output represents a method that is compiled. The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the values time and mem into each line, as shown in the following example: + (cold) java/lang/System.getEncoding(I)Ljava/lang/String; @ 00007F29183A921C-00007F29183A936D OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=0000000000F13A70 bcsz=3 JNI time=311us mem=[region=704 system=16384]KB compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% time=311us reflects the amount of time taken to do the compilation. mem=[region=704 system=16384]KB reflects the amount of memory that was allocated during the compilation. The following example can be used to create verbose output that includes lines to show when compilation for a method starts and ends, and any methods that are inlined during the compilation. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version Note: The suboptions count and -XcompilationThreads1 are included only to simplify the output for this example and are not recommended for production. The following section is taken from the output and describes the compilation and inlining of one method java/lang/String.equals : (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB #INL: 7 methods inlined into 4dce72bd java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40 #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The first line is included as a result of setting the compileStart suboption and shows the start of the warm method compilation: (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB Similarly, the last line shows the successful compilation of this method, as denoted by the + : + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The lines inbetween that start with #INL describe the inlining operations that took place. A total of 7 methods were inlined into java/lang/String.equals : The first three methods ( #0 , #1 , #2 ) are inlined into the top level method, denoted as #-1 : #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z The next four methods ( #3 , #4 , #5 , #6 ) are inlined into the method denoted by #2 . #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C Here's how to interpret the line for #INL: #0: : The method is inlined into 4dce72bd , where 4dce72bd is an internal pointer that corresponds to this method (in this case, java/lang/String.equals(Ljava/lang/Object;)Z ). The value @22 at the end of the pointer is a bytecode index, which describes the bytecode index of the call that is being inlined. The call is 81670d20 bcsz=37 java/lang/String.lengthInternal()I , which shows the corresponding internal pointer, bytecode size (bcsz) and the name of the method that got inlined. Going through the #INL output line by line then: java/lang/String.lengthInternal()I got inlined into its caller 4dce72bd at bytecode index @22. java/lang/String.lengthInternal()I also got inlined into its caller 4dce72bd at bytecode index @28. java/lang/String.regionMatchesInternal(...) got inlined at call reference 4dce72bd at bytecode index @104. Then 4 distinct calls to java/lang/String.charAtInternal(I[C)C were also inlined into java/lang/String.regionMatchesInternal(...) : #3 at bytecode index @121 of regionMatchesInternal #4 at bytecode index @131 of regionMatchesInternal #5 at bytecode index @156 of regionMatchesInternal #6 at bytecode index @166 of regionMatchesInternal These were all the calls that the inliner decided to inline into the method being compiled. There is some additional output that describes calls to methods that weren't inlined: #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z While the output does not specifically say why these methods were not inlined, the relatively larger bytecode size ( bcsz=233 ) probably prevented the first method from being inlined. It's possible that, at a higher optimization level than cold, this deduplicateStrings method may get inlined. The coldCalled label on the last two lines, however, indicate that these calls are located in a part of the method that has not ever been executed, so the JIT decided that inlining those last two methods will probably increase compile time without much promise that it will improve performance. By reading the log in this way you can reconstruct the tree of inlines that are taking place as the compilation proceeds. You can see which methods are being inlined and which methods are not being inlined.","title":"Understanding JIT verbose logs"},{"location":"jit/#see-also","text":"Diagnosing a JIT or AOT problem","title":"See also"},{"location":"jitserver/","text":"JITServer technology Linux\u00ae on x86, Linux on IBM Power\u00ae systems, and Linux on IBM Z\u00ae systems (64-bit only) JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java\u2122 application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and performance of Java applications. You might want to try this technology if the following criteria are met: Your Java application is required to compile many methods using JIT in a relatively short time. The application is running in an environment with limited CPU or memory, which can worsen interference from the JIT compiler. The network latency between JITServer and client VM is relatively low. For more details about JITServer technology, including its advantages and disadvantages and when best to use it, see blog posts such as the following: Free your JVM from the JIT with JITServer Technology JITServer - Optimize your Java cloud-native applications Using JITServer technology JITServer technology is not enabled by default: you must explicitly invoke it. Running OpenJ9 without either of the following options launches it as a regular VM with embedded JIT compilation. Launch Eclipse OpenJ9 in client mode Use the following command-line option to launch Eclipse OpenJ9\u2122 in client mode. In this mode, the VM sends compilation requests to an available JITServer. The client operates as a regular VM with its own JIT compiler if a server is not available. -XX:+UseJITServer Launch OpenJ9 in server mode Use the following command to start a JITServer process that listens for incoming compilation requests: jitserver Configuring JITServer technology You can use command line options to further configure the JITServer and the client VM processes. For example: -XX:JITServerPort=<port> : Specifies the port the server listens to for compilation requests -XX:JITServerAddress=<address> : Specifies the name or IP of the server -XX:JITServerTimeout=<timeout> : Specifies a timeout value in milliseconds for socket operations -XX:[+|-]JITServerShareROMClasses : Specifies whether the server shares cached ROM classes between clients -XX:[+|-]JITServerLocalSyncCompiles : Improves performance for real-time applications by compiling synchronous JIT compilations locally, with a remote asynchronous recompilation scheduled at a later point -XX:[+|-]JITServerLogConnections : Enables logging of connection/disconnection events between the server and the client -XX:[+|-]JITServerMetrics : Specifies whether the JITServer custom metrics exporter is enabled or disabled -XX:JITServerMetricsPort=<port> : Specifies the port number on which the JITServer metrics are provided to a monitoring agent -XX:JITServerAOTCacheName=<cache_name> : Specifies the name of the server-side AOT cache to use -XX:[+|-]JITServerUseAOTCache : Specifies whether the server caches AOT-compiled methods If a JITServer server crashes, the client is forced to perform compilations locally. You can change this behavior by using the -XX:[+|-]RequireJITServer option so that the client crashes with an assert when it detects that the server is unavailable. This feature is useful when you are running a test suite with JITServer enabled and you want the server crash to cause the test to fail. Security You can encrypt network communication between the client VM and JITServer by using OpenSSL 1.0.x, 1.1.x, or 3.0.x. To enable encryption, you specify the private key and the certificate at the server and use the certificate at the client. For more information, see -XX:JITServerSSLCert / -XX:JITServerSSLKey / -XX:JITServerSSLRootCerts . Tuning JITServer For best practices regarding JITServer configuration and tuning, see the document JITServer tuning and practical considerations . Building a JDK with JITServer technology If you want to build a JDK with JITServer technology, see Appendix A of Free your JVM from the JIT with JITServer Technology . See also The JIT compiler","title":"JITServer technology"},{"location":"jitserver/#jitserver-technology","text":"Linux\u00ae on x86, Linux on IBM Power\u00ae systems, and Linux on IBM Z\u00ae systems (64-bit only) JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java\u2122 application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and performance of Java applications. You might want to try this technology if the following criteria are met: Your Java application is required to compile many methods using JIT in a relatively short time. The application is running in an environment with limited CPU or memory, which can worsen interference from the JIT compiler. The network latency between JITServer and client VM is relatively low. For more details about JITServer technology, including its advantages and disadvantages and when best to use it, see blog posts such as the following: Free your JVM from the JIT with JITServer Technology JITServer - Optimize your Java cloud-native applications","title":"JITServer technology"},{"location":"jitserver/#using-jitserver-technology","text":"JITServer technology is not enabled by default: you must explicitly invoke it. Running OpenJ9 without either of the following options launches it as a regular VM with embedded JIT compilation.","title":"Using JITServer technology"},{"location":"jitserver/#launch-eclipse-openj9-in-client-mode","text":"Use the following command-line option to launch Eclipse OpenJ9\u2122 in client mode. In this mode, the VM sends compilation requests to an available JITServer. The client operates as a regular VM with its own JIT compiler if a server is not available. -XX:+UseJITServer","title":"Launch Eclipse OpenJ9 in client mode"},{"location":"jitserver/#launch-openj9-in-server-mode","text":"Use the following command to start a JITServer process that listens for incoming compilation requests: jitserver","title":"Launch OpenJ9 in server mode"},{"location":"jitserver/#configuring-jitserver-technology","text":"You can use command line options to further configure the JITServer and the client VM processes. For example: -XX:JITServerPort=<port> : Specifies the port the server listens to for compilation requests -XX:JITServerAddress=<address> : Specifies the name or IP of the server -XX:JITServerTimeout=<timeout> : Specifies a timeout value in milliseconds for socket operations -XX:[+|-]JITServerShareROMClasses : Specifies whether the server shares cached ROM classes between clients -XX:[+|-]JITServerLocalSyncCompiles : Improves performance for real-time applications by compiling synchronous JIT compilations locally, with a remote asynchronous recompilation scheduled at a later point -XX:[+|-]JITServerLogConnections : Enables logging of connection/disconnection events between the server and the client -XX:[+|-]JITServerMetrics : Specifies whether the JITServer custom metrics exporter is enabled or disabled -XX:JITServerMetricsPort=<port> : Specifies the port number on which the JITServer metrics are provided to a monitoring agent -XX:JITServerAOTCacheName=<cache_name> : Specifies the name of the server-side AOT cache to use -XX:[+|-]JITServerUseAOTCache : Specifies whether the server caches AOT-compiled methods If a JITServer server crashes, the client is forced to perform compilations locally. You can change this behavior by using the -XX:[+|-]RequireJITServer option so that the client crashes with an assert when it detects that the server is unavailable. This feature is useful when you are running a test suite with JITServer enabled and you want the server crash to cause the test to fail.","title":"Configuring JITServer technology"},{"location":"jitserver/#security","text":"You can encrypt network communication between the client VM and JITServer by using OpenSSL 1.0.x, 1.1.x, or 3.0.x. To enable encryption, you specify the private key and the certificate at the server and use the certificate at the client. For more information, see -XX:JITServerSSLCert / -XX:JITServerSSLKey / -XX:JITServerSSLRootCerts .","title":"Security"},{"location":"jitserver/#tuning-jitserver","text":"For best practices regarding JITServer configuration and tuning, see the document JITServer tuning and practical considerations .","title":"Tuning JITServer"},{"location":"jitserver/#building-a-jdk-with-jitserver-technology","text":"If you want to build a JDK with JITServer technology, see Appendix A of Free your JVM from the JIT with JITServer Technology .","title":"Building a JDK with JITServer technology"},{"location":"jitserver/#see-also","text":"The JIT compiler","title":"See also"},{"location":"jitserver_tuning/","text":"JITServer tuning and practical considerations Server caches Client-session caches Multiple client JVMs can be connected at the same time to a single JIT server. For each client, the server maintains a client-session cache with information about the environment the client is running in (Java classes, class hierarchy, profiling information, JVM options, etc.). Typically, the information in these caches is kept separately, per client. However, if you specify the -XX:+JITServerShareROMClasses option, the read-only part of the Java classes (ROMClasses in Eclipse OpenJ9\u2122 parlance) is shared between the different clients. This option can generate memory savings at the server when the connected clients run identical or similar Java applications. The client-session caches are deleted when the clients terminate, but this can happen only if the clients are shutdown gracefully, giving them the opportunity to send a termination message to the server. To address the scenario of clients ending abruptly, the server also deletes the cache for a client that hasn\u2019t issued a compilation request for 1000 minutes, or 5 minutes under memory pressure. If needed, you can change these values with the following options: -Xjit:oldAge=<time-in-ms>,oldAgeUnderLowMemory=<time-in-ms> JITServer AOT cache The JITServer technology can cache AOT compiled methods at the server. The JITServer can, therefore, avoid carrying out an AOT compilation when a compatible AOT method body already exists in the cache, thereby saving CPU resource and improving remote compilation latency. This mechanism works in conjunction with the dynamic AOT technology at the client and therefore the client needs to have the shared class cache (SCC) enabled (the SCC is the repository for the AOT code). When the JITServer receives an AOT compilation request, it checks its AOT cache for a compatible compiled method body. If one is not found, the server performs the AOT compilation, sends the response to the client JVM, then serializes the compiled method and stores it in its local AOT cache, for future use. If a compatible compiled method is found, the server sends the client the serialized compiled method from its cache, thus avoiding a compilation. The client deserializes the response, stores the result in its local SCC, and loads the compiled method as a regular dynamic AOT code. To enable this feature, specify the -XX:+JITServerUseAOTCache command line option, both at the server and at the client JVM. A JITServer instance can have several AOT caches, each with its own name. This addresses the situation when client JVMs with significantly different profiles of execution use the same JITServer instance. A client JVM can indicate a specific AOT cache it wants to use by providing its name with the following command line option -XX:JITServerAOTCacheName=<cache_name> . The default is to use a nameless cache. Current limitations: The amount of memory that an AOT cache can consume at the server is not limited. The number of caches that a JITServer can hold is also not limited. The AOT cache is a non-persistent in-memory cache. If the JITServer instance ends, the cache content is lost. AOT cache entries are not shared between different JITServer instances. Caching works only for AOT compilation requests. For this reason, when JITServer AOT caching is enabled, the client JVM will attempt to generate as many AOT requests as possible. Number of concurrent clients The amount of CPU and memory resources consumed by the server is expected to increase with the number of connected clients. Finding the appropriate number of clients to connect to a server is a tricky proposition that depends on many factors: number of methods that need to be compiled by the clients, optimization levels for these compilations, how clients are started (staggered or not), how clients are shutdown (gracefully or not), etc. As a rule of thumb, you should have 10-20 JVMs simultaneously connected to a server with 1-2 GB of memory. With respect to CPU resources, in Kubernetes you might want to set a low \"request\" value at the server (1-2 vCPUs) and a larger \"limit\" value (4-8 vCPUs) in order to soak all those idle cycles. It is possible to connect even more clients to one server instance if memory and CPU resources are increased, but in general, two medium-sized server instances placed on different nodes are better than a single, larger server. Alleviating CPU congestion at the server When too many clients connect to the server, the server can become flooded with compilation requests, leading to increased compilation times and slower start-up/ramp-up for applications. It should be noted that a client JVM issues most of its compilation requests during the start-up phase and ramp-up phase of an application, when load is first applied to it. Thus, from the CPU consumption point of view what matters is the number of clients that start-up or ramp-up concurrently. To alleviate the CPU strain on the server, you can start the client JVMs in a staggered fashion, rather than all at the same time. Sometimes the staggering happens naturally; for instance, when using Kubernetes horizontal pod auto-scaling, additional application instances are launched gradually as the load increases. Another idea is to use the -Xjit:enableJITServerHeuristics command line option at the clients. When this option is present, the client JVMs share some of the compilation burden by performing the cheap compilations locally and send only expensive compilations to the server. What constitutes a cheap compilation is determined by JIT heuristics that look at the method size, optimization level and the amount of CPU and memory available to the JVM. Avoiding memory shortages at the server Roughly speaking, the server uses two types of memory: 1. \"Scratch\" memory. This is allocated during a compilation (for JIT internal data structures) and released to the operating system at the end of the compilation. 2. \"Persistent\" memory. This is used for client-session caches and gets deleted only when a client terminates gracefully (or when the JITServer purging mechanism is triggered). The total amount of scratch memory at any given moment depends on how many compilations are in progress and how expensive those compilations are. To reduce this amount, you can start the clients in a staggered fashion as suggested previously, or reduce the number of compilation threads per client. Note that the latter already happens automatically: when the server senses that it is about to run out of memory, it provides feedback to the connected clients to reduce their number of active compilation threads. To reduce the amount of persistent memory, you can use the techniques described in section Server caches . Traffic encryption Enabling network encryption can increase the CPU overhead, both at the client and at the server. For this reason, you should turn on encryption only if needed. Note that some technologies like Istio, Weave, Linkerd, Calico, Cilium already encrypt all network traffic, so using JITServer encryption might be redundant. Minimizing application stalls Usually, the compilation threads in OpenJ9 JVM execute in parallel with Java application threads. However, for correctness reasons a small number of compilations are performed synchronously, meaning that Java application threads have to wait for the compilation result before being allowed to execute the method being compiled. Since remote compilations typically take longer to complete due to network latency, application stalls caused by synchronous compilations can be more severe in a JITServer setting. If this becomes a problem, you should add the following command line option at the client: -XX:+JITServerLocalSyncCompiles This option instructs the client JVM to perform the synchronous compilations locally, at a low optimization level (thus the compilation is relatively quick), and to follow-on with remote asynchronous recompilations at a higher optimization level to avoid any performance loss. Session affinity For technical reasons, a client JVM must use a single JITServer at a time. In a Kubernetes environment, where a JITServer service can be backed up by several server instances, you can satisfy this requirement by using session affinity. Note that if a server crashes (or gets terminated by the Kubernetes controller) the clients can connect to another server instance. This scenario imposes some performance penalty because the client-session caches that the server maintains need to be built anew. Following is an example of a Kubernetes service definition that uses sessionAffinity: apiVersion: v1 kind: Service metadata: name: jitserver spec: type: ClusterIP selector: app: jitserver ports: - protocol: TCP port: 38400 targetPort: 38400 sessionAffinity: ClientIP sessionAffinityConfig: clientIP: timeoutSeconds: 86400 Resilience If the client JVM does not find a compatible server to connect to, compilations are performed locally, by the client itself. To account for the case where the server is temporarily unavailable (for example, server crash followed by Kubernetes launching another server instance), from time to time the client retries to connect to a server at the indicated address and port. The retry mechanism uses an exponential back-off where the retry interval is doubled with each unsuccessful attempt. Monitoring Performance metrics You can enable the provision of performance metrics by specifying the -XX:+JITServerMetrics command line option. After enabling this option, you can use a monitoring tool that follows the OpenMetrics standard, such as Prometheus, to collect the data by issuing an HTTP GET request to the following url: http://<jitserveraddress>:<port>/metrics . Note: There is a limit of four concurrent GET requests at any given time. You can use the -XX:JITServerMetricsSSLKey and -XX:JITServerMetricsSSLCert options to encrypt the data with TLS or SSL. For more information, including the types of metrics that are provided, see the -XX:[+|-]JITServerMetrics topic. Verbose logging You can inspect the behavior of a JITServer instance by using the OpenJ9 verbose logging facility . Note that if the name of the verbose log is not specified, the relevant information is printed to stderr. When you use the -XX:+JITServerLogConnections command line option, the server prints a message to the verbose log every time a new client JVM connects to it or disconnects from it. This is an easy way to determine that the clients are able to reach the server. Example of output: #JITServer: t= 74232 A new client (clientUID=14692403771747196083) connected. Server allocated a new client session. #JITServer: t= 74282 A new client (clientUID=2599593246759846167) connected. Server allocated a new client session. #JITServer: t= 86281 Client (clientUID=14692403771747196083) disconnected. Client session deleted The server has a heart-beat thread that periodically prints to the verbose log information related to the number of clients connected, the number of active compilation threads, the amount of CPU used, the amount of available memory and the number of times the internal server caches have been cleared. This last bit of information is important for diagnosing performance problems. The heart-beat information is enabled with the following option: -Xjit:statisticsFrequency=<period-in-ms> Example of output: #JITServer: CurrentTime: Aug 06 17:25:15 2021 #JITServer: Compilation Queue Size: 0 #JITServer: Number of clients : 2 #JITServer: Total compilation threads : 63 #JITServer: Active compilation threads : 2 #JITServer: Physical memory available: 14299 MB #JITServer: CpuLoad 206% (AvgUsage 25%) JvmCpu 113% ... A value greater than 0 for the Compilation Queue Size is a sign that the server is overloaded. Compilation requests that wait in the compilation queue face greater delays and run the risk of exceeding network timeouts. To avoid this scenario, you can reduce the number of connected clients, use the techniques described in section Alleviating CPU congestion at the server , or increase the number of compilation threads at the server by using the -XcompilationThreads option. Increasing the maximum number of client threads can improve performance in high network latency settings because there can be more in-progress concurrent compilation requests. Increasing the number of threads at the server can improve performance if the server has many CPU cores available and serves a large number of clients concurrently. More detailed diagnostics can be obtained with the option -Xjit:verbose={JITServer},verbose={compilePerformance} , which is typically used for debugging server behavior.","title":"JITServer tuning"},{"location":"jitserver_tuning/#jitserver-tuning-and-practical-considerations","text":"","title":"JITServer tuning and practical considerations"},{"location":"jitserver_tuning/#server-caches","text":"","title":"Server caches"},{"location":"jitserver_tuning/#client-session-caches","text":"Multiple client JVMs can be connected at the same time to a single JIT server. For each client, the server maintains a client-session cache with information about the environment the client is running in (Java classes, class hierarchy, profiling information, JVM options, etc.). Typically, the information in these caches is kept separately, per client. However, if you specify the -XX:+JITServerShareROMClasses option, the read-only part of the Java classes (ROMClasses in Eclipse OpenJ9\u2122 parlance) is shared between the different clients. This option can generate memory savings at the server when the connected clients run identical or similar Java applications. The client-session caches are deleted when the clients terminate, but this can happen only if the clients are shutdown gracefully, giving them the opportunity to send a termination message to the server. To address the scenario of clients ending abruptly, the server also deletes the cache for a client that hasn\u2019t issued a compilation request for 1000 minutes, or 5 minutes under memory pressure. If needed, you can change these values with the following options: -Xjit:oldAge=<time-in-ms>,oldAgeUnderLowMemory=<time-in-ms>","title":"Client-session caches"},{"location":"jitserver_tuning/#jitserver-aot-cache","text":"The JITServer technology can cache AOT compiled methods at the server. The JITServer can, therefore, avoid carrying out an AOT compilation when a compatible AOT method body already exists in the cache, thereby saving CPU resource and improving remote compilation latency. This mechanism works in conjunction with the dynamic AOT technology at the client and therefore the client needs to have the shared class cache (SCC) enabled (the SCC is the repository for the AOT code). When the JITServer receives an AOT compilation request, it checks its AOT cache for a compatible compiled method body. If one is not found, the server performs the AOT compilation, sends the response to the client JVM, then serializes the compiled method and stores it in its local AOT cache, for future use. If a compatible compiled method is found, the server sends the client the serialized compiled method from its cache, thus avoiding a compilation. The client deserializes the response, stores the result in its local SCC, and loads the compiled method as a regular dynamic AOT code. To enable this feature, specify the -XX:+JITServerUseAOTCache command line option, both at the server and at the client JVM. A JITServer instance can have several AOT caches, each with its own name. This addresses the situation when client JVMs with significantly different profiles of execution use the same JITServer instance. A client JVM can indicate a specific AOT cache it wants to use by providing its name with the following command line option -XX:JITServerAOTCacheName=<cache_name> . The default is to use a nameless cache. Current limitations: The amount of memory that an AOT cache can consume at the server is not limited. The number of caches that a JITServer can hold is also not limited. The AOT cache is a non-persistent in-memory cache. If the JITServer instance ends, the cache content is lost. AOT cache entries are not shared between different JITServer instances. Caching works only for AOT compilation requests. For this reason, when JITServer AOT caching is enabled, the client JVM will attempt to generate as many AOT requests as possible.","title":"JITServer AOT cache"},{"location":"jitserver_tuning/#number-of-concurrent-clients","text":"The amount of CPU and memory resources consumed by the server is expected to increase with the number of connected clients. Finding the appropriate number of clients to connect to a server is a tricky proposition that depends on many factors: number of methods that need to be compiled by the clients, optimization levels for these compilations, how clients are started (staggered or not), how clients are shutdown (gracefully or not), etc. As a rule of thumb, you should have 10-20 JVMs simultaneously connected to a server with 1-2 GB of memory. With respect to CPU resources, in Kubernetes you might want to set a low \"request\" value at the server (1-2 vCPUs) and a larger \"limit\" value (4-8 vCPUs) in order to soak all those idle cycles. It is possible to connect even more clients to one server instance if memory and CPU resources are increased, but in general, two medium-sized server instances placed on different nodes are better than a single, larger server.","title":"Number of concurrent clients"},{"location":"jitserver_tuning/#alleviating-cpu-congestion-at-the-server","text":"When too many clients connect to the server, the server can become flooded with compilation requests, leading to increased compilation times and slower start-up/ramp-up for applications. It should be noted that a client JVM issues most of its compilation requests during the start-up phase and ramp-up phase of an application, when load is first applied to it. Thus, from the CPU consumption point of view what matters is the number of clients that start-up or ramp-up concurrently. To alleviate the CPU strain on the server, you can start the client JVMs in a staggered fashion, rather than all at the same time. Sometimes the staggering happens naturally; for instance, when using Kubernetes horizontal pod auto-scaling, additional application instances are launched gradually as the load increases. Another idea is to use the -Xjit:enableJITServerHeuristics command line option at the clients. When this option is present, the client JVMs share some of the compilation burden by performing the cheap compilations locally and send only expensive compilations to the server. What constitutes a cheap compilation is determined by JIT heuristics that look at the method size, optimization level and the amount of CPU and memory available to the JVM.","title":"Alleviating CPU congestion at the server"},{"location":"jitserver_tuning/#avoiding-memory-shortages-at-the-server","text":"Roughly speaking, the server uses two types of memory: 1. \"Scratch\" memory. This is allocated during a compilation (for JIT internal data structures) and released to the operating system at the end of the compilation. 2. \"Persistent\" memory. This is used for client-session caches and gets deleted only when a client terminates gracefully (or when the JITServer purging mechanism is triggered). The total amount of scratch memory at any given moment depends on how many compilations are in progress and how expensive those compilations are. To reduce this amount, you can start the clients in a staggered fashion as suggested previously, or reduce the number of compilation threads per client. Note that the latter already happens automatically: when the server senses that it is about to run out of memory, it provides feedback to the connected clients to reduce their number of active compilation threads. To reduce the amount of persistent memory, you can use the techniques described in section Server caches .","title":"Avoiding memory shortages at the server"},{"location":"jitserver_tuning/#traffic-encryption","text":"Enabling network encryption can increase the CPU overhead, both at the client and at the server. For this reason, you should turn on encryption only if needed. Note that some technologies like Istio, Weave, Linkerd, Calico, Cilium already encrypt all network traffic, so using JITServer encryption might be redundant.","title":"Traffic encryption"},{"location":"jitserver_tuning/#minimizing-application-stalls","text":"Usually, the compilation threads in OpenJ9 JVM execute in parallel with Java application threads. However, for correctness reasons a small number of compilations are performed synchronously, meaning that Java application threads have to wait for the compilation result before being allowed to execute the method being compiled. Since remote compilations typically take longer to complete due to network latency, application stalls caused by synchronous compilations can be more severe in a JITServer setting. If this becomes a problem, you should add the following command line option at the client: -XX:+JITServerLocalSyncCompiles This option instructs the client JVM to perform the synchronous compilations locally, at a low optimization level (thus the compilation is relatively quick), and to follow-on with remote asynchronous recompilations at a higher optimization level to avoid any performance loss.","title":"Minimizing application stalls"},{"location":"jitserver_tuning/#session-affinity","text":"For technical reasons, a client JVM must use a single JITServer at a time. In a Kubernetes environment, where a JITServer service can be backed up by several server instances, you can satisfy this requirement by using session affinity. Note that if a server crashes (or gets terminated by the Kubernetes controller) the clients can connect to another server instance. This scenario imposes some performance penalty because the client-session caches that the server maintains need to be built anew. Following is an example of a Kubernetes service definition that uses sessionAffinity: apiVersion: v1 kind: Service metadata: name: jitserver spec: type: ClusterIP selector: app: jitserver ports: - protocol: TCP port: 38400 targetPort: 38400 sessionAffinity: ClientIP sessionAffinityConfig: clientIP: timeoutSeconds: 86400","title":"Session affinity"},{"location":"jitserver_tuning/#resilience","text":"If the client JVM does not find a compatible server to connect to, compilations are performed locally, by the client itself. To account for the case where the server is temporarily unavailable (for example, server crash followed by Kubernetes launching another server instance), from time to time the client retries to connect to a server at the indicated address and port. The retry mechanism uses an exponential back-off where the retry interval is doubled with each unsuccessful attempt.","title":"Resilience"},{"location":"jitserver_tuning/#monitoring","text":"","title":"Monitoring"},{"location":"jitserver_tuning/#performance-metrics","text":"You can enable the provision of performance metrics by specifying the -XX:+JITServerMetrics command line option. After enabling this option, you can use a monitoring tool that follows the OpenMetrics standard, such as Prometheus, to collect the data by issuing an HTTP GET request to the following url: http://<jitserveraddress>:<port>/metrics . Note: There is a limit of four concurrent GET requests at any given time. You can use the -XX:JITServerMetricsSSLKey and -XX:JITServerMetricsSSLCert options to encrypt the data with TLS or SSL. For more information, including the types of metrics that are provided, see the -XX:[+|-]JITServerMetrics topic.","title":"Performance metrics"},{"location":"jitserver_tuning/#verbose-logging","text":"You can inspect the behavior of a JITServer instance by using the OpenJ9 verbose logging facility . Note that if the name of the verbose log is not specified, the relevant information is printed to stderr. When you use the -XX:+JITServerLogConnections command line option, the server prints a message to the verbose log every time a new client JVM connects to it or disconnects from it. This is an easy way to determine that the clients are able to reach the server. Example of output: #JITServer: t= 74232 A new client (clientUID=14692403771747196083) connected. Server allocated a new client session. #JITServer: t= 74282 A new client (clientUID=2599593246759846167) connected. Server allocated a new client session. #JITServer: t= 86281 Client (clientUID=14692403771747196083) disconnected. Client session deleted The server has a heart-beat thread that periodically prints to the verbose log information related to the number of clients connected, the number of active compilation threads, the amount of CPU used, the amount of available memory and the number of times the internal server caches have been cleared. This last bit of information is important for diagnosing performance problems. The heart-beat information is enabled with the following option: -Xjit:statisticsFrequency=<period-in-ms> Example of output: #JITServer: CurrentTime: Aug 06 17:25:15 2021 #JITServer: Compilation Queue Size: 0 #JITServer: Number of clients : 2 #JITServer: Total compilation threads : 63 #JITServer: Active compilation threads : 2 #JITServer: Physical memory available: 14299 MB #JITServer: CpuLoad 206% (AvgUsage 25%) JvmCpu 113% ... A value greater than 0 for the Compilation Queue Size is a sign that the server is overloaded. Compilation requests that wait in the compilation queue face greater delays and run the risk of exceeding network timeouts. To avoid this scenario, you can reduce the number of connected clients, use the techniques described in section Alleviating CPU congestion at the server , or increase the number of compilation threads at the server by using the -XcompilationThreads option. Increasing the maximum number of client threads can improve performance in high network latency settings because there can be more in-progress concurrent compilation requests. Increasing the number of threads at the server can improve performance if the server has many CPU cores available and serves a large number of clients concurrently. More detailed diagnostics can be obtained with the option -Xjit:verbose={JITServer},verbose={compilePerformance} , which is typically used for debugging server behavior.","title":"Verbose logging"},{"location":"legal/","text":"Legal License agreement, notices, copyright, and trademark information for the user documentation. License agreement See License Notices See Notices Copyright information Eclipse OpenJ9\u2122 documentation is subject to the following copyright: Copyright (c) 2017, 2022 IBM Corp. Trademarks IBM, the IBM logo, and ibm.com are trademarks or registered trademarks of International Business Machines Corp., registered in many jurisdictions worldwide. Other product and service names might be trademarks of IBM or other companies. A current list of IBM trademarks is available on the Web at \"Copyright and trademark information\" here . Java and all Java-based trademarks and logos are trademarks or registered trademarks of Oracle and/or its affiliates. Linux is a registered trademark of Linus Torvalds in the United States, other countries, or both. Microsoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or both.","title":"Legal"},{"location":"legal/#legal","text":"License agreement, notices, copyright, and trademark information for the user documentation.","title":"Legal"},{"location":"legal/#license-agreement","text":"See License","title":"License agreement"},{"location":"legal/#notices","text":"See Notices","title":"Notices"},{"location":"legal/#copyright-information","text":"Eclipse OpenJ9\u2122 documentation is subject to the following copyright: Copyright (c) 2017, 2022 IBM Corp.","title":"Copyright information"},{"location":"legal/#trademarks","text":"IBM, the IBM logo, and ibm.com are trademarks or registered trademarks of International Business Machines Corp., registered in many jurisdictions worldwide. Other product and service names might be trademarks of IBM or other companies. A current list of IBM trademarks is available on the Web at \"Copyright and trademark information\" here . Java and all Java-based trademarks and logos are trademarks or registered trademarks of Oracle and/or its affiliates. Linux is a registered trademark of Linus Torvalds in the United States, other countries, or both. Microsoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or both.","title":"Trademarks"},{"location":"messages_intro/","text":"Eclipse OpenJ9 VM messages Messages are issued by the Eclipse OpenJ9\u2122 virtual machine (VM) in response to certain conditions. Understanding what the messages mean can help you with problem determination. Message categories There are three main categories of message: Information Information messages provide information about VM processing. For example, a dump information message is typically issued when a dump agent requests a dump. Warning Warning messages are issued by the VM to indicate conditions that might need user intervention. Error Error messages are issued by the VM when normal processing cannot proceed, because of unexpected conditions. OpenJ9 virtual machine messages have the following format: JVM<type><number><code> where: JVM is a standard prefix. <type> refers to the VM subcomponent that issued the message. <number> is a unique numerical number. <code> is one of the following codes: I - Information message W - Warning message E - Error message These messages can help you with problem determination. By default, all error and some information messages are routed to the system log and also written to stderr or stdout . The specific information messages are JVMDUMP039I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the VM. To route additional message types to the system log, or turn off message logging to the system log, use the -Xsyslog option. The -Xsyslog option does not affect messages written to the standard error stream (stderr). See OpenJ9 command-line options . Note: The -Xsyslog option replaces the -Xlog option in OpenJ9 version 0.24.0. Finding logged messages Logged messages can be found in different locations, according to platform. Finding AIX messages On AIX\u00ae, messages are logged by the syslog daemon ( /usr/sbin/syslogd ). Logged messages are written to the syslog file that is configured in /etc/syslog.conf . If the syslog daemon is not running, logged messages are lost. You can redirect messages from the syslog daemon to the AIX error log facility by performing the following configuration steps: Set up a redirect in the file syslog.conf so that syslog messages are sent to the error log, by adding the following line: user.debug errlog If syslogd is already running, reload the updated configuration by running the following command: refresh -s syslogd The updated configuration is used each time syslogd starts. 4. Use the AIX errpt command or the System Management Interface Tool (SMIT) to read the messages sent to the error log. For more information about AIX logging, see: Error-logging overview . Finding Linux messages On Linux\u00ae, messages are logged by the syslog daemon. To find where messages are logged, check the syslog configuration file. Finding macOS messages On macOS\u00ae, messages are logged by the syslog daemon. However, on Sierra and High Sierra, syslog does not work. If /var/log/system.log is not available, Console.app can be used instead. Finding Windows messages On Windows\u2122, messages are logged in the application events section of the event viewer. Finding z/OS messages On z/OS\u00ae, messages are sent to the operator console. To see the messages, go from the ispf panel to the sdsf panel, then open the log panel. Obtaining detailed message descriptions Detailed message information is available to help with problem diagnosis. Understanding the warning or error message issued by the VM can help you diagnose problems. All warning and error messages issued by the VM are listed by type in the messages guide: IBM\u00ae VM messages . The messages, error codes, and exit codes in this guide apply to multiple versions of the VM. Note: If the VM fills all available memory, the message number might be produced without a description for the error that caused the problem. Look for the message number in the relevant section of the J9 VM Messages guide to see the message description and the additional information provided.","title":"OpenJ9 messages"},{"location":"messages_intro/#eclipse-openj9-vm-messages","text":"Messages are issued by the Eclipse OpenJ9\u2122 virtual machine (VM) in response to certain conditions. Understanding what the messages mean can help you with problem determination.","title":"Eclipse OpenJ9 VM messages"},{"location":"messages_intro/#message-categories","text":"There are three main categories of message: Information Information messages provide information about VM processing. For example, a dump information message is typically issued when a dump agent requests a dump. Warning Warning messages are issued by the VM to indicate conditions that might need user intervention. Error Error messages are issued by the VM when normal processing cannot proceed, because of unexpected conditions. OpenJ9 virtual machine messages have the following format: JVM<type><number><code> where: JVM is a standard prefix. <type> refers to the VM subcomponent that issued the message. <number> is a unique numerical number. <code> is one of the following codes: I - Information message W - Warning message E - Error message These messages can help you with problem determination. By default, all error and some information messages are routed to the system log and also written to stderr or stdout . The specific information messages are JVMDUMP039I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the VM. To route additional message types to the system log, or turn off message logging to the system log, use the -Xsyslog option. The -Xsyslog option does not affect messages written to the standard error stream (stderr). See OpenJ9 command-line options . Note: The -Xsyslog option replaces the -Xlog option in OpenJ9 version 0.24.0.","title":"Message categories"},{"location":"messages_intro/#finding-logged-messages","text":"Logged messages can be found in different locations, according to platform.","title":"Finding logged messages"},{"location":"messages_intro/#finding-aix-messages","text":"On AIX\u00ae, messages are logged by the syslog daemon ( /usr/sbin/syslogd ). Logged messages are written to the syslog file that is configured in /etc/syslog.conf . If the syslog daemon is not running, logged messages are lost. You can redirect messages from the syslog daemon to the AIX error log facility by performing the following configuration steps: Set up a redirect in the file syslog.conf so that syslog messages are sent to the error log, by adding the following line: user.debug errlog If syslogd is already running, reload the updated configuration by running the following command: refresh -s syslogd The updated configuration is used each time syslogd starts. 4. Use the AIX errpt command or the System Management Interface Tool (SMIT) to read the messages sent to the error log. For more information about AIX logging, see: Error-logging overview .","title":"Finding AIX messages"},{"location":"messages_intro/#finding-linux-messages","text":"On Linux\u00ae, messages are logged by the syslog daemon. To find where messages are logged, check the syslog configuration file.","title":"Finding Linux messages"},{"location":"messages_intro/#finding-macos-messages","text":"On macOS\u00ae, messages are logged by the syslog daemon. However, on Sierra and High Sierra, syslog does not work. If /var/log/system.log is not available, Console.app can be used instead.","title":"Finding macOS messages"},{"location":"messages_intro/#finding-windows-messages","text":"On Windows\u2122, messages are logged in the application events section of the event viewer.","title":"Finding Windows messages"},{"location":"messages_intro/#finding-zos-messages","text":"On z/OS\u00ae, messages are sent to the operator console. To see the messages, go from the ispf panel to the sdsf panel, then open the log panel.","title":"Finding z/OS messages"},{"location":"messages_intro/#obtaining-detailed-message-descriptions","text":"Detailed message information is available to help with problem diagnosis. Understanding the warning or error message issued by the VM can help you diagnose problems. All warning and error messages issued by the VM are listed by type in the messages guide: IBM\u00ae VM messages . The messages, error codes, and exit codes in this guide apply to multiple versions of the VM. Note: If the VM fills all available memory, the message number might be produced without a description for the error that caused the problem. Look for the message number in the relevant section of the J9 VM Messages guide to see the message description and the additional information provided.","title":"Obtaining detailed message descriptions"},{"location":"migrating11to17/","text":"Migrating from Java 11 to Java 17 Support for OpenJDK 17 was added in Eclipse OpenJ9\u2122 version 0.29.1. The following new OpenJ9 changes apply when OpenJ9 is built with Java SE 17 class libraries. This information exists elsewhere in the documentation but is summarized here for convenience. Support for JDK enhancement proposals (JEP) The new JEPs that are supported are listed in the following topics: JDK 12: What's new in version 0.13.0 JDK 13: What's new in version 0.16.0 JDK 14: What's new in version 0.19.0 JDK 15: What's new in version 0.22.0 JDK 16: What's new in version 0.25.0 JDK 17: What's new in version 0.29.1 New OpenJ9 features and changes The following table lists the new OpenJ9 features and notable changes with the OpenJ9 release in which they were added: Features and changes OpenJ9 release Linux builds for all platforms use gcc 10.3 instead of gcc 7.5. See the list of build environments . 0.33.0 The default operating system stack size on x64 platforms is increased from 256 KB to 512 KB to accommodate vector support. You can change the operating system stack size by using the -Xmso option. 0.33.0","title":"Migrating from Java 11 to Java 17"},{"location":"migrating11to17/#migrating-from-java-11-to-java-17","text":"Support for OpenJDK 17 was added in Eclipse OpenJ9\u2122 version 0.29.1. The following new OpenJ9 changes apply when OpenJ9 is built with Java SE 17 class libraries. This information exists elsewhere in the documentation but is summarized here for convenience.","title":"Migrating from Java 11 to Java 17"},{"location":"migrating11to17/#support-for-jdk-enhancement-proposals-jep","text":"The new JEPs that are supported are listed in the following topics: JDK 12: What's new in version 0.13.0 JDK 13: What's new in version 0.16.0 JDK 14: What's new in version 0.19.0 JDK 15: What's new in version 0.22.0 JDK 16: What's new in version 0.25.0 JDK 17: What's new in version 0.29.1","title":"Support for JDK enhancement proposals (JEP)"},{"location":"migrating11to17/#new-openj9-features-and-changes","text":"The following table lists the new OpenJ9 features and notable changes with the OpenJ9 release in which they were added: Features and changes OpenJ9 release Linux builds for all platforms use gcc 10.3 instead of gcc 7.5. See the list of build environments . 0.33.0 The default operating system stack size on x64 platforms is increased from 256 KB to 512 KB to accommodate vector support. You can change the operating system stack size by using the -Xmso option. 0.33.0","title":"New OpenJ9 features and changes"},{"location":"migrating8to11/","text":"Migrating from Java 8 to Java 11 Support for OpenJDK 11 was added in Eclipse OpenJ9\u2122 version 0.10.0. The following new OpenJ9 features and notable changes apply when OpenJ9 is built with Java SE 11 class libraries. This information exists elsewhere in the documentation but is summarized here for convenience. Support for JDK enhancement proposals (JEP) The new JEPs that are supported are listed in the following topics: JDK 9: What's new in version 0.9.0 JDK 10: What's new in version 0.9.0 JDK 11: What's new in version 0.10.0 New OpenJ9 features and changes The following table lists the new OpenJ9 features and notable changes with the OpenJ9 release in which they were added: Features and changes OpenJ9 release The path that is specified by the default -Xoptionsfile value is the <java_home>/lib directory, where <java_home> is the directory for your runtime environment. For Java 8, the path is the VM directory that is listed in Directory conventions . First release Low-overhead heap profiling is supported. JEP 331 provides a mechanism for sampling Java heap allocations with a low overhead via the JVM Tool Interface (JVMTI). Restrictions: JEP 331 is implemented for OpenJ9 with the following limitations: The balanced and metronome garbage collection policies are not supported. The JEP331 JVMTI agent and the Health Center agent both set a sampling interval, which by default is different. If both agents are used at the same time the Health Center agent will get incorrect results, unless the sampling intervals are adjusted to use the same value. 0.15.0 OpenSSL support for the ChaCha20 and ChaCha20-Poly1305 algorithms is available. The version of OpenSSL must be version 1.1.x or later. For more information, see -Djdk.nativeChaCha20 . 0.15.0 The -verbose:module option, which writes information to stderr for each module that is loaded and unloaded, is now supported. 0.25.0 The default value of the -XX:MaxDirectMemorySize option, which limits the amount of heap memory that is used for direct byte buffers, is the same as the maximum heap size. For JDK 8, the VM default value is 87.5% of the maximum heap size. 0.32.0","title":"Migrating from Java 8 to Java 11"},{"location":"migrating8to11/#migrating-from-java-8-to-java-11","text":"Support for OpenJDK 11 was added in Eclipse OpenJ9\u2122 version 0.10.0. The following new OpenJ9 features and notable changes apply when OpenJ9 is built with Java SE 11 class libraries. This information exists elsewhere in the documentation but is summarized here for convenience.","title":"Migrating from Java 8 to Java 11"},{"location":"migrating8to11/#support-for-jdk-enhancement-proposals-jep","text":"The new JEPs that are supported are listed in the following topics: JDK 9: What's new in version 0.9.0 JDK 10: What's new in version 0.9.0 JDK 11: What's new in version 0.10.0","title":"Support for JDK enhancement proposals (JEP)"},{"location":"migrating8to11/#new-openj9-features-and-changes","text":"The following table lists the new OpenJ9 features and notable changes with the OpenJ9 release in which they were added: Features and changes OpenJ9 release The path that is specified by the default -Xoptionsfile value is the <java_home>/lib directory, where <java_home> is the directory for your runtime environment. For Java 8, the path is the VM directory that is listed in Directory conventions . First release Low-overhead heap profiling is supported. JEP 331 provides a mechanism for sampling Java heap allocations with a low overhead via the JVM Tool Interface (JVMTI). Restrictions: JEP 331 is implemented for OpenJ9 with the following limitations: The balanced and metronome garbage collection policies are not supported. The JEP331 JVMTI agent and the Health Center agent both set a sampling interval, which by default is different. If both agents are used at the same time the Health Center agent will get incorrect results, unless the sampling intervals are adjusted to use the same value. 0.15.0 OpenSSL support for the ChaCha20 and ChaCha20-Poly1305 algorithms is available. The version of OpenSSL must be version 1.1.x or later. For more information, see -Djdk.nativeChaCha20 . 0.15.0 The -verbose:module option, which writes information to stderr for each module that is loaded and unloaded, is now supported. 0.25.0 The default value of the -XX:MaxDirectMemorySize option, which limits the amount of heap memory that is used for direct byte buffers, is the same as the maximum heap size. For JDK 8, the VM default value is 87.5% of the maximum heap size. 0.32.0","title":"New OpenJ9 features and changes"},{"location":"openj9_defaults/","text":"Default settings for the Eclipse OpenJ9\u2122 VM The following tables provide a quick reference to the default settings for the VM when it is first installed. The last 2 columns show whether the default setting can be changed by a command-line parameter or an environment variable. Note that if both are set, the command-line parameter always takes precedence. VM setting Default Command line Env. variable Javadump Enabled yes yes Heapdump Disabled yes yes System dump Enabled yes yes Snap traces Enabled yes yes JIT dump Enabled yes yes Verbose output Disabled yes no Compressed references (See Note 1 ) yes yes Boot classpath search Disabled yes no JNI checks Disabled yes no Remote debugging Disabled yes no Strict conformance checks Disabled yes no Quickstart Disabled yes no Remote debug info server Disabled yes no Reduced signaling Disabled yes no Signal handler chaining Enabled yes no Classpath Not set yes yes Class data sharing Disabled yes no Accessibility support Enabled no yes JIT compiler Enabled yes yes AOT compiler (See Note 2 ) Enabled yes no JIT debug options Disabled yes no Java2D max size of fonts with algorithmic bold 14 point no yes Java2D use rendered bitmaps in scalable fonts Enabled no yes Java2D freetype font rasterizing Enabled no yes Java2D use AWT fonts Disabled no yes Notes: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: Enabled for -Xmx values \u2264 57 GB, otherwise disabled. On z/OS\u00ae: Enabled for -Xmx values \u2264 25 GB, otherwise disabled. With APAR OA49416 , enabled for -Xmx values \u2264 57 GB. AOT is not used by the VM unless shared classes are also enabled. VM setting AIX Linux macOS Windows z/OS Command line Env. variable Default locale None None None N/A None no yes Time to wait before starting plug-in N/A Zero N/A N/A N/A no yes Temporary directory /tmp /tmp /tmp c:\\temp /tmp no yes Plug-in redirection None None None N/A None no yes IM switching Disabled Disabled Disabled N/A Disabled no yes IM modifiers Disabled Disabled Disabled N/A Disabled no yes Thread model N/A N/A N/A N/A Native no yes Initial stack size for Java Threads (32/64-bit) . Use -Xiss<size> 2 KB 2 KB 2 KB 2 KB 2 KB yes no Maximum stack size for Java Threads (32-bit) . Use -Xss<size> 320 KB 320 KB N/A 320 KB 320 KB yes no Maximum stack size for Java Threads (64-bit) . Use -Xss<size> 1024 KB 1024 KB 1024 KB 1024 KB 1024 KB yes no Stack size for OS Threads (32-bit) . Use -Xmso<size> 256 KB 256 KB N/A 32 KB 256 KB yes no Stack size for OS Threads (64-bit) . Use -Xmso<size> 512 KB 512 KB (256 KB on IBM Z\u00ae) Earlier Java versions: 256 KB (512 KB on PPC) 512 KB Earlier Java versions: 256 KB 512 KB Earlier Java versions: 256 KB 1 MB yes no Initial heap size. Use -Xms<size> 8 MB 8 MB 8 MB 8 MB 8 MB yes no Maximum Java heap size. Use -Xmx<size> See Notes See Notes See Notes See Notes See Notes yes no Page size for the Java object heap and code cache (For restrictions, see the -Xlp:codecache and -Xlp:objectheap options). Operating system default Architecture: x86: 2MB, IBM Z: 1MB, Other architectures: Operating system default 4 KB Operating system default 1M pageable yes no Notes: The default value of -Xmx : The value is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. On Linux\u00ae sytems, if the VM is running in a container and -XX:+UseContainerSupport is enabled, the value is 75% of the container memory limit, with a maximum of 25 GB. However, if the container memory limit is less than 1 GB, the value is 50% of the container memory limit. If the container memory limit is between 1GB and 2GB, the value is the container memory limit minus 512 MB. The default value is capped at 25 GB, which is the limit of heap size for 3-bit shift of compressed references (see -Xcompressedrefs ), to prevent silent switching to 4-bit shift of compressed references, which has possible performance penalties. You can use the -Xmx option to overwrite the 25 GB limit. If you have set the -XX:+OriginalJDK8HeapSizeCompatibilityMode option for compatibility with earlier releases, the value is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Available memory is defined as being the smallest of two values: The real or physical memory or the RLIMIT_AS value.","title":"Default settings"},{"location":"openj9_defaults/#default-settings-for-the-eclipse-openj9-vm","text":"The following tables provide a quick reference to the default settings for the VM when it is first installed. The last 2 columns show whether the default setting can be changed by a command-line parameter or an environment variable. Note that if both are set, the command-line parameter always takes precedence. VM setting Default Command line Env. variable Javadump Enabled yes yes Heapdump Disabled yes yes System dump Enabled yes yes Snap traces Enabled yes yes JIT dump Enabled yes yes Verbose output Disabled yes no Compressed references (See Note 1 ) yes yes Boot classpath search Disabled yes no JNI checks Disabled yes no Remote debugging Disabled yes no Strict conformance checks Disabled yes no Quickstart Disabled yes no Remote debug info server Disabled yes no Reduced signaling Disabled yes no Signal handler chaining Enabled yes no Classpath Not set yes yes Class data sharing Disabled yes no Accessibility support Enabled no yes JIT compiler Enabled yes yes AOT compiler (See Note 2 ) Enabled yes no JIT debug options Disabled yes no Java2D max size of fonts with algorithmic bold 14 point no yes Java2D use rendered bitmaps in scalable fonts Enabled no yes Java2D freetype font rasterizing Enabled no yes Java2D use AWT fonts Disabled no yes Notes: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: Enabled for -Xmx values \u2264 57 GB, otherwise disabled. On z/OS\u00ae: Enabled for -Xmx values \u2264 25 GB, otherwise disabled. With APAR OA49416 , enabled for -Xmx values \u2264 57 GB. AOT is not used by the VM unless shared classes are also enabled. VM setting AIX Linux macOS Windows z/OS Command line Env. variable Default locale None None None N/A None no yes Time to wait before starting plug-in N/A Zero N/A N/A N/A no yes Temporary directory /tmp /tmp /tmp c:\\temp /tmp no yes Plug-in redirection None None None N/A None no yes IM switching Disabled Disabled Disabled N/A Disabled no yes IM modifiers Disabled Disabled Disabled N/A Disabled no yes Thread model N/A N/A N/A N/A Native no yes Initial stack size for Java Threads (32/64-bit) . Use -Xiss<size> 2 KB 2 KB 2 KB 2 KB 2 KB yes no Maximum stack size for Java Threads (32-bit) . Use -Xss<size> 320 KB 320 KB N/A 320 KB 320 KB yes no Maximum stack size for Java Threads (64-bit) . Use -Xss<size> 1024 KB 1024 KB 1024 KB 1024 KB 1024 KB yes no Stack size for OS Threads (32-bit) . Use -Xmso<size> 256 KB 256 KB N/A 32 KB 256 KB yes no Stack size for OS Threads (64-bit) . Use -Xmso<size> 512 KB 512 KB (256 KB on IBM Z\u00ae) Earlier Java versions: 256 KB (512 KB on PPC) 512 KB Earlier Java versions: 256 KB 512 KB Earlier Java versions: 256 KB 1 MB yes no Initial heap size. Use -Xms<size> 8 MB 8 MB 8 MB 8 MB 8 MB yes no Maximum Java heap size. Use -Xmx<size> See Notes See Notes See Notes See Notes See Notes yes no Page size for the Java object heap and code cache (For restrictions, see the -Xlp:codecache and -Xlp:objectheap options). Operating system default Architecture: x86: 2MB, IBM Z: 1MB, Other architectures: Operating system default 4 KB Operating system default 1M pageable yes no Notes: The default value of -Xmx : The value is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. On Linux\u00ae sytems, if the VM is running in a container and -XX:+UseContainerSupport is enabled, the value is 75% of the container memory limit, with a maximum of 25 GB. However, if the container memory limit is less than 1 GB, the value is 50% of the container memory limit. If the container memory limit is between 1GB and 2GB, the value is the container memory limit minus 512 MB. The default value is capped at 25 GB, which is the limit of heap size for 3-bit shift of compressed references (see -Xcompressedrefs ), to prevent silent switching to 4-bit shift of compressed references, which has possible performance penalties. You can use the -Xmx option to overwrite the 25 GB limit. If you have set the -XX:+OriginalJDK8HeapSizeCompatibilityMode option for compatibility with earlier releases, the value is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Available memory is defined as being the smallest of two values: The real or physical memory or the RLIMIT_AS value.","title":"Default settings for the Eclipse OpenJ9&trade; VM"},{"location":"openj9_directories/","text":"Directory conventions The following tables provide a quick reference to the Eclipse OpenJ9\u2122 VM directory location on different Java\u2122 versions and different platform architectures. Some pages refer to the VM directory location as <vm_dir> . Operating system Java 8 Java 11 and later AIX\u00ae <install_dir>/jre/lib/ppc[64]/default <install_dir>/ Linux\u00ae <install_dir>/jre/lib/<arch>/default <install_dir>/ macOS\u00ae <install_dir>/jre/lib/default <install_dir>/ Windows\u2122 <install_dir>\\jre\\bin\\default <install_dir>\\ z/OS\u00ae <install_dir>/jre/lib/s390[x]/default <install_dir>/ Where: <install_dir> is your JDK installation directory. <arch> depends on the architecture your Linux distribution is running on. See the following table for possible values: Architecture Value of <arch> x86 32-bit i386 x86 64-bit x86-64 IBM POWER\u00ae 32-bit (Big Endian) ppc IBM POWER 64-bit (Big Endian) ppc64 IBM POWER 64-bit (Little Endian) ppc64le IBM Z\u00ae 31-bit s390 IBM Z 64-bit s390x","title":"Directory conventions"},{"location":"openj9_directories/#directory-conventions","text":"The following tables provide a quick reference to the Eclipse OpenJ9\u2122 VM directory location on different Java\u2122 versions and different platform architectures. Some pages refer to the VM directory location as <vm_dir> . Operating system Java 8 Java 11 and later AIX\u00ae <install_dir>/jre/lib/ppc[64]/default <install_dir>/ Linux\u00ae <install_dir>/jre/lib/<arch>/default <install_dir>/ macOS\u00ae <install_dir>/jre/lib/default <install_dir>/ Windows\u2122 <install_dir>\\jre\\bin\\default <install_dir>\\ z/OS\u00ae <install_dir>/jre/lib/s390[x]/default <install_dir>/ Where: <install_dir> is your JDK installation directory. <arch> depends on the architecture your Linux distribution is running on. See the following table for possible values: Architecture Value of <arch> x86 32-bit i386 x86 64-bit x86-64 IBM POWER\u00ae 32-bit (Big Endian) ppc IBM POWER 64-bit (Big Endian) ppc64 IBM POWER 64-bit (Little Endian) ppc64le IBM Z\u00ae 31-bit s390 IBM Z 64-bit s390x","title":"Directory conventions"},{"location":"openj9_newuser/","text":"New to Eclipse OpenJ9? The Eclipse OpenJ9\u2122 virtual machine (VM) implements the Java Virtual Machine Specification . Most Java applications should run on an OpenJDK that contains the OpenJ9 VM without changing anything. However, because it is an independent implementation there are some differences compared to the HotSpot VM, which is the default OpenJDK VM and is also included in an Oracle JDK. Command-line options Although OpenJ9 implements its own command-line interface, many HotSpot options are recognized and accepted by the VM for compatibility. Any -XX: options that are not recognized by the VM are ignored by default, which prevents an application failing to start. You can turn off this behavior with the -XX:-IgnoreUnrecognizedXXColonOptions option. For a list of compatible options, equivalent options, and options that need to be set for compatibility, see Switching to OpenJ9 . Garbage collection policies Eclipse OpenJ9 has a number of garbage collection (GC) policies designed around different types of applications and workloads. By default, OpenJ9 uses the Generational Concurrent ( gencon ) GC policy, which is best suited for transactional applications that have many short-lived objects. The policy aims to minimize GC pause times without compromising throughput. If you are using Java 8, the gencon policy is similar to the HotSpot CMS (concurrent mark sweep). If you are using Java 11, the OpenJ9 balanced ( balanced ) policy is most similar to the default HotSpot policy. If you have a different type of workload, you might want to select a different GC policy. For details about the available policies and when to choose them, see Garbage collection . Operational tooling If you are a Java application developer or you are responsible for managing large server or desktop deployments of a Java runtime environment, you probably use a number of tools for monitoring, management, and troubleshooting. Because OpenJ9 is an independent implementation, it has evolved with its own approach for these areas and, in some cases, its own unique tools. In other cases, tools have been added for compatibility with the reference implementation, but these tools might differ in behavior from equivalent tools in HotSpot. For a list of these tools, see Switching to OpenJ9 in the Tools section. Dumps, logs, and trace files OpenJ9 contains extensive trace and debugging capabilities to help identify, isolate, and solve run time problems. Dump files: Various types of dump are produced by default in response to certain events and can also be triggered for a whole range of events by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. Dumps include Java dumps , heap dumps , system dumps , JIT dumps, stack dumps, and snap dumps (tracepoint data). For more information, see the -Xdump option. Verbose log files: Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination, including class data sharing , garbage collection , and the JIT compiler . Trace files: The OpenJ9 implementation contains extensive tracepoints used to log information and exceptional conditions, with minimal impact on performance. Some tracepoints are enabled by default; others can be enabled on demand. For more information, see the -Xtrace option for tracing Java applications and the VM, and the -Xtgc option for tracing garbage collection. If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you probably make use of the monitoring and diagnostic tools that are provided with the VM. OpenJ9 has implemented a different approach to providing similar data; rather than running a number of different tools to obtain a different piece of information, the Java dump file provides a comprehensive set of information in one place. You can find the following information in an OpenJ9 Java dump: The system the VM is running on and the resources available. The Java execution environment, including the options set from the command line. The native memory used by the VM, broken down by VM component. Memory usage in the VM for the object heap and internal VM structures, such as the JIT code cache. Lock operations that protect shared resources during runtime. Java threads, native threads, and stack traces. Hook interfaces, for performance analysis. Details about the shared classes cache, if used. Detailed information about classloaders, together with a list of libraries and classes that are loaded. For more information, see Java dump . Tools OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Eclipse Memory Analyzer\u2122: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center. Most of the other tools provided with HotSpot are not officially supported, but equivalent functionality is available in OpenJ9 through command-line options, dump agents, and AttachAPI. Interfaces OpenJ9 provides the following interfaces, which can be used for monitoring and diagnostic purposes: JVMTI : OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information about this interface, see Java Virtual Machine Tool Interface . DTFJ interface : The Diagnostic Tool Framework for Java (DTFJ) API allows custom applications to be written that can access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer Toolkit (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information about DTFJ, see Diagnostic Tool Framework for Java . java.lang.management API : OpenJ9 provides MXBean additions and extensions to this standard API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you might make use of certain com.sun.management interfaces. Although OpenJ9 implements some of these interfaces, a few are specific to the HotSpot VM. The following table indicates alternative classes or mechanisms that you can use for equivalent function in OpenJ9: HotSpot-specific classes Alternatives for OpenJ9 HotSpotDiagnosticMXBean OpenJ9DiagnosticsMXBean (for heap dumps) MissionControl Use Health Center MissionControlMXBean Use Health Center ThreadMXBean JvmCpuMonitorMXBean (for thread time) VMOption OpenJ9 Java dump (option -Xdump:java ) DiagnosticCommandMBean None Note: OpenJ9 implements the following com.sun.management interfaces: GarbageCollectorMXBean , GarbageCollectionNotificationInfo , GcInfo , OperatingSystemMXBean , UnixOperatingSystemMXBean . For information about OpenJ9 application programming interfaces, see API documentation . Other differences This topic describes the differences between the HotSpot VM and the Eclipse OpenJ9 VM. Therefore, if you are currently using an OpenJDK with the default HotSpot VM and you want to switch to using an OpenJDK with the OpenJ9 VM, these are the only differences you might be concerned about. If however, you are using an Oracle JDK, you might want to learn about differences between other components that make up an Oracle JDK or an OpenJDK from the AdoptOpenJDK community. For more information, read the Migration guide .","title":"New to OpenJ9?"},{"location":"openj9_newuser/#new-to-eclipse-openj9","text":"The Eclipse OpenJ9\u2122 virtual machine (VM) implements the Java Virtual Machine Specification . Most Java applications should run on an OpenJDK that contains the OpenJ9 VM without changing anything. However, because it is an independent implementation there are some differences compared to the HotSpot VM, which is the default OpenJDK VM and is also included in an Oracle JDK.","title":"New to Eclipse OpenJ9?"},{"location":"openj9_newuser/#command-line-options","text":"Although OpenJ9 implements its own command-line interface, many HotSpot options are recognized and accepted by the VM for compatibility. Any -XX: options that are not recognized by the VM are ignored by default, which prevents an application failing to start. You can turn off this behavior with the -XX:-IgnoreUnrecognizedXXColonOptions option. For a list of compatible options, equivalent options, and options that need to be set for compatibility, see Switching to OpenJ9 .","title":"Command-line options"},{"location":"openj9_newuser/#garbage-collection-policies","text":"Eclipse OpenJ9 has a number of garbage collection (GC) policies designed around different types of applications and workloads. By default, OpenJ9 uses the Generational Concurrent ( gencon ) GC policy, which is best suited for transactional applications that have many short-lived objects. The policy aims to minimize GC pause times without compromising throughput. If you are using Java 8, the gencon policy is similar to the HotSpot CMS (concurrent mark sweep). If you are using Java 11, the OpenJ9 balanced ( balanced ) policy is most similar to the default HotSpot policy. If you have a different type of workload, you might want to select a different GC policy. For details about the available policies and when to choose them, see Garbage collection .","title":"Garbage collection policies"},{"location":"openj9_newuser/#operational-tooling","text":"If you are a Java application developer or you are responsible for managing large server or desktop deployments of a Java runtime environment, you probably use a number of tools for monitoring, management, and troubleshooting. Because OpenJ9 is an independent implementation, it has evolved with its own approach for these areas and, in some cases, its own unique tools. In other cases, tools have been added for compatibility with the reference implementation, but these tools might differ in behavior from equivalent tools in HotSpot. For a list of these tools, see Switching to OpenJ9 in the Tools section.","title":"Operational tooling"},{"location":"openj9_newuser/#dumps-logs-and-trace-files","text":"OpenJ9 contains extensive trace and debugging capabilities to help identify, isolate, and solve run time problems. Dump files: Various types of dump are produced by default in response to certain events and can also be triggered for a whole range of events by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. Dumps include Java dumps , heap dumps , system dumps , JIT dumps, stack dumps, and snap dumps (tracepoint data). For more information, see the -Xdump option. Verbose log files: Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination, including class data sharing , garbage collection , and the JIT compiler . Trace files: The OpenJ9 implementation contains extensive tracepoints used to log information and exceptional conditions, with minimal impact on performance. Some tracepoints are enabled by default; others can be enabled on demand. For more information, see the -Xtrace option for tracing Java applications and the VM, and the -Xtgc option for tracing garbage collection. If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you probably make use of the monitoring and diagnostic tools that are provided with the VM. OpenJ9 has implemented a different approach to providing similar data; rather than running a number of different tools to obtain a different piece of information, the Java dump file provides a comprehensive set of information in one place. You can find the following information in an OpenJ9 Java dump: The system the VM is running on and the resources available. The Java execution environment, including the options set from the command line. The native memory used by the VM, broken down by VM component. Memory usage in the VM for the object heap and internal VM structures, such as the JIT code cache. Lock operations that protect shared resources during runtime. Java threads, native threads, and stack traces. Hook interfaces, for performance analysis. Details about the shared classes cache, if used. Detailed information about classloaders, together with a list of libraries and classes that are loaded. For more information, see Java dump .","title":"Dumps, logs, and trace files"},{"location":"openj9_newuser/#tools","text":"OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Eclipse Memory Analyzer\u2122: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center. Most of the other tools provided with HotSpot are not officially supported, but equivalent functionality is available in OpenJ9 through command-line options, dump agents, and AttachAPI.","title":"Tools"},{"location":"openj9_newuser/#interfaces","text":"OpenJ9 provides the following interfaces, which can be used for monitoring and diagnostic purposes: JVMTI : OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information about this interface, see Java Virtual Machine Tool Interface . DTFJ interface : The Diagnostic Tool Framework for Java (DTFJ) API allows custom applications to be written that can access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer Toolkit (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information about DTFJ, see Diagnostic Tool Framework for Java . java.lang.management API : OpenJ9 provides MXBean additions and extensions to this standard API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you might make use of certain com.sun.management interfaces. Although OpenJ9 implements some of these interfaces, a few are specific to the HotSpot VM. The following table indicates alternative classes or mechanisms that you can use for equivalent function in OpenJ9: HotSpot-specific classes Alternatives for OpenJ9 HotSpotDiagnosticMXBean OpenJ9DiagnosticsMXBean (for heap dumps) MissionControl Use Health Center MissionControlMXBean Use Health Center ThreadMXBean JvmCpuMonitorMXBean (for thread time) VMOption OpenJ9 Java dump (option -Xdump:java ) DiagnosticCommandMBean None Note: OpenJ9 implements the following com.sun.management interfaces: GarbageCollectorMXBean , GarbageCollectionNotificationInfo , GcInfo , OperatingSystemMXBean , UnixOperatingSystemMXBean . For information about OpenJ9 application programming interfaces, see API documentation .","title":"Interfaces"},{"location":"openj9_newuser/#other-differences","text":"This topic describes the differences between the HotSpot VM and the Eclipse OpenJ9 VM. Therefore, if you are currently using an OpenJDK with the default HotSpot VM and you want to switch to using an OpenJDK with the OpenJ9 VM, these are the only differences you might be concerned about. If however, you are using an Oracle JDK, you might want to learn about differences between other components that make up an Oracle JDK or an OpenJDK from the AdoptOpenJDK community. For more information, read the Migration guide .","title":"Other differences"},{"location":"openj9_releases/","text":"Overview New releases of Eclipse OpenJ9\u2122 are set to coincide with critical patch updates and new versions of the Java\u2122 SE class libraries. To learn more about when these releases take place, and the OpenJ9 support lifecycle, see Supported environments . If you are interested in the content of future releases, plans are published in the Eclipse OpenJ9 project page . High level information about the features and changes in final releases of OpenJ9 can be found in the topics that follow.","title":"Overview"},{"location":"openj9_releases/#overview","text":"New releases of Eclipse OpenJ9\u2122 are set to coincide with critical patch updates and new versions of the Java\u2122 SE class libraries. To learn more about when these releases take place, and the OpenJ9 support lifecycle, see Supported environments . If you are interested in the content of future releases, plans are published in the Eclipse OpenJ9 project page . High level information about the features and changes in final releases of OpenJ9 can be found in the topics that follow.","title":"Overview"},{"location":"openj9_signals/","text":"Signal handling Signals used by the Eclipse OpenJ9\u2122 VM include the following types: Exceptions (Exc): Raised synchronously by the operating system whenever an unrecoverable condition occurs (not applicable on Windows\u2122 systems). Errors (Err): Raised by the OpenJ9 VM when an unrecoverable condition occurs. Interrupts (Int): Raised asynchronously from outside a VM process to request a VM exit. Controls (Con): Other signals that are used by the VM for control purposes. For exceptions and errors, if the VM cannot handle the condition and recover, dumps are produced and a controlled shut down sequence takes place. Interrupts also cause the VM to enter a controlled shut down sequence, but without generating dumps. The shutdown sequence is equivalent to calling System.exit() , which results in the following steps: The VM calls the equivalent application signal handler. The VM calls any hooks installed by the application (unexpected shutdown hooks for exceptions or errors, shutdown or exit hooks for interrupts). The VM does any final clean up. Control signals are used for internal control purposes and do not cause the VM to end. The VM takes control of any signals for Java\u2122 threads. For non-Java threads, the VM passes control to an application handler, if one is installed. If the application does not install a signal handler, or signal chaining is turned off, the signal is either ignored or the default action is taken. Signal chaining is controlled by the -Xsigchain / -Xnosigchain command-line option. The signals relevant to each platform are detailed in the sections that follow. When reading each table, a number supplied after the signal name is the standard numerical value for that signal. Note that certain signals on VM threads cause OpenJ9 to shutdown. An application signal handler should not attempt to recover from these signals unless it no longer requires the VM. Signals on Linux Signal Type Description Option to disable signal SIGBUS (7) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (12) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (34) Con Used by the VM for thread introspection - SIGRTMIN +1 (35) Con Used by the VM for Runtime Instrumentation (Linux for IBM Z\u00ae systems only) - SIGRTMAX -2 (62) Con Used by the java.net class library code - SIGCHLD (17) Con Used by the java.lang.Process implementation - Notes: The use of SIGRTMIN is configurable with the -Xdump:suspendwith=<num> option. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signals on macOS Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (31) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (30) Con Used by the VM for thread introspection - SIGIO (23) Con Used by the java.net class library code - Note: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signals on Windows Signal Type Description Option to disable signal SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGBREAK Con A break signal from a terminal. By default, this triggers a Java dump -Xrs Notes: The following mechanisms are used by OpenJ9 for signal handling: structured exception handling (32-bit VM only) AddVectoredExceptionHandler() API (64-bit JVM only) SetConsoleCtrlHandler() applicable All mechanisms can be disabled by using the -Xrs option. However, only structured exception handling and the use of the AddVectoredExceptionHandler() API can be disabled by using the -Xrs:sync option. The option -Xnosigchain , which turns off signal handler chaining, is ignored on Windows systems. Signals on z/OS Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (3) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (17) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (24) Con Quit signal from a terminal, triggers a Java dump by default -Xrs SIGTRAP (26) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (16) Con Used by the java.net class library code - Note: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signals on AIX Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (31) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (3) Con Triggers a Java dump by default -Xrs No Name (40) Con Used by the VM for control purposes -Xrs SIGRECONFIG (58) Con Reserved to detect changes to resources (CPUs, processing capacity, or physical memory) -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (50) Con Used by the VM for thread introspection - SIGRTMAX -1 (56) Con Used by the java.net class library code - SIGCHLD (20) Con Used by the java.lang.Process implementation - Notes: VM performance is affected if you install a signal handler for SIGTRAP (5) or SIGRECONFIG (58) because these signals are used for internal control purposes. If you want to generate floating point exceptions, use the following call in your code to generate a SIGFPE signal: fp_trap( P_TRAP_SYNC) . Although you can use the C compiler -qflttrap setting to generate SIGTRAP signals to trap floating point exceptions, this mechanism can affect the JIT compiler. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signal chaining Signal chaining allows application code to interoperate with VM signal handling. By linking and loading a shared library, certain calls can be intercepted so that the application handlers do not replace the VM signal handlers. Instead, the application handlers are chained behind the VM handlers. If signals that are raised do not target the VM, the application handlers take over. Signals that can be chained include signal() , sigset() , and sigaction() . The following table shows the shared library that must be linked with the application that creates or embeds a VM, and the command line syntax to use with the compiler, where available: Operating system Shared library Method for linking Linux\u00ae, macOS\u00ae, and z/OS\u00ae libjsig.so gcc -L$JAVA_HOME/bin -ljsig -L$JAVA_HOME/lib/j9vm -ljvm <java_application>.c Windows jsig.dll Link the DLL with the application that creates or embeds a VM AIX libjsig.so cc_r [-q64] <other_compile/link_parameter> -L<java_install_dir> -ljsig -L<java_install_dir>/lib/j9vm -ljvm <java_application>.c Note: On Linux, macOS, and z/OS systems, you can use the LD_PRELOAD environment variable as an alternative method to the command line for linking the shared library as shown in the following list: bash and ksh shells: export LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application> csh shell: setenv LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application> See also -Xrs -Xsigcatch -Xsigchain -Xsignal (z/OS only)","title":"Signal handling"},{"location":"openj9_signals/#signal-handling","text":"Signals used by the Eclipse OpenJ9\u2122 VM include the following types: Exceptions (Exc): Raised synchronously by the operating system whenever an unrecoverable condition occurs (not applicable on Windows\u2122 systems). Errors (Err): Raised by the OpenJ9 VM when an unrecoverable condition occurs. Interrupts (Int): Raised asynchronously from outside a VM process to request a VM exit. Controls (Con): Other signals that are used by the VM for control purposes. For exceptions and errors, if the VM cannot handle the condition and recover, dumps are produced and a controlled shut down sequence takes place. Interrupts also cause the VM to enter a controlled shut down sequence, but without generating dumps. The shutdown sequence is equivalent to calling System.exit() , which results in the following steps: The VM calls the equivalent application signal handler. The VM calls any hooks installed by the application (unexpected shutdown hooks for exceptions or errors, shutdown or exit hooks for interrupts). The VM does any final clean up. Control signals are used for internal control purposes and do not cause the VM to end. The VM takes control of any signals for Java\u2122 threads. For non-Java threads, the VM passes control to an application handler, if one is installed. If the application does not install a signal handler, or signal chaining is turned off, the signal is either ignored or the default action is taken. Signal chaining is controlled by the -Xsigchain / -Xnosigchain command-line option. The signals relevant to each platform are detailed in the sections that follow. When reading each table, a number supplied after the signal name is the standard numerical value for that signal. Note that certain signals on VM threads cause OpenJ9 to shutdown. An application signal handler should not attempt to recover from these signals unless it no longer requires the VM.","title":"Signal handling"},{"location":"openj9_signals/#signals-on-linux","text":"Signal Type Description Option to disable signal SIGBUS (7) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (12) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (34) Con Used by the VM for thread introspection - SIGRTMIN +1 (35) Con Used by the VM for Runtime Instrumentation (Linux for IBM Z\u00ae systems only) - SIGRTMAX -2 (62) Con Used by the java.net class library code - SIGCHLD (17) Con Used by the java.lang.Process implementation - Notes: The use of SIGRTMIN is configurable with the -Xdump:suspendwith=<num> option. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on Linux"},{"location":"openj9_signals/#signals-on-macos","text":"Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (31) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (30) Con Used by the VM for thread introspection - SIGIO (23) Con Used by the java.net class library code - Note: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on macOS"},{"location":"openj9_signals/#signals-on-windows","text":"Signal Type Description Option to disable signal SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGBREAK Con A break signal from a terminal. By default, this triggers a Java dump -Xrs Notes: The following mechanisms are used by OpenJ9 for signal handling: structured exception handling (32-bit VM only) AddVectoredExceptionHandler() API (64-bit JVM only) SetConsoleCtrlHandler() applicable All mechanisms can be disabled by using the -Xrs option. However, only structured exception handling and the use of the AddVectoredExceptionHandler() API can be disabled by using the -Xrs:sync option. The option -Xnosigchain , which turns off signal handler chaining, is ignored on Windows systems.","title":"Signals on Windows"},{"location":"openj9_signals/#signals-on-zos","text":"Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (3) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (17) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (24) Con Quit signal from a terminal, triggers a Java dump by default -Xrs SIGTRAP (26) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (16) Con Used by the java.net class library code - Note: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on z/OS"},{"location":"openj9_signals/#signals-on-aix","text":"Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEGV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGUSR2 (31) Int User-defined signal for triggering a dump agent -Xrs SIGQUIT (3) Con Triggers a Java dump by default -Xrs No Name (40) Con Used by the VM for control purposes -Xrs SIGRECONFIG (58) Con Reserved to detect changes to resources (CPUs, processing capacity, or physical memory) -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (50) Con Used by the VM for thread introspection - SIGRTMAX -1 (56) Con Used by the java.net class library code - SIGCHLD (20) Con Used by the java.lang.Process implementation - Notes: VM performance is affected if you install a signal handler for SIGTRAP (5) or SIGRECONFIG (58) because these signals are used for internal control purposes. If you want to generate floating point exceptions, use the following call in your code to generate a SIGFPE signal: fp_trap( P_TRAP_SYNC) . Although you can use the C compiler -qflttrap setting to generate SIGTRAP signals to trap floating point exceptions, this mechanism can affect the JIT compiler. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on AIX"},{"location":"openj9_signals/#signal-chaining","text":"Signal chaining allows application code to interoperate with VM signal handling. By linking and loading a shared library, certain calls can be intercepted so that the application handlers do not replace the VM signal handlers. Instead, the application handlers are chained behind the VM handlers. If signals that are raised do not target the VM, the application handlers take over. Signals that can be chained include signal() , sigset() , and sigaction() . The following table shows the shared library that must be linked with the application that creates or embeds a VM, and the command line syntax to use with the compiler, where available: Operating system Shared library Method for linking Linux\u00ae, macOS\u00ae, and z/OS\u00ae libjsig.so gcc -L$JAVA_HOME/bin -ljsig -L$JAVA_HOME/lib/j9vm -ljvm <java_application>.c Windows jsig.dll Link the DLL with the application that creates or embeds a VM AIX libjsig.so cc_r [-q64] <other_compile/link_parameter> -L<java_install_dir> -ljsig -L<java_install_dir>/lib/j9vm -ljvm <java_application>.c Note: On Linux, macOS, and z/OS systems, you can use the LD_PRELOAD environment variable as an alternative method to the command line for linking the shared library as shown in the following list: bash and ksh shells: export LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application> csh shell: setenv LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application>","title":"Signal chaining"},{"location":"openj9_signals/#see-also","text":"-Xrs -Xsigcatch -Xsigchain -Xsignal (z/OS only)","title":"See also"},{"location":"openj9_support/","text":"Supported environments The Eclipse OpenJ9\u2122 project source code can be built against multiple JDK levels starting with JDK8, so the question of support has a more complicated answer than at OpenJDK. Our community is committed to supporting JDK levels as long as they are supported at the OpenJDK open source project with a significant user base. Currently, Eclipse OpenJ9 produces a new release every quarter that can build against all JDK levels that are currently supported by the OpenJDK community. We are committed to accepting problem reports when using Eclipse OpenJ9 against a supported OpenJDK level, with fixes being delivered in each release of Eclipse OpenJ9. In order to track the OpenJDK 6-month release cadence, OpenJ9 also produces two releases a year that support only a single JDK level. These releases will occur in March and September with the intention of supporting only the corresponding new OpenJDK feature release. The following table summarizes which JDK levels are expected to be supported by which Eclipse OpenJ9 releases, along with projected release dates. All future dates and support expectations are predictions that might change depending on how the OpenJDK and OpenJ9 projects evolve over time. To keep this table concise, some rows and columns will be removed over time. Eclipse OpenJ9 releases OpenJ9 release Release date JDK8 (LTS) JDK11 (LTS) JDK17 (LTS) JDK18 JDK19 JDK20 0.32.0 Apr 2022 yes yes yes yes 0.33.0 Jul 2022 yes yes yes yes 0.35.0 Oct 2022 yes yes yes no 0.36.0 Jan 2023 (1) yes yes yes no yes 0.37.0 Mar 2023 (2) no no no no no yes Notes: These future OpenJ9 releases are expected, in line with our support statement. These OpenJ9 releases are feature releases that support a new OpenJDK release only. These OpenJ9 releases support a new LTS OpenJDK release only. For any issues or limitations of an Eclipse OpenJ9 release, read the release notes . Platform support The Eclipse OpenJ9 project is open to supporting any hardware or operating system platforms provided that we have community members available to maintain them. For practical reasons the Eclipse OpenJ9 JVM does not currently run on every platform. OpenJDK 8 OpenJDK 8 binaries are expected to function on the minimum operating system levels shown in the following tables: Linux\u00ae AArch64 x32 x64 ppc64le Z31 Z64 CentOS 6.10 no yes yes no no no CentOS 7.9 yes yes yes yes no no CentOS Stream 8 yes no yes yes no no Red Hat Enterprise Linux (RHEL) 6.10 no yes yes no no no RHEL 7.8 yes yes yes yes no yes RHEL 8.2 yes no yes yes no yes RHEL 9.0 no no yes yes no yes SUSE Linux Enterprise Server (SLES) 12 SP5 no yes yes yes yes yes Ubuntu 18.04 yes yes yes yes no yes Ubuntu 20.04 yes no yes yes no yes Ubuntu 22.04 no no yes yes no yes Note: Not all of these distributions are tested, but the following distributions are expected to function without problems: Linux distributions that have a minimum glibc version 2.12 (x) or 2.17 (others) RHEL 9.0 and Ubuntu 22.04 distributions on AArch64 architecture Windows\u2122 x32 x64 Windows 10 yes yes Windows Server 2012 R2 yes yes Windows Server 2016 yes yes Windows Server 2019 yes yes macOS\u00ae x64 OS X\u00ae 10.10.0+ yes AIX\u00ae ppc32 ppc64 AIX 7.1 TL5 yes yes AIX 7.2 TL4 yes yes When public support for an operating system version ends, OpenJ9 can no longer be supported on that level. OpenJDK 11 OpenJDK 11 binaries are expected to function on the minimum operating system levels shown in the following tables: Linux ( Note 1 ) AArch64 x64 ppc64le Z64 CentOS 6.10 no yes no no CentOS 7.9 yes yes yes no CentOS Stream 8 yes yes yes no Red Hat Enterprise Linux (RHEL) 6.10 no yes no no RHEL 7.8 yes yes yes yes RHEL 8.2 yes yes yes yes RHEL 9.0 no yes yes yes SUSE Linux Enterprise Server (SLES) 12 SP5 no yes yes yes Ubuntu 18.04 yes yes yes yes Ubuntu 20.04 yes yes yes yes Ubuntu 22.04 no yes yes yes Note: Not all of these distributions are tested, but the following distributions are expected to function without problems: Linux distributions that have a minimum glibc version 2.12 (x) or 2.17 (others) RHEL 9.0 and Ubuntu 22.04 distributions on AArch64 architecture Windows x64 Windows 10 yes Windows Server 2012 R2 yes Windows Server 2016 yes Windows Server 2019 yes macOS x64 OS X 10.11+ yes AIX ppc64 AIX 7.1 TL5 yes AIX 7.2 TL4 yes Important: AIX OpenJ9 builds require the XL C++ Runtime 16.1.0.7 or later . When public support for an operating system version ends, OpenJ9 can no longer be supported on that level. OpenJDK 17 OpenJDK 17 binaries are expected to function on the minimum operating system levels shown in the following tables: Linux ( Note 1 ) AArch64 x64 ppc64le Z64 CentOS 7.9 yes yes yes no CentOS Stream 8 yes yes yes no RHEL 7.8 yes yes yes yes RHEL 8.2 yes yes yes yes RHEL 9.0 no yes yes yes SUSE Linux Enterprise Server (SLES) 12 SP5 no yes yes yes Ubuntu 18.04 yes yes yes yes Ubuntu 20.04 yes yes yes yes Ubuntu 22.04 no yes yes yes Note: Not all of these distributions are tested, but the following distributions are expected to function without problems: Linux distributions that have a minimum glibc version 2.12 (x) or 2.17 (others) RHEL 9.0 and Ubuntu 22.04 distributions on AArch64 architecture Windows x64 Windows 10 yes Windows Server 2012 R2 yes Windows Server 2016 yes Windows Server 2019 yes macOS x64 OS X 10.14+ yes AIX ppc64 AIX 7.1 TL5 yes AIX 7.2 TL4 yes Important: AIX OpenJ9 builds require the XL C++ Runtime 16.1.0.7 or later . When public support for an operating system version ends, OpenJ9 can no longer be supported on that level. Build environments The project builds and tests OpenJDK with OpenJ9 on a number of platforms. The operating system and compiler levels for the build systems are shown in the following tables. OpenJDK 8 Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER\u00ae LE 64-bit CentOS 7.9 gcc 7.5 Linux on IBM Z\u00ae 64-bit RHEL 7.9 gcc 7.5 Linux AArch64 64-bit CentOS 7.9 gcc 7.5 Windows x86 32-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 macOS x86 64-bit OSX 10.15.7 xcode 12.4 and clang 12.0.0 AIX POWER BE 64-bit AIX 7.1 TL05 xlc/C++ 13.1.3 OpenJDK 11 Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER LE 64-bit CentOS 7.9 gcc 7.5 Linux on IBM Z 64-bit RHEL 7.9 gcc 7.5 Linux AArch64 64-bit CentOS 7.9 gcc 7.5 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2019 macOS x86 64-bit macOS 10.15.7 xcode 12.4 and clang 12.0.0 AIX POWER BE 64-bit AIX 7.1 TL05 xlc/C++ 16.1.0.11 OpenJDK 17 Platform Operating system Compiler Linux x86 64-bit CentOS 7.9 gcc 10.3 Linux on POWER LE 64-bit CentOS 7.9 gcc 10.3 Linux on IBM Z 64-bit RHEL 7.9 gcc 10.3 Linux AArch64 64-bit CentOS 7.9 gcc 10.3 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2019 macOS x86 64-bit macOS 10.15.7 xcode 12.4 and clang 12.0.0 AIX POWER BE 64-bit AIX 7.1 TL05 xlc/C++ 16.1.0.11","title":"Supported environments"},{"location":"openj9_support/#supported-environments","text":"The Eclipse OpenJ9\u2122 project source code can be built against multiple JDK levels starting with JDK8, so the question of support has a more complicated answer than at OpenJDK. Our community is committed to supporting JDK levels as long as they are supported at the OpenJDK open source project with a significant user base. Currently, Eclipse OpenJ9 produces a new release every quarter that can build against all JDK levels that are currently supported by the OpenJDK community. We are committed to accepting problem reports when using Eclipse OpenJ9 against a supported OpenJDK level, with fixes being delivered in each release of Eclipse OpenJ9. In order to track the OpenJDK 6-month release cadence, OpenJ9 also produces two releases a year that support only a single JDK level. These releases will occur in March and September with the intention of supporting only the corresponding new OpenJDK feature release. The following table summarizes which JDK levels are expected to be supported by which Eclipse OpenJ9 releases, along with projected release dates. All future dates and support expectations are predictions that might change depending on how the OpenJDK and OpenJ9 projects evolve over time. To keep this table concise, some rows and columns will be removed over time.","title":"Supported environments"},{"location":"openj9_support/#eclipse-openj9-releases","text":"OpenJ9 release Release date JDK8 (LTS) JDK11 (LTS) JDK17 (LTS) JDK18 JDK19 JDK20 0.32.0 Apr 2022 yes yes yes yes 0.33.0 Jul 2022 yes yes yes yes 0.35.0 Oct 2022 yes yes yes no 0.36.0 Jan 2023 (1) yes yes yes no yes 0.37.0 Mar 2023 (2) no no no no no yes Notes: These future OpenJ9 releases are expected, in line with our support statement. These OpenJ9 releases are feature releases that support a new OpenJDK release only. These OpenJ9 releases support a new LTS OpenJDK release only. For any issues or limitations of an Eclipse OpenJ9 release, read the release notes .","title":"Eclipse OpenJ9 releases"},{"location":"openj9_support/#platform-support","text":"The Eclipse OpenJ9 project is open to supporting any hardware or operating system platforms provided that we have community members available to maintain them. For practical reasons the Eclipse OpenJ9 JVM does not currently run on every platform.","title":"Platform support"},{"location":"openj9_support/#openjdk-8","text":"OpenJDK 8 binaries are expected to function on the minimum operating system levels shown in the following tables: Linux\u00ae AArch64 x32 x64 ppc64le Z31 Z64 CentOS 6.10 no yes yes no no no CentOS 7.9 yes yes yes yes no no CentOS Stream 8 yes no yes yes no no Red Hat Enterprise Linux (RHEL) 6.10 no yes yes no no no RHEL 7.8 yes yes yes yes no yes RHEL 8.2 yes no yes yes no yes RHEL 9.0 no no yes yes no yes SUSE Linux Enterprise Server (SLES) 12 SP5 no yes yes yes yes yes Ubuntu 18.04 yes yes yes yes no yes Ubuntu 20.04 yes no yes yes no yes Ubuntu 22.04 no no yes yes no yes Note: Not all of these distributions are tested, but the following distributions are expected to function without problems: Linux distributions that have a minimum glibc version 2.12 (x) or 2.17 (others) RHEL 9.0 and Ubuntu 22.04 distributions on AArch64 architecture Windows\u2122 x32 x64 Windows 10 yes yes Windows Server 2012 R2 yes yes Windows Server 2016 yes yes Windows Server 2019 yes yes macOS\u00ae x64 OS X\u00ae 10.10.0+ yes AIX\u00ae ppc32 ppc64 AIX 7.1 TL5 yes yes AIX 7.2 TL4 yes yes When public support for an operating system version ends, OpenJ9 can no longer be supported on that level.","title":"OpenJDK 8"},{"location":"openj9_support/#openjdk-11","text":"OpenJDK 11 binaries are expected to function on the minimum operating system levels shown in the following tables: Linux ( Note 1 ) AArch64 x64 ppc64le Z64 CentOS 6.10 no yes no no CentOS 7.9 yes yes yes no CentOS Stream 8 yes yes yes no Red Hat Enterprise Linux (RHEL) 6.10 no yes no no RHEL 7.8 yes yes yes yes RHEL 8.2 yes yes yes yes RHEL 9.0 no yes yes yes SUSE Linux Enterprise Server (SLES) 12 SP5 no yes yes yes Ubuntu 18.04 yes yes yes yes Ubuntu 20.04 yes yes yes yes Ubuntu 22.04 no yes yes yes Note: Not all of these distributions are tested, but the following distributions are expected to function without problems: Linux distributions that have a minimum glibc version 2.12 (x) or 2.17 (others) RHEL 9.0 and Ubuntu 22.04 distributions on AArch64 architecture Windows x64 Windows 10 yes Windows Server 2012 R2 yes Windows Server 2016 yes Windows Server 2019 yes macOS x64 OS X 10.11+ yes AIX ppc64 AIX 7.1 TL5 yes AIX 7.2 TL4 yes Important: AIX OpenJ9 builds require the XL C++ Runtime 16.1.0.7 or later . When public support for an operating system version ends, OpenJ9 can no longer be supported on that level.","title":"OpenJDK 11"},{"location":"openj9_support/#openjdk-17","text":"OpenJDK 17 binaries are expected to function on the minimum operating system levels shown in the following tables: Linux ( Note 1 ) AArch64 x64 ppc64le Z64 CentOS 7.9 yes yes yes no CentOS Stream 8 yes yes yes no RHEL 7.8 yes yes yes yes RHEL 8.2 yes yes yes yes RHEL 9.0 no yes yes yes SUSE Linux Enterprise Server (SLES) 12 SP5 no yes yes yes Ubuntu 18.04 yes yes yes yes Ubuntu 20.04 yes yes yes yes Ubuntu 22.04 no yes yes yes Note: Not all of these distributions are tested, but the following distributions are expected to function without problems: Linux distributions that have a minimum glibc version 2.12 (x) or 2.17 (others) RHEL 9.0 and Ubuntu 22.04 distributions on AArch64 architecture Windows x64 Windows 10 yes Windows Server 2012 R2 yes Windows Server 2016 yes Windows Server 2019 yes macOS x64 OS X 10.14+ yes AIX ppc64 AIX 7.1 TL5 yes AIX 7.2 TL4 yes Important: AIX OpenJ9 builds require the XL C++ Runtime 16.1.0.7 or later . When public support for an operating system version ends, OpenJ9 can no longer be supported on that level.","title":"OpenJDK 17"},{"location":"openj9_support/#build-environments","text":"The project builds and tests OpenJDK with OpenJ9 on a number of platforms. The operating system and compiler levels for the build systems are shown in the following tables.","title":"Build environments"},{"location":"openj9_support/#openjdk-8_1","text":"Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER\u00ae LE 64-bit CentOS 7.9 gcc 7.5 Linux on IBM Z\u00ae 64-bit RHEL 7.9 gcc 7.5 Linux AArch64 64-bit CentOS 7.9 gcc 7.5 Windows x86 32-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 macOS x86 64-bit OSX 10.15.7 xcode 12.4 and clang 12.0.0 AIX POWER BE 64-bit AIX 7.1 TL05 xlc/C++ 13.1.3","title":"OpenJDK 8"},{"location":"openj9_support/#openjdk-11_1","text":"Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER LE 64-bit CentOS 7.9 gcc 7.5 Linux on IBM Z 64-bit RHEL 7.9 gcc 7.5 Linux AArch64 64-bit CentOS 7.9 gcc 7.5 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2019 macOS x86 64-bit macOS 10.15.7 xcode 12.4 and clang 12.0.0 AIX POWER BE 64-bit AIX 7.1 TL05 xlc/C++ 16.1.0.11","title":"OpenJDK 11"},{"location":"openj9_support/#openjdk-17_1","text":"Platform Operating system Compiler Linux x86 64-bit CentOS 7.9 gcc 10.3 Linux on POWER LE 64-bit CentOS 7.9 gcc 10.3 Linux on IBM Z 64-bit RHEL 7.9 gcc 10.3 Linux AArch64 64-bit CentOS 7.9 gcc 10.3 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2019 macOS x86 64-bit macOS 10.15.7 xcode 12.4 and clang 12.0.0 AIX POWER BE 64-bit AIX 7.1 TL05 xlc/C++ 16.1.0.11","title":"OpenJDK 17"},{"location":"shrc/","text":"Introduction to class data sharing Sharing class data between Eclipse OpenJ9\u2122 VMs improves start up performance and reduces memory footprint. Consider the following outcomes for two VMs that are running similar Java applications but sharing class data: Start up performance is improved by placing classes that each application needs when initializing into a shared classes cache. The next time the application runs, it takes less time to start because the classes are already available. Memory footprint is reduced by sharing common classes between the applications. When class data sharing is enabled, OpenJ9 automatically creates shared memory that stores and shares the classes in memory between processes. This shared classes cache is updated dynamically; when an application loads new classes, the VM automatically stores them in the cache without any user intervention. By default, class data sharing is enabled for bootstrap classes, as described in Enabling class data sharing . When class data sharing is enabled, Ahead-of-time (AOT) compilation is also enabled by default, which dynamically compiles certain methods into AOT code at runtime. By using these features in combination, startup performance is further improved because the cached AOT code can be used to quickly enable native code performance for subsequent runs of your application. For more information about AOT, see AOT Compiler . Further performance improvements are gained by storing JIT data and profiles in the shared classes cache. The contents of a shared classes cache can include the following artifacts: Bootstrap classes Application classes Metadata that describes the classes AOT-compiled code JIT data GC hints (for initial Java heap size) Bootstrap jar file indexes Cache utilities Active caches can be managed by a set of cache utilities, which are invoked by specifying -Xshareclasses suboptions. These utilities control the following types of operations: Displaying information about the caches on a system. Adjusting the size of a cache and the amount of space that is reserved for AOT code or JIT data. Creating a snapshot of a non-persistent cache to save to disk and restoring the cache from disk. Troubleshooting cache problems. Removing unwanted caches on a system. These cache utilities are discussed in more detail in the sections that follow. Enabling class data sharing Class data sharing is enabled by default for bootstrap classes, unless your application is running in a container. Default behavior includes the following characteristics: On Windows\u00ae, the cache is created in the user's C:\\Users\\<username>\\AppData\\Local\\javasharedresources directory. On z/OS\u00ae, the default cache directory is /tmp/javasharedresources . On other systems, the cache is created in the javasharedresources directory in the users home directory, unless the groupAccess parameter is specified, in which case it is created in /tmp/javasharedresources . Please do not set the home directory on a NFS mount or shared mount across systems or LPARs. The cache name is sharedcc_%u , where %u is the current user name. If class data sharing fails, the VM still starts without printing any errors. Shared class behavior is controlled by specifying the -Xshareclasses option on the command line when you start your application. The default settings are equivalent to specifying the following suboptions: -Xshareclasses:bootClassesOnly,nonFatal,silent You can enable class data sharing for non-bootstrap classes as well as bootstrap classes, by omitting the bootClassesOnly suboption. You can also disable all class data sharing by using the none suboption. Further suboptions are available to configure a cache at startup, including name, location, and startup size. You can also use cache utilities to manage a shared classes cache after it is initialized and in use. A shared classes cache can be persistent or non-persistent according to the following definition: persistent caches are written to memory-mapped files and remain in place, even after a system is rebooted. non-persistent caches exist in shared memory and are automatically removed when the operating system is restarted. By default, a shared classes cache is persistent, except on the z/OS\u00ae platform, where persistent caches are not supported. If you are using a non-persistent cache, you can use a cache utility to create a snapshot of the cache, which can be reinitialized after a reboot. For more information see Saving a non-persistent shared classes cache . If you have multiple VMs and you do not change the default shared classes behavior, the VMs share a single default cache, assuming that the VMs are from a single Java installation. If the VMs are from different Java installations, the cache might be deleted and re-created. For a set of best practices when using class data sharing, see Creating a shared classes cache . Class data sharing operations When a VM loads a class and the class loader is enabled for class sharing, the VM looks in the shared classes cache to see if the class is already present. If the class is present and the classpath or URL to load the class is a match, the VM loads the class from the cache. Otherwise, it loads the class from the file system and writes it into the cache. The VM detects file system updates by storing timestamp values into the cache and comparing the cached values with actual values. In this way, the VM detects when a class might be invalidated and can mark the class as stale . These operations happen transparently when classes are loaded, so users can modify and update as many classes as they like during the lifetime of a shared class cache, knowing that the correct classes are always loaded. Stale classes are redeemed if the same class is subsequently fetched by the class loader from another VM and checked against the stale class in the cache. Occasionally, caches that are created from one version of the VM might not be compatible with caches that are created from a different version. This situation typically occurs when an update is made in OpenJ9 that changes the internal cache data structure. If a VM detects an incompatible cache at start up, it creates a new cache that can coexist, even if it has the same name. The VM detects a conflict by checking an internal shared classes cache generation number. Caches are not compatible between VMs that are using different object storage modes. For example, a 64-bit VM that uses compressed references to store 64-bit objects in a 32-bit representation, cannot share a cache with a 64-bit VM that is not using compressed references. For more information about object storage options, see Compressed references . In the OpenJ9 implementation of java.net.URLClassLoader , classes are read from and written to the cache using the public Helper API. Therefore, any class loader that extends java.net.URLClassLoader gets class sharing support for free provided that it continues to use the methods in java.net.URLClassLoader to load classes. Custom class loaders that do not extend java.net.URLClassLoader must be adapted to share class data as described in Support for custom class loaders . AOT code and JIT data OpenJ9 can automatically store small amounts of AOT code and JIT data, which helps improve performance in the following ways: The JIT compiler dynamically compiles certain methods into AOT code at runtime. Subsequent VMs that attach to the cache can take advantage of the compiled code to start faster. The JIT compiler stores profiling data and various compilation hints into the shared classes cache. This data enables subsequent VMs that attach to the cache to start faster, run faster, or both. The default settings provide significant performance benefits. However, you can specify options on the command line to configure AOT code storage or JIT data storage in the shared classes cache, as shown in the following table: Component Setting a minimum storage value Setting a maximum storage value Turning off storage AOT code -Xscminaot<size> -Xscmaxaot<size> -Xshareclasses:noaot JIT data -Xscminjitdata<size> -Xscmaxjitdata<size> -Xshareclasses:nojitdata The following cache utilities are available to adjust the storage values when a cache is active: Component Adjusting the minimum storage value Adjusting the maximum storage value AOT code -Xshareclasses:adjustminaot -Xshareclasses:adjustmaxaot JIT code -Xshareclasses:adjustminjit -Xshareclasses:adjustmaxjit You can also use the -Xshareclasses:findAotMethods cache utility to list the AOT methods in a cache that match a method specification. This utility helps you identify methods that are causing a failure in an application. You can then invalidate the method without destroying the cache by using the -Xshareclasses:invalidateAotMethods cache utility. You can also revalidate an AOT method with the -Xshareclasses:revalidateAotMethods cache utility. To troubleshoot AOT problems, use the -Xshareclasses:verboseAOT suboption on the command line, which generates output about AOT code that is found or stored in the cache. For more information see -Xshareclasses . Creating a shared classes cache The -Xshareclasses option is highly configurable, allowing you to specify where to create the cache, how much space to allocate, and more. The following best practices apply to using class data sharing: Before starting your application, use the -Xshareclasses:listAllCaches cache utility to review and maintain the existing caches on your system. This option lists all the caches that exist in the default directory, including compatible and incompatible caches. You can also specify the cacheDir suboption to look for caches in a specified directory. Remove any obsolete caches, as described in Housekeeping . If you are creating a new cache, set an application-specific cache name ( -Xshareclasses:name=<name> ). If a cache with the specified name doesn't already exist, a new cache is created. This avoids sharing your application cache with a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note: You cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. Set a specific cache directory ( -Xshareclasses:cacheDir=<directory> ). Set a cache directory that is specific to your application, to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory. Your application will be unaffected by a user running java -Xshareclasses:destroyAll . Please do not set the cache directory on a NFS mount or a shared mount across systems or LPARs. In addition, if you have VMs from different Java installations, of the same Java release and installed by the same user, each VM checks whether the existing default shared cache in the cache directory is from the same Java installation as the VM. If not, the VM deletes that shared cache, then creates a new one. Specifying a different cache directory for each Java installation avoids this situation. Ensure that the cache directory permissions are set appropriately ( -Xshareclasses:cacheDirPerm ). It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. Access is controlled by operating system permissions and Java security permissions; read/write access is the default only for the current user. On Unix systems, you can use the -Xshareclasses:groupAccess suboption to allow read/write permissions for groups as well as users. On z/OS, a cache can be accessed only by a VM that is running in the same storage key as the VM that created the cache. If the keys do not match, permission to access the cache is denied. Set the -Xshareclasses:nonfatal option. In most cases, setting this option allows your application to start even if there is a problem opening or creating the shared cache. The VM will continue to start without class data sharing. Set a soft maximum size for the cache by specifying the -Xscmx option with the -XXSharedCacheHardLimit option. For example, you might create a 64 MB shared cache and set a smaller value, such as 16 MB, for the -Xscmx option, to limit the data stored in the cache ( -XX:SharedCacheHardLimit=64m -Xscmx16m ). You can then adjust the soft maximum size by using the -Xshareclasses:adjustsoftmx cache utility or the MemoryMXBean.setSharedClassCacheSoftmxBytes() method in the com.ibm.lang.management API. For more information, see Setting a soft maximum size . Creating layer caches Creating a layered cache might be useful when you are building a Docker image. Normally, writing to an existing shared cache in a lower image layer results in Docker duplicating the shared cache to the top layer (following the Docker copy-on-write strategy ). With a layered cache, you can instead write into a new cache in the top layer. The new cache builds on the existing cache, so space is saved in the image. The following example shows a Docker container with four layers: The lowest layer is a Ubuntu Docker image. The next layer is an OpenJ9 Docker image that is built on the Ubuntu image. As part of this image, the -Xshareclasses:name=MyCache suboption is used to create a cache called MyCache . The layer number assigned to this cache is 0 . The listAllCaches suboption shows the cache and the layer number: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches MyCache Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 The next Docker layer up is a middleware image that is built on the OpenJ9 image. As part of this image, the -Xshareclasses:name=MyCache,layer=1 suboption is used to create another cache called MyCache . Because the layer=1 suboption is specified, this new cache is a layered cache, which builds on MyCache in the previous container layer. (Open Liberty starts two VMs, so if you instead use the createLayer suboption here, two layered caches are created, with layer numbers of 1 and 2.) Note that cache layers are different from, and independent of, container layers. In the same way, another Docker layer is added for an application, and another layered cache is created to add to MyCache . The listAllCaches suboption now shows all the caches and their layers: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches MyCache Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 MyCache Java8 64-bit persistent cr 1 Mon Sep 23 11:46:25 2019 MyCache Java8 64-bit persistent cr 2 In use The caches are created in the same directory. When you use the -Xshareclasses:name=MyCache suboption in future Java commands, all the caches are started. The top-layer cache is started in read/write mode, and lower-layer caches are started in read-only mode. Modifying a lower-layer cache will invalidate all the caches in the layers above. The following options and cache utilities are available for creating, managing, and removing layered caches: -Xshareclasses:createLayer -Xshareclasses:layer -Xshareclasses:printTopLayerStats (for example output, see printTopLayerStats ) -Xshareclasses:destroyAllLayers Saving a non-persistent shared classes cache As described in an earlier section, a shared classes cache can be persistent or non-persistent; persistent caches are memory-mapped files. By default, a cache is persistent on all platforms, except z/OS. Non-persistent caches are stored in shared memory and are removed when a system is rebooted. If you want to save a non-persistent cache beyond a reboot, you might want to consider taking a cache snapshot. To create a snapshot of a non-persistent shared classes cache, use the -Xshareclasses:snapshotCache cache utility. The snapshot has the same name and location as the shared cache, as specified by the name and cacheDir suboptions. The shared cache can be in use when the snapshot is taken, but VMs are blocked when they try to write to the shared cache while the cache data is copied to the file. Typically, after a system is reinitialized, the snapshot file is used to restore the copy of the non-persistent cache into shared memory, by using the -Xshareclasses:restoreFromSnapshot cache utility. Because this process removes all non-persistent caches from shared memory, restoring the cache from the snapshot file can result in better VM startup performance, because the contents of the shared cache, including classes and AOT code, do not have to be re-created. The -Xshareclasses:listAllCaches cache utility can be used to identify snapshots on a system. A snapshot can be created only if the user has sufficient permissions to create the destination snapshot file. If a snapshot of the same name exists already, it is overwritten. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to create a snapshot. For information about removing snapshot files, see the destroySnapshot and destroyAllSnapshots cache utilities in Housekeeping . Notes: Persistent caches are not supported on z/OS. The snapshotCache and restoreFromCache cache utilities cannot be used on Windows systems. Housekeeping Caches can be deleted if they contain many stale classes or if the cache is full and you want to create a bigger cache. Use one of the following utilities to remove unwanted caches: -Xshareclasses:destroy : Removes specific caches when used with the name , cacheDir , and nonpersistent suboptions. -Xshareclasses:destroyAll : Removes all the caches that are specified by the cacheDir and nonpersistent suboptions. -Xshareclasses:destroySnapshot : Removes a cache snapshot from disk that is specified by name and cacheDir suboptions. -Xshareclasses:destroyAllSnapshots : Removes all cache snapshots from disk that are found by specifying the cacheDir suboption. -Xshareclasses:destroyAllLayers : Removes all shared cache layers that are specified by the name and cacheDir suboptions. Note: You must always use the utilities to remove non-persistent caches correctly from shared memory. Caches can also be removed if they are unused for a specified amount of time. To configure time-based housekeeping, use the -Xshareclasses:expire option. If you want to remove a cache but allow it to be re-created when the VM restarts, use the -Xshareclasses:reset option. Support for custom class loaders Classes are shared by the bootstrap class loader internally in the VM. The OpenJ9 implementation of java.net.URLClassLoader is modified to use SharedClassURLClasspathHelper and any class loaders that extend java.net.URLClassLoader can inherit this behavior. If you are using a custom class loader that does not extend java.net.URLClassLoader , you can use the Java Helper API to find and store classes in a shared classes cache. If a running application uses its own class loader and you are using a SecurityManager , you must grant the class loader permission to SharedCachePermission before they can share classes. To grant permission, add shared class permissions to the java.policy file by specifying the ClassLoader class name. Permissions can be set for read , write , or read,write . For example: permission com.ibm.oti.shared.SharedClassPermission \"com.abc.customclassloaders.*\", \"read,write\"; If a running application is calling the com.ibm.oti.shared.SharedClassUtilities APIs getSharedCacheInfo() or destroySharedCache() , you must also grant the code calling these APIs the appropriate SharedClassesNamedPermission . For example: permission com.ibm.oti.shared.SharedClassesNamedPermission \"getSharedCacheInfo\"; permission com.ibm.oti.shared.SharedClassesNamedPermission \"destroySharedCache\"; The Java shared classes Helper API The Java Helper API classes can be found in the com.ibm.oti.shared package. Each class loader that wants to share classes must get a SharedClassHelper object from a SharedClassHelperFactory . The SharedClassHelper , when created, has a one to one relationship with the class loader. That is, it belongs to the class loader that requested it and can only store classes defined by that class loader. The SharedClassHelper gives the class loader a simple API for finding and storing classes in the class cache to which the VM is connected. If the class loader is garbage collected, its SharedClassHelper is also garbage collected. The following main functions are available from the SharedClassHelper API: findSharedClass : Used to check whether a class is already in the cache before looking for the class on the file system. storeSharedClass : Used to store a class in the cache. setSharingFilter : A filter that can be used to decide which classes are found and stored in the cache. This filter can be applied to a particular package by implementing the SharedClassFilter interface. To apply a filter to all non-bootstrap class loaders that share classes, specify the -Dcom.ibm.oti.shared.SharedClassGlobalFilterClass system property on the command line. You can also define partitions in a cache to store sets of classes separately from one another. For more information see SharedClassHelper cache partitions . Each class loader that wants to share data must get a SharedDataHelper object from a SharedDataHelperFactory . A SharedDataHelperFactory provides an interface that can be used to create SharedDataHelpers , which are used for storing Java byte array data. A SharedDataHelper also has a one to one relationship with a class loader, although a class loader can exist without a SharedDataHelper . The Java shared classes utility API The following APIs are available for obtaining information about a shared classes cache: com.ibm.oti.shared.SharedClassStatistics : Obtains information about cache size, including free space, soft maximum limit, and the limits enforced for AOT and JIT data. com.ibm.oti.shared.SharedClassUtilities : Obtains detailed information about a shared classes cache, including its size, name, type, and status. com.ibm.oti.shared.SharedClassCacheInfo : Stores information about a shared classes cache and provides API methods to retrieve the information and remove caches. You can also use the IterateSharedCaches and DestroySharedCache JVMTI extensions . Support for bytecode instrumentation Modifying the bytecode of a set of classes at runtime is a useful mechanism for adding functions to a program, such as profiling or debugging. The JVM Tools Interface (JVMTI) includes hooks that allow you to instrument the byte code in this way. Alternatively, you can write your own Java agent that uses the java.lang.instrument API. Sharing classes that are changed before they are loaded adds complexity to the class sharing process. By default, if OpenJ9 detects that a JVMTI agent or java.lang.instrument agent has registered to modify class bytes, modified classes are not stored in the cache. Instead, the VM stores original class byte data in the cache, which allows classes to be retransformed. If you turn off bytecode instrumentation support by specifying -Xshareclasses:disableBCI and do not use a modification context to share modified classes safely, all bytecode is loaded from the file system for the agent to modify. When passed to the cache for storing, the VM compares the bytes with known classes of the same name. If a match is found, the class is reused. However, if a match is not found, the potentially modified class is stored in the cache in a way that prevents other VMs from loading it. In this situation, performance can be affected because the bytecode is always loaded from the file system and compared with existing classes in the cache. When bytecode instrumentation is turned off, classes loaded from the shared cache cannot be retransformed. For more information about using a modification context, see Sharing modified bytecode . Redefined and retransformed classes The following rules exist for classes that are redefined or retransformed by JVMTI or java.lang.instrument agents: Redefined classes contain replacement bytecode that is provided by an agent at run time by using the JVMTI RedefineClasses or Instrumentation.redefineClasses function. A typical use case is for debugging, where function is added for log output. These classes are never stored in the cache. Retransformed classes contain bytecode that can be changed without any reference to the original bytecode by using the JVMTI RetransformClasses or Instrumentation.retransformClasses functions. A typical use case is a profiling agent that adds or removes profiling calls with each retransformation. These classes can be modified multiple times and are not stored in the cache by default. If you want to store these modified classes for reuse, you can do so by setting the -Xshareclasses:cacheRetransformed suboption when you start your application. This option turns off bytecode instrumentation support, forcing cache creation into -Xshareclasses:disableBCI mode. Sharing modified bytecode Sharing modified bytecode can be advantageous for applications that use the same modifications because the transformation process needs to happen only once. OpenJ9 allows multiple VMs that are using the same or different types of class modifications to safely share the cache. However, when a class is modified and cached, it cannot be modified (retransformed) further. Modified bytecode can be shared safely by using a modification context . Use the -Xshareclasses:disableBCI and -Xshareclasses:modified=<modified_context> suboptions when you start your application, where <modified_context> is a user-defined description. The cache is structured so that any VM that is started with the same modification context can share the classes in a private area. The following outcomes apply to VMs that do not want to share the modified classes: A VM that is started without specifying a modification context shares classes outside of that area as normal. A VM that is started with a different modification context, shares classes in its own private area. SharedClassHelper cache partitions Another method of structuring and protecting classes in the shared classes cache can be implemented by using the SharedClassHelper API with a custom class loader. This mechanism creates partitions by using a string key to identify a set of classes, which can be stored and retrieved by the class loader. A use case for this mechanism is Aspect Oriented Programming (AOP) where aspects are woven in to bytecode when a class is loaded into the VM. Being able to partition the cache provides a suitable level of granularity when you want to use different aspect paths. Although it is possible to combine partitions and modification contexts, this practice is not recommended because the cache will contain partitions within partitions. Note: Partitions are not supported by the bootstrap class loader or the default application class loader. See also AOT compiler Class sharing article Diagnosing problems with class data sharing","title":"Introduction"},{"location":"shrc/#introduction-to-class-data-sharing","text":"Sharing class data between Eclipse OpenJ9\u2122 VMs improves start up performance and reduces memory footprint. Consider the following outcomes for two VMs that are running similar Java applications but sharing class data: Start up performance is improved by placing classes that each application needs when initializing into a shared classes cache. The next time the application runs, it takes less time to start because the classes are already available. Memory footprint is reduced by sharing common classes between the applications. When class data sharing is enabled, OpenJ9 automatically creates shared memory that stores and shares the classes in memory between processes. This shared classes cache is updated dynamically; when an application loads new classes, the VM automatically stores them in the cache without any user intervention. By default, class data sharing is enabled for bootstrap classes, as described in Enabling class data sharing . When class data sharing is enabled, Ahead-of-time (AOT) compilation is also enabled by default, which dynamically compiles certain methods into AOT code at runtime. By using these features in combination, startup performance is further improved because the cached AOT code can be used to quickly enable native code performance for subsequent runs of your application. For more information about AOT, see AOT Compiler . Further performance improvements are gained by storing JIT data and profiles in the shared classes cache. The contents of a shared classes cache can include the following artifacts: Bootstrap classes Application classes Metadata that describes the classes AOT-compiled code JIT data GC hints (for initial Java heap size) Bootstrap jar file indexes","title":"Introduction to class data sharing"},{"location":"shrc/#cache-utilities","text":"Active caches can be managed by a set of cache utilities, which are invoked by specifying -Xshareclasses suboptions. These utilities control the following types of operations: Displaying information about the caches on a system. Adjusting the size of a cache and the amount of space that is reserved for AOT code or JIT data. Creating a snapshot of a non-persistent cache to save to disk and restoring the cache from disk. Troubleshooting cache problems. Removing unwanted caches on a system. These cache utilities are discussed in more detail in the sections that follow.","title":"Cache utilities"},{"location":"shrc/#enabling-class-data-sharing","text":"Class data sharing is enabled by default for bootstrap classes, unless your application is running in a container. Default behavior includes the following characteristics: On Windows\u00ae, the cache is created in the user's C:\\Users\\<username>\\AppData\\Local\\javasharedresources directory. On z/OS\u00ae, the default cache directory is /tmp/javasharedresources . On other systems, the cache is created in the javasharedresources directory in the users home directory, unless the groupAccess parameter is specified, in which case it is created in /tmp/javasharedresources . Please do not set the home directory on a NFS mount or shared mount across systems or LPARs. The cache name is sharedcc_%u , where %u is the current user name. If class data sharing fails, the VM still starts without printing any errors. Shared class behavior is controlled by specifying the -Xshareclasses option on the command line when you start your application. The default settings are equivalent to specifying the following suboptions: -Xshareclasses:bootClassesOnly,nonFatal,silent You can enable class data sharing for non-bootstrap classes as well as bootstrap classes, by omitting the bootClassesOnly suboption. You can also disable all class data sharing by using the none suboption. Further suboptions are available to configure a cache at startup, including name, location, and startup size. You can also use cache utilities to manage a shared classes cache after it is initialized and in use. A shared classes cache can be persistent or non-persistent according to the following definition: persistent caches are written to memory-mapped files and remain in place, even after a system is rebooted. non-persistent caches exist in shared memory and are automatically removed when the operating system is restarted. By default, a shared classes cache is persistent, except on the z/OS\u00ae platform, where persistent caches are not supported. If you are using a non-persistent cache, you can use a cache utility to create a snapshot of the cache, which can be reinitialized after a reboot. For more information see Saving a non-persistent shared classes cache . If you have multiple VMs and you do not change the default shared classes behavior, the VMs share a single default cache, assuming that the VMs are from a single Java installation. If the VMs are from different Java installations, the cache might be deleted and re-created. For a set of best practices when using class data sharing, see Creating a shared classes cache .","title":"Enabling class data sharing"},{"location":"shrc/#class-data-sharing-operations","text":"When a VM loads a class and the class loader is enabled for class sharing, the VM looks in the shared classes cache to see if the class is already present. If the class is present and the classpath or URL to load the class is a match, the VM loads the class from the cache. Otherwise, it loads the class from the file system and writes it into the cache. The VM detects file system updates by storing timestamp values into the cache and comparing the cached values with actual values. In this way, the VM detects when a class might be invalidated and can mark the class as stale . These operations happen transparently when classes are loaded, so users can modify and update as many classes as they like during the lifetime of a shared class cache, knowing that the correct classes are always loaded. Stale classes are redeemed if the same class is subsequently fetched by the class loader from another VM and checked against the stale class in the cache. Occasionally, caches that are created from one version of the VM might not be compatible with caches that are created from a different version. This situation typically occurs when an update is made in OpenJ9 that changes the internal cache data structure. If a VM detects an incompatible cache at start up, it creates a new cache that can coexist, even if it has the same name. The VM detects a conflict by checking an internal shared classes cache generation number. Caches are not compatible between VMs that are using different object storage modes. For example, a 64-bit VM that uses compressed references to store 64-bit objects in a 32-bit representation, cannot share a cache with a 64-bit VM that is not using compressed references. For more information about object storage options, see Compressed references . In the OpenJ9 implementation of java.net.URLClassLoader , classes are read from and written to the cache using the public Helper API. Therefore, any class loader that extends java.net.URLClassLoader gets class sharing support for free provided that it continues to use the methods in java.net.URLClassLoader to load classes. Custom class loaders that do not extend java.net.URLClassLoader must be adapted to share class data as described in Support for custom class loaders .","title":"Class data sharing operations"},{"location":"shrc/#aot-code-and-jit-data","text":"OpenJ9 can automatically store small amounts of AOT code and JIT data, which helps improve performance in the following ways: The JIT compiler dynamically compiles certain methods into AOT code at runtime. Subsequent VMs that attach to the cache can take advantage of the compiled code to start faster. The JIT compiler stores profiling data and various compilation hints into the shared classes cache. This data enables subsequent VMs that attach to the cache to start faster, run faster, or both. The default settings provide significant performance benefits. However, you can specify options on the command line to configure AOT code storage or JIT data storage in the shared classes cache, as shown in the following table: Component Setting a minimum storage value Setting a maximum storage value Turning off storage AOT code -Xscminaot<size> -Xscmaxaot<size> -Xshareclasses:noaot JIT data -Xscminjitdata<size> -Xscmaxjitdata<size> -Xshareclasses:nojitdata The following cache utilities are available to adjust the storage values when a cache is active: Component Adjusting the minimum storage value Adjusting the maximum storage value AOT code -Xshareclasses:adjustminaot -Xshareclasses:adjustmaxaot JIT code -Xshareclasses:adjustminjit -Xshareclasses:adjustmaxjit You can also use the -Xshareclasses:findAotMethods cache utility to list the AOT methods in a cache that match a method specification. This utility helps you identify methods that are causing a failure in an application. You can then invalidate the method without destroying the cache by using the -Xshareclasses:invalidateAotMethods cache utility. You can also revalidate an AOT method with the -Xshareclasses:revalidateAotMethods cache utility. To troubleshoot AOT problems, use the -Xshareclasses:verboseAOT suboption on the command line, which generates output about AOT code that is found or stored in the cache. For more information see -Xshareclasses .","title":"AOT code and JIT data"},{"location":"shrc/#creating-a-shared-classes-cache","text":"The -Xshareclasses option is highly configurable, allowing you to specify where to create the cache, how much space to allocate, and more. The following best practices apply to using class data sharing: Before starting your application, use the -Xshareclasses:listAllCaches cache utility to review and maintain the existing caches on your system. This option lists all the caches that exist in the default directory, including compatible and incompatible caches. You can also specify the cacheDir suboption to look for caches in a specified directory. Remove any obsolete caches, as described in Housekeeping . If you are creating a new cache, set an application-specific cache name ( -Xshareclasses:name=<name> ). If a cache with the specified name doesn't already exist, a new cache is created. This avoids sharing your application cache with a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note: You cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. Set a specific cache directory ( -Xshareclasses:cacheDir=<directory> ). Set a cache directory that is specific to your application, to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory. Your application will be unaffected by a user running java -Xshareclasses:destroyAll . Please do not set the cache directory on a NFS mount or a shared mount across systems or LPARs. In addition, if you have VMs from different Java installations, of the same Java release and installed by the same user, each VM checks whether the existing default shared cache in the cache directory is from the same Java installation as the VM. If not, the VM deletes that shared cache, then creates a new one. Specifying a different cache directory for each Java installation avoids this situation. Ensure that the cache directory permissions are set appropriately ( -Xshareclasses:cacheDirPerm ). It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. Access is controlled by operating system permissions and Java security permissions; read/write access is the default only for the current user. On Unix systems, you can use the -Xshareclasses:groupAccess suboption to allow read/write permissions for groups as well as users. On z/OS, a cache can be accessed only by a VM that is running in the same storage key as the VM that created the cache. If the keys do not match, permission to access the cache is denied. Set the -Xshareclasses:nonfatal option. In most cases, setting this option allows your application to start even if there is a problem opening or creating the shared cache. The VM will continue to start without class data sharing. Set a soft maximum size for the cache by specifying the -Xscmx option with the -XXSharedCacheHardLimit option. For example, you might create a 64 MB shared cache and set a smaller value, such as 16 MB, for the -Xscmx option, to limit the data stored in the cache ( -XX:SharedCacheHardLimit=64m -Xscmx16m ). You can then adjust the soft maximum size by using the -Xshareclasses:adjustsoftmx cache utility or the MemoryMXBean.setSharedClassCacheSoftmxBytes() method in the com.ibm.lang.management API. For more information, see Setting a soft maximum size .","title":"Creating a shared classes cache"},{"location":"shrc/#creating-layer-caches","text":"Creating a layered cache might be useful when you are building a Docker image. Normally, writing to an existing shared cache in a lower image layer results in Docker duplicating the shared cache to the top layer (following the Docker copy-on-write strategy ). With a layered cache, you can instead write into a new cache in the top layer. The new cache builds on the existing cache, so space is saved in the image. The following example shows a Docker container with four layers: The lowest layer is a Ubuntu Docker image. The next layer is an OpenJ9 Docker image that is built on the Ubuntu image. As part of this image, the -Xshareclasses:name=MyCache suboption is used to create a cache called MyCache . The layer number assigned to this cache is 0 . The listAllCaches suboption shows the cache and the layer number: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches MyCache Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 The next Docker layer up is a middleware image that is built on the OpenJ9 image. As part of this image, the -Xshareclasses:name=MyCache,layer=1 suboption is used to create another cache called MyCache . Because the layer=1 suboption is specified, this new cache is a layered cache, which builds on MyCache in the previous container layer. (Open Liberty starts two VMs, so if you instead use the createLayer suboption here, two layered caches are created, with layer numbers of 1 and 2.) Note that cache layers are different from, and independent of, container layers. In the same way, another Docker layer is added for an application, and another layered cache is created to add to MyCache . The listAllCaches suboption now shows all the caches and their layers: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches MyCache Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 MyCache Java8 64-bit persistent cr 1 Mon Sep 23 11:46:25 2019 MyCache Java8 64-bit persistent cr 2 In use The caches are created in the same directory. When you use the -Xshareclasses:name=MyCache suboption in future Java commands, all the caches are started. The top-layer cache is started in read/write mode, and lower-layer caches are started in read-only mode. Modifying a lower-layer cache will invalidate all the caches in the layers above. The following options and cache utilities are available for creating, managing, and removing layered caches: -Xshareclasses:createLayer -Xshareclasses:layer -Xshareclasses:printTopLayerStats (for example output, see printTopLayerStats ) -Xshareclasses:destroyAllLayers","title":"Creating layer caches"},{"location":"shrc/#saving-a-non-persistent-shared-classes-cache","text":"As described in an earlier section, a shared classes cache can be persistent or non-persistent; persistent caches are memory-mapped files. By default, a cache is persistent on all platforms, except z/OS. Non-persistent caches are stored in shared memory and are removed when a system is rebooted. If you want to save a non-persistent cache beyond a reboot, you might want to consider taking a cache snapshot. To create a snapshot of a non-persistent shared classes cache, use the -Xshareclasses:snapshotCache cache utility. The snapshot has the same name and location as the shared cache, as specified by the name and cacheDir suboptions. The shared cache can be in use when the snapshot is taken, but VMs are blocked when they try to write to the shared cache while the cache data is copied to the file. Typically, after a system is reinitialized, the snapshot file is used to restore the copy of the non-persistent cache into shared memory, by using the -Xshareclasses:restoreFromSnapshot cache utility. Because this process removes all non-persistent caches from shared memory, restoring the cache from the snapshot file can result in better VM startup performance, because the contents of the shared cache, including classes and AOT code, do not have to be re-created. The -Xshareclasses:listAllCaches cache utility can be used to identify snapshots on a system. A snapshot can be created only if the user has sufficient permissions to create the destination snapshot file. If a snapshot of the same name exists already, it is overwritten. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to create a snapshot. For information about removing snapshot files, see the destroySnapshot and destroyAllSnapshots cache utilities in Housekeeping . Notes: Persistent caches are not supported on z/OS. The snapshotCache and restoreFromCache cache utilities cannot be used on Windows systems.","title":"Saving a non-persistent shared classes cache"},{"location":"shrc/#housekeeping","text":"Caches can be deleted if they contain many stale classes or if the cache is full and you want to create a bigger cache. Use one of the following utilities to remove unwanted caches: -Xshareclasses:destroy : Removes specific caches when used with the name , cacheDir , and nonpersistent suboptions. -Xshareclasses:destroyAll : Removes all the caches that are specified by the cacheDir and nonpersistent suboptions. -Xshareclasses:destroySnapshot : Removes a cache snapshot from disk that is specified by name and cacheDir suboptions. -Xshareclasses:destroyAllSnapshots : Removes all cache snapshots from disk that are found by specifying the cacheDir suboption. -Xshareclasses:destroyAllLayers : Removes all shared cache layers that are specified by the name and cacheDir suboptions. Note: You must always use the utilities to remove non-persistent caches correctly from shared memory. Caches can also be removed if they are unused for a specified amount of time. To configure time-based housekeeping, use the -Xshareclasses:expire option. If you want to remove a cache but allow it to be re-created when the VM restarts, use the -Xshareclasses:reset option.","title":"Housekeeping"},{"location":"shrc/#support-for-custom-class-loaders","text":"Classes are shared by the bootstrap class loader internally in the VM. The OpenJ9 implementation of java.net.URLClassLoader is modified to use SharedClassURLClasspathHelper and any class loaders that extend java.net.URLClassLoader can inherit this behavior. If you are using a custom class loader that does not extend java.net.URLClassLoader , you can use the Java Helper API to find and store classes in a shared classes cache. If a running application uses its own class loader and you are using a SecurityManager , you must grant the class loader permission to SharedCachePermission before they can share classes. To grant permission, add shared class permissions to the java.policy file by specifying the ClassLoader class name. Permissions can be set for read , write , or read,write . For example: permission com.ibm.oti.shared.SharedClassPermission \"com.abc.customclassloaders.*\", \"read,write\"; If a running application is calling the com.ibm.oti.shared.SharedClassUtilities APIs getSharedCacheInfo() or destroySharedCache() , you must also grant the code calling these APIs the appropriate SharedClassesNamedPermission . For example: permission com.ibm.oti.shared.SharedClassesNamedPermission \"getSharedCacheInfo\"; permission com.ibm.oti.shared.SharedClassesNamedPermission \"destroySharedCache\";","title":"Support for custom class loaders"},{"location":"shrc/#the-java-shared-classes-helper-api","text":"The Java Helper API classes can be found in the com.ibm.oti.shared package. Each class loader that wants to share classes must get a SharedClassHelper object from a SharedClassHelperFactory . The SharedClassHelper , when created, has a one to one relationship with the class loader. That is, it belongs to the class loader that requested it and can only store classes defined by that class loader. The SharedClassHelper gives the class loader a simple API for finding and storing classes in the class cache to which the VM is connected. If the class loader is garbage collected, its SharedClassHelper is also garbage collected. The following main functions are available from the SharedClassHelper API: findSharedClass : Used to check whether a class is already in the cache before looking for the class on the file system. storeSharedClass : Used to store a class in the cache. setSharingFilter : A filter that can be used to decide which classes are found and stored in the cache. This filter can be applied to a particular package by implementing the SharedClassFilter interface. To apply a filter to all non-bootstrap class loaders that share classes, specify the -Dcom.ibm.oti.shared.SharedClassGlobalFilterClass system property on the command line. You can also define partitions in a cache to store sets of classes separately from one another. For more information see SharedClassHelper cache partitions . Each class loader that wants to share data must get a SharedDataHelper object from a SharedDataHelperFactory . A SharedDataHelperFactory provides an interface that can be used to create SharedDataHelpers , which are used for storing Java byte array data. A SharedDataHelper also has a one to one relationship with a class loader, although a class loader can exist without a SharedDataHelper .","title":"The Java shared classes Helper API"},{"location":"shrc/#the-java-shared-classes-utility-api","text":"The following APIs are available for obtaining information about a shared classes cache: com.ibm.oti.shared.SharedClassStatistics : Obtains information about cache size, including free space, soft maximum limit, and the limits enforced for AOT and JIT data. com.ibm.oti.shared.SharedClassUtilities : Obtains detailed information about a shared classes cache, including its size, name, type, and status. com.ibm.oti.shared.SharedClassCacheInfo : Stores information about a shared classes cache and provides API methods to retrieve the information and remove caches. You can also use the IterateSharedCaches and DestroySharedCache JVMTI extensions .","title":"The Java shared classes utility API"},{"location":"shrc/#support-for-bytecode-instrumentation","text":"Modifying the bytecode of a set of classes at runtime is a useful mechanism for adding functions to a program, such as profiling or debugging. The JVM Tools Interface (JVMTI) includes hooks that allow you to instrument the byte code in this way. Alternatively, you can write your own Java agent that uses the java.lang.instrument API. Sharing classes that are changed before they are loaded adds complexity to the class sharing process. By default, if OpenJ9 detects that a JVMTI agent or java.lang.instrument agent has registered to modify class bytes, modified classes are not stored in the cache. Instead, the VM stores original class byte data in the cache, which allows classes to be retransformed. If you turn off bytecode instrumentation support by specifying -Xshareclasses:disableBCI and do not use a modification context to share modified classes safely, all bytecode is loaded from the file system for the agent to modify. When passed to the cache for storing, the VM compares the bytes with known classes of the same name. If a match is found, the class is reused. However, if a match is not found, the potentially modified class is stored in the cache in a way that prevents other VMs from loading it. In this situation, performance can be affected because the bytecode is always loaded from the file system and compared with existing classes in the cache. When bytecode instrumentation is turned off, classes loaded from the shared cache cannot be retransformed. For more information about using a modification context, see Sharing modified bytecode .","title":"Support for bytecode instrumentation"},{"location":"shrc/#redefined-and-retransformed-classes","text":"The following rules exist for classes that are redefined or retransformed by JVMTI or java.lang.instrument agents: Redefined classes contain replacement bytecode that is provided by an agent at run time by using the JVMTI RedefineClasses or Instrumentation.redefineClasses function. A typical use case is for debugging, where function is added for log output. These classes are never stored in the cache. Retransformed classes contain bytecode that can be changed without any reference to the original bytecode by using the JVMTI RetransformClasses or Instrumentation.retransformClasses functions. A typical use case is a profiling agent that adds or removes profiling calls with each retransformation. These classes can be modified multiple times and are not stored in the cache by default. If you want to store these modified classes for reuse, you can do so by setting the -Xshareclasses:cacheRetransformed suboption when you start your application. This option turns off bytecode instrumentation support, forcing cache creation into -Xshareclasses:disableBCI mode.","title":"Redefined and retransformed classes"},{"location":"shrc/#sharing-modified-bytecode","text":"Sharing modified bytecode can be advantageous for applications that use the same modifications because the transformation process needs to happen only once. OpenJ9 allows multiple VMs that are using the same or different types of class modifications to safely share the cache. However, when a class is modified and cached, it cannot be modified (retransformed) further. Modified bytecode can be shared safely by using a modification context . Use the -Xshareclasses:disableBCI and -Xshareclasses:modified=<modified_context> suboptions when you start your application, where <modified_context> is a user-defined description. The cache is structured so that any VM that is started with the same modification context can share the classes in a private area. The following outcomes apply to VMs that do not want to share the modified classes: A VM that is started without specifying a modification context shares classes outside of that area as normal. A VM that is started with a different modification context, shares classes in its own private area.","title":"Sharing modified bytecode"},{"location":"shrc/#sharedclasshelper-cache-partitions","text":"Another method of structuring and protecting classes in the shared classes cache can be implemented by using the SharedClassHelper API with a custom class loader. This mechanism creates partitions by using a string key to identify a set of classes, which can be stored and retrieved by the class loader. A use case for this mechanism is Aspect Oriented Programming (AOP) where aspects are woven in to bytecode when a class is loaded into the VM. Being able to partition the cache provides a suitable level of granularity when you want to use different aspect paths. Although it is possible to combine partitions and modification contexts, this practice is not recommended because the cache will contain partitions within partitions. Note: Partitions are not supported by the bootstrap class loader or the default application class loader.","title":"SharedClassHelper cache partitions"},{"location":"shrc/#see-also","text":"AOT compiler Class sharing article Diagnosing problems with class data sharing","title":"See also"},{"location":"shrc_diag_util/","text":"Diagnosing problems with class data sharing If you encounter problems with class data sharing, VM messages are typically generated that point to an underlying cause. In some situations, a cache might fail to initialize correctly. In other situations classes might not be found or stored in the shared classes cache. To provide more information about a problem, you can generate verbose output, use diagnostic cache utilities, or use the Eclipse OpenJ9\u2122 trace facility. Initialization problems If you do not specify a directory for the shared classes cache by using the cacheDir suboption, the cache is created in the javasharedresources directory in the following default location: On Windows\u00ae systems, this directory is created in the user's C:\\Users\\<username>\\AppData\\Local\\ directory. On z/OS\u00ae systems, this directory is created in the /tmp directory. On other systems, this directory is located in the user's home directory. Do not set the user's home directory on an NFS mount or a shared mount across systems or LPARs. Initialization problems can occur on systems other than Windows because caches are created with read/write access for the user only and subsequent users do not have permission to write to the home directory. If you specify the -Xshareclasses:groupAccess suboption, the cache is created in the /tmp directory instead where all users have permission to write to the cache. For a persistent cache, initialization problems can also occur if there is insufficient disk space available or if you are attempting to locate the cache on a remote networked file system, which is not supported. For a non-persistent cache, a shared memory area is required. Check that your system is configured with sufficient resources as described in Setting shared memory values . If initialization problems persist, try deleting the cache by using the -Xshareclasses:destroyAll cache utility, which removes all known shared memory areas and semaphores for caches in the cacheDir specified or the default directory. These actions force the VM to re-create the cache. Problems finding or storing classes The most common cause for classes not being stored in the cache is due to space constraints. Make sure that you set an appropriate size for the cache, as described in Creating a shared classes cache . Setting a soft maximum size is recommended, because you can adjust the soft maximum size that is set for the cache after it is created. See Setting a soft maximum size . Storing classes can also be a problem if the cache is opened read-only or if the class does not exist on the file system because it is sourced from a URL location. If you are attempting to share modified bytecode, you must use a modification context, as described in Sharing modified bytecode . Otherwise, classes are stored in a private area that is not accessible to other VMs. If you are using a custom class loader, class path entries in the SharedClassURLClasspathHelper must be confirmed before classes can be found for these entries. More information about confirmed entries is available in the SharedClassURLClasspathHelper interface in the com.ibm.oti.shared API documentation . If you are instrumenting bytecode by using a JVMTI agent or java.lang.instrument agent, the following rules apply: Redefined classes are never stored in the cache. Retransformed classes are stored only if you specify the -Xshareclasses:cacheRetransformed suboption when you start your application. If a running application uses its own class loader and you are using a SecurityManager , you must grant the class loader permission to SharedCachePermission before they can share classes. For more information, see Support for custom class loaders . In very rare cases, problems with finding or storing classes might be due to cache corruption. If the VM detects that a cache is corrupt, it attempts to destroy the cache and re-create it. If the VM cannot re-create the cache, it starts only if the -Xshareclasses:nonfatal suboption is specified on the command line, but without using the shared cache. Try using the -Xshareclasses:destroy cache utility to remove the specific cache and re-create it. You might need to specify the cacheDir=<directory> and name=<cache_name> suboptions if the cache is not using the default settings. Generating verbose output A number of -Xshareclasses suboptions are available for generating verbose output during class data sharing operations, which can help you identify the root cause of a problem. verbose The -Xshareclasses:verbose suboption provides basic output on cache usage. In the following example, a persistent cache is opened and attached to the VM for class sharing. Information is provided about the size of the cache, the unstored bytes due to the setting of a soft maximum size, and maximum AOT and JIT data size. java -Xshareclasses:name=myCache,verbose HelloWorld [-Xshareclasses persistent cache enabled] [-Xshareclasses verbose output enabled] JVMSHRC237I Opened shared classes persistent cache myCache JVMSHRC246I Attached shared classes persistent cache myCache JVMSHRC765I Memory page protection on runtime data, string read-write data and partially filled pages is successfully enabled Hello World JVMSHRC168I Total shared class bytes read=2532416. Total bytes stored=268156 JVMSHRC818I Total unstored bytes due to the setting of shared cache soft max is 0. Unstored AOT bytes due to the setting of -Xscmaxaot is 0. Unstored JIT bytes due to the setting of -Xscmaxjitdata is 0. verboseIO The -Xshareclasses:verboseIO suboption provides more detailed information about class sharing operations. In the following example, some classes are found when the cache is accessed. However, class openj9/internal/tools/attach/target/CommonDirectory is not found and is therefore stored for sharing. java -Xshareclasses:name=myCache,verboseIO HelloWorld [-Xshareclasses verbose I/O output enabled] Found class java/lang/Object in shared cache for class-loader id 0. Found class java/lang/J9VMInternals in shared cache for class-loader id 0. Found class com/ibm/oti/vm/VM in shared cache for class-loader id 0. Found class java/lang/J9VMInternals$ClassInitializationLock in shared cache for class-loader id 0. ... Failed to find class openj9/internal/tools/attach/target/CommonDirectory in shared cache for class-loader id 0. Stored class openj9/internal/tools/attach/target/CommonDirectory in shared cache for class-loader id 0 with URL /root/sdk/jre/lib/amd64/compressedrefs/jclSC180/vm.jar (index 0). ... The bootstrap class loader has an ID of 0 ; other class loaders are given a unique ID. Class loaders follow the class loader hierarchy by asking the parent class loader for a class. If a parent fails to find the class in the cache, the child class loader stores the class in the cache. In some situations, verbose output might not show classes being found. For example, classes are typically not found if the class is stale, as described in Class data sharing operations . Stale classes are redeemed if the same class is subsequently fetched by the class loader from another VM and checked against the stale class in the cache. verboseAOT To troubleshoot AOT problems, use the -Xshareclasses:verboseAOT suboption on the command line, which generates output about AOT code that is found or stored in the cache. In the following example output, a populated cache is being accessed to look for compiled AOT code. Some AOT code is found, which can be shared, and some AOT code is stored for reuse. java -Xshareclasses:name=myCache,verboseAOT HelloWorld [-Xshareclasses AOT verbose output enabled] Found AOT code for ROMMethod 0x00007F658005C180 in shared cache. Found AOT code for ROMMethod 0x00007F65800723EC in shared cache. Found AOT code for ROMMethod 0x00007F6580071D14 in shared cache. Stored AOT code for ROMMethod 0x00007F65801847B8 in shared cache. Stored AOT code for ROMMethod 0x00007F65800D38A4 in shared cache. Stored AOT code for ROMMethod 0x00007F65800723CC in shared cache. Found AOT code for ROMMethod 0x00007F65800D38A4 in shared cache. Stored AOT code for ROMMethod 0x00007F65800724C4 in shared cache. ... verboseHelper To troubleshoot problems with custom class loaders that use the Java SharedClassHelper API, specify the -Xshareclasses:verboseHelper suboption. Information messages and error messages are generated in the output, which can help you diagnose problems with finding or storing classes in the shared cache. The following example output shows only information messages: java -Xshareclasses:name=myCache,verboseHelper HelloWorld [-Xshareclasses Helper API verbose output enabled] Info for SharedClassURLClasspathHelper id 1: Verbose output enabled for SharedClassURLClasspathHelper id 1 Info for SharedClassURLClasspathHelper id 1: Created SharedClassURLClasspathHelper with id 1 Info for SharedClassURLClasspathHelper id 2: Verbose output enabled for SharedClassURLClasspathHelper id 2 Info for SharedClassURLClasspathHelper id 2: Created SharedClassURLClasspathHelper with id 2 Info for SharedClassURLClasspathHelper id 1: There are no confirmed elements in the classpath. Returning null. Info for SharedClassURLClasspathHelper id 2: There are no confirmed elements in the classpath. Returning null. Info for SharedClassURLClasspathHelper id 2: setClasspath() updated classpath. No invalid URLs found Info for SharedClassURLClasspathHelper id 2: Number of confirmed entries is now 1 Hello World Diagnostic cache utilities These utilities display information about the contents of a shared classes cache. Run the utilities by specifying them as suboptions of -Xshareclasses . The utilities run on the default cache unless you specify a cache by adding the name=<cache_name> and cacheDir=<directory> suboptions. printStats -Xshareclasses:printStats -Xshareclasses:printStats,name=<cache_name> -Xshareclasses:printStats=<data_type1>[+<data_type2>][...],name=<cache_name> Displays summary information about the cache. For layered caches, -Xshareclasses:printStats shows some information for the top layer cache, and summary information (bytes and counts only) for all layers combined. To see information for the top layer cache only, use printTopLayerStats . You can request more detail about items of a specific data type that are stored in the shared cache by using printStats=<data_type> . Use the plus symbol (+) to separate the data types. For example, use printStats=romclass+url,name=myCache to see information about ROMClass and URL items in all the layer caches of the cache called Cache1 . The valid data types are as follows (case insensitive): help (displays the list of valid data types) all (equivalent to printAllStats ) classpath url token romclass rommethod aot jitprofile jithint zipcache stale startuphint Example output for a traditional cache (no cache layers: cache layer = 0 ), with summary information only: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr Cache contains only classes with line numbers base address = 0x00007F60B807A000 end address = 0x00007F60B905E000 allocation pointer = 0x00007F60B81BE3A8 cache layer = 0 cache size = 16776608 softmx bytes = 16776608 free bytes = 12740572 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 30440 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 189358 Class debug area % used = 14% ROMClass bytes = 1328040 AOT bytes = 98404 JIT data bytes = 168 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 2 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 24% full Cache is accessible to current user = true Example output for a cache with 2 layers ( cache layer = 1 ), with summary information only: Current statistics for top layer of cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007FCAB2766000 end address = 0x00007FCAB374A000 allocation pointer = 0x00007FCAB2766000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% Cache is 8% full Cache is accessible to current user = true --------------------------------------------------------- Current statistics for all layers of cache \"Cache1\": ROMClass bytes = 1328040 AOT bytes = 128924 JIT data bytes = 812 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 20 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% The Cache created with section indicates the options that were used when the cache was created. BCI Enabled relates to the -Xshareclasses:enableBCI option (enabled by default) and Restrict Classpaths relates to the -Xshareclasses:restrictClasspaths option. Feature = cr indicates that the cache is a 64-bit compressed references cache. Line number information for classes in the cache is then shown with one of the following messages: Cache contains only classes with line numbers : VM line number processing was enabled for all the classes that were stored in this shared cache (the -Xlinenumbers option is enabled by default). All classes in the cache contain line numbers if the original classes contained line number data. Cache contains only classes without line numbers : The -Xnolinenumbers option was used to disable VM line number processing for all the classes that were stored in this shared cache, so none of the classes contain line numbers. Cache contains classes with line numbers and classes without line numbers : VM line number processing was enabled for some classes and disabled for others (the -Xnolinenumbers option was specified when some of the classes were added to the cache). The following summary data is displayed: baseAddress and endAddress The boundary addresses of the shared memory area that contains the classes. These addresses vary from run to run, depending on where the operating system allocates the memory. allocation pointer The address where ROMClass data is currently being allocated in the cache. cache layer The layer number that the cache stats relate to. cache size and free bytes cache size shows the total size of the shared memory area in bytes free bytes shows the free bytes that remain. The free space is not necessarily all available for storing new classes. The cache contains separate areas for different data, and can reserve space for AOT and JIT data, as shown by subsequent summary data. softmx bytes The soft maximum size for the cache. For more information, see -Xscmx . ROMClass bytes The number of bytes of class data in the cache, which does not include data that is stored in the class debug area (see separate output for the class debug area). AOT bytes The number of bytes of AOT-compiled code in the cache. Reserved space for AOT bytes The number of bytes reserved for AOT-compiled code in the cache. Maximum space for AOT bytes The maximum number of bytes of AOT-compiled code that can be stored in the cache. JIT data bytes The number of bytes of JIT-related data stored in the cache. Reserved space for JIT data bytes The number of bytes reserved for JIT-related data in the cache. Maximum space for JIT data bytes The maximum number of bytes of JIT-related data that can be stored in the cache. Zip cache bytes The number of zip entry cache bytes stored in the cache. On Java 11 and later, this value is zero unless a jar file is added to the boot classpath. Startup hint bytes The number of bytes of data stored to describe startup hints. Data bytes The number of bytes of non-class data stored by the VM. Metadata bytes The number of bytes of data stored to describe the cached classes. Note: This field is available only in the top layer cache output or when a cache is not layered. Metadata % used The proportion of metadata bytes to class bytes, which indicates how efficiently cache space is being used. The value shown does consider the Class debug area size . Class debug area size The size in bytes of the class debug area. This area is reserved to store LineNumberTable and LocalVariableTable class attribute information. Class debug area bytes used The size in bytes of the Class Debug Area that contains data. Class debug area % used The percentage of the Class Debug Area that contains data. ROMClasses The number of classes in the cache. The cache stores ROMClasses (the class data itself, which is read-only) and information about the location from which the classes were loaded. This information is stored in different ways, depending on the Java SharedClassHelper API that was used to store the classes. For more information, see Support for custom class loaders . AOT methods Optionally, ROMClass methods can be compiled and the AOT code stored in the cache. The AOT methods information shows the total number of methods in the cache that have AOT code compiled for them. This number includes AOT code for stale classes. Classpaths , URLs , and Tokens The number of class paths, URLs, and tokens in the cache. Classes stored from a SharedClassURLClasspathHelper are stored with a Classpath. Classes stored using a SharedClassURLHelper are stored with a URL. Classes stored using a SharedClassTokenHelper are stored with a Token. Most class loaders, including the bootstrap and application class loaders, use a SharedClassURLClasspathHelper . The result is that it is most common to see class paths in the cache. The number of Classpaths, URLs, and Tokens stored is determined by a number of factors. For example, every time an element of a Classpath is updated, such as when a .jar file is rebuilt, a new Classpath is added to the cache. Additionally, if partitions or modification contexts are used, they are associated with the Classpath, URL, or Token. A Classpath, URL, or Token is stored for each unique combination of partition and modification context. For more information, see Sharing modified bytecode and SharedClassHelper cache partitions . Zip caches The number of .zip files that have entry caches stored in the shared cache. On Java 11 and later, this value is zero unless a jar file is added to the boot classpath. Startup hints The number of startup hints stored in the cache. There can be a startup hint for each unique set of command line options used to start the VM. Stale classes The number of classes that have been marked as \"potentially stale\" by the cache code, because of a VM or Java application update. See Class data sharing operations . % Stale classes The percentage of classes in the cache that are stale. Cache is XXX% full The percentage of the cache that is currently used. This line is displayed only if the soft maximum size is not set. This value is calculated as follows: % Full = (('Cache Size' - 'Free Bytes') * 100) / ('Cache Size') Cache is XXX% soft full The percentage of the soft maximum size that is currently used. This line is displayed only if the soft maximum size is set. The free bytes in the cache statistics means the free bytes within the soft maximum limit. This value is calculated as follows: % soft Full = (('Soft max bytes' - 'Free Bytes') * 100) / ('Soft max bytes') For more information about the soft maximum size, see -Xscmx . Cache is accessible to current user Whether the current user can access the cache. printAllStats -Xshareclasses:printAllStats -Xshareclasses:printAllStats,name=<cache_name> Displays the contents of the cache in chronological order. You can use this output to see the history of updates that were made to the cache. For layered caches, some information is shown for the top layer cache only, and some is shown for all layers combined. To see information for the top layer cache only, use printTopLayerStats=all . Each entry in the output starts with a VM ID, so you can see which VM wrote the associated data. Here are example entries for various types of cache data, with explanations: Class paths The following example shows one class path with 4 entries: 1: 0x2234FA6C CLASSPATH /myVM/Apps/application1.jar /myVM/Apps/application2.jar /myVM/Apps/application3.jar /myVM/Apps/application4.jar 1 : the ID of the VM that wrote this data. 0x2234FA6C : the address where this data is stored. CLASSPATH : the type of data that was written. ROMClasses This example shows an entry for a single ROMClass : 1: 0x2234F7DC ROMCLASS: java/lang/Runnable at 0x213684A8 Index 1 in class path 0x2234FA6C 1 : the ID of the VM that wrote this data. 0x2234F7DC : the address where the metadata about the class is stored. ROMCLASS : the type of data that was stored. java/lang/Runnable : the name of the class. 0x213684A8 : the address where the class was stored. Index 1 : the index in the class path where the class was loaded from. 0x2234FA6C : the address of the class path against which this class is stored. Stale classes are marked with !STALE! . Any partition or modification context that is used when the class is stored is also shown. AOT methods This example shows an entry for one AOT-compiled method: 1: 0x00007F841A800554 AOT: hashCode Signature: ()I Address: 0x00007F83F6859280 for ROMClass java/lang/Object at 0x00007F83F6859000. 1 : the ID of the VM that wrote this data. 0x00007F841A800554 : the address where the data is stored. AOT : the type of data that was stored. hashCode : the method for which AOT-compiled code is stored. ()I : the signature of the ROM method. 0x00007F83F6859280 : the ROM method address. java/lang/Object : the class that contains the method. 0x00007F83F6859000 : the address of the class that contains the method. Stale methods are marked with !STALE! . URLs and tokens The output for these data types has the same format as that for class paths, but with a single entry. A Token is a string that is passed to the Java SharedClassHelper API. Zip entry caches The following example shows 4 separate entries for zip entry caches: 1: 0x042FE07C ZIPCACHE: luni-kernel.jar_347075_1272300300_1 Address: 0x042FE094 Size: 7898 1: 0x042FA878 ZIPCACHE: luni.jar_598904_1272300546_1 Address: 0x042FA890 Size: 14195 1: 0x042F71F8 ZIPCACHE: nio.jar_405359_1272300546_1 Address: 0x042F7210 Size: 13808 1: 0x042F6D58 ZIPCACHE: annotation.jar_13417_1272300554_1 Address: 0x042F6D70 Size: 1023 1 : the ID of the VM that wrote this data. 0x042FE07C : the address where the metadata for the zip entry cache is stored. ZIPCACHE : the type of data that was stored. luni-kernel.jar_347075_1272300300_1 : the name of the zip entry cache. 0x042FE094 : the address where the data is stored. 7898 : the size of the stored data, in bytes. JIT data Information about JIT data is shown in JITPROFILE and JITHINT entries. For example: 1: 0xD6290368 JITPROFILE: getKeyHash Signature: ()I Address: 0xD55118C0 for ROMClass java/util/Hashtable$Entry at 0xD5511640. 2: 0xD6283848 JITHINT: loadClass Signature: (Ljava/lang/String;)Ljava/lang/Class; Address: 0xD5558F98 for ROMClass com/ibm/oti/vm/BootstrapClassLoader at 0xD5558AE0. Startup hints Information about startup hints is shown in STARTUP HINTS KEY and STARTUP HINTS DETAIL . For example: 1: 0x000000002237C6E0 STARTUP HINTS KEY: -Xoptionsfile=jre\\bin\\compressedrefs\\options.default -Xlockword:mode=default -Xjcl:jclse29 -Dcom.ibm.oti.vm.bootstrap.library.path=jre\\bin\\compressedrefs;jre\\bin -Djava.home=jre -Djava.ext.dirs=jre\\lib\\ext -Duser.dir=bin -Djava.class.path=. -Dsun.java.launcher=SUN_STANDARD Address: 0x000000002237C700 Size: 96 STARTUP HINTS DETAIL Flags: 1 DATA1: 1677721 DATA2: 5033165 printTopLayerStats Use this utility with a layered cache. This utility works in the same way as printStats . By default, this utility shows information for the top layer cache. To view statistics for a specific layer, use the layer=<number> option. For example, to show statistics for the second layer in a 2-layer cache, run printTopLayerStats,layer=1 . Example output: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007F234C054000 end address = 0x00007F234D038000 allocation pointer = 0x00007F234C054000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 792 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% ROMClass bytes = 0 AOT bytes = 30520 JIT data bytes = 644 Zip cache bytes = 0 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 0 # AOT Methods = 18 # Classpaths = 0 # URLs = 0 # Tokens = 0 # Zip caches = 0 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 8% full Cache is accessible to current user = true Using the trace facility Trace output contains very detailed information that might be used by a VM developer to diagnose complex problems with class data sharing. Trace is configured by using the -Xtrace option and the binary output of the trace facility must be processed by the Trace formatter into a human-readable format. The trace component for class data sharing is j9shr . Five levels of trace are available, starting from basic initialization and runtime information in level 1 up to the most detailed trace output in level 5. To trace memory-mapped files, shared memory, and shared semaphores, include the j9prt trace component. To trace operations with Java Helper API methods, include the j9jcl trace component.","title":"Diagnosing problems"},{"location":"shrc_diag_util/#diagnosing-problems-with-class-data-sharing","text":"If you encounter problems with class data sharing, VM messages are typically generated that point to an underlying cause. In some situations, a cache might fail to initialize correctly. In other situations classes might not be found or stored in the shared classes cache. To provide more information about a problem, you can generate verbose output, use diagnostic cache utilities, or use the Eclipse OpenJ9\u2122 trace facility.","title":"Diagnosing problems with class data sharing"},{"location":"shrc_diag_util/#initialization-problems","text":"If you do not specify a directory for the shared classes cache by using the cacheDir suboption, the cache is created in the javasharedresources directory in the following default location: On Windows\u00ae systems, this directory is created in the user's C:\\Users\\<username>\\AppData\\Local\\ directory. On z/OS\u00ae systems, this directory is created in the /tmp directory. On other systems, this directory is located in the user's home directory. Do not set the user's home directory on an NFS mount or a shared mount across systems or LPARs. Initialization problems can occur on systems other than Windows because caches are created with read/write access for the user only and subsequent users do not have permission to write to the home directory. If you specify the -Xshareclasses:groupAccess suboption, the cache is created in the /tmp directory instead where all users have permission to write to the cache. For a persistent cache, initialization problems can also occur if there is insufficient disk space available or if you are attempting to locate the cache on a remote networked file system, which is not supported. For a non-persistent cache, a shared memory area is required. Check that your system is configured with sufficient resources as described in Setting shared memory values . If initialization problems persist, try deleting the cache by using the -Xshareclasses:destroyAll cache utility, which removes all known shared memory areas and semaphores for caches in the cacheDir specified or the default directory. These actions force the VM to re-create the cache.","title":"Initialization problems"},{"location":"shrc_diag_util/#problems-finding-or-storing-classes","text":"The most common cause for classes not being stored in the cache is due to space constraints. Make sure that you set an appropriate size for the cache, as described in Creating a shared classes cache . Setting a soft maximum size is recommended, because you can adjust the soft maximum size that is set for the cache after it is created. See Setting a soft maximum size . Storing classes can also be a problem if the cache is opened read-only or if the class does not exist on the file system because it is sourced from a URL location. If you are attempting to share modified bytecode, you must use a modification context, as described in Sharing modified bytecode . Otherwise, classes are stored in a private area that is not accessible to other VMs. If you are using a custom class loader, class path entries in the SharedClassURLClasspathHelper must be confirmed before classes can be found for these entries. More information about confirmed entries is available in the SharedClassURLClasspathHelper interface in the com.ibm.oti.shared API documentation . If you are instrumenting bytecode by using a JVMTI agent or java.lang.instrument agent, the following rules apply: Redefined classes are never stored in the cache. Retransformed classes are stored only if you specify the -Xshareclasses:cacheRetransformed suboption when you start your application. If a running application uses its own class loader and you are using a SecurityManager , you must grant the class loader permission to SharedCachePermission before they can share classes. For more information, see Support for custom class loaders . In very rare cases, problems with finding or storing classes might be due to cache corruption. If the VM detects that a cache is corrupt, it attempts to destroy the cache and re-create it. If the VM cannot re-create the cache, it starts only if the -Xshareclasses:nonfatal suboption is specified on the command line, but without using the shared cache. Try using the -Xshareclasses:destroy cache utility to remove the specific cache and re-create it. You might need to specify the cacheDir=<directory> and name=<cache_name> suboptions if the cache is not using the default settings.","title":"Problems finding or storing classes"},{"location":"shrc_diag_util/#generating-verbose-output","text":"A number of -Xshareclasses suboptions are available for generating verbose output during class data sharing operations, which can help you identify the root cause of a problem.","title":"Generating verbose output"},{"location":"shrc_diag_util/#verbose","text":"The -Xshareclasses:verbose suboption provides basic output on cache usage. In the following example, a persistent cache is opened and attached to the VM for class sharing. Information is provided about the size of the cache, the unstored bytes due to the setting of a soft maximum size, and maximum AOT and JIT data size. java -Xshareclasses:name=myCache,verbose HelloWorld [-Xshareclasses persistent cache enabled] [-Xshareclasses verbose output enabled] JVMSHRC237I Opened shared classes persistent cache myCache JVMSHRC246I Attached shared classes persistent cache myCache JVMSHRC765I Memory page protection on runtime data, string read-write data and partially filled pages is successfully enabled Hello World JVMSHRC168I Total shared class bytes read=2532416. Total bytes stored=268156 JVMSHRC818I Total unstored bytes due to the setting of shared cache soft max is 0. Unstored AOT bytes due to the setting of -Xscmaxaot is 0. Unstored JIT bytes due to the setting of -Xscmaxjitdata is 0.","title":"verbose"},{"location":"shrc_diag_util/#verboseio","text":"The -Xshareclasses:verboseIO suboption provides more detailed information about class sharing operations. In the following example, some classes are found when the cache is accessed. However, class openj9/internal/tools/attach/target/CommonDirectory is not found and is therefore stored for sharing. java -Xshareclasses:name=myCache,verboseIO HelloWorld [-Xshareclasses verbose I/O output enabled] Found class java/lang/Object in shared cache for class-loader id 0. Found class java/lang/J9VMInternals in shared cache for class-loader id 0. Found class com/ibm/oti/vm/VM in shared cache for class-loader id 0. Found class java/lang/J9VMInternals$ClassInitializationLock in shared cache for class-loader id 0. ... Failed to find class openj9/internal/tools/attach/target/CommonDirectory in shared cache for class-loader id 0. Stored class openj9/internal/tools/attach/target/CommonDirectory in shared cache for class-loader id 0 with URL /root/sdk/jre/lib/amd64/compressedrefs/jclSC180/vm.jar (index 0). ... The bootstrap class loader has an ID of 0 ; other class loaders are given a unique ID. Class loaders follow the class loader hierarchy by asking the parent class loader for a class. If a parent fails to find the class in the cache, the child class loader stores the class in the cache. In some situations, verbose output might not show classes being found. For example, classes are typically not found if the class is stale, as described in Class data sharing operations . Stale classes are redeemed if the same class is subsequently fetched by the class loader from another VM and checked against the stale class in the cache.","title":"verboseIO"},{"location":"shrc_diag_util/#verboseaot","text":"To troubleshoot AOT problems, use the -Xshareclasses:verboseAOT suboption on the command line, which generates output about AOT code that is found or stored in the cache. In the following example output, a populated cache is being accessed to look for compiled AOT code. Some AOT code is found, which can be shared, and some AOT code is stored for reuse. java -Xshareclasses:name=myCache,verboseAOT HelloWorld [-Xshareclasses AOT verbose output enabled] Found AOT code for ROMMethod 0x00007F658005C180 in shared cache. Found AOT code for ROMMethod 0x00007F65800723EC in shared cache. Found AOT code for ROMMethod 0x00007F6580071D14 in shared cache. Stored AOT code for ROMMethod 0x00007F65801847B8 in shared cache. Stored AOT code for ROMMethod 0x00007F65800D38A4 in shared cache. Stored AOT code for ROMMethod 0x00007F65800723CC in shared cache. Found AOT code for ROMMethod 0x00007F65800D38A4 in shared cache. Stored AOT code for ROMMethod 0x00007F65800724C4 in shared cache. ...","title":"verboseAOT"},{"location":"shrc_diag_util/#verbosehelper","text":"To troubleshoot problems with custom class loaders that use the Java SharedClassHelper API, specify the -Xshareclasses:verboseHelper suboption. Information messages and error messages are generated in the output, which can help you diagnose problems with finding or storing classes in the shared cache. The following example output shows only information messages: java -Xshareclasses:name=myCache,verboseHelper HelloWorld [-Xshareclasses Helper API verbose output enabled] Info for SharedClassURLClasspathHelper id 1: Verbose output enabled for SharedClassURLClasspathHelper id 1 Info for SharedClassURLClasspathHelper id 1: Created SharedClassURLClasspathHelper with id 1 Info for SharedClassURLClasspathHelper id 2: Verbose output enabled for SharedClassURLClasspathHelper id 2 Info for SharedClassURLClasspathHelper id 2: Created SharedClassURLClasspathHelper with id 2 Info for SharedClassURLClasspathHelper id 1: There are no confirmed elements in the classpath. Returning null. Info for SharedClassURLClasspathHelper id 2: There are no confirmed elements in the classpath. Returning null. Info for SharedClassURLClasspathHelper id 2: setClasspath() updated classpath. No invalid URLs found Info for SharedClassURLClasspathHelper id 2: Number of confirmed entries is now 1 Hello World","title":"verboseHelper"},{"location":"shrc_diag_util/#diagnostic-cache-utilities","text":"These utilities display information about the contents of a shared classes cache. Run the utilities by specifying them as suboptions of -Xshareclasses . The utilities run on the default cache unless you specify a cache by adding the name=<cache_name> and cacheDir=<directory> suboptions.","title":"Diagnostic cache utilities"},{"location":"shrc_diag_util/#printstats","text":"-Xshareclasses:printStats -Xshareclasses:printStats,name=<cache_name> -Xshareclasses:printStats=<data_type1>[+<data_type2>][...],name=<cache_name> Displays summary information about the cache. For layered caches, -Xshareclasses:printStats shows some information for the top layer cache, and summary information (bytes and counts only) for all layers combined. To see information for the top layer cache only, use printTopLayerStats . You can request more detail about items of a specific data type that are stored in the shared cache by using printStats=<data_type> . Use the plus symbol (+) to separate the data types. For example, use printStats=romclass+url,name=myCache to see information about ROMClass and URL items in all the layer caches of the cache called Cache1 . The valid data types are as follows (case insensitive): help (displays the list of valid data types) all (equivalent to printAllStats ) classpath url token romclass rommethod aot jitprofile jithint zipcache stale startuphint Example output for a traditional cache (no cache layers: cache layer = 0 ), with summary information only: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr Cache contains only classes with line numbers base address = 0x00007F60B807A000 end address = 0x00007F60B905E000 allocation pointer = 0x00007F60B81BE3A8 cache layer = 0 cache size = 16776608 softmx bytes = 16776608 free bytes = 12740572 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 30440 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 189358 Class debug area % used = 14% ROMClass bytes = 1328040 AOT bytes = 98404 JIT data bytes = 168 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 2 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 24% full Cache is accessible to current user = true Example output for a cache with 2 layers ( cache layer = 1 ), with summary information only: Current statistics for top layer of cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007FCAB2766000 end address = 0x00007FCAB374A000 allocation pointer = 0x00007FCAB2766000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% Cache is 8% full Cache is accessible to current user = true --------------------------------------------------------- Current statistics for all layers of cache \"Cache1\": ROMClass bytes = 1328040 AOT bytes = 128924 JIT data bytes = 812 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 20 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% The Cache created with section indicates the options that were used when the cache was created. BCI Enabled relates to the -Xshareclasses:enableBCI option (enabled by default) and Restrict Classpaths relates to the -Xshareclasses:restrictClasspaths option. Feature = cr indicates that the cache is a 64-bit compressed references cache. Line number information for classes in the cache is then shown with one of the following messages: Cache contains only classes with line numbers : VM line number processing was enabled for all the classes that were stored in this shared cache (the -Xlinenumbers option is enabled by default). All classes in the cache contain line numbers if the original classes contained line number data. Cache contains only classes without line numbers : The -Xnolinenumbers option was used to disable VM line number processing for all the classes that were stored in this shared cache, so none of the classes contain line numbers. Cache contains classes with line numbers and classes without line numbers : VM line number processing was enabled for some classes and disabled for others (the -Xnolinenumbers option was specified when some of the classes were added to the cache). The following summary data is displayed: baseAddress and endAddress The boundary addresses of the shared memory area that contains the classes. These addresses vary from run to run, depending on where the operating system allocates the memory. allocation pointer The address where ROMClass data is currently being allocated in the cache. cache layer The layer number that the cache stats relate to. cache size and free bytes cache size shows the total size of the shared memory area in bytes free bytes shows the free bytes that remain. The free space is not necessarily all available for storing new classes. The cache contains separate areas for different data, and can reserve space for AOT and JIT data, as shown by subsequent summary data. softmx bytes The soft maximum size for the cache. For more information, see -Xscmx . ROMClass bytes The number of bytes of class data in the cache, which does not include data that is stored in the class debug area (see separate output for the class debug area). AOT bytes The number of bytes of AOT-compiled code in the cache. Reserved space for AOT bytes The number of bytes reserved for AOT-compiled code in the cache. Maximum space for AOT bytes The maximum number of bytes of AOT-compiled code that can be stored in the cache. JIT data bytes The number of bytes of JIT-related data stored in the cache. Reserved space for JIT data bytes The number of bytes reserved for JIT-related data in the cache. Maximum space for JIT data bytes The maximum number of bytes of JIT-related data that can be stored in the cache. Zip cache bytes The number of zip entry cache bytes stored in the cache. On Java 11 and later, this value is zero unless a jar file is added to the boot classpath. Startup hint bytes The number of bytes of data stored to describe startup hints. Data bytes The number of bytes of non-class data stored by the VM. Metadata bytes The number of bytes of data stored to describe the cached classes. Note: This field is available only in the top layer cache output or when a cache is not layered. Metadata % used The proportion of metadata bytes to class bytes, which indicates how efficiently cache space is being used. The value shown does consider the Class debug area size . Class debug area size The size in bytes of the class debug area. This area is reserved to store LineNumberTable and LocalVariableTable class attribute information. Class debug area bytes used The size in bytes of the Class Debug Area that contains data. Class debug area % used The percentage of the Class Debug Area that contains data. ROMClasses The number of classes in the cache. The cache stores ROMClasses (the class data itself, which is read-only) and information about the location from which the classes were loaded. This information is stored in different ways, depending on the Java SharedClassHelper API that was used to store the classes. For more information, see Support for custom class loaders . AOT methods Optionally, ROMClass methods can be compiled and the AOT code stored in the cache. The AOT methods information shows the total number of methods in the cache that have AOT code compiled for them. This number includes AOT code for stale classes. Classpaths , URLs , and Tokens The number of class paths, URLs, and tokens in the cache. Classes stored from a SharedClassURLClasspathHelper are stored with a Classpath. Classes stored using a SharedClassURLHelper are stored with a URL. Classes stored using a SharedClassTokenHelper are stored with a Token. Most class loaders, including the bootstrap and application class loaders, use a SharedClassURLClasspathHelper . The result is that it is most common to see class paths in the cache. The number of Classpaths, URLs, and Tokens stored is determined by a number of factors. For example, every time an element of a Classpath is updated, such as when a .jar file is rebuilt, a new Classpath is added to the cache. Additionally, if partitions or modification contexts are used, they are associated with the Classpath, URL, or Token. A Classpath, URL, or Token is stored for each unique combination of partition and modification context. For more information, see Sharing modified bytecode and SharedClassHelper cache partitions . Zip caches The number of .zip files that have entry caches stored in the shared cache. On Java 11 and later, this value is zero unless a jar file is added to the boot classpath. Startup hints The number of startup hints stored in the cache. There can be a startup hint for each unique set of command line options used to start the VM. Stale classes The number of classes that have been marked as \"potentially stale\" by the cache code, because of a VM or Java application update. See Class data sharing operations . % Stale classes The percentage of classes in the cache that are stale. Cache is XXX% full The percentage of the cache that is currently used. This line is displayed only if the soft maximum size is not set. This value is calculated as follows: % Full = (('Cache Size' - 'Free Bytes') * 100) / ('Cache Size') Cache is XXX% soft full The percentage of the soft maximum size that is currently used. This line is displayed only if the soft maximum size is set. The free bytes in the cache statistics means the free bytes within the soft maximum limit. This value is calculated as follows: % soft Full = (('Soft max bytes' - 'Free Bytes') * 100) / ('Soft max bytes') For more information about the soft maximum size, see -Xscmx . Cache is accessible to current user Whether the current user can access the cache.","title":"printStats"},{"location":"shrc_diag_util/#printallstats","text":"-Xshareclasses:printAllStats -Xshareclasses:printAllStats,name=<cache_name> Displays the contents of the cache in chronological order. You can use this output to see the history of updates that were made to the cache. For layered caches, some information is shown for the top layer cache only, and some is shown for all layers combined. To see information for the top layer cache only, use printTopLayerStats=all . Each entry in the output starts with a VM ID, so you can see which VM wrote the associated data. Here are example entries for various types of cache data, with explanations:","title":"printAllStats"},{"location":"shrc_diag_util/#class-paths","text":"The following example shows one class path with 4 entries: 1: 0x2234FA6C CLASSPATH /myVM/Apps/application1.jar /myVM/Apps/application2.jar /myVM/Apps/application3.jar /myVM/Apps/application4.jar 1 : the ID of the VM that wrote this data. 0x2234FA6C : the address where this data is stored. CLASSPATH : the type of data that was written.","title":"Class paths"},{"location":"shrc_diag_util/#romclasses","text":"This example shows an entry for a single ROMClass : 1: 0x2234F7DC ROMCLASS: java/lang/Runnable at 0x213684A8 Index 1 in class path 0x2234FA6C 1 : the ID of the VM that wrote this data. 0x2234F7DC : the address where the metadata about the class is stored. ROMCLASS : the type of data that was stored. java/lang/Runnable : the name of the class. 0x213684A8 : the address where the class was stored. Index 1 : the index in the class path where the class was loaded from. 0x2234FA6C : the address of the class path against which this class is stored. Stale classes are marked with !STALE! . Any partition or modification context that is used when the class is stored is also shown.","title":"ROMClasses"},{"location":"shrc_diag_util/#aot-methods","text":"This example shows an entry for one AOT-compiled method: 1: 0x00007F841A800554 AOT: hashCode Signature: ()I Address: 0x00007F83F6859280 for ROMClass java/lang/Object at 0x00007F83F6859000. 1 : the ID of the VM that wrote this data. 0x00007F841A800554 : the address where the data is stored. AOT : the type of data that was stored. hashCode : the method for which AOT-compiled code is stored. ()I : the signature of the ROM method. 0x00007F83F6859280 : the ROM method address. java/lang/Object : the class that contains the method. 0x00007F83F6859000 : the address of the class that contains the method. Stale methods are marked with !STALE! .","title":"AOT methods"},{"location":"shrc_diag_util/#urls-and-tokens","text":"The output for these data types has the same format as that for class paths, but with a single entry. A Token is a string that is passed to the Java SharedClassHelper API.","title":"URLs and tokens"},{"location":"shrc_diag_util/#zip-entry-caches","text":"The following example shows 4 separate entries for zip entry caches: 1: 0x042FE07C ZIPCACHE: luni-kernel.jar_347075_1272300300_1 Address: 0x042FE094 Size: 7898 1: 0x042FA878 ZIPCACHE: luni.jar_598904_1272300546_1 Address: 0x042FA890 Size: 14195 1: 0x042F71F8 ZIPCACHE: nio.jar_405359_1272300546_1 Address: 0x042F7210 Size: 13808 1: 0x042F6D58 ZIPCACHE: annotation.jar_13417_1272300554_1 Address: 0x042F6D70 Size: 1023 1 : the ID of the VM that wrote this data. 0x042FE07C : the address where the metadata for the zip entry cache is stored. ZIPCACHE : the type of data that was stored. luni-kernel.jar_347075_1272300300_1 : the name of the zip entry cache. 0x042FE094 : the address where the data is stored. 7898 : the size of the stored data, in bytes.","title":"Zip entry caches"},{"location":"shrc_diag_util/#jit-data","text":"Information about JIT data is shown in JITPROFILE and JITHINT entries. For example: 1: 0xD6290368 JITPROFILE: getKeyHash Signature: ()I Address: 0xD55118C0 for ROMClass java/util/Hashtable$Entry at 0xD5511640. 2: 0xD6283848 JITHINT: loadClass Signature: (Ljava/lang/String;)Ljava/lang/Class; Address: 0xD5558F98 for ROMClass com/ibm/oti/vm/BootstrapClassLoader at 0xD5558AE0.","title":"JIT data"},{"location":"shrc_diag_util/#startup-hints","text":"Information about startup hints is shown in STARTUP HINTS KEY and STARTUP HINTS DETAIL . For example: 1: 0x000000002237C6E0 STARTUP HINTS KEY: -Xoptionsfile=jre\\bin\\compressedrefs\\options.default -Xlockword:mode=default -Xjcl:jclse29 -Dcom.ibm.oti.vm.bootstrap.library.path=jre\\bin\\compressedrefs;jre\\bin -Djava.home=jre -Djava.ext.dirs=jre\\lib\\ext -Duser.dir=bin -Djava.class.path=. -Dsun.java.launcher=SUN_STANDARD Address: 0x000000002237C700 Size: 96 STARTUP HINTS DETAIL Flags: 1 DATA1: 1677721 DATA2: 5033165","title":"Startup hints"},{"location":"shrc_diag_util/#printtoplayerstats","text":"Use this utility with a layered cache. This utility works in the same way as printStats . By default, this utility shows information for the top layer cache. To view statistics for a specific layer, use the layer=<number> option. For example, to show statistics for the second layer in a 2-layer cache, run printTopLayerStats,layer=1 . Example output: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007F234C054000 end address = 0x00007F234D038000 allocation pointer = 0x00007F234C054000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 792 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% ROMClass bytes = 0 AOT bytes = 30520 JIT data bytes = 644 Zip cache bytes = 0 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 0 # AOT Methods = 18 # Classpaths = 0 # URLs = 0 # Tokens = 0 # Zip caches = 0 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 8% full Cache is accessible to current user = true","title":"printTopLayerStats"},{"location":"shrc_diag_util/#using-the-trace-facility","text":"Trace output contains very detailed information that might be used by a VM developer to diagnose complex problems with class data sharing. Trace is configured by using the -Xtrace option and the binary output of the trace facility must be processed by the Trace formatter into a human-readable format. The trace component for class data sharing is j9shr . Five levels of trace are available, starting from basic initialization and runtime information in level 1 up to the most detailed trace output in level 5. To trace memory-mapped files, shared memory, and shared semaphores, include the j9prt trace component. To trace operations with Java Helper API methods, include the j9jcl trace component.","title":"Using the trace facility"},{"location":"tool_builder/","text":"Option builder tools You can modify many of the command-line options by specifying a number of parameters. Several of the options have many available parameters that you can combine in numerous ways to achieve the effect you want. Tools are available for the following options to help you select these parameters correctly, achieve the correct combinations, and avoid conflicts: -Xdump -Xtrace","title":"Option builder"},{"location":"tool_builder/#option-builder-tools","text":"You can modify many of the command-line options by specifying a number of parameters. Several of the options have many available parameters that you can combine in numerous ways to achieve the effect you want. Tools are available for the following options to help you select these parameters correctly, achieve the correct combinations, and avoid conflicts: -Xdump -Xtrace","title":"Option builder tools"},{"location":"tool_jcmd/","text":"Java diagnostic command ( jcmd ) tool Use the jcmd tool to run diagnostic commands on a specified VM. Note: Running diagnostic commands can significantly affect the performance of the target VM. The command syntax is as follows: jcmd [<options>] [<vmid> <arguments>] Where: The available <options> are: -J : supplies arguments to the Java VM that is running the jcmd command. You can use multiple -J options, for example: jcmd -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints the jcmd help <vmid> is the Attach API virtual machine identifier for the Java\u2122 VM process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. You can use the jps command to find the VMID. The available arguments are: help : shows the diagnostic commands that are available for this VM. This list of commands can vary between VMs. help <command> : shows help information for the specified diagnostic command <command> [<command_arguments>] : runs the specified diagnostic command, with optional command arguments Examples: jcmd 31452 Thread.print jcmd 31452 help Dump.heap jcmd 31452 Dump.heap myHeapDump Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to Eclipse OpenJ9\u2122. For information about the differences between these two implementations, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java command (jcmd) tool"},{"location":"tool_jcmd/#java-diagnostic-command-jcmd-tool","text":"Use the jcmd tool to run diagnostic commands on a specified VM. Note: Running diagnostic commands can significantly affect the performance of the target VM. The command syntax is as follows: jcmd [<options>] [<vmid> <arguments>] Where: The available <options> are: -J : supplies arguments to the Java VM that is running the jcmd command. You can use multiple -J options, for example: jcmd -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints the jcmd help <vmid> is the Attach API virtual machine identifier for the Java\u2122 VM process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. You can use the jps command to find the VMID. The available arguments are: help : shows the diagnostic commands that are available for this VM. This list of commands can vary between VMs. help <command> : shows help information for the specified diagnostic command <command> [<command_arguments>] : runs the specified diagnostic command, with optional command arguments Examples: jcmd 31452 Thread.print jcmd 31452 help Dump.heap jcmd 31452 Dump.heap myHeapDump Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to Eclipse OpenJ9\u2122. For information about the differences between these two implementations, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java diagnostic command (jcmd) tool"},{"location":"tool_jdmpview/","text":"Dump viewer ( jdmpview ) The dump viewer is a command-line tool that allows you to examine the contents of system dumps produced from the Eclipse OpenJ9\u2122 VM. The dump viewer allows you to view both Java\u2122 and native information from the time the dump was produced. You can run the dump viewer on one platform to work with dumps from another platform. For long running tasks, the dump viewer can also be run in batch mode. The dump viewer is useful for diagnosing OutOfMemoryError exceptions in Java\u2122 applications. For problems like general protection faults (GPFs), system abends, and SIGSEGVs, a system debugger such as gdb (Linux) provides more information. Syntax Starting the dump viewer jdmpview [-J<vm option>] (-core <core file> | -zip <zip file>) [-notemp] Input option Explanation -core <core file> Specifies a dump file. -zip <zip file> Specifies a compressed file containing the core file (produced by the dump extractor ( jpackcore ) tool on AIX\u00ae, Linux\u00ae, and macOS\u00ae systems). -notemp By default, when you specify a file by using the -zip option, the contents are extracted to a temporary directory before processing. Use the -notemp option to prevent this extraction step, and run all subsequent commands in memory. -J-Dcom.ibm.j9ddr.path.mapping=<mappings> The variable <mappings> is a list of native library mappings of the form old-path=new-path , using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). -J-Dcom.ibm.j9ddr.library.path=<path> The variable <path> is a list of paths to search for native libraries, using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). Note: The -core option can be used with the -zip option to specify the core file in the compressed file. With these options, jdmpview shows multiple contexts, one for each source file that it identified in the compressed file. Note: On AIX and Linux, some jdmpview commands must locate the executable and the native libraries that are referenced by the core. For example, commands that relate to call-sites. A common scenario involves using jdmpview to examine core files that originate on different systems. However, if the executable and the libraries are in their original locations, jdmpview might not consider them. Therefore, first check the executable and the list of native libraries by running jdmpview on a core with the info mod command. One way to assist jdmpview to locate those files is by specifying on the command line one or both of the path mapping option ( -J-Dcom.ibm.j9ddr.path.mapping=<mappings> ) and the library path option ( -J-Dcom.ibm.j9ddr.library.path=<path> ). Alternatively, on the system where the core file was produced, you can use jpackcore to collect all the relevant files into a single zip archive. That archive can be unpacked, possibly on another system, into a new, empty directory. Running jdmpview in that new directory (where the core file will be located) should enable it to find all the data it needs, including information that might not be included in the core file itself, such as symbols or sections. When you use an archive produced by jpackcore , setting the path or library mapping system properties should not be necessary. On z/OS\u00ae, you can copy the dump to an HFS file and supply that as input to jdmpview , or you can supply a fully qualified MVS\u2122 data set name. For example: > jdmpview -core USER1.JVM.TDUMP.SSHD6.D070430.T092211 DTFJView version 4.29.5, using DTFJ version 1.12.29003 Loading image from DTFJ... MVS data set names may contain the dollar sign ($). Names that contain a dollar sign must be enclosed by single quotation marks ('). For example: > jdmpview -core 'USER1.JVM.$TDUMP.SSH$D7.D141211.T045506' After jdmpview processes the dump files, a session starts, showing this message: For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" > If you run the jdmpview tool on a compressed file that contains multiple dumps, the tool detects and shows all the dump files, whether these are system dumps, Java dumps, or heap dumps. Because of this behavior, more than one context might be displayed when you start jdmpview . To switch context, type context <n> , where <n> is the context value for the dump you want to investigate. On z/OS, a system dump can contain multiple address spaces and an address space can contain multiple VM instances. In this case, the context allows you to select the address space and VM instance within the dump file. The following z/OS example shows address spaces ( ASID ), with two JVMs occupying address space 0x73 (context 5 and 6). The current context is 5 ( CTX:5> ), shown with an asterisk. To view the JVM in context 6, you can switch by specifying context 6 . CTX:5> context Available contexts (* = currently selected context) : 0 : ASID: 0x1 : No JRE : No JRE 1 : ASID: 0x3 : No JRE : No JRE 2 : ASID: 0x4 : No JRE : No JRE 3 : ASID: 0x6 : No JRE : No JRE 4 : ASID: 0x7 : No JRE : No JRE *5 : ASID: 0x73 EDB: 0x83d2053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 6 : ASID: 0x73 EDB: 0x8004053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 7 : ASID: 0x73 EDB: 0x4a7bd9e8 : No JRE 8 : ASID: 0xffff : No JRE : No JRE If you are using jdmpview to view Java dumps and heap dumps, some options do not produce any output. For example, a heap dump doesn't contain the information requested by the info system command, but does contain information requested by the info class command. If you are viewing a dump where there are a large number of objects on the heap, you can speed up the performance of jdmpview by ensuring that your system has enough memory available and does not need to page memory to disk. To achieve this, start jdmpview with a larger heap size by specifying the -Xmx option. Use the -J option to pass the -Xmx command line option to the JVM. For example: jdmpview -J-Xmx<n> -core <core file> The options available to the dump viewer session are shown under Session parameters Starting in batch mode For long running or routine jobs, jdmpview can be used in batch mode. You can run a single command without specifying a command file by appending the command to the end of the jdmpview command line. For example: jdmpview -core mycore.dmp info class When specifying jdmpview commands that accept a wildcard parameter, you must replace the wildcard symbol with ALL to prevent the shell interpreting the wildcard symbol. For example, in interactive mode, the command info thread * must be specified in the following way: jdmpview -core mycore.dmp info thread ALL Batch mode is controlled with the following command line options: Option Explanation -cmdfile <path to command file> A file that contains a series of jdmpview commands, which are read and run sequentially. -charset <character set name> The character set for the commands specified in -cmdfile (name must be a supported charset as defined in java.nio.charset.Charset. For example, US-ASCII) -outfile <path to output file> The file to record any output generated by commands. -overwrite If the file specified in -outfile exists, this option overwrites the file. -append If the file specified in -outfile exists, new output messages are appended to the end of that file. The -append and -overwrite options cannot be used at the same time. The command file can have empty lines that contain spaces, or comment lines that start with // or #. These lines are ignored by jdmpview. Example command file: // commands.txt info system info proc To run jdmpview in batch mode, using this command file, specify: jdmpview -outfile out.txt [-overwrite|-append] -cmdfile commands.txt -core <path to core file> When the output file exists, you need to specify either the -overwrite option or the -append option. If you do not, an error message is generated. Processing output You can redirect command output to a file, or pipe the command output to another command. To redirect jdmpview command output to a file, use one of the following formats: command > <target_file> If the target file exists, this redirection overwrites the content within it. command >> <target_file> If the target file exists, this redirection appends the output to it. Where <target_file> is the file name, which can include the full path to the file. To pipe jdmpview command output to another command, use the vertical bar (|) character. For example: command | grep string You can chain more than two commands together by using multiple vertical bar characters. The following commands can be used to interrogate the output: charsFrom charsTo grep tokens Using CharsFrom Use the charsFrom command after the vertical bar character to exclude all characters that come before a specified pattern in a resulting line. charsFrom <options> pattern Where <options> : -e or -exclude : Exclude the matched pattern from the resulting line. By default, the matched pattern is included in the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays resulting lines that contain the pattern jre , and trims each line to exclude all characters that come before this pattern: > info mod | charsFrom jre jre/lib/ppc64/libzip.so @ 0x0, sections: jre/lib/ppc64/libdbgwrapper80.so @ 0x0, sections: jre/lib/ppc64/libverify.so @ 0x0, sections: jre/lib/ppc64/libjava.so @ 0x0, sections: jre/lib/ppc64/compressedrefs/libjclse7b_28.so @ 0x0, sections: Using CharsTo Use the CharsTo command after the vertical bar character to include the characters in a resulting line until a specific pattern is found. charsTo <options> pattern Where <options> : -include : Include the matched pattern in the resulting line. By default, the matched pattern is excluded from the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays lines that contain the pattern @ , and trims each line to exclude all characters from @ onwards: > info mod | charsTo @ bin/java /usr/lib64/gconv/UTF-16.so /test/sdk/lib/ppc64le/libnet.so /test/sdk/lib/ppc64le/libnio.so /test/sdk/lib/ppc64le/libzip.so /test/sdk/lib/ppc64le/libjsig.so libjsig.so You can also use charsFrom and charsTo together, separated by a vertical bar character. For example, the following command displays lines that contain the pattern lib , and trims each line to exclude all characters that come before this pattern, as well as all characters from the pattern @ : > info mod | charsFrom lib | charsTo @ lib/ppc64le/libzip.so lib/ppc64le/libjsig.so lib/ppc64le/libverify.so lib/ppc64le/libjava.so lib/ppc64le/compressedrefs/libj9jit29.so Note: The line will not be displayed if the charsFrom and charsTo are used together, but only one of the patterns are matched in a line. Furthermore, the line will not be displayed if both patterns are matched in a line, but the charsTo pattern appears before, and not after, the charsFrom pattern. Using grep Use the grep command after the vertical bar character to show which lines match a specified pattern. grep <options> pattern Where <options> : -i : Ignore case. -r , -G , or --regex : Use a regular expression as defined in the Java documentation of the java.utils.regex.Pattern class. -b or --block : Show blocks of lines where at least one of the lines matches the pattern. Blocks of lines are separated by empty lines. -A <NUM> or +<NUM> : Show at most <NUM> lines after the matching line. For example grep -A 2 <pattern> or grep +2 <pattern> . -B <NUM> or -<NUM> : Show at most <NUM> lines before the matching line. -C <NUM> or +-<NUM> : Show at most <NUM> lines before and after the matching line. -v or --invert-match : Use with the grep command to show lines that do not match the pattern. These options are equivalent to the grep command. -F or --fixed-strings : Do not treat the asterisk (*) as a wildcard character. Use these options with the -r , -G , or --regex options. Pattern rules: An asterisk (*) in a pattern is treated as a wildcard character unless you specify the -F or --fixed-strings options. If a pattern contains spaces, enclose the pattern in a pair of double quotation marks (\"). If a pattern contains double quotation marks, enclose the pattern in a pair of single quotation marks ('). You can specify multiple sub-patterns to match by using the following format, but only if you do not use the -r , -G , or --regex options: \"[pattern1|pattern2|...|patternN]\" The initial and trailing double quotation marks and brackets ([ ]) are required. Use a vertical bar character to separate the sub-patterns. Quotation marks and the vertical bar are not allowed in a sub-pattern. Spaces are allowed in the middle of a sub-pattern, but leading and trailing spaces will be trimmed. Use the grep command to show lines that do not match the pattern. In the following example, the command displays the number of instances and total heap size for the java/lang/String class: > info class | grep java/lang/String 94 7688 [Ljava/lang/String; 1822 58304 java/lang/String 1 16 java/lang/String$CaseInsensitiveComparator 0 0 java/lang/String$UnsafeHelpers In the following example, the command uses two pipes in combination to display the number of instances and total heap size for the java/lang/StringCoding.StringDecoder class: > info class | grep java/lang/String | grep -i decoder 1 48 java/lang/StringCoding$StringDecoder Using tokens Use the tokens command after the vertical bar character to isolate specified tokens in the resulting lines. tokens [options] range[,range][..range] You can define range in the following formats: x x,y x..y A set of rules applies to these formats: x or y can be prefixed with - . This means that x or y are counting backwards from the end of a list. For example, a y value of -1 represents the last token in a list, while -2 represents the penultimate token in a list. x must represent a token that either precedes or is at the same position as y . In this format, if x is omitted, it is assumed to be 1 . If y is omitted, it is assumed to be -1 . For example, the following command displays the first and second token for each resulting line: > info mmap | grep -r ^0x | tokens 1,2 0x0000000000012fff 0x000000000000d000 0x0000000000017fff 0x0000000000004000 0x00000000009dafff 0x0000000000018000 0x00000000009fffff 0x000000000001f000 0x0000000000cbefff 0x0000000000002000 0x0000000000d76fff 0x0000000000001000 0x0000000003145fff 0x0000000000071000 0x0000000003b93fff 0x0000000000003000 Session parameters When jdmpview is started, many parameters can be used during the session to interrogate the system dump data, which are divided into general and expert parameters. The general parameters are documented in this section. To see a list of expert parameters, use the !j9help option. !j9help !j9help Lists all expert parameters that can be used in a session, with a brief description. Note: The expert parameters are subject to change and not intended as a supported interface. cd cd <directory_name> Changes the working directory to <directory_name> . The working directory is used for log files. Logging is controlled by the set logging command. Use the pwd command to query the current working directory. cmdfile cmdfile <directory_name> Runs all of the commands in a file. The commands are read line by line and run sequentially. Empty lines, and lines that start with // or # , are ignored. Use the option charset to identify the character set that is used in the chosen file. The character set must be supported, as defined in java.nio.charset.Charset , such as US-ASCII . deadlock This command detects deadlock situations in the Java application that was running when the system dump was produced. Example output: deadlock loop: thread: Thread-2 (monitor object: 0x9e32c8) waiting for => thread: Thread-3 (monitor object: 0x9e3300) waiting for => thread: Thread-2 (monitor object: 0x9e32c8) In this example, the deadlock analysis shows that Thread-2 is waiting for a lock held by Thread-3 , which is in turn waiting for a lock held earlier by Thread-2 . Threads are identified by their Java thread name, whereas object monitors are identified by the address of the object in the Java heap. You can obtain further information about the threads using the info thread * command. You can obtain further information about the monitors using the x/J <0xaddr> command. find find <pattern>,<start_address>,<end_address>,<memory_boundary>, <bytes_to_print>,<matches_to_display> This command searches for <pattern> in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the find command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes. findnext Finds the next instance of the last string passed to find or findptr . It repeats the previous find or findptr command, depending on which one was issued last, starting from the last match. findptr findptr <pattern>,<start_address>,<end_address>,<memory_boundary>,<bytes_to_print>,<matches_to_display> Searches memory for the given pointer. findptr searches for <pattern> as a pointer in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the findptr command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes. help help [<command_name>] Shows information for a specific command. If you supply no parameters, help shows the complete list of supported commands. history history|his [-r][<N>] Recalls and displays the history of commands that you have run. The default behavior is to display the 20 most recent commands. If you use the argument <N> , then N commands are displayed. For example, if you run history 35, then the 35 most recent commands are displayed. You can also use the -r option with <N> to run the Nth most recent command in your history. Using the -r option alone runs the most recent command in your history. info thread info thread [*|all|<native_thread_ID>|<zos_TCB_address>] Displays information about Java and native threads. The following information is displayed for all threads (\"*\"), or the specified thread: Thread id Registers Stack sections Thread frames: procedure name and base pointer Thread properties: list of native thread properties and their values. For example: thread priority. Associated Java thread, if applicable: Name of Java thread Address of associated java.lang.Thread object State (shown in JVMTI and java.lang.Thread.State formats) The monitor the thread is waiting for Thread frames: base pointer, method, and filename:line If you supply no parameters, the command shows information about the current thread. info system Displays the following information about the system that produced the core dump: Amount of memory Operating system Virtual machine or virtual machines present info class info class [<class_name>] [-sort:<name>|<count>|<size>] Displays the inheritance chain and other data for a given class. If a class name is passed to info class, the following information is shown about that class: Name ID Superclass ID Class loader ID Modifiers Number of instances and total size of instances Inheritance chain Fields with modifiers (and values for static fields) Methods with modifiers If no parameters are passed to info class , the following information is shown: The number of instances of each class. The total size of all instances of each class. The class name The total number of instances of all classes. The total size of all objects. The sort option allows the list of classes to be sorted by name (default), by number of instances of each class, or by the total size of instances of each class. info proc Displays threads, command-line arguments, environment variables, and shared modules of the current process. To view the shared modules used by a process, use the info sym command. info jitm Displays JIT compiled methods and their addresses: Method name and signature Method start address Method end address info lock Displays a list of available monitors and locked objects. info sym Displays a list of available modules. For each process in the address spaces, this command shows a list of module sections for each module, their start and end addresses, names, and sizes. info mmap info mmap [<address>] [-verbose] [-sort:<size>|<address>] Displays a summary list of memory sections in the process address space, with start and end address, size, and properties. If an address parameter is specified, the results show details of only the memory section containing the address. If -verbose is specified, full details of the properties of each memory section are displayed. The -sort option allows the list of memory sections to be sorted by size or by start address (default). info mod Displays a list of native library modules in the process address space, which includes file paths and other information about each module. info heap info heap [*|<heap_name>*] If no parameters are passed to this command, the heap names and heap sections are shown. Using either \"*\" or a heap name shows the following information about all heaps or the specified heap: Heap name (Heap size and occupancy) Heap sections Section name Section size Whether the section is shared Whether the section is executable Whether the section is read only heapdump heapdump [<heaps>] Generates a Java heap dump to a file. You can select which Java heaps to dump by listing the heap names, separated by spaces. To see which heaps are available, use the info heap command. By default, all Java heaps are dumped. hexdump hexdump <hex_address> <bytes_to_print> Displays a section of memory in a hexdump-like format. Displays <bytes_to_print> bytes of memory contents starting from <hex_address> . + Displays the next section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling forwards through memory. The previous hexdump command is repeated, starting from the end of the previous one. - Displays the previous section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling backwards through memory. The previous hexdump command is repeated, starting from a position before the previous one. pwd Displays the current working directory, which is the directory where log files are stored. quit Exits the core file viewing tool; any log files that are currently open are closed before exit. set heapdump Configures Heapdump generation settings. set heapdump <options> where <options> are: phd : Set the Heapdump format to Portable Heapdump, which is the default. txt : Set the Heapdump format to classic. file <file> : Set the destination of the Heapdump. multiplefiles [on|off] : If multiplefiles is set to on, each Java heap in the system dump is written to a separate file. If multiplefiles is set to off, all Java heaps are written to the same file. The default is off. set logging set logging <options> Configures logging settings, starts logging, or stops logging. This parameter enables the results of commands to be logged to a file, where <options> are: [on|off] : Turns logging on or off. (Default: off) file <filename> : Sets the file to log to. The path is relative to the directory returned by the pwd command, unless an absolute path is specified. If the file is set while logging is on, the change takes effect the next time logging is started. Not set by default. overwrite [on|off] : Turns overwriting of the specified log file on or off. When overwrite is off, log messages are appended to the log file. When overwrite is on, the log file is overwritten after the set logging command. (Default: off) redirect [on|off] : Turns redirecting to file on or off, with off being the default. When logging is set to on: A value of on for redirect sends non-error output only to the log file. A value of off for redirect sends non-error output to the console and log file. Redirect must be turned off before logging can be turned off. (Default: off) show heapdump show heapdump <options> Displays the current heap dump generation settings. show logging show logging <options> Displays the current logging settings: set_logging = [on|off] set_logging_file = set_logging_overwrite = [on|off] set_logging_redirect = [on|off] current_logging_file = The file that is currently being logged to might be different from set_logging_file, if that value was changed after logging was started. whatis <hex_address> Displays information about whatis stored at the given memory address, <hex_address> . This command examines the memory location at <hex_address> and tries to find out more information about this address. For example: > whatis 0x8e76a8 heap #1 - name: Default@19fce8 0x8e76a8 is within heap segment: 8b0000 -- cb0000 0x8e76a8 is start of an object of type java/lang/Thread x/ (examine) Passes the number of items to display and the unit size, as listed in the following table, to the sub-command. For example, x/12bd . Abbreviation Unit Size b Byte 8-bit h Half word 16-bit w Word 32-bit g Giant word 64-bit This command is similar to the use of the x/ command in gdb, including the use of defaults. x/J [ <class_name> | <0xaddr> ] Displays information about a particular object, or all objects of a class. If <class_name> is supplied, all static fields with their values are shown, followed by all objects of that class with their fields and values. If an object address (in hex) is supplied, static fields for that object's class are not shown; the other fields and values of that object are printed along with its address. Note: This command ignores the number of items and unit size passed to it by the x/ command. x/D < 0xaddr > Displays the integer at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big-endian architecture. This command uses the number of items and unit size passed to it by the x/ command. x/X < 0xaddr > Displays the hex value of the bytes at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big-endian architecture. Note: This command uses the number of items and unit size passed to it by the x/ command. x/K < 0xaddr > Where the size is defined by the pointer size of the architecture, this parameter shows the value of each section of memory. The output is adjusted for the hardware architecture this dump file is from, starting at the specified address. It also displays a module with a module section and an offset from the start of that module section in memory if the pointer points to that module section. If no symbol is found, it displays a \"*\" and an offset from the current address if the pointer points to an address in 4KB (4096 bytes) of the current address. Although this command can work on an arbitrary section of memory, it is probably more useful on a section of memory that refers to a stack frame. To find the memory section of a thread stack frame, use the info thread command. Note: This command uses the number of items and unit size passed to it by the x/ command. Example This example session illustrates a selection of the commands available and their use. In the example session, which is generated on a Linux system, some lines have been removed for clarity (and terseness). User input is prefaced by a greater than symbol (>). test@madras:~/test> sdk/bin/jdmpview -core core.20121116.154147.16838.0001.dmp DTFJView version 4.29.5, using DTFJ version 1.12.29003 Loading image from DTFJ... For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" Available contexts (* = currently selected context) : Source : file:///home/test/core.20121116.154147.16838.0001.dmp *0 : PID: 16867 : JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6480-20121116_01 ) > help + displays the next section of memory in hexdump-like format - displays the previous section of memory in hexdump-like format cd changes the current working directory, used for log files close [context id] closes the connection to a core file context [ID|asid ID] switch to the selected context deadlock displays information about deadlocks if there are any exit Exit the application find searches memory for a given string findnext finds the next instance of the last string passed to \"find\" findptr searches memory for the given pointer heapdump generates a PHD or classic format heapdump help [command name] displays list of commands or help for a specific command hexdump outputs a section of memory in a hexdump-like format info <component> Information about the specified component info class <Java class name> Provides information about the specified Java class info heap [*|heap name] Displays information about Java heaps info jitm Displays JIT'ed methods and their addresses info lock outputs a list of system monitors and locked objects info mmap Outputs a list of all memory segments in the address space info mod outputs module information info proc shortened form of info process info process displays threads, command line arguments, environment info sym an alias for 'mod' info sys shortened form of info system info system displays information about the system the core dump is from info thread displays information about Java and native threads log [name level] display and control instances of java.util.logging.Logger open [path to core or zip] opens the specified core or zip file plugins Plugin management commands list Show the list of loaded plugins for the current context reload Reload plugins for the current context showpath Show the DTFJ View plugin search path for the current context setpath Set the DTFJ View plugin search path for the current context pwd displays the current working directory quit Exit the application set [logging|heapdump] Sets options for the specified command set heapdump configures heapdump format, filename and multiple heap support set logging configures several logging-related parameters, starts/stops logging on turn on logging off turn off logging file turn on logging overwrite controls the overwriting of log files show [logging|heapdump] Displays the current set options for a command show heapdump displays heapdump settings show logging shows the current logging options whatis [hex address] gives information about what is stored at the given memory address x/d <hex address> displays the integer at the specified address x/j <object address> [class name] displays information about a particular object or all objects of a class x/k <hex address> displays the specified memory section as if it were a stack frame parameters x/x <hex address> displays the hex value of the bytes at the specified address > set logging file log.txt logging turned on; outputting to \"/home/test/log.txt\" > info system Machine OS: Linux Hypervisor: PowerVM Machine name: madras Machine IP address(es): 9.20.88.155 System memory: 8269201408 Dump creation time: 2015/08/10 14:44:36:019 Dump creation time (nanoseconds): 21314421467539 Java version: JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6490-20121116_01) JVM start time: 2015/08/10 14:44:05:690 JVM start time (nanoseconds): 21284086192267 > info thread * native threads for address space process id: 16838 thread id: 16839 registers: native stack sections: native stack frames: properties: associated Java thread: name: main Thread object: java/lang/Thread @ 0x2ffd1e08 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x0000000000085b28 method: void com/ibm/jvm/Dump.SystemDumpImpl() (Native Method) objects: <no objects in this frame> bp: 0x0000000000085b40 method: void com/ibm/jvm/Dump.SystemDump() source: Dump.java:41 objects: <no objects in this frame> bp: 0x0000000000085b68 method: void mySystemDump.main(String[]) source: mySystemDump.java:29 objects: <no objects in this frame> ===Lines Removed=== name: GC Worker id: 16860 Thread object: java/lang/Thread @ 0x3001b980 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::workerThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: GC Worker id: 16861 Thread object: java/lang/Thread @ 0x3001c180 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::workerThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: Signal Dispatcher id: 16847 Thread object: com/ibm/misc/SignalDispatcher @ 0x3000f268 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x00000000000df748 method: int com/ibm/misc/SignalDispatcher.waitForSignal() (Native Method) objects: <no objects in this frame> bp: 0x00000000000df788 method: void com/ibm/misc/SignalDispatcher.run() source: SignalDispatcher.java:54 objects: 0x30015828 0x30015828 ===Lines Removed=== > info heap * Heap #1: Generational@fff78303d30 Section #1: Heap extent at 0x100d0000 (0x300000 bytes) Size: 3145728 bytes Shared: false Executable: false Read Only: false Section #2: Heap extent at 0x2ffd0000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false Section #3: Heap extent at 0x30050000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false > info class java/lang/String name = java/lang/String ID = 0x37c00 superID = 0x30300 classLoader = 0x2ffe9b58 modifiers: public final number of instances: 2146 total size of instances: 51504 bytes Inheritance chain.... java/lang/Object java/lang/String Fields...... static fields for \"java/lang/String\" private static final long serialVersionUID = -6849794470754667710 (0xa0f0a4387a3bb342) public static final java.util.Comparator CASE_INSENSITIVE_ORDER = <object> @ 0x2ffd0278 private static final char[] ascii = <object> @ 0x2ffd02c8 private static String[] stringArray = <object> @ 0x2ffd0298 private static final int stringArraySize = 10 (0xa) static boolean enableCopy = false private static int seed = -126504465 (0xfffffffff875b1ef) private static char[] startCombiningAbove = <object> @ 0x100d0c40 private static char[] endCombiningAbove = <object> @ 0x100d0cc0 private static final char[] upperValues = <object> @ 0x100d0d40 private static final java.io.ObjectStreamField[] serialPersistentFields = <object> @ 0x2ffd0920 non-static fields for \"java/lang/String\" private final char[] value private final int offset private final int count private int hashCode private int hashCode32 Methods...... Bytecode range(s): : private static native int getSeed() Bytecode range(s): fff76d8ce48 -- fff76d8ce5e: public void <init>() Bytecode range(s): fff76d8ce88 -- fff76d8cecd: private void <init>(String, char) Bytecode range(s): fff76d8cf10 -- fff76d8cf19: public void <init>(byte[]) Bytecode range(s): fff76d8cf40 -- fff76d8cf4a: public void <init>(byte[], int) Bytecode range(s): fff76d8cf7c -- fff76d8cfb5: public void <init>(byte[], int, int) Bytecode range(s): fff76d8cff8 -- fff76d8d065: public void <init>(byte[], int, int, int) Bytecode range(s): fff76d8d0c4 -- fff76d8d10c: public void <init>(byte[], int, int, String) ===Lines Removed=== > whatis 0x2ffd0298 heap #1 - name: Generational@fff78303d30 0x2ffd0298 is within heap segment: 2ffd0000 -- 30050000 0x2ffd0298 is the start of an object of type [Ljava/lang/String;","title":"Dump viewer"},{"location":"tool_jdmpview/#dump-viewer-jdmpview","text":"The dump viewer is a command-line tool that allows you to examine the contents of system dumps produced from the Eclipse OpenJ9\u2122 VM. The dump viewer allows you to view both Java\u2122 and native information from the time the dump was produced. You can run the dump viewer on one platform to work with dumps from another platform. For long running tasks, the dump viewer can also be run in batch mode. The dump viewer is useful for diagnosing OutOfMemoryError exceptions in Java\u2122 applications. For problems like general protection faults (GPFs), system abends, and SIGSEGVs, a system debugger such as gdb (Linux) provides more information.","title":"Dump viewer (jdmpview)"},{"location":"tool_jdmpview/#syntax","text":"","title":"Syntax"},{"location":"tool_jdmpview/#starting-the-dump-viewer","text":"jdmpview [-J<vm option>] (-core <core file> | -zip <zip file>) [-notemp] Input option Explanation -core <core file> Specifies a dump file. -zip <zip file> Specifies a compressed file containing the core file (produced by the dump extractor ( jpackcore ) tool on AIX\u00ae, Linux\u00ae, and macOS\u00ae systems). -notemp By default, when you specify a file by using the -zip option, the contents are extracted to a temporary directory before processing. Use the -notemp option to prevent this extraction step, and run all subsequent commands in memory. -J-Dcom.ibm.j9ddr.path.mapping=<mappings> The variable <mappings> is a list of native library mappings of the form old-path=new-path , using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). -J-Dcom.ibm.j9ddr.library.path=<path> The variable <path> is a list of paths to search for native libraries, using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). Note: The -core option can be used with the -zip option to specify the core file in the compressed file. With these options, jdmpview shows multiple contexts, one for each source file that it identified in the compressed file. Note: On AIX and Linux, some jdmpview commands must locate the executable and the native libraries that are referenced by the core. For example, commands that relate to call-sites. A common scenario involves using jdmpview to examine core files that originate on different systems. However, if the executable and the libraries are in their original locations, jdmpview might not consider them. Therefore, first check the executable and the list of native libraries by running jdmpview on a core with the info mod command. One way to assist jdmpview to locate those files is by specifying on the command line one or both of the path mapping option ( -J-Dcom.ibm.j9ddr.path.mapping=<mappings> ) and the library path option ( -J-Dcom.ibm.j9ddr.library.path=<path> ). Alternatively, on the system where the core file was produced, you can use jpackcore to collect all the relevant files into a single zip archive. That archive can be unpacked, possibly on another system, into a new, empty directory. Running jdmpview in that new directory (where the core file will be located) should enable it to find all the data it needs, including information that might not be included in the core file itself, such as symbols or sections. When you use an archive produced by jpackcore , setting the path or library mapping system properties should not be necessary. On z/OS\u00ae, you can copy the dump to an HFS file and supply that as input to jdmpview , or you can supply a fully qualified MVS\u2122 data set name. For example: > jdmpview -core USER1.JVM.TDUMP.SSHD6.D070430.T092211 DTFJView version 4.29.5, using DTFJ version 1.12.29003 Loading image from DTFJ... MVS data set names may contain the dollar sign ($). Names that contain a dollar sign must be enclosed by single quotation marks ('). For example: > jdmpview -core 'USER1.JVM.$TDUMP.SSH$D7.D141211.T045506' After jdmpview processes the dump files, a session starts, showing this message: For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" > If you run the jdmpview tool on a compressed file that contains multiple dumps, the tool detects and shows all the dump files, whether these are system dumps, Java dumps, or heap dumps. Because of this behavior, more than one context might be displayed when you start jdmpview . To switch context, type context <n> , where <n> is the context value for the dump you want to investigate. On z/OS, a system dump can contain multiple address spaces and an address space can contain multiple VM instances. In this case, the context allows you to select the address space and VM instance within the dump file. The following z/OS example shows address spaces ( ASID ), with two JVMs occupying address space 0x73 (context 5 and 6). The current context is 5 ( CTX:5> ), shown with an asterisk. To view the JVM in context 6, you can switch by specifying context 6 . CTX:5> context Available contexts (* = currently selected context) : 0 : ASID: 0x1 : No JRE : No JRE 1 : ASID: 0x3 : No JRE : No JRE 2 : ASID: 0x4 : No JRE : No JRE 3 : ASID: 0x6 : No JRE : No JRE 4 : ASID: 0x7 : No JRE : No JRE *5 : ASID: 0x73 EDB: 0x83d2053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 6 : ASID: 0x73 EDB: 0x8004053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 7 : ASID: 0x73 EDB: 0x4a7bd9e8 : No JRE 8 : ASID: 0xffff : No JRE : No JRE If you are using jdmpview to view Java dumps and heap dumps, some options do not produce any output. For example, a heap dump doesn't contain the information requested by the info system command, but does contain information requested by the info class command. If you are viewing a dump where there are a large number of objects on the heap, you can speed up the performance of jdmpview by ensuring that your system has enough memory available and does not need to page memory to disk. To achieve this, start jdmpview with a larger heap size by specifying the -Xmx option. Use the -J option to pass the -Xmx command line option to the JVM. For example: jdmpview -J-Xmx<n> -core <core file> The options available to the dump viewer session are shown under Session parameters","title":"Starting the dump viewer"},{"location":"tool_jdmpview/#starting-in-batch-mode","text":"For long running or routine jobs, jdmpview can be used in batch mode. You can run a single command without specifying a command file by appending the command to the end of the jdmpview command line. For example: jdmpview -core mycore.dmp info class When specifying jdmpview commands that accept a wildcard parameter, you must replace the wildcard symbol with ALL to prevent the shell interpreting the wildcard symbol. For example, in interactive mode, the command info thread * must be specified in the following way: jdmpview -core mycore.dmp info thread ALL Batch mode is controlled with the following command line options: Option Explanation -cmdfile <path to command file> A file that contains a series of jdmpview commands, which are read and run sequentially. -charset <character set name> The character set for the commands specified in -cmdfile (name must be a supported charset as defined in java.nio.charset.Charset. For example, US-ASCII) -outfile <path to output file> The file to record any output generated by commands. -overwrite If the file specified in -outfile exists, this option overwrites the file. -append If the file specified in -outfile exists, new output messages are appended to the end of that file. The -append and -overwrite options cannot be used at the same time. The command file can have empty lines that contain spaces, or comment lines that start with // or #. These lines are ignored by jdmpview. Example command file: // commands.txt info system info proc To run jdmpview in batch mode, using this command file, specify: jdmpview -outfile out.txt [-overwrite|-append] -cmdfile commands.txt -core <path to core file> When the output file exists, you need to specify either the -overwrite option or the -append option. If you do not, an error message is generated.","title":"Starting in batch mode"},{"location":"tool_jdmpview/#processing-output","text":"You can redirect command output to a file, or pipe the command output to another command. To redirect jdmpview command output to a file, use one of the following formats: command > <target_file> If the target file exists, this redirection overwrites the content within it. command >> <target_file> If the target file exists, this redirection appends the output to it. Where <target_file> is the file name, which can include the full path to the file. To pipe jdmpview command output to another command, use the vertical bar (|) character. For example: command | grep string You can chain more than two commands together by using multiple vertical bar characters. The following commands can be used to interrogate the output: charsFrom charsTo grep tokens","title":"Processing output"},{"location":"tool_jdmpview/#using-charsfrom","text":"Use the charsFrom command after the vertical bar character to exclude all characters that come before a specified pattern in a resulting line. charsFrom <options> pattern Where <options> : -e or -exclude : Exclude the matched pattern from the resulting line. By default, the matched pattern is included in the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays resulting lines that contain the pattern jre , and trims each line to exclude all characters that come before this pattern: > info mod | charsFrom jre jre/lib/ppc64/libzip.so @ 0x0, sections: jre/lib/ppc64/libdbgwrapper80.so @ 0x0, sections: jre/lib/ppc64/libverify.so @ 0x0, sections: jre/lib/ppc64/libjava.so @ 0x0, sections: jre/lib/ppc64/compressedrefs/libjclse7b_28.so @ 0x0, sections:","title":"Using CharsFrom"},{"location":"tool_jdmpview/#using-charsto","text":"Use the CharsTo command after the vertical bar character to include the characters in a resulting line until a specific pattern is found. charsTo <options> pattern Where <options> : -include : Include the matched pattern in the resulting line. By default, the matched pattern is excluded from the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays lines that contain the pattern @ , and trims each line to exclude all characters from @ onwards: > info mod | charsTo @ bin/java /usr/lib64/gconv/UTF-16.so /test/sdk/lib/ppc64le/libnet.so /test/sdk/lib/ppc64le/libnio.so /test/sdk/lib/ppc64le/libzip.so /test/sdk/lib/ppc64le/libjsig.so libjsig.so You can also use charsFrom and charsTo together, separated by a vertical bar character. For example, the following command displays lines that contain the pattern lib , and trims each line to exclude all characters that come before this pattern, as well as all characters from the pattern @ : > info mod | charsFrom lib | charsTo @ lib/ppc64le/libzip.so lib/ppc64le/libjsig.so lib/ppc64le/libverify.so lib/ppc64le/libjava.so lib/ppc64le/compressedrefs/libj9jit29.so Note: The line will not be displayed if the charsFrom and charsTo are used together, but only one of the patterns are matched in a line. Furthermore, the line will not be displayed if both patterns are matched in a line, but the charsTo pattern appears before, and not after, the charsFrom pattern.","title":"Using CharsTo"},{"location":"tool_jdmpview/#using-grep","text":"Use the grep command after the vertical bar character to show which lines match a specified pattern. grep <options> pattern Where <options> : -i : Ignore case. -r , -G , or --regex : Use a regular expression as defined in the Java documentation of the java.utils.regex.Pattern class. -b or --block : Show blocks of lines where at least one of the lines matches the pattern. Blocks of lines are separated by empty lines. -A <NUM> or +<NUM> : Show at most <NUM> lines after the matching line. For example grep -A 2 <pattern> or grep +2 <pattern> . -B <NUM> or -<NUM> : Show at most <NUM> lines before the matching line. -C <NUM> or +-<NUM> : Show at most <NUM> lines before and after the matching line. -v or --invert-match : Use with the grep command to show lines that do not match the pattern. These options are equivalent to the grep command. -F or --fixed-strings : Do not treat the asterisk (*) as a wildcard character. Use these options with the -r , -G , or --regex options. Pattern rules: An asterisk (*) in a pattern is treated as a wildcard character unless you specify the -F or --fixed-strings options. If a pattern contains spaces, enclose the pattern in a pair of double quotation marks (\"). If a pattern contains double quotation marks, enclose the pattern in a pair of single quotation marks ('). You can specify multiple sub-patterns to match by using the following format, but only if you do not use the -r , -G , or --regex options: \"[pattern1|pattern2|...|patternN]\" The initial and trailing double quotation marks and brackets ([ ]) are required. Use a vertical bar character to separate the sub-patterns. Quotation marks and the vertical bar are not allowed in a sub-pattern. Spaces are allowed in the middle of a sub-pattern, but leading and trailing spaces will be trimmed. Use the grep command to show lines that do not match the pattern. In the following example, the command displays the number of instances and total heap size for the java/lang/String class: > info class | grep java/lang/String 94 7688 [Ljava/lang/String; 1822 58304 java/lang/String 1 16 java/lang/String$CaseInsensitiveComparator 0 0 java/lang/String$UnsafeHelpers In the following example, the command uses two pipes in combination to display the number of instances and total heap size for the java/lang/StringCoding.StringDecoder class: > info class | grep java/lang/String | grep -i decoder 1 48 java/lang/StringCoding$StringDecoder","title":"Using grep"},{"location":"tool_jdmpview/#using-tokens","text":"Use the tokens command after the vertical bar character to isolate specified tokens in the resulting lines. tokens [options] range[,range][..range] You can define range in the following formats: x x,y x..y A set of rules applies to these formats: x or y can be prefixed with - . This means that x or y are counting backwards from the end of a list. For example, a y value of -1 represents the last token in a list, while -2 represents the penultimate token in a list. x must represent a token that either precedes or is at the same position as y . In this format, if x is omitted, it is assumed to be 1 . If y is omitted, it is assumed to be -1 . For example, the following command displays the first and second token for each resulting line: > info mmap | grep -r ^0x | tokens 1,2 0x0000000000012fff 0x000000000000d000 0x0000000000017fff 0x0000000000004000 0x00000000009dafff 0x0000000000018000 0x00000000009fffff 0x000000000001f000 0x0000000000cbefff 0x0000000000002000 0x0000000000d76fff 0x0000000000001000 0x0000000003145fff 0x0000000000071000 0x0000000003b93fff 0x0000000000003000","title":"Using tokens"},{"location":"tool_jdmpview/#session-parameters","text":"When jdmpview is started, many parameters can be used during the session to interrogate the system dump data, which are divided into general and expert parameters. The general parameters are documented in this section. To see a list of expert parameters, use the !j9help option.","title":"Session parameters"},{"location":"tool_jdmpview/#j9help","text":"!j9help Lists all expert parameters that can be used in a session, with a brief description. Note: The expert parameters are subject to change and not intended as a supported interface.","title":"!j9help"},{"location":"tool_jdmpview/#cd","text":"cd <directory_name> Changes the working directory to <directory_name> . The working directory is used for log files. Logging is controlled by the set logging command. Use the pwd command to query the current working directory.","title":"cd"},{"location":"tool_jdmpview/#cmdfile","text":"cmdfile <directory_name> Runs all of the commands in a file. The commands are read line by line and run sequentially. Empty lines, and lines that start with // or # , are ignored. Use the option charset to identify the character set that is used in the chosen file. The character set must be supported, as defined in java.nio.charset.Charset , such as US-ASCII .","title":"cmdfile"},{"location":"tool_jdmpview/#deadlock","text":"This command detects deadlock situations in the Java application that was running when the system dump was produced. Example output: deadlock loop: thread: Thread-2 (monitor object: 0x9e32c8) waiting for => thread: Thread-3 (monitor object: 0x9e3300) waiting for => thread: Thread-2 (monitor object: 0x9e32c8) In this example, the deadlock analysis shows that Thread-2 is waiting for a lock held by Thread-3 , which is in turn waiting for a lock held earlier by Thread-2 . Threads are identified by their Java thread name, whereas object monitors are identified by the address of the object in the Java heap. You can obtain further information about the threads using the info thread * command. You can obtain further information about the monitors using the x/J <0xaddr> command.","title":"deadlock"},{"location":"tool_jdmpview/#find","text":"find <pattern>,<start_address>,<end_address>,<memory_boundary>, <bytes_to_print>,<matches_to_display> This command searches for <pattern> in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the find command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes.","title":"find"},{"location":"tool_jdmpview/#findnext","text":"Finds the next instance of the last string passed to find or findptr . It repeats the previous find or findptr command, depending on which one was issued last, starting from the last match.","title":"findnext"},{"location":"tool_jdmpview/#findptr","text":"findptr <pattern>,<start_address>,<end_address>,<memory_boundary>,<bytes_to_print>,<matches_to_display> Searches memory for the given pointer. findptr searches for <pattern> as a pointer in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the findptr command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes.","title":"findptr"},{"location":"tool_jdmpview/#help","text":"help [<command_name>] Shows information for a specific command. If you supply no parameters, help shows the complete list of supported commands.","title":"help"},{"location":"tool_jdmpview/#history","text":"history|his [-r][<N>] Recalls and displays the history of commands that you have run. The default behavior is to display the 20 most recent commands. If you use the argument <N> , then N commands are displayed. For example, if you run history 35, then the 35 most recent commands are displayed. You can also use the -r option with <N> to run the Nth most recent command in your history. Using the -r option alone runs the most recent command in your history.","title":"history"},{"location":"tool_jdmpview/#info-thread","text":"info thread [*|all|<native_thread_ID>|<zos_TCB_address>] Displays information about Java and native threads. The following information is displayed for all threads (\"*\"), or the specified thread: Thread id Registers Stack sections Thread frames: procedure name and base pointer Thread properties: list of native thread properties and their values. For example: thread priority. Associated Java thread, if applicable: Name of Java thread Address of associated java.lang.Thread object State (shown in JVMTI and java.lang.Thread.State formats) The monitor the thread is waiting for Thread frames: base pointer, method, and filename:line If you supply no parameters, the command shows information about the current thread.","title":"info thread"},{"location":"tool_jdmpview/#info-system","text":"Displays the following information about the system that produced the core dump: Amount of memory Operating system Virtual machine or virtual machines present","title":"info system"},{"location":"tool_jdmpview/#info-class","text":"info class [<class_name>] [-sort:<name>|<count>|<size>] Displays the inheritance chain and other data for a given class. If a class name is passed to info class, the following information is shown about that class: Name ID Superclass ID Class loader ID Modifiers Number of instances and total size of instances Inheritance chain Fields with modifiers (and values for static fields) Methods with modifiers If no parameters are passed to info class , the following information is shown: The number of instances of each class. The total size of all instances of each class. The class name The total number of instances of all classes. The total size of all objects. The sort option allows the list of classes to be sorted by name (default), by number of instances of each class, or by the total size of instances of each class.","title":"info class"},{"location":"tool_jdmpview/#info-proc","text":"Displays threads, command-line arguments, environment variables, and shared modules of the current process. To view the shared modules used by a process, use the info sym command.","title":"info proc"},{"location":"tool_jdmpview/#info-jitm","text":"Displays JIT compiled methods and their addresses: Method name and signature Method start address Method end address","title":"info jitm"},{"location":"tool_jdmpview/#info-lock","text":"Displays a list of available monitors and locked objects.","title":"info lock"},{"location":"tool_jdmpview/#info-sym","text":"Displays a list of available modules. For each process in the address spaces, this command shows a list of module sections for each module, their start and end addresses, names, and sizes.","title":"info sym"},{"location":"tool_jdmpview/#info-mmap","text":"info mmap [<address>] [-verbose] [-sort:<size>|<address>] Displays a summary list of memory sections in the process address space, with start and end address, size, and properties. If an address parameter is specified, the results show details of only the memory section containing the address. If -verbose is specified, full details of the properties of each memory section are displayed. The -sort option allows the list of memory sections to be sorted by size or by start address (default).","title":"info mmap"},{"location":"tool_jdmpview/#info-mod","text":"Displays a list of native library modules in the process address space, which includes file paths and other information about each module.","title":"info mod"},{"location":"tool_jdmpview/#info-heap","text":"info heap [*|<heap_name>*] If no parameters are passed to this command, the heap names and heap sections are shown. Using either \"*\" or a heap name shows the following information about all heaps or the specified heap: Heap name (Heap size and occupancy) Heap sections Section name Section size Whether the section is shared Whether the section is executable Whether the section is read only","title":"info heap"},{"location":"tool_jdmpview/#heapdump","text":"heapdump [<heaps>] Generates a Java heap dump to a file. You can select which Java heaps to dump by listing the heap names, separated by spaces. To see which heaps are available, use the info heap command. By default, all Java heaps are dumped.","title":"heapdump"},{"location":"tool_jdmpview/#hexdump","text":"hexdump <hex_address> <bytes_to_print> Displays a section of memory in a hexdump-like format. Displays <bytes_to_print> bytes of memory contents starting from <hex_address> .","title":"hexdump"},{"location":"tool_jdmpview/#_1","text":"Displays the next section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling forwards through memory. The previous hexdump command is repeated, starting from the end of the previous one.","title":"+"},{"location":"tool_jdmpview/#-","text":"Displays the previous section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling backwards through memory. The previous hexdump command is repeated, starting from a position before the previous one.","title":"-"},{"location":"tool_jdmpview/#pwd","text":"Displays the current working directory, which is the directory where log files are stored.","title":"pwd"},{"location":"tool_jdmpview/#quit","text":"Exits the core file viewing tool; any log files that are currently open are closed before exit.","title":"quit"},{"location":"tool_jdmpview/#set-heapdump","text":"Configures Heapdump generation settings. set heapdump <options> where <options> are: phd : Set the Heapdump format to Portable Heapdump, which is the default. txt : Set the Heapdump format to classic. file <file> : Set the destination of the Heapdump. multiplefiles [on|off] : If multiplefiles is set to on, each Java heap in the system dump is written to a separate file. If multiplefiles is set to off, all Java heaps are written to the same file. The default is off.","title":"set heapdump"},{"location":"tool_jdmpview/#set-logging","text":"set logging <options> Configures logging settings, starts logging, or stops logging. This parameter enables the results of commands to be logged to a file, where <options> are: [on|off] : Turns logging on or off. (Default: off) file <filename> : Sets the file to log to. The path is relative to the directory returned by the pwd command, unless an absolute path is specified. If the file is set while logging is on, the change takes effect the next time logging is started. Not set by default. overwrite [on|off] : Turns overwriting of the specified log file on or off. When overwrite is off, log messages are appended to the log file. When overwrite is on, the log file is overwritten after the set logging command. (Default: off) redirect [on|off] : Turns redirecting to file on or off, with off being the default. When logging is set to on: A value of on for redirect sends non-error output only to the log file. A value of off for redirect sends non-error output to the console and log file. Redirect must be turned off before logging can be turned off. (Default: off)","title":"set logging"},{"location":"tool_jdmpview/#show-heapdump","text":"show heapdump <options> Displays the current heap dump generation settings.","title":"show heapdump"},{"location":"tool_jdmpview/#show-logging","text":"show logging <options> Displays the current logging settings: set_logging = [on|off] set_logging_file = set_logging_overwrite = [on|off] set_logging_redirect = [on|off] current_logging_file = The file that is currently being logged to might be different from set_logging_file, if that value was changed after logging was started.","title":"show logging"},{"location":"tool_jdmpview/#whatis-hex_address","text":"Displays information about whatis stored at the given memory address, <hex_address> . This command examines the memory location at <hex_address> and tries to find out more information about this address. For example: > whatis 0x8e76a8 heap #1 - name: Default@19fce8 0x8e76a8 is within heap segment: 8b0000 -- cb0000 0x8e76a8 is start of an object of type java/lang/Thread","title":"whatis &lt;hex_address&gt;"},{"location":"tool_jdmpview/#x-examine","text":"Passes the number of items to display and the unit size, as listed in the following table, to the sub-command. For example, x/12bd . Abbreviation Unit Size b Byte 8-bit h Half word 16-bit w Word 32-bit g Giant word 64-bit This command is similar to the use of the x/ command in gdb, including the use of defaults.","title":"x/ (examine)"},{"location":"tool_jdmpview/#xj-class_name0xaddr","text":"Displays information about a particular object, or all objects of a class. If <class_name> is supplied, all static fields with their values are shown, followed by all objects of that class with their fields and values. If an object address (in hex) is supplied, static fields for that object's class are not shown; the other fields and values of that object are printed along with its address. Note: This command ignores the number of items and unit size passed to it by the x/ command.","title":"x/J [&lt;class_name&gt;|&lt;0xaddr&gt;]"},{"location":"tool_jdmpview/#xd-0xaddr","text":"Displays the integer at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big-endian architecture. This command uses the number of items and unit size passed to it by the x/ command.","title":"x/D &lt;0xaddr&gt;"},{"location":"tool_jdmpview/#xx-0xaddr","text":"Displays the hex value of the bytes at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big-endian architecture. Note: This command uses the number of items and unit size passed to it by the x/ command.","title":"x/X &lt;0xaddr&gt;"},{"location":"tool_jdmpview/#xk-0xaddr","text":"Where the size is defined by the pointer size of the architecture, this parameter shows the value of each section of memory. The output is adjusted for the hardware architecture this dump file is from, starting at the specified address. It also displays a module with a module section and an offset from the start of that module section in memory if the pointer points to that module section. If no symbol is found, it displays a \"*\" and an offset from the current address if the pointer points to an address in 4KB (4096 bytes) of the current address. Although this command can work on an arbitrary section of memory, it is probably more useful on a section of memory that refers to a stack frame. To find the memory section of a thread stack frame, use the info thread command. Note: This command uses the number of items and unit size passed to it by the x/ command.","title":"x/K &lt;0xaddr&gt;"},{"location":"tool_jdmpview/#example","text":"This example session illustrates a selection of the commands available and their use. In the example session, which is generated on a Linux system, some lines have been removed for clarity (and terseness). User input is prefaced by a greater than symbol (>). test@madras:~/test> sdk/bin/jdmpview -core core.20121116.154147.16838.0001.dmp DTFJView version 4.29.5, using DTFJ version 1.12.29003 Loading image from DTFJ... For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" Available contexts (* = currently selected context) : Source : file:///home/test/core.20121116.154147.16838.0001.dmp *0 : PID: 16867 : JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6480-20121116_01 ) > help + displays the next section of memory in hexdump-like format - displays the previous section of memory in hexdump-like format cd changes the current working directory, used for log files close [context id] closes the connection to a core file context [ID|asid ID] switch to the selected context deadlock displays information about deadlocks if there are any exit Exit the application find searches memory for a given string findnext finds the next instance of the last string passed to \"find\" findptr searches memory for the given pointer heapdump generates a PHD or classic format heapdump help [command name] displays list of commands or help for a specific command hexdump outputs a section of memory in a hexdump-like format info <component> Information about the specified component info class <Java class name> Provides information about the specified Java class info heap [*|heap name] Displays information about Java heaps info jitm Displays JIT'ed methods and their addresses info lock outputs a list of system monitors and locked objects info mmap Outputs a list of all memory segments in the address space info mod outputs module information info proc shortened form of info process info process displays threads, command line arguments, environment info sym an alias for 'mod' info sys shortened form of info system info system displays information about the system the core dump is from info thread displays information about Java and native threads log [name level] display and control instances of java.util.logging.Logger open [path to core or zip] opens the specified core or zip file plugins Plugin management commands list Show the list of loaded plugins for the current context reload Reload plugins for the current context showpath Show the DTFJ View plugin search path for the current context setpath Set the DTFJ View plugin search path for the current context pwd displays the current working directory quit Exit the application set [logging|heapdump] Sets options for the specified command set heapdump configures heapdump format, filename and multiple heap support set logging configures several logging-related parameters, starts/stops logging on turn on logging off turn off logging file turn on logging overwrite controls the overwriting of log files show [logging|heapdump] Displays the current set options for a command show heapdump displays heapdump settings show logging shows the current logging options whatis [hex address] gives information about what is stored at the given memory address x/d <hex address> displays the integer at the specified address x/j <object address> [class name] displays information about a particular object or all objects of a class x/k <hex address> displays the specified memory section as if it were a stack frame parameters x/x <hex address> displays the hex value of the bytes at the specified address > set logging file log.txt logging turned on; outputting to \"/home/test/log.txt\" > info system Machine OS: Linux Hypervisor: PowerVM Machine name: madras Machine IP address(es): 9.20.88.155 System memory: 8269201408 Dump creation time: 2015/08/10 14:44:36:019 Dump creation time (nanoseconds): 21314421467539 Java version: JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6490-20121116_01) JVM start time: 2015/08/10 14:44:05:690 JVM start time (nanoseconds): 21284086192267 > info thread * native threads for address space process id: 16838 thread id: 16839 registers: native stack sections: native stack frames: properties: associated Java thread: name: main Thread object: java/lang/Thread @ 0x2ffd1e08 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x0000000000085b28 method: void com/ibm/jvm/Dump.SystemDumpImpl() (Native Method) objects: <no objects in this frame> bp: 0x0000000000085b40 method: void com/ibm/jvm/Dump.SystemDump() source: Dump.java:41 objects: <no objects in this frame> bp: 0x0000000000085b68 method: void mySystemDump.main(String[]) source: mySystemDump.java:29 objects: <no objects in this frame> ===Lines Removed=== name: GC Worker id: 16860 Thread object: java/lang/Thread @ 0x3001b980 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::workerThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: GC Worker id: 16861 Thread object: java/lang/Thread @ 0x3001c180 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::workerThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: Signal Dispatcher id: 16847 Thread object: com/ibm/misc/SignalDispatcher @ 0x3000f268 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x00000000000df748 method: int com/ibm/misc/SignalDispatcher.waitForSignal() (Native Method) objects: <no objects in this frame> bp: 0x00000000000df788 method: void com/ibm/misc/SignalDispatcher.run() source: SignalDispatcher.java:54 objects: 0x30015828 0x30015828 ===Lines Removed=== > info heap * Heap #1: Generational@fff78303d30 Section #1: Heap extent at 0x100d0000 (0x300000 bytes) Size: 3145728 bytes Shared: false Executable: false Read Only: false Section #2: Heap extent at 0x2ffd0000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false Section #3: Heap extent at 0x30050000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false > info class java/lang/String name = java/lang/String ID = 0x37c00 superID = 0x30300 classLoader = 0x2ffe9b58 modifiers: public final number of instances: 2146 total size of instances: 51504 bytes Inheritance chain.... java/lang/Object java/lang/String Fields...... static fields for \"java/lang/String\" private static final long serialVersionUID = -6849794470754667710 (0xa0f0a4387a3bb342) public static final java.util.Comparator CASE_INSENSITIVE_ORDER = <object> @ 0x2ffd0278 private static final char[] ascii = <object> @ 0x2ffd02c8 private static String[] stringArray = <object> @ 0x2ffd0298 private static final int stringArraySize = 10 (0xa) static boolean enableCopy = false private static int seed = -126504465 (0xfffffffff875b1ef) private static char[] startCombiningAbove = <object> @ 0x100d0c40 private static char[] endCombiningAbove = <object> @ 0x100d0cc0 private static final char[] upperValues = <object> @ 0x100d0d40 private static final java.io.ObjectStreamField[] serialPersistentFields = <object> @ 0x2ffd0920 non-static fields for \"java/lang/String\" private final char[] value private final int offset private final int count private int hashCode private int hashCode32 Methods...... Bytecode range(s): : private static native int getSeed() Bytecode range(s): fff76d8ce48 -- fff76d8ce5e: public void <init>() Bytecode range(s): fff76d8ce88 -- fff76d8cecd: private void <init>(String, char) Bytecode range(s): fff76d8cf10 -- fff76d8cf19: public void <init>(byte[]) Bytecode range(s): fff76d8cf40 -- fff76d8cf4a: public void <init>(byte[], int) Bytecode range(s): fff76d8cf7c -- fff76d8cfb5: public void <init>(byte[], int, int) Bytecode range(s): fff76d8cff8 -- fff76d8d065: public void <init>(byte[], int, int, int) Bytecode range(s): fff76d8d0c4 -- fff76d8d10c: public void <init>(byte[], int, int, String) ===Lines Removed=== > whatis 0x2ffd0298 heap #1 - name: Generational@fff78303d30 0x2ffd0298 is within heap segment: 2ffd0000 -- 30050000 0x2ffd0298 is the start of an object of type [Ljava/lang/String;","title":"Example"},{"location":"tool_jextract/","text":"Dump extractor ( jpackcore ) (AIX\u00ae, Linux\u00ae, macOS\u00ae) On some operating systems, copies of executable files and libraries are required for a full analysis of a core dump (you can get some information from the dump without these files, but not as much). Run the jpackcore utility to collect these extra files and package them into an archive file along with the core dump. To analyze the output, use the dump viewer ( jdmpview ) . Note: This tool replaces jextract , which is deprecated in Eclipse OpenJ9\u2122 version 0.26.0. Syntax jpackcore [-r] [-x] <core file name> [<zip_file>] where: -r forces the jpackcore utility to proceed when the system dump is created from an SDK with a different build ID. See Restriction . -x causes the jpackcore utility to omit the system dump itself from the archive produced. In its place, the file excluded-files.txt is added which names the excluded file. <core file name> is the name of the system dump. <zip_file> is the name you want to give to the processed file. If you do not specify a name, output is written to <core file name>.zip by default. The output is written to the same directory as the core file. Restriction: You should run jpackcore on the same system that produced the system dump in order to collect the correct executables and libraries referenced in the system dump. You should also run jpackcore using the same VM level, to avoid any problems. From Eclipse OpenJ9 V0.24.0, the utility always checks that the build ID of the SDK that created the dump file matches the jpackcore build ID. Where these IDs do not match, the following exception is thrown: J9RAS.buildID is incorrect (found XXX, expecting YYY). This version of jpackcore is incompatible with this dump (use '-r' option to relax this check). To continue, despite the mismatch, use the -r option. See also Dump viewer ( jdmpview )","title":"Dump extractor"},{"location":"tool_jextract/#dump-extractor-jpackcore","text":"(AIX\u00ae, Linux\u00ae, macOS\u00ae) On some operating systems, copies of executable files and libraries are required for a full analysis of a core dump (you can get some information from the dump without these files, but not as much). Run the jpackcore utility to collect these extra files and package them into an archive file along with the core dump. To analyze the output, use the dump viewer ( jdmpview ) . Note: This tool replaces jextract , which is deprecated in Eclipse OpenJ9\u2122 version 0.26.0.","title":"Dump extractor (jpackcore)"},{"location":"tool_jextract/#syntax","text":"jpackcore [-r] [-x] <core file name> [<zip_file>] where: -r forces the jpackcore utility to proceed when the system dump is created from an SDK with a different build ID. See Restriction . -x causes the jpackcore utility to omit the system dump itself from the archive produced. In its place, the file excluded-files.txt is added which names the excluded file. <core file name> is the name of the system dump. <zip_file> is the name you want to give to the processed file. If you do not specify a name, output is written to <core file name>.zip by default. The output is written to the same directory as the core file. Restriction: You should run jpackcore on the same system that produced the system dump in order to collect the correct executables and libraries referenced in the system dump. You should also run jpackcore using the same VM level, to avoid any problems. From Eclipse OpenJ9 V0.24.0, the utility always checks that the build ID of the SDK that created the dump file matches the jpackcore build ID. Where these IDs do not match, the following exception is thrown: J9RAS.buildID is incorrect (found XXX, expecting YYY). This version of jpackcore is incompatible with this dump (use '-r' option to relax this check). To continue, despite the mismatch, use the -r option.","title":"Syntax"},{"location":"tool_jextract/#see-also","text":"Dump viewer ( jdmpview )","title":"See also"},{"location":"tool_jmap/","text":"Java memory map ( jmap ) tool Use the jmap tool to get memory information for a particular Java\u2122 process, or list of processes. The tool shows statistics about classes on the heap, including the number of objects and their aggregate size. The command syntax is as follows: jmap [<option>] [<vmid>] <vmid> is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in jps or other Attach API-based tools. Multiple VMIDs can be specified, separated by a space. If you do not specify a VMID, the command reads input from stdin . You can therefore get information for all processes by piping the output of the jps command to jmap : jps -q | jmap -histo IDs of dead processes are silently ignored. On its own, jmap prints help information. To obtain memory information, a -histo argument must be supplied, where the available <options> are as follows: -histo : Prints statistics about classes on the heap, including the number of objects and their aggregate size -histo:live : Prints statistics for live objects only -J : supplies arguments to the Java VM that is running the jmap command. You can use multiple -J options, for example: jmap -J-Xms2m -J-Xmx10m The output has the following format: num object count total size class name ------------------------------------------------- 1 3354 107328 [C 2 717 57360 java.lang.Class 3 2427 38832 java.lang.String 4 50 13200 [J 5 717 11472 java.lang.J9VMInternals$ClassInitializationLock 6 342 8208 java.lang.StringBuilder 7 151 7248 jdk.internal.org.objectweb.asm.Item 8 396 6336 [Ljava.lang.Object; Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to Eclipse OpenJ9\u2122. The following tool limitations apply: Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <options> <pid> . Displaying data from core dumps is not supported; use jdmpview instead. Other options , such as -F (force a dump of an unresponsive process) can be accomplished using kill -QUIT <pid> . The tool uses the Attach API, and has the following limitations: Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java memory map (jmap) tool"},{"location":"tool_jmap/#java-memory-map-jmap-tool","text":"Use the jmap tool to get memory information for a particular Java\u2122 process, or list of processes. The tool shows statistics about classes on the heap, including the number of objects and their aggregate size. The command syntax is as follows: jmap [<option>] [<vmid>] <vmid> is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in jps or other Attach API-based tools. Multiple VMIDs can be specified, separated by a space. If you do not specify a VMID, the command reads input from stdin . You can therefore get information for all processes by piping the output of the jps command to jmap : jps -q | jmap -histo IDs of dead processes are silently ignored. On its own, jmap prints help information. To obtain memory information, a -histo argument must be supplied, where the available <options> are as follows: -histo : Prints statistics about classes on the heap, including the number of objects and their aggregate size -histo:live : Prints statistics for live objects only -J : supplies arguments to the Java VM that is running the jmap command. You can use multiple -J options, for example: jmap -J-Xms2m -J-Xmx10m The output has the following format: num object count total size class name ------------------------------------------------- 1 3354 107328 [C 2 717 57360 java.lang.Class 3 2427 38832 java.lang.String 4 50 13200 [J 5 717 11472 java.lang.J9VMInternals$ClassInitializationLock 6 342 8208 java.lang.StringBuilder 7 151 7248 jdk.internal.org.objectweb.asm.Item 8 396 6336 [Ljava.lang.Object; Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to Eclipse OpenJ9\u2122. The following tool limitations apply: Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <options> <pid> . Displaying data from core dumps is not supported; use jdmpview instead. Other options , such as -F (force a dump of an unresponsive process) can be accomplished using kill -QUIT <pid> . The tool uses the Attach API, and has the following limitations: Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java memory map (jmap) tool"},{"location":"tool_jps/","text":"Java process status ( jps ) tool Use the jps tool to query running Java\u2122 processes. The tool shows information for every Java process that is owned by the current user ID on the current host. The command syntax is as follows: jps [<options>] where the available <options> are as follows: -J : supplies arguments to the Java VM that is running the jps command. You can use multiple -J options, for example: jps -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -l : prints the application package name -q : prints only the virtual machine identifiers -m : prints the application arguments -v : prints the Java VM arguments, including those that are produced automatically The output has the following format: <VMID> [[<class_name>|<jar_name>|\"Unknown\"] [<application_args>][<vm_args>]] where VMID is the Attach API virtual machine identifier for the Java process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. For example: $ jps -l 5462 org.foo.bar.MyApplication 14332 openj9.tools.attach.diagnostics.Jps $ jps -q 5462 14332 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to Eclipse OpenJ9\u2122. The tool uses the Attach API, and has the following limitations: Does not list Java processes on other hosts, to enhance security Does not list Java processes owned by other users Does not list non-OpenJ9 Java processes Does not list processes whose attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java process status (jps)"},{"location":"tool_jps/#java-process-status-jps-tool","text":"Use the jps tool to query running Java\u2122 processes. The tool shows information for every Java process that is owned by the current user ID on the current host. The command syntax is as follows: jps [<options>] where the available <options> are as follows: -J : supplies arguments to the Java VM that is running the jps command. You can use multiple -J options, for example: jps -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -l : prints the application package name -q : prints only the virtual machine identifiers -m : prints the application arguments -v : prints the Java VM arguments, including those that are produced automatically The output has the following format: <VMID> [[<class_name>|<jar_name>|\"Unknown\"] [<application_args>][<vm_args>]] where VMID is the Attach API virtual machine identifier for the Java process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. For example: $ jps -l 5462 org.foo.bar.MyApplication 14332 openj9.tools.attach.diagnostics.Jps $ jps -q 5462 14332 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to Eclipse OpenJ9\u2122. The tool uses the Attach API, and has the following limitations: Does not list Java processes on other hosts, to enhance security Does not list Java processes owned by other users Does not list non-OpenJ9 Java processes Does not list processes whose attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java process status (jps) tool"},{"location":"tool_jstack/","text":"Java stack ( jstack ) tool Use the jstack tool to obtain Java stack traces and thread information for processes. The tool is similar to the HotSpot tool of the same name; the Eclipse OpenJ9\u2122 version of jstack is an independent implementation, added for compatibility. The command syntax is as follows: jstack <options>* <pid>* Where <pid>* is a list of process IDs. If none are supplied, the process IDs are read from stdin , which allows a user running a Bourne or equivalent shell to query all processes via jps -q | jstack . IDs of inactive processes are silently ignored. The output contains Java stacks and thread information of the specified processes (equivalent to the information provided in java.lang.management.ThreadInfo ). The values for <options>* are as follows: -J : supplies arguments to the Java VM that is running the jstack command. You can use multiple -J options, for example: jstack -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -p : prints the system and agent properties of the process -l : prints more verbose output, including information about locks -h : prints help information Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java stack (jstack) tool"},{"location":"tool_jstack/#java-stack-jstack-tool","text":"Use the jstack tool to obtain Java stack traces and thread information for processes. The tool is similar to the HotSpot tool of the same name; the Eclipse OpenJ9\u2122 version of jstack is an independent implementation, added for compatibility. The command syntax is as follows: jstack <options>* <pid>* Where <pid>* is a list of process IDs. If none are supplied, the process IDs are read from stdin , which allows a user running a Bourne or equivalent shell to query all processes via jps -q | jstack . IDs of inactive processes are silently ignored. The output contains Java stacks and thread information of the specified processes (equivalent to the information provided in java.lang.management.ThreadInfo ). The values for <options>* are as follows: -J : supplies arguments to the Java VM that is running the jstack command. You can use multiple -J options, for example: jstack -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -p : prints the system and agent properties of the process -l : prints more verbose output, including information about locks -h : prints help information Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java stack (jstack) tool"},{"location":"tool_jstat/","text":"Java statistics monitoring ( jstat ) tool Use the jstat tool to obtain Java Virtual Machine (JVM) statistics. The tool is similar to the HotSpot tool of the same name; the Eclipse OpenJ9\u2122 version of jstat is an independent implementation, added for compatibility. The command syntax is as follows: jstat [<option>] [<vmid>] where vmid is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in Java process status (jps) tool or other Attach API-based tools. On its own, jstat prints help information. The values for <option> are as follows: -J : supplies arguments to the JVM that is running the jstat command. You can use multiple -J options, for example: jstat -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints help information -options : lists the available command options -class : displays classloading statistics The output has the following format: Class Loaded Class Unloaded 860 0 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java statistics monitoring (jstat) tool"},{"location":"tool_jstat/#java-statistics-monitoring-jstat-tool","text":"Use the jstat tool to obtain Java Virtual Machine (JVM) statistics. The tool is similar to the HotSpot tool of the same name; the Eclipse OpenJ9\u2122 version of jstat is an independent implementation, added for compatibility. The command syntax is as follows: jstat [<option>] [<vmid>] where vmid is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in Java process status (jps) tool or other Attach API-based tools. On its own, jstat prints help information. The values for <option> are as follows: -J : supplies arguments to the JVM that is running the jstat command. You can use multiple -J options, for example: jstat -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints help information -options : lists the available command options -class : displays classloading statistics The output has the following format: Class Loaded Class Unloaded 860 0 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Java Attach API .","title":"Java statistics monitoring (jstat) tool"},{"location":"tool_migration/","text":"Switching to Eclipse OpenJ9 Eclipse OpenJ9\u2122 provides the following tools, which might differ in behavior from the HotSpot equivalent. Note: For information about HotSpot equivalences and differences for items other than tools, see New to Eclipse OpenJ9? Java diagnostic command tool ( jcmd ) Runs diagnostic commands on a specified VM. The main difference from the HotSpot jcmd tool is that the following options are not currently supported: The -f option to read commands from a file. The Perfcounter.print option for displaying performance counters for the target VM. Selecting VMs by main class instead of VMID. Specifying 0 as a VMID to target all VMs. Java memory map tool ( jmap ) Displays information about classes on the heap, including the number of objects and their aggregate size. The main differences from the HotSpot jmap tool are as follows: Uses the Attach API. Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <option> <vmid> , where <vmid> is the Attach API virtual machine identifier for the Java\u2122 process. Does not support displaying data from core dumps; use Dump viewer instead. Does not include a -F option to force a dump of an unresponsive process. User kill -QUIT <pid> instead, where <pid> is the process identifier. For more information, see jmap . Java process status ( jps ) Displays information about running Java processes. The main differences from the HotSpot jps tool are as follows: Runs on Windows\u00ae, AIX\u00ae, and z/OS\u00ae, as well as Linux\u00ae. Uses the Attach API. Shows processes on the current host only. There is no -V option. For more information, see Java process status . Java stack ( jstack ) tool Displays information about Java stack traces and thread information for processes. The main differences from the HotSpot jstack tool are as follows: In the interests of security, the OpenJ9 implementation of jstack prints only information about local processes that are owned by the current user. Printing data for core dumps is not supported. Use the Dump viewer instead. There is no -m option. Printing data for native stack frames is not supported. There is no -F option to force a dump, although this might be accomplished using kill -QUIT <pid> on some platforms. For more information, see jstack . Java statistics monitoring ( jstat ) tool Displays information about Java statistics for processes. The main difference from the HotSpot jstat tool is that this tool only provides the number of classes loaded and the number of class unloaded. For more information, see jstat .","title":"Switching to OpenJ9"},{"location":"tool_migration/#switching-to-eclipse-openj9","text":"Eclipse OpenJ9\u2122 provides the following tools, which might differ in behavior from the HotSpot equivalent. Note: For information about HotSpot equivalences and differences for items other than tools, see New to Eclipse OpenJ9?","title":"Switching to Eclipse OpenJ9"},{"location":"tool_migration/#java-diagnostic-command-tool-jcmd","text":"Runs diagnostic commands on a specified VM. The main difference from the HotSpot jcmd tool is that the following options are not currently supported: The -f option to read commands from a file. The Perfcounter.print option for displaying performance counters for the target VM. Selecting VMs by main class instead of VMID. Specifying 0 as a VMID to target all VMs.","title":"Java diagnostic command tool (jcmd)"},{"location":"tool_migration/#java-memory-map-tool-jmap","text":"Displays information about classes on the heap, including the number of objects and their aggregate size. The main differences from the HotSpot jmap tool are as follows: Uses the Attach API. Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <option> <vmid> , where <vmid> is the Attach API virtual machine identifier for the Java\u2122 process. Does not support displaying data from core dumps; use Dump viewer instead. Does not include a -F option to force a dump of an unresponsive process. User kill -QUIT <pid> instead, where <pid> is the process identifier. For more information, see jmap .","title":"Java memory map tool (jmap)"},{"location":"tool_migration/#java-process-status-jps","text":"Displays information about running Java processes. The main differences from the HotSpot jps tool are as follows: Runs on Windows\u00ae, AIX\u00ae, and z/OS\u00ae, as well as Linux\u00ae. Uses the Attach API. Shows processes on the current host only. There is no -V option. For more information, see Java process status .","title":"Java process status (jps)"},{"location":"tool_migration/#java-stack-jstack-tool","text":"Displays information about Java stack traces and thread information for processes. The main differences from the HotSpot jstack tool are as follows: In the interests of security, the OpenJ9 implementation of jstack prints only information about local processes that are owned by the current user. Printing data for core dumps is not supported. Use the Dump viewer instead. There is no -m option. Printing data for native stack frames is not supported. There is no -F option to force a dump, although this might be accomplished using kill -QUIT <pid> on some platforms. For more information, see jstack .","title":"Java stack (jstack) tool"},{"location":"tool_migration/#java-statistics-monitoring-jstat-tool","text":"Displays information about Java statistics for processes. The main difference from the HotSpot jstat tool is that this tool only provides the number of classes loaded and the number of class unloaded. For more information, see jstat .","title":"Java statistics monitoring (jstat) tool"},{"location":"tool_traceformat/","text":"Trace formatter ( traceformat ) The trace formatter is a Java\u2122 program that converts binary trace point data in a trace file to a readable form. The formatter requires the TraceFormat.dat and J9TraceFormat.dat files, which contain the formatting templates. The formatter produces a file that contains header information about the VM that produced the binary trace file, a list of threads for which trace points were produced, and the formatted trace points with their time stamp, thread ID, trace point ID, and trace point data. Syntax To use the trace formatter on a binary trace file type: traceformat <input_file> [<output_file>] <parameters> Where <input_file> is the name of the binary trace file to be formatted, and <output_file> is the name of the output file. If you do not specify an output file, the output file is called input_file.fmt . The size of the heap that is needed to format the trace is directly proportional to the number of threads present in the trace file. For large numbers of threads the formatter might run out of memory, generating the error OutOfMemoryError . In this case, increase the heap size by using the -Xmx option. Parameters The following <parameters> are available with the trace formatter: Option Explanation -datfile=<file1.dat>[,<file2.dat>] A comma-separated list of trace formatting data files. By default, the following files are used:$JAVA_HOME/lib/J9TraceFormat.dat and $JAVA_HOME/lib/TraceFormat.dat -format_time=yes|no Specifies whether to format the time stamps into human readable form. The default is yes . -help Displays usage information. -indent Indents trace messages at each Entry trace point and outdents trace messages at each Exit trace point. The default is not to indent the messages. -summary Prints summary information to the screen without generating an output file. -threads=<thread id>[,<thread id>]... Filters the output for the given thread IDs only. thread id is the ID of the thread, which can be specified in decimal or hex (0x) format. Any number of thread IDs can be specified, separated by commas. -timezone=+|-HH:MM Specifies the offset from UTC, as positive or negative hours and minutes, to apply when formatting time stamps. -verbose Output detailed warning and error messages, and performance statistics. Examples The following example shows output from running the trace formatter command: C:\\test>traceformat sample.trc Writing formatted trace output to file sample.trc.fmt Processing 0.4921875Mb of binary trace data Completed processing of 6983 tracepoints with 0 warnings and 0 errors The formatted trace output looks similar to the following extract, which is truncated to show the key areas of information: Trace Summary Service level: JRE 1.8.0 Windows 7 amd64-64 build (pwa6480sr2-20150624_06(SR2)) JVM startup options: -Xoptionsfile=c:\\build\\pwa6480sr2-20150624\\sdk\\lib\\compressedrefs\\options.default .... Processor information: Arch family: AMD64 Processor Sub-type: Opteron Num Processors: 8 Word size: 64 Trace activation information:: FORMAT=c:\\build\\pwa6480sr2-20150624\\sdk\\lib;. MAXIMAL=all{level1} EXCEPTION=j9mm{gclogger} MAXIMAL=all{level2} output=sample Trace file header: JVM start time: 08:58:35.527000000 Generations: 1 Pointer size: 8 Active threads .... 0x000000000f155f00 Attach API wait loop 0x000000000f18b200 Thread-1 0x000000000f190200 Thread-3 Trace Formatted Data Time (UTC) Thread ID Tracepoint ID Type Tracepoint Data 08:58:35.527291919 *0x000000000f010500 j9trc.0 Event Trace engine initialized for VM = 0x3ad4d0 08:58:35.527349836 0x000000000f010500 j9prt.0 Event Trace engine initialized for module j9port 08:58:35.527354040 0x000000000f010500 j9thr.0 Event Trace engine initialized for module j9thr 08:58:35.529409621 *0x000000000f01eb00 j9trc.5 Event Thread started VMthread = 0xf01eb00, name = (unnamed thread), nativeID = 0x24a798 .... 08:58:35.536134516 0x000000000f010500 j9vm.1 Entry >Create RAM class from ROM class 0x3cab680 in class loader 0x3042338 08:58:35.536136384 0x000000000f010500 j9vm.80 Event ROM class 0x3cab680 is named java/lang/Object 08:58:35.536200373 0x000000000f010500 j9vm.2 Exit <Created RAM class 0xf03ef00 from ROM class 0x3cab680","title":"Trace formatter"},{"location":"tool_traceformat/#trace-formatter-traceformat","text":"The trace formatter is a Java\u2122 program that converts binary trace point data in a trace file to a readable form. The formatter requires the TraceFormat.dat and J9TraceFormat.dat files, which contain the formatting templates. The formatter produces a file that contains header information about the VM that produced the binary trace file, a list of threads for which trace points were produced, and the formatted trace points with their time stamp, thread ID, trace point ID, and trace point data.","title":"Trace formatter (traceformat)"},{"location":"tool_traceformat/#syntax","text":"To use the trace formatter on a binary trace file type: traceformat <input_file> [<output_file>] <parameters> Where <input_file> is the name of the binary trace file to be formatted, and <output_file> is the name of the output file. If you do not specify an output file, the output file is called input_file.fmt . The size of the heap that is needed to format the trace is directly proportional to the number of threads present in the trace file. For large numbers of threads the formatter might run out of memory, generating the error OutOfMemoryError . In this case, increase the heap size by using the -Xmx option.","title":"Syntax"},{"location":"tool_traceformat/#parameters","text":"The following <parameters> are available with the trace formatter: Option Explanation -datfile=<file1.dat>[,<file2.dat>] A comma-separated list of trace formatting data files. By default, the following files are used:$JAVA_HOME/lib/J9TraceFormat.dat and $JAVA_HOME/lib/TraceFormat.dat -format_time=yes|no Specifies whether to format the time stamps into human readable form. The default is yes . -help Displays usage information. -indent Indents trace messages at each Entry trace point and outdents trace messages at each Exit trace point. The default is not to indent the messages. -summary Prints summary information to the screen without generating an output file. -threads=<thread id>[,<thread id>]... Filters the output for the given thread IDs only. thread id is the ID of the thread, which can be specified in decimal or hex (0x) format. Any number of thread IDs can be specified, separated by commas. -timezone=+|-HH:MM Specifies the offset from UTC, as positive or negative hours and minutes, to apply when formatting time stamps. -verbose Output detailed warning and error messages, and performance statistics.","title":"Parameters"},{"location":"tool_traceformat/#examples","text":"The following example shows output from running the trace formatter command: C:\\test>traceformat sample.trc Writing formatted trace output to file sample.trc.fmt Processing 0.4921875Mb of binary trace data Completed processing of 6983 tracepoints with 0 warnings and 0 errors The formatted trace output looks similar to the following extract, which is truncated to show the key areas of information: Trace Summary Service level: JRE 1.8.0 Windows 7 amd64-64 build (pwa6480sr2-20150624_06(SR2)) JVM startup options: -Xoptionsfile=c:\\build\\pwa6480sr2-20150624\\sdk\\lib\\compressedrefs\\options.default .... Processor information: Arch family: AMD64 Processor Sub-type: Opteron Num Processors: 8 Word size: 64 Trace activation information:: FORMAT=c:\\build\\pwa6480sr2-20150624\\sdk\\lib;. MAXIMAL=all{level1} EXCEPTION=j9mm{gclogger} MAXIMAL=all{level2} output=sample Trace file header: JVM start time: 08:58:35.527000000 Generations: 1 Pointer size: 8 Active threads .... 0x000000000f155f00 Attach API wait loop 0x000000000f18b200 Thread-1 0x000000000f190200 Thread-3 Trace Formatted Data Time (UTC) Thread ID Tracepoint ID Type Tracepoint Data 08:58:35.527291919 *0x000000000f010500 j9trc.0 Event Trace engine initialized for VM = 0x3ad4d0 08:58:35.527349836 0x000000000f010500 j9prt.0 Event Trace engine initialized for module j9port 08:58:35.527354040 0x000000000f010500 j9thr.0 Event Trace engine initialized for module j9thr 08:58:35.529409621 *0x000000000f01eb00 j9trc.5 Event Thread started VMthread = 0xf01eb00, name = (unnamed thread), nativeID = 0x24a798 .... 08:58:35.536134516 0x000000000f010500 j9vm.1 Entry >Create RAM class from ROM class 0x3cab680 in class loader 0x3042338 08:58:35.536136384 0x000000000f010500 j9vm.80 Event ROM class 0x3cab680 is named java/lang/Object 08:58:35.536200373 0x000000000f010500 j9vm.2 Exit <Created RAM class 0xf03ef00 from ROM class 0x3cab680","title":"Examples"},{"location":"version0.10/","text":"What's new in version 0.10.0 The following new features and notable changes since v.0.9.0 are included in this release: New binaries and changes to supported environments. Change to the default shared classes cache size for OpenJDK 8 builds New information for the SHARED CLASSES section of a Javadump file Support for OpenJDK HotSpot options New JDK 11 features Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.10.0 supports OpenJDK 11, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 11 OpenJDK 11 with Eclipse OpenJ9 is a long term support (LTS) release and supersedes OpenJDK 10 with Eclipse OpenJ9. Although it is possible to build an OpenJDK v8 with the OpenJ9 0.10.0 release level, testing at the project is not complete and therefore support is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments Change to the default shared classes cache size For OpenJDK 8 builds, the default shared classes cache size is increased from 16 MB to 300 MB, with a \"soft\" maximum limit for the initial size of the cache set to 64 MB. Certain exceptions apply. For more information, see -Xshareclasses . The new default also applies to OpenJDK 11 builds. New information for the SHARED CLASSES section of a Java dump file The value of the soft maximum size ( -Xscmx ) of the shared classes cache is now recorded in the SHARED CLASSES section of a Java dump file against the string 2SCLTEXTSMB . For example output, see Java dump . Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:HeapDumpPath -XX:[+|-]HeapDumpOnOutOfMemory -XX:ActiveProcessorCount New JDK 11 features The following features are supported by OpenJ9: JEP 181 : Nest-Based Access Control JEP 309 : Dynamic Class-File Constants JEP 320 : Remove the Java EE and CORBA Modules JEP 321 : HTTP Client (Standard) JEP 323 : Local-Variable Syntax for Lambda Parameters JEP 324 : Key Agreement with Curve25519 and Curve448 JEP 329 : ChaCha20 and Poly1305 Cryptographic Algorithms JEP 330 : Launch Single-File Source-Code Programs JEP 332 : Transport Layer Security (TLS) 1.3 JEP 335 : Deprecate the Nashorn JavaScript Engine JEP 336 : Deprecate the Pack200 Tools and API You can find the full list of features for JDK 11 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.9.0 and version 0.10.0 releases, see the Release notes .","title":"Version 0.10.0"},{"location":"version0.10/#whats-new-in-version-0100","text":"The following new features and notable changes since v.0.9.0 are included in this release: New binaries and changes to supported environments. Change to the default shared classes cache size for OpenJDK 8 builds New information for the SHARED CLASSES section of a Javadump file Support for OpenJDK HotSpot options New JDK 11 features","title":"What's new in version 0.10.0"},{"location":"version0.10/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.10/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.10.0 supports OpenJDK 11, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 11 OpenJDK 11 with Eclipse OpenJ9 is a long term support (LTS) release and supersedes OpenJDK 10 with Eclipse OpenJ9. Although it is possible to build an OpenJDK v8 with the OpenJ9 0.10.0 release level, testing at the project is not complete and therefore support is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments","title":"Binaries and supported environments"},{"location":"version0.10/#change-to-the-default-shared-classes-cache-size","text":"For OpenJDK 8 builds, the default shared classes cache size is increased from 16 MB to 300 MB, with a \"soft\" maximum limit for the initial size of the cache set to 64 MB. Certain exceptions apply. For more information, see -Xshareclasses . The new default also applies to OpenJDK 11 builds.","title":"Change to the default shared classes cache size"},{"location":"version0.10/#new-information-for-the-shared-classes-section-of-a-java-dump-file","text":"The value of the soft maximum size ( -Xscmx ) of the shared classes cache is now recorded in the SHARED CLASSES section of a Java dump file against the string 2SCLTEXTSMB . For example output, see Java dump .","title":"New information for the SHARED CLASSES section of a Java dump file"},{"location":"version0.10/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:HeapDumpPath -XX:[+|-]HeapDumpOnOutOfMemory -XX:ActiveProcessorCount","title":"Support for OpenJDK HotSpot options"},{"location":"version0.10/#new-jdk-11-features","text":"The following features are supported by OpenJ9: JEP 181 : Nest-Based Access Control JEP 309 : Dynamic Class-File Constants JEP 320 : Remove the Java EE and CORBA Modules JEP 321 : HTTP Client (Standard) JEP 323 : Local-Variable Syntax for Lambda Parameters JEP 324 : Key Agreement with Curve25519 and Curve448 JEP 329 : ChaCha20 and Poly1305 Cryptographic Algorithms JEP 330 : Launch Single-File Source-Code Programs JEP 332 : Transport Layer Security (TLS) 1.3 JEP 335 : Deprecate the Nashorn JavaScript Engine JEP 336 : Deprecate the Pack200 Tools and API You can find the full list of features for JDK 11 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9.","title":"New JDK 11 features"},{"location":"version0.10/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.9.0 and version 0.10.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.11/","text":"What's new in version 0.11.0 The following new features and notable changes since version 0.10.0 are included in this release: New binaries and changes to supported environments. OpenSSL is now supported for improved native cryptographic performance Changes to the location of the default shared cache and cache snapshot directory New class data sharing suboptions Container awareness in the Eclipse OpenJ9\u2122 VM is now enabled by default Pause-less garbage collection mode is now available on Linux x86 platforms You can now restrict identity hash codes to non-negative values Support for OpenJDK HotSpot options Features and changes Binaries and supported environments Eclipse OpenJ9 release 0.11.0 provides limited support for the macOS\u00ae platform on OpenJDK 11. Early builds of OpenJDK 11 with OpenJ9 on macOS are available at the AdoptOpenJDK project at the following link: OpenJDK version 11 Support for macOS on OpenJDK 8 is coming soon. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments OpenSSL is now supported for improved native cryptographic performance OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binary due to an unresolved problem. Changes to the location of the default shared cache and cache snapshot directory To increase security, the default shared classes cache directory is changed on non-Windows platforms from /tmp/javasharedresources/ to the user's home directory, unless you specify -Xshareclasses:groupAccess . If you use the groupAccess suboption, the default directory is unchanged because some members of the group might not have access to the user home directory. Note: For persistent caches, the shared classes cache directory cannot be on an NFS mount. If your user home directory is on an NFS mount, either move it or use the -Xshareclasses:cacheDir=<directory> suboption to specify a different directory for the cache. In general, caches cannot be shared across different Java releases, so you cannot re-use a cache that was created by a previous level of Java 11; if you use the name and cacheDir suboptions to specify an existing cache, the VM attempts to delete the cache and create a new one. However, on Windows, the cache cannot be deleted if it is in use, in which case the VM continues to use the existing cache. You can find and remove old caches or snapshots by using the following command-line options: For persistent caches: - -Xshareclasses:cacheDir=/tmp/javasharedresources/,listAllCaches to find the cache - -Xshareclasses:cacheDir=/tmp/javasharedresources/,name=<cacheName>,destroy to remove the cache For nonpersistent caches or snapshots: - -Xshareclasses:cacheDir=/tmp,listAllCaches to find the item - -Xshareclasses:cacheDir=/tmp,name=<snapshotName>,destroySnapshot to remove the item New class data sharing suboptions -Xshareclasses:bootClassesOnly : disables caching of classes that are loaded by non-bootstrap class loaders. This suboption also enables the nonfatal suboption, which allows the VM to start even if there was an error creating the shared classes cache. -Xshareclasses:fatal : prevents the VM from starting if there was an error creating the shared classes cache. You might want to enable this suboption when using the -Xshareclasses:bootClassesOnly suboption, to troubleshoot problems when creating the cache. Container awareness in the OpenJ9 VM is now enabled by default When using container technology, applications are typically run on their own and do not need to compete for memory. If the VM detects that it is running in a container environment, and a memory limit for the container is set, the VM automatically adjusts the maximum default Java heap size. In earlier releases, this behavior was enabled by setting the -XX:+UseContainerSupport option. This setting is now the default. For more information about the Java heap size set for a container, see -XX:[+|-]UseContainerSupport . Pause-less garbage collection mode is now available on Linux x86 platforms Pause-less garbage collection mode is aimed at large heap, response-time sensitive applications. When enabled, the VM attempts to reduce GC pause times. In earlier releases, pause-less garbage collection mode ( -Xgc:concurrentScavenge ) was available only on IBM z14 hardware. This mode is now available on 64-bit x86 Linux platforms. Restrictions: The Generational Concurrent ( gencon ) garbage collection policy must be used. (This is the default policy.) Compressed references must be used. See -Xcompressedrefs . Compressed references are enabled by default when the maximum heap size ( -Xmx ) \u2264 57 GB. The concurrent scavenge option is ignored if the maximum heap size is > 57 GB. You can now restrict identity hash codes to non-negative values OpenJ9 allows both positive and negative identity hashcodes, which can be problematic if your program (incorrectly) assumes hashcodes can only be positive. However, you can now use the -XX:[+|-]PositiveIdentityHash option to limit identity hash codes to non-negative values. Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:MaxHeapSize -XX:InitialHeapSize Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.10.0 and version 0.11.0 releases, see the Release notes .","title":"Version 0.11.0"},{"location":"version0.11/#whats-new-in-version-0110","text":"The following new features and notable changes since version 0.10.0 are included in this release: New binaries and changes to supported environments. OpenSSL is now supported for improved native cryptographic performance Changes to the location of the default shared cache and cache snapshot directory New class data sharing suboptions Container awareness in the Eclipse OpenJ9\u2122 VM is now enabled by default Pause-less garbage collection mode is now available on Linux x86 platforms You can now restrict identity hash codes to non-negative values Support for OpenJDK HotSpot options","title":"What's new in version 0.11.0"},{"location":"version0.11/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.11/#binaries-and-supported-environments","text":"Eclipse OpenJ9 release 0.11.0 provides limited support for the macOS\u00ae platform on OpenJDK 11. Early builds of OpenJDK 11 with OpenJ9 on macOS are available at the AdoptOpenJDK project at the following link: OpenJDK version 11 Support for macOS on OpenJDK 8 is coming soon. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments","title":"Binaries and supported environments"},{"location":"version0.11/#openssl-is-now-supported-for-improved-native-cryptographic-performance","text":"OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binary due to an unresolved problem.","title":"OpenSSL is now supported for improved native cryptographic performance"},{"location":"version0.11/#changes-to-the-location-of-the-default-shared-cache-and-cache-snapshot-directory","text":"To increase security, the default shared classes cache directory is changed on non-Windows platforms from /tmp/javasharedresources/ to the user's home directory, unless you specify -Xshareclasses:groupAccess . If you use the groupAccess suboption, the default directory is unchanged because some members of the group might not have access to the user home directory. Note: For persistent caches, the shared classes cache directory cannot be on an NFS mount. If your user home directory is on an NFS mount, either move it or use the -Xshareclasses:cacheDir=<directory> suboption to specify a different directory for the cache. In general, caches cannot be shared across different Java releases, so you cannot re-use a cache that was created by a previous level of Java 11; if you use the name and cacheDir suboptions to specify an existing cache, the VM attempts to delete the cache and create a new one. However, on Windows, the cache cannot be deleted if it is in use, in which case the VM continues to use the existing cache. You can find and remove old caches or snapshots by using the following command-line options: For persistent caches: - -Xshareclasses:cacheDir=/tmp/javasharedresources/,listAllCaches to find the cache - -Xshareclasses:cacheDir=/tmp/javasharedresources/,name=<cacheName>,destroy to remove the cache For nonpersistent caches or snapshots: - -Xshareclasses:cacheDir=/tmp,listAllCaches to find the item - -Xshareclasses:cacheDir=/tmp,name=<snapshotName>,destroySnapshot to remove the item","title":"Changes to the location of the default shared cache and cache snapshot directory"},{"location":"version0.11/#new-class-data-sharing-suboptions","text":"-Xshareclasses:bootClassesOnly : disables caching of classes that are loaded by non-bootstrap class loaders. This suboption also enables the nonfatal suboption, which allows the VM to start even if there was an error creating the shared classes cache. -Xshareclasses:fatal : prevents the VM from starting if there was an error creating the shared classes cache. You might want to enable this suboption when using the -Xshareclasses:bootClassesOnly suboption, to troubleshoot problems when creating the cache.","title":"New class data sharing suboptions"},{"location":"version0.11/#container-awareness-in-the-openj9-vm-is-now-enabled-by-default","text":"When using container technology, applications are typically run on their own and do not need to compete for memory. If the VM detects that it is running in a container environment, and a memory limit for the container is set, the VM automatically adjusts the maximum default Java heap size. In earlier releases, this behavior was enabled by setting the -XX:+UseContainerSupport option. This setting is now the default. For more information about the Java heap size set for a container, see -XX:[+|-]UseContainerSupport .","title":"Container awareness in the OpenJ9 VM is now enabled by default"},{"location":"version0.11/#pause-less-garbage-collection-mode-is-now-available-on-linux-x86-platforms","text":"Pause-less garbage collection mode is aimed at large heap, response-time sensitive applications. When enabled, the VM attempts to reduce GC pause times. In earlier releases, pause-less garbage collection mode ( -Xgc:concurrentScavenge ) was available only on IBM z14 hardware. This mode is now available on 64-bit x86 Linux platforms. Restrictions: The Generational Concurrent ( gencon ) garbage collection policy must be used. (This is the default policy.) Compressed references must be used. See -Xcompressedrefs . Compressed references are enabled by default when the maximum heap size ( -Xmx ) \u2264 57 GB. The concurrent scavenge option is ignored if the maximum heap size is > 57 GB.","title":"Pause-less garbage collection mode is now available on Linux x86 platforms"},{"location":"version0.11/#you-can-now-restrict-identity-hash-codes-to-non-negative-values","text":"OpenJ9 allows both positive and negative identity hashcodes, which can be problematic if your program (incorrectly) assumes hashcodes can only be positive. However, you can now use the -XX:[+|-]PositiveIdentityHash option to limit identity hash codes to non-negative values.","title":"You can now restrict identity hash codes to non-negative values"},{"location":"version0.11/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:MaxHeapSize -XX:InitialHeapSize","title":"Support for OpenJDK HotSpot options"},{"location":"version0.11/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.10.0 and version 0.11.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.12/","text":"What's new in version 0.12.x Version 0.12.0 The following new features and notable changes since version 0.11.0 are included in this release: Improved flexibility for managing the size of the JIT code cache Idle-tuning is enabled by default when Eclipse OpenJ9\u2122 runs in a docker container Changes to default shared classes cache directory permissions (not Windows) OpenSSL is now supported for improved native cryptographic performance Improved support for pause-less garbage collection RSA algorithm support for OpenSSL IBM_JAVA_OPTIONS is deprecated Warning: Following the release of OpenJ9 0.12.0, an intermittent problem was identified with OpenSSL V1.1.x acceleration of the cryptographic Digest algorithm. For more information about the issue, see #4530 . You can turn off the Digest algorithm by setting the -Djdk.nativeDigest system property to false . A new release of OpenJ9 (0.12.1) is available that disables the Digest algorithm by default. Features and changes Binaries and supported environments Eclipse OpenJ9 release 0.12.0 provides support for OpenJDK 8 with OpenJ9 and OpenJDK 11 with OpenJ9 . In this release support is extended to the 64-bit macOS\u00ae platform on OpenJDK with OpenJ9. Builds for all platforms are available from the AdoptOpenJDK project at the following links: OpenJDK 8 with OpenJ9 OpenJDK 11 with OpenJ9 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Improved flexibility for managing the size of the JIT code cache The JIT code cache stores the native code of compiled Java\u2122 methods. By default, the size of the code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. In earlier releases the size of the code cache could be increased from the default value by using the -Xcodecachetotal command line option. In this release the size can also be decreased by using this option, with a minimum size of 2 MB. The size of the JIT code cache also affects the size of the JIT data cache, which holds metadata about compiled methods. If you use the -Xcodecachetotal option to manage the size of the code cache, the size of the data cache is adjusted by the same proportion. For more information, see -Xcodecachetotal . Idle-tuning is enabled by default when OpenJ9 runs in a docker container In an earlier release, a set of idle-tuning options were introduced to manage the footprint of the Java heap when the OpenJ9 VM is in an idle state. These options could be set manually on the command line. In this release, the following two options are enabled by default when OpenJ9 is running in a container: -XX:[+|-]IdleTuningGcOnIdle , which runs a garbage collection cycle and releases free memory pages back to the operating system when the VM state is set to idle. -XX:[+|-]IdleTuningCompactOnIdle , which compacts the object heap to reduce fragmentation when the VM state is set to idle. By default, the VM must be idle for 180 seconds before the status is set to idle. To control the wait time before an idle state is set, use the -XX:IdleTuningMinIdleWaitTime option. To turn off idle detection, set the value to 0 . Changes to default shared classes cache directory permissions (not Windows) If you do not use the cachDirPerm suboption to specify permissions for a shared classes cache directory, and the cache directory is not the /tmp/javasharedresources default, the following changes apply: When creating a new cache directory, the default permissions are now stricter. If the cache directory already exists, permissions are now unchanged (previously, when a cache was opened using this directory, the permissions would be set to 0777). For more information, see -Xshareclasses . OpenSSL is now supported for improved native cryptographic performance OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: OpenJDK 8 with OpenJ9 includes OpenSSL support since version 0.11.0. Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binaries due to an unresolved problem. Improved support for pause-less garbage collection Concurrent scavenge mode is now supported on 64-bit Windows operating systems. In Eclipse OpenJ9 version 0.11.0, support was added for -Xgc:concurrentScavenge on Linux x86-64 virtual machines that use compressed references. In this release, support is now available for Linux x86-64 large-heap virtual machines (non-compressed references). For more information, see the -Xgc:concurrentScavenge option. RSA algorithm support for OpenSSL OpenSSL v1.1 support for the RSA algorithm is added in this release, providing improved cryptographic performance. OpenSSL support is enabled by default. If you want to turn off support for the RSA algorithm, set the -Djdk.nativeRSA system property to false . IBM_JAVA_OPTIONS is deprecated The VM environment variable IBM_JAVA_OPTIONS is deprecated and is replaced by OPENJ9_JAVA_OPTIONS . IBM_JAVA_OPTIONS will be removed in a future release. For more information about the use of this variable, see the general options in Environment variables . Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.11.0 and version 0.12.0 releases, see the Release notes . Version 0.12.1 The following change is implemented since version 0.12.0: By default, OpenJ9 provides native cryptographic acceleration using OpenSSL version 1.1.x for the Digest, CBC, GCM, and RSA algorithms. Under certain circumstances acceleration of the Digest algorithm was found to cause a segmentation error. Cryptographic acceleration of the Digest algorithm is now turned off by default. The system property -Djdk.nativeDigest cannot be used to turn on support. This property is ignored by the VM. Full release information Release notes to describe the changes between Eclipse OpenJ9 version 0.12.0 and version 0.12.1 releases, can be found in the OpenJ9 GitHub repository .","title":"Version 0.12.0"},{"location":"version0.12/#whats-new-in-version-012x","text":"","title":"What's new in version 0.12.x"},{"location":"version0.12/#version-0120","text":"The following new features and notable changes since version 0.11.0 are included in this release: Improved flexibility for managing the size of the JIT code cache Idle-tuning is enabled by default when Eclipse OpenJ9\u2122 runs in a docker container Changes to default shared classes cache directory permissions (not Windows) OpenSSL is now supported for improved native cryptographic performance Improved support for pause-less garbage collection RSA algorithm support for OpenSSL IBM_JAVA_OPTIONS is deprecated Warning: Following the release of OpenJ9 0.12.0, an intermittent problem was identified with OpenSSL V1.1.x acceleration of the cryptographic Digest algorithm. For more information about the issue, see #4530 . You can turn off the Digest algorithm by setting the -Djdk.nativeDigest system property to false . A new release of OpenJ9 (0.12.1) is available that disables the Digest algorithm by default.","title":"Version 0.12.0"},{"location":"version0.12/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.12/#binaries-and-supported-environments","text":"Eclipse OpenJ9 release 0.12.0 provides support for OpenJDK 8 with OpenJ9 and OpenJDK 11 with OpenJ9 . In this release support is extended to the 64-bit macOS\u00ae platform on OpenJDK with OpenJ9. Builds for all platforms are available from the AdoptOpenJDK project at the following links: OpenJDK 8 with OpenJ9 OpenJDK 11 with OpenJ9 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.12/#improved-flexibility-for-managing-the-size-of-the-jit-code-cache","text":"The JIT code cache stores the native code of compiled Java\u2122 methods. By default, the size of the code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. In earlier releases the size of the code cache could be increased from the default value by using the -Xcodecachetotal command line option. In this release the size can also be decreased by using this option, with a minimum size of 2 MB. The size of the JIT code cache also affects the size of the JIT data cache, which holds metadata about compiled methods. If you use the -Xcodecachetotal option to manage the size of the code cache, the size of the data cache is adjusted by the same proportion. For more information, see -Xcodecachetotal .","title":"Improved flexibility for managing the size of the JIT code cache"},{"location":"version0.12/#idle-tuning-is-enabled-by-default-when-openj9-runs-in-a-docker-container","text":"In an earlier release, a set of idle-tuning options were introduced to manage the footprint of the Java heap when the OpenJ9 VM is in an idle state. These options could be set manually on the command line. In this release, the following two options are enabled by default when OpenJ9 is running in a container: -XX:[+|-]IdleTuningGcOnIdle , which runs a garbage collection cycle and releases free memory pages back to the operating system when the VM state is set to idle. -XX:[+|-]IdleTuningCompactOnIdle , which compacts the object heap to reduce fragmentation when the VM state is set to idle. By default, the VM must be idle for 180 seconds before the status is set to idle. To control the wait time before an idle state is set, use the -XX:IdleTuningMinIdleWaitTime option. To turn off idle detection, set the value to 0 .","title":"Idle-tuning is enabled by default when OpenJ9 runs in a docker container"},{"location":"version0.12/#changes-to-default-shared-classes-cache-directory-permissions-not-windows","text":"If you do not use the cachDirPerm suboption to specify permissions for a shared classes cache directory, and the cache directory is not the /tmp/javasharedresources default, the following changes apply: When creating a new cache directory, the default permissions are now stricter. If the cache directory already exists, permissions are now unchanged (previously, when a cache was opened using this directory, the permissions would be set to 0777). For more information, see -Xshareclasses .","title":"Changes to default shared classes cache directory permissions (not Windows)"},{"location":"version0.12/#openssl-is-now-supported-for-improved-native-cryptographic-performance","text":"OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: OpenJDK 8 with OpenJ9 includes OpenSSL support since version 0.11.0. Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binaries due to an unresolved problem.","title":"OpenSSL is now supported for improved native cryptographic performance"},{"location":"version0.12/#improved-support-for-pause-less-garbage-collection","text":"Concurrent scavenge mode is now supported on 64-bit Windows operating systems. In Eclipse OpenJ9 version 0.11.0, support was added for -Xgc:concurrentScavenge on Linux x86-64 virtual machines that use compressed references. In this release, support is now available for Linux x86-64 large-heap virtual machines (non-compressed references). For more information, see the -Xgc:concurrentScavenge option.","title":"Improved support for pause-less garbage collection"},{"location":"version0.12/#rsa-algorithm-support-for-openssl","text":"OpenSSL v1.1 support for the RSA algorithm is added in this release, providing improved cryptographic performance. OpenSSL support is enabled by default. If you want to turn off support for the RSA algorithm, set the -Djdk.nativeRSA system property to false .","title":"RSA algorithm support for OpenSSL"},{"location":"version0.12/#ibm_java_options-is-deprecated","text":"The VM environment variable IBM_JAVA_OPTIONS is deprecated and is replaced by OPENJ9_JAVA_OPTIONS . IBM_JAVA_OPTIONS will be removed in a future release. For more information about the use of this variable, see the general options in Environment variables .","title":"IBM_JAVA_OPTIONS is deprecated"},{"location":"version0.12/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.11.0 and version 0.12.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.12/#version-0121","text":"The following change is implemented since version 0.12.0: By default, OpenJ9 provides native cryptographic acceleration using OpenSSL version 1.1.x for the Digest, CBC, GCM, and RSA algorithms. Under certain circumstances acceleration of the Digest algorithm was found to cause a segmentation error. Cryptographic acceleration of the Digest algorithm is now turned off by default. The system property -Djdk.nativeDigest cannot be used to turn on support. This property is ignored by the VM.","title":"Version 0.12.1"},{"location":"version0.12/#full-release-information_1","text":"Release notes to describe the changes between Eclipse OpenJ9 version 0.12.0 and version 0.12.1 releases, can be found in the OpenJ9 GitHub repository .","title":"Full release information"},{"location":"version0.13/","text":"What's new in version 0.13.0 The following new features and notable changes since version 0.12.1 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New Java\u2122 process status tool Writing a Java dump to STDOUT or STDERR Better diagnostic information for Linux systems that implement control groups Improved support for pause-less garbage collection New JDK 12 features Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.13.0 supports OpenJDK 12, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 12 OpenJDK 12 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.12.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.13.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Support for OpenSSL 1.0.2 OpenSSL cryptographic support is extended to include OpenSSL 1.0.2 for the Digest, CBC, GCM, and RSA algorithms. Support is enabled by default. On Linux and AIX platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . In addition, support for the OpenSSL Digest algorithm is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path. New Java process status tool A Java process status tool ( jps ) is available for querying running Java processes. For more information, see Java process status . Writing a Java dump to STDOUT or STDERR You can now write a Java dump file to STDOUT or STDERR by using the -Xdump command-line option. See Writing to STDOUT / STDERR for details. Better diagnostic information for Linux systems that implement control groups If you use control groups (cgroups) to manage resources on Linux systems, information about CPU and memory limits is now recorded in a Java dump file. This information is particularly important for applications that run in Docker containers, because when resource limits are set inside a container, the Docker Engine relies on cgroups to enforce the settings. If you are getting a Java OutOfMemoryError error because a container limit has been set on the amount of memory available to an application and this allocation is not sufficient, you can diagnose this problem from the Java dump file. You can find the cgroup information in the ENVINFO section. For sample output, see Java dump (ENVINFO) . Improved support for pause-less garbage collection Concurrent scavenge mode is now supported on the following platforms: Linux on POWER LE AIX For more information, see the -Xgc:concurrentScavenge option. New JDK 12 features The following feature is supported by OpenJ9: JEP 334 : JVM Constants API The following feature is implemented in OpenJDK and available in any builds of OpenJDK 12 with OpenJ9: JEP 325 : Switch Expressions (Preview) You can find the full list of features for JDK 12 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.12.1 and version 0.13.0 releases, see the Release notes .","title":"Version 0.13.0"},{"location":"version0.13/#whats-new-in-version-0130","text":"The following new features and notable changes since version 0.12.1 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New Java\u2122 process status tool Writing a Java dump to STDOUT or STDERR Better diagnostic information for Linux systems that implement control groups Improved support for pause-less garbage collection New JDK 12 features","title":"What's new in version 0.13.0"},{"location":"version0.13/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.13/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.13.0 supports OpenJDK 12, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 12 OpenJDK 12 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.12.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.13.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.13/#support-for-openssl-102","text":"OpenSSL cryptographic support is extended to include OpenSSL 1.0.2 for the Digest, CBC, GCM, and RSA algorithms. Support is enabled by default. On Linux and AIX platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . In addition, support for the OpenSSL Digest algorithm is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path.","title":"Support for OpenSSL 1.0.2"},{"location":"version0.13/#new-java-process-status-tool","text":"A Java process status tool ( jps ) is available for querying running Java processes. For more information, see Java process status .","title":"New Java process status tool"},{"location":"version0.13/#writing-a-java-dump-to-stdout-or-stderr","text":"You can now write a Java dump file to STDOUT or STDERR by using the -Xdump command-line option. See Writing to STDOUT / STDERR for details.","title":"Writing a Java dump to STDOUT or STDERR"},{"location":"version0.13/#better-diagnostic-information-for-linux-systems-that-implement-control-groups","text":"If you use control groups (cgroups) to manage resources on Linux systems, information about CPU and memory limits is now recorded in a Java dump file. This information is particularly important for applications that run in Docker containers, because when resource limits are set inside a container, the Docker Engine relies on cgroups to enforce the settings. If you are getting a Java OutOfMemoryError error because a container limit has been set on the amount of memory available to an application and this allocation is not sufficient, you can diagnose this problem from the Java dump file. You can find the cgroup information in the ENVINFO section. For sample output, see Java dump (ENVINFO) .","title":"Better diagnostic information for Linux systems that implement control groups"},{"location":"version0.13/#improved-support-for-pause-less-garbage-collection","text":"Concurrent scavenge mode is now supported on the following platforms: Linux on POWER LE AIX For more information, see the -Xgc:concurrentScavenge option.","title":"Improved support for pause-less garbage collection"},{"location":"version0.13/#new-jdk-12-features","text":"The following feature is supported by OpenJ9: JEP 334 : JVM Constants API The following feature is implemented in OpenJDK and available in any builds of OpenJDK 12 with OpenJ9: JEP 325 : Switch Expressions (Preview) You can find the full list of features for JDK 12 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9.","title":"New JDK 12 features"},{"location":"version0.13/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.12.1 and version 0.13.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.14/","text":"What's new in version 0.14.x Version 0.14.0 The following new features and notable changes since version 0.13.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New option for ignoring or reporting unrecognized -XX: options Improved support for pause-less garbage collection New Java stack ( jstack ) tool for obtaining stack traces and thread information New Java process status ( jps ) tool New experimental option to improve the performance of JVMTI watched fields New option to prevent a network query being used to determine host name and IP address Changes to the shared classes cache generation number Change to the default native stack size on 64-bit z/OS\u00ae Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.14.0 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Support for OpenSSL 1.0.2 OpenJ9 release 0.13.0 introduced support for OpenSSL 1.0.2 for Java 12. In this release, support is extended to Java 8 and Java 11. OpenSSL is enabled by default for the CBC, Digest, GCM, and RSA cryptographic algorithms. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . Note: Support for the OpenSSL Digest algorithm on Java 8 and 11 is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path. New option for ignoring or reporting unrecognized -XX: options By default, unrecognized -XX: command-line options are ignored, which prevents an application failing to start. You can now use -XX:-IgnoreUnrecognizedXXColonOptions to turn off this behavior, so that unrecognized -XX: options are reported instead. For more information, see -XX:[+|-]IgnoreUnrecognizedXXColonOptions . Improved support for pause-less garbage collection Support for Concurrent scavenge mode is now extended to Linux on POWER\u00ae BE architectures. For more information, see -Xgc:concurrentScavenge . New jstack tool for obtaining stack traces and thread information For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jstack tool. To learn how to use the tool and about any differences compared to the HotSpot tool of the same name, see Java stack tool . New jps tool OpenJ9 release 0.13.0 introduced support for the jps tool for Java 12. In this release, support is added for Java 8 and 11. The jps tool can be used to query running Java processes. For more information, see Java process status . New experimental option to improve the performance of JVMTI watched fields The -XX:[+|-]JITInlineWatches option is introduced in this release. When enabled, the option turns on experimental JIT operations that are intended to improve the performance of JVMTI watched fields. This option is currently supported only on x86 platforms (Windows\u00ae, macOS\u00ae, and Linux). New option to prevent a network query being used to determine host name and IP address By default, a network query is used to determine the host name and IP address for troubleshooting purposes. To avoid your program waiting to time out if a nameserver cannot be contacted, you can now prevent the query from being performed. For more information, see -XX:[+|-]ReadIPInfoForRAS . Changes to the shared classes cache generation number On all platforms, the format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache, rather than re-creating or reusing an existing cache. To save space, all existing shared caches can be removed unless they are in use by an earlier release. For more information about destroying a shared classes cache, see -Xshareclasses . Change to the default native stack size on 64-bit z/OS The default stack size for operating system threads on 64-bit z/OS is changed from 384 KB to the operating system minimum of 1 MB. For more information about this setting, see -Xmso . Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.13.0 and version 0.14.0 releases, see the Release notes . Version 0.14.2 The following new features and notable changes since version 0.14.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.1 OpenSSL Digest algorithm disabled Features and changes Binaries and supported environments OpenJ9 release 0.14.2 supports OpenJDK 8 and 11. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 The Windows (MSI) installer for OpenJDK v8 (64-bit) can now be used to optionally install the IcedTea-Web package, which provides equivalent functionality to Java Web Start. For more information about the installer, see the AdoptOpenJDK Installation page . For more information about migrating to IcedTea-Web, read the AdoptOpenJDK Migration Guide . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Support for OpenSSL 1.0.1 OpenSSL version 1.0.1 support is now enabled; Earlier releases supported only OpenSSL 1.0.2 and 1.1.x. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . OpenSSL Digest algorithm disabled Due to issue #5611 , the Digest algorithm is disabled.","title":"Version 0.14.0"},{"location":"version0.14/#whats-new-in-version-014x","text":"","title":"What's new in version 0.14.x"},{"location":"version0.14/#version-0140","text":"The following new features and notable changes since version 0.13.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New option for ignoring or reporting unrecognized -XX: options Improved support for pause-less garbage collection New Java stack ( jstack ) tool for obtaining stack traces and thread information New Java process status ( jps ) tool New experimental option to improve the performance of JVMTI watched fields New option to prevent a network query being used to determine host name and IP address Changes to the shared classes cache generation number Change to the default native stack size on 64-bit z/OS\u00ae","title":"Version 0.14.0"},{"location":"version0.14/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.14/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.14.0 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.14/#support-for-openssl-102","text":"OpenJ9 release 0.13.0 introduced support for OpenSSL 1.0.2 for Java 12. In this release, support is extended to Java 8 and Java 11. OpenSSL is enabled by default for the CBC, Digest, GCM, and RSA cryptographic algorithms. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . Note: Support for the OpenSSL Digest algorithm on Java 8 and 11 is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path.","title":"Support for OpenSSL 1.0.2"},{"location":"version0.14/#new-option-for-ignoring-or-reporting-unrecognized-xx-options","text":"By default, unrecognized -XX: command-line options are ignored, which prevents an application failing to start. You can now use -XX:-IgnoreUnrecognizedXXColonOptions to turn off this behavior, so that unrecognized -XX: options are reported instead. For more information, see -XX:[+|-]IgnoreUnrecognizedXXColonOptions .","title":"New option for ignoring or reporting unrecognized -XX: options"},{"location":"version0.14/#improved-support-for-pause-less-garbage-collection","text":"Support for Concurrent scavenge mode is now extended to Linux on POWER\u00ae BE architectures. For more information, see -Xgc:concurrentScavenge .","title":"Improved support for pause-less garbage collection"},{"location":"version0.14/#new-jstack-tool-for-obtaining-stack-traces-and-thread-information","text":"For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jstack tool. To learn how to use the tool and about any differences compared to the HotSpot tool of the same name, see Java stack tool .","title":"New jstack tool for obtaining stack traces and thread information"},{"location":"version0.14/#new-jps-tool","text":"OpenJ9 release 0.13.0 introduced support for the jps tool for Java 12. In this release, support is added for Java 8 and 11. The jps tool can be used to query running Java processes. For more information, see Java process status .","title":"New jps tool"},{"location":"version0.14/#new-experimental-option-to-improve-the-performance-of-jvmti-watched-fields","text":"The -XX:[+|-]JITInlineWatches option is introduced in this release. When enabled, the option turns on experimental JIT operations that are intended to improve the performance of JVMTI watched fields. This option is currently supported only on x86 platforms (Windows\u00ae, macOS\u00ae, and Linux).","title":"New experimental option to improve the performance of JVMTI watched fields"},{"location":"version0.14/#new-option-to-prevent-a-network-query-being-used-to-determine-host-name-and-ip-address","text":"By default, a network query is used to determine the host name and IP address for troubleshooting purposes. To avoid your program waiting to time out if a nameserver cannot be contacted, you can now prevent the query from being performed. For more information, see -XX:[+|-]ReadIPInfoForRAS .","title":"New option to prevent a network query being used to determine host name and IP address"},{"location":"version0.14/#changes-to-the-shared-classes-cache-generation-number","text":"On all platforms, the format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache, rather than re-creating or reusing an existing cache. To save space, all existing shared caches can be removed unless they are in use by an earlier release. For more information about destroying a shared classes cache, see -Xshareclasses .","title":"Changes to the shared classes cache generation number"},{"location":"version0.14/#change-to-the-default-native-stack-size-on-64-bit-zos","text":"The default stack size for operating system threads on 64-bit z/OS is changed from 384 KB to the operating system minimum of 1 MB. For more information about this setting, see -Xmso .","title":"Change to the default native stack size on 64-bit z/OS"},{"location":"version0.14/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.13.0 and version 0.14.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.14/#version-0142","text":"The following new features and notable changes since version 0.14.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.1 OpenSSL Digest algorithm disabled","title":"Version 0.14.2"},{"location":"version0.14/#features-and-changes_1","text":"","title":"Features and changes"},{"location":"version0.14/#binaries-and-supported-environments_1","text":"OpenJ9 release 0.14.2 supports OpenJDK 8 and 11. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 The Windows (MSI) installer for OpenJDK v8 (64-bit) can now be used to optionally install the IcedTea-Web package, which provides equivalent functionality to Java Web Start. For more information about the installer, see the AdoptOpenJDK Installation page . For more information about migrating to IcedTea-Web, read the AdoptOpenJDK Migration Guide . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.14/#support-for-openssl-101","text":"OpenSSL version 1.0.1 support is now enabled; Earlier releases supported only OpenSSL 1.0.2 and 1.1.x. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations .","title":"Support for OpenSSL 1.0.1"},{"location":"version0.14/#openssl-digest-algorithm-disabled","text":"Due to issue #5611 , the Digest algorithm is disabled.","title":"OpenSSL Digest algorithm disabled"},{"location":"version0.15/","text":"What's new in version 0.15.1 The following new features and notable changes since version 0.14.0 are included in this release: New binaries and changes to supported environments Performance improvements for JVMTI watched fields Support for pause-less garbage collection on IBM Z systems ChaCha20 algorithm support for OpenSSL OpenSSL Digest algorithm disabled Support for OpenJDK HotSpot options Support for Transparent Huge Pages (THP) Support for low-overhead heap profiling (JEP 331) New Java memory map (jmap) tool Automatically setting an initial heap size Removal of -Xdiagnosticscollector option Change in behaviour of -XX:[+|-]IdleTuningCompactOnIdle Addition of heuristics for compaction during idle GC Change in shared classes behavior for checking timestamps of jar or zip files Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 0.15.0 and 0.15.1 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 Note: The binaries at AdoptOpenJDK are labeled 0.15.1 due to a missing change. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Performance improvements for JVMTI watched fields OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which, when enabled, turned on experimental JIT operations to improve the performance of JVMTI watched fields. Following successful results, this option is now enabled by default. This option is now also supported on z/OS\u00ae and Linux for IBM Z\u00ae, in addition to x86 platforms (Windows\u00ae, macOS\u00ae, and Linux). Support for pause-less garbage collection on IBM Z systems Support for Concurrent scavenge mode is now extended to Linux on IBM Z\u00ae systems and z/OS\u00ae. For more information, see -Xgc:concurrentScavenge . ChaCha20 algorithm support for OpenSSL The ChaCha20 and ChaCha20-Poly1305 algorithms can now use OpenSSL on Java 11. For more information, see -Djdk.nativeChaCha20 . OpenSSL Digest algorithm disabled Due to issue #5611 , the Digest algorithm is disabled. This algorithm was disabled for Java 8 and 11 in release 0.14.2, which did not support Java 12. Support for OpenJDK HotSpot options For compatibility, the -XX:OnOutOfMemoryError OpenJDK HotSpot option is now supported by OpenJ9. Support for Transparent Huge Pages (THP) The VM now supports the allocation of huge pages on Linux when you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting. To enable this feature, set -XX:+TransparentHugePage on the command line when you start your application. This option is currently not enabled by default. Support for low-overhead heap profiling JEP 331 provides a mechanism for sampling Java heap allocations with a low overhead via the JVM Tool Interface (JVMTI). Restrictions: JEP 331 is implemented for OpenJ9 with the following limitations: The balanced and metronome garbage collection policies are not supported. The JEP331 JVMTI agent and the Health Center agent both set a sampling interval, which by default is different. If both agents are used at the same time the Health Center agent will get incorrect results, unless the sampling intervals are adjusted to use the same value. New Java memory map tool The Java memory map (jmap) tool is similar to the HotSpot tool of the same name, and can be used to print statistics about classes on the heap, including the number of objects and their aggregate size. For usage information, see Java memory map (jmap) tool . Automatically setting an initial heap size OpenJ9 can now learn and set an appropriate initial heap size for an application as an alternative to a user manually sizing and setting an -Xms value. The VM records the size of the heap when startup processing ends, writing this data to the shared classes cache. An average value is set over a few restarts, helping to ensure that the value used for the initial heap size is as accurate as possible. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. To turn on this behavior, set the -XX:+UseGCStartupHints option on the command line when you start your application. Removal of -Xdiagnosticscollector option This option was redundant and has now been removed. If you try to use this option on the command line, the VM outputs this error message: JVMJ9VM007E Command-line option unrecognised: -Xdiagnosticscollector Change in behaviour of -XX:IdleTuningCompactOnIdle -XX:[+|-]IdleTuningCompactOnIdle is now no longer effective when -XX:+IdleTuningGcOnIdle is not specified. Heuristics for compaction during idle GC OpenJ9 now automatically compacts the heap when certain triggers are met during idle garbage collection (GC). As a result of this change, -XX:[+|-]IdleTuningCompactOnIdle is deprecated. Change in shared classes behavior for checking timestamps of jar or zip files In earlier releases, the shared classes cache checks timestamps of jar or zip files every time a class is loaded and reloads a class if the timestamp has changed. This behavior is now changed; timestamps are checked only when zip or jar files are added to class loaders and used for the first time to look for a class, which can improve class-loading performance. If jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. To revert to the behavior of earlier releases, set the -Xshareclasses:checkURLTimestamps option on the command line when you start your application. Note: Multiple -Xshareclasses: options are not combined, only the last one is used. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.14.0 and version 0.15.1 releases, see the Release notes .","title":"Version 0.15.1"},{"location":"version0.15/#whats-new-in-version-0151","text":"The following new features and notable changes since version 0.14.0 are included in this release: New binaries and changes to supported environments Performance improvements for JVMTI watched fields Support for pause-less garbage collection on IBM Z systems ChaCha20 algorithm support for OpenSSL OpenSSL Digest algorithm disabled Support for OpenJDK HotSpot options Support for Transparent Huge Pages (THP) Support for low-overhead heap profiling (JEP 331) New Java memory map (jmap) tool Automatically setting an initial heap size Removal of -Xdiagnosticscollector option Change in behaviour of -XX:[+|-]IdleTuningCompactOnIdle Addition of heuristics for compaction during idle GC Change in shared classes behavior for checking timestamps of jar or zip files","title":"What's new in version 0.15.1"},{"location":"version0.15/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.15/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 0.15.0 and 0.15.1 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 Note: The binaries at AdoptOpenJDK are labeled 0.15.1 due to a missing change. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.15/#performance-improvements-for-jvmti-watched-fields","text":"OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which, when enabled, turned on experimental JIT operations to improve the performance of JVMTI watched fields. Following successful results, this option is now enabled by default. This option is now also supported on z/OS\u00ae and Linux for IBM Z\u00ae, in addition to x86 platforms (Windows\u00ae, macOS\u00ae, and Linux).","title":"Performance improvements for JVMTI watched fields"},{"location":"version0.15/#support-for-pause-less-garbage-collection-on-ibm-z-systems","text":"Support for Concurrent scavenge mode is now extended to Linux on IBM Z\u00ae systems and z/OS\u00ae. For more information, see -Xgc:concurrentScavenge .","title":"Support for pause-less garbage collection on IBM Z systems"},{"location":"version0.15/#chacha20-algorithm-support-for-openssl","text":"The ChaCha20 and ChaCha20-Poly1305 algorithms can now use OpenSSL on Java 11. For more information, see -Djdk.nativeChaCha20 .","title":"ChaCha20 algorithm support for OpenSSL"},{"location":"version0.15/#openssl-digest-algorithm-disabled","text":"Due to issue #5611 , the Digest algorithm is disabled. This algorithm was disabled for Java 8 and 11 in release 0.14.2, which did not support Java 12.","title":"OpenSSL Digest algorithm disabled"},{"location":"version0.15/#support-for-openjdk-hotspot-options","text":"For compatibility, the -XX:OnOutOfMemoryError OpenJDK HotSpot option is now supported by OpenJ9.","title":"Support for OpenJDK HotSpot options"},{"location":"version0.15/#support-for-transparent-huge-pages-thp","text":"The VM now supports the allocation of huge pages on Linux when you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting. To enable this feature, set -XX:+TransparentHugePage on the command line when you start your application. This option is currently not enabled by default.","title":"Support for Transparent Huge Pages (THP)"},{"location":"version0.15/#support-for-low-overhead-heap-profiling","text":"JEP 331 provides a mechanism for sampling Java heap allocations with a low overhead via the JVM Tool Interface (JVMTI). Restrictions: JEP 331 is implemented for OpenJ9 with the following limitations: The balanced and metronome garbage collection policies are not supported. The JEP331 JVMTI agent and the Health Center agent both set a sampling interval, which by default is different. If both agents are used at the same time the Health Center agent will get incorrect results, unless the sampling intervals are adjusted to use the same value.","title":"Support for low-overhead heap profiling"},{"location":"version0.15/#new-java-memory-map-tool","text":"The Java memory map (jmap) tool is similar to the HotSpot tool of the same name, and can be used to print statistics about classes on the heap, including the number of objects and their aggregate size. For usage information, see Java memory map (jmap) tool .","title":"New Java memory map tool"},{"location":"version0.15/#automatically-setting-an-initial-heap-size","text":"OpenJ9 can now learn and set an appropriate initial heap size for an application as an alternative to a user manually sizing and setting an -Xms value. The VM records the size of the heap when startup processing ends, writing this data to the shared classes cache. An average value is set over a few restarts, helping to ensure that the value used for the initial heap size is as accurate as possible. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. To turn on this behavior, set the -XX:+UseGCStartupHints option on the command line when you start your application.","title":"Automatically setting an initial heap size"},{"location":"version0.15/#removal-of-xdiagnosticscollector-option","text":"This option was redundant and has now been removed. If you try to use this option on the command line, the VM outputs this error message: JVMJ9VM007E Command-line option unrecognised: -Xdiagnosticscollector","title":"Removal of -Xdiagnosticscollector option"},{"location":"version0.15/#change-in-behaviour-of-xxidletuningcompactonidle","text":"-XX:[+|-]IdleTuningCompactOnIdle is now no longer effective when -XX:+IdleTuningGcOnIdle is not specified.","title":"Change in behaviour of -XX:IdleTuningCompactOnIdle"},{"location":"version0.15/#heuristics-for-compaction-during-idle-gc","text":"OpenJ9 now automatically compacts the heap when certain triggers are met during idle garbage collection (GC). As a result of this change, -XX:[+|-]IdleTuningCompactOnIdle is deprecated.","title":"Heuristics for compaction during idle GC"},{"location":"version0.15/#change-in-shared-classes-behavior-for-checking-timestamps-of-jar-or-zip-files","text":"In earlier releases, the shared classes cache checks timestamps of jar or zip files every time a class is loaded and reloads a class if the timestamp has changed. This behavior is now changed; timestamps are checked only when zip or jar files are added to class loaders and used for the first time to look for a class, which can improve class-loading performance. If jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. To revert to the behavior of earlier releases, set the -Xshareclasses:checkURLTimestamps option on the command line when you start your application. Note: Multiple -Xshareclasses: options are not combined, only the last one is used.","title":"Change in shared classes behavior for checking timestamps of jar or zip files"},{"location":"version0.15/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.14.0 and version 0.15.1 releases, see the Release notes .","title":"Full release information"},{"location":"version0.16/","text":"What's new in version 0.16.0 The following new features and notable changes since version 0.15.1 are included in this release: New binaries and changes to supported environments Some class data sharing is enabled by default Automatic setting of initial heap size is enabled by default Option to share VM anonymous classes Performance improvements for JVMTI watched fields on Power Systems Linux on x86: Support for Transparent Huge Pages (THP) New Java\u2122 diagnostic command ( jcmd ) tool Changes to the shared classes cache generation number The -Xverify:none and -noverify options are deprecated New JDK 13 features Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.16.0 supports OpenJDK 13, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 13 OpenJDK 13 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.15.2. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.16.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Some class data sharing is enabled by default Class data sharing is enabled by default for bootstrap classes, unless your application is running in a container. You can use the -Xshareclasses option to change the default behavior, including using -Xshareclasses:none to disable all class data sharing. For more information, see Introduction to class data sharing . Automatic setting of initial heap size is enabled by default OpenJ9 version 0.15.1 introduced the -XX:[+|-]UseGCStartupHints option, which, when enabled, turned on the automatic learning and setting of an appropriate heap size for an application. This option is now enabled by default. Option to share VM anonymous classes Prior to version 0.16.0, anonymous classes, those created by Unsafe.defineAnonymousClass , were not stored in the shared classes cache. They are now stored there by default, which means they are available for ahead-of-time (AOT) compilation, potentially improving startup performance. A new command, -XX:[+|-]ShareAnonymousClasses , is introduced that enables you to stop anonymous classes being stored in the shared classes cache. Performance improvements for JVMTI watched fields on Power Systems OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which turns on JIT operations to improve the performance of JVMTI watched fields. This option, which was enabled by default in version 0.15.1, is now also supported on AIX\u00ae and Linux on Power Systems\u2122. Linux\u00ae on x86: Support for Transparent Huge Pages (THP) When you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting on Linux on x86 systems, THP is now enabled by default. To disable this feature, set -XX:-TransparentHugePage on the command line when you start your application. The THP setting on other systems remains disabled by default when you use madvise , but can be enabled by setting -XX:+TransparentHugePage . New jcmd tool For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jcmd tool for running diagnostic commands on a VM. For more information, see Java diagnostic command tool . Changes to the shared classes cache generation number The format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache rather than re-creating or reusing an existing cache. To save space, you can remove all existing shared caches unless they are in use by an earlier release. As a result of the format change, a layer column now appears in the output of the -Xshareclasses:listAllCaches option. This change is to support a future enhancement. For more information about the -Xshareclasses option, including the destroy options that you can use to remove caches, see -Xshareclasses . The -Xverify:none and -noverify options are deprecated The option -Xverify:none (and its equivalent -noverify ) is deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions. New JDK 13 features The following features are implemented in OpenJDK and available in any builds of OpenJDK 13 with OpenJ9: JEP 353 : Reimplement the Legacy Socket API JEP 354 : Switch Expressions (Preview) JEP 355 : Text Blocks (Preview) You can find the full list of features for JDK 13 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.15.1 and version 0.16.0 releases, see the Release notes .","title":"Version 0.16.0"},{"location":"version0.16/#whats-new-in-version-0160","text":"The following new features and notable changes since version 0.15.1 are included in this release: New binaries and changes to supported environments Some class data sharing is enabled by default Automatic setting of initial heap size is enabled by default Option to share VM anonymous classes Performance improvements for JVMTI watched fields on Power Systems Linux on x86: Support for Transparent Huge Pages (THP) New Java\u2122 diagnostic command ( jcmd ) tool Changes to the shared classes cache generation number The -Xverify:none and -noverify options are deprecated New JDK 13 features","title":"What's new in version 0.16.0"},{"location":"version0.16/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.16/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.16.0 supports OpenJDK 13, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 13 OpenJDK 13 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.15.2. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.16.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.16/#some-class-data-sharing-is-enabled-by-default","text":"Class data sharing is enabled by default for bootstrap classes, unless your application is running in a container. You can use the -Xshareclasses option to change the default behavior, including using -Xshareclasses:none to disable all class data sharing. For more information, see Introduction to class data sharing .","title":"Some class data sharing is enabled by default"},{"location":"version0.16/#automatic-setting-of-initial-heap-size-is-enabled-by-default","text":"OpenJ9 version 0.15.1 introduced the -XX:[+|-]UseGCStartupHints option, which, when enabled, turned on the automatic learning and setting of an appropriate heap size for an application. This option is now enabled by default.","title":"Automatic setting of initial heap size is enabled by default"},{"location":"version0.16/#option-to-share-vm-anonymous-classes","text":"Prior to version 0.16.0, anonymous classes, those created by Unsafe.defineAnonymousClass , were not stored in the shared classes cache. They are now stored there by default, which means they are available for ahead-of-time (AOT) compilation, potentially improving startup performance. A new command, -XX:[+|-]ShareAnonymousClasses , is introduced that enables you to stop anonymous classes being stored in the shared classes cache.","title":"Option to share VM anonymous classes"},{"location":"version0.16/#performance-improvements-for-jvmti-watched-fields-on-power-systems","text":"OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which turns on JIT operations to improve the performance of JVMTI watched fields. This option, which was enabled by default in version 0.15.1, is now also supported on AIX\u00ae and Linux on Power Systems\u2122.","title":"Performance improvements for JVMTI watched fields on Power Systems"},{"location":"version0.16/#linux-on-x86-support-for-transparent-huge-pages-thp","text":"When you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting on Linux on x86 systems, THP is now enabled by default. To disable this feature, set -XX:-TransparentHugePage on the command line when you start your application. The THP setting on other systems remains disabled by default when you use madvise , but can be enabled by setting -XX:+TransparentHugePage .","title":"Linux&reg; on x86: Support for Transparent Huge Pages (THP)"},{"location":"version0.16/#new-jcmd-tool","text":"For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jcmd tool for running diagnostic commands on a VM. For more information, see Java diagnostic command tool .","title":"New jcmd tool"},{"location":"version0.16/#changes-to-the-shared-classes-cache-generation-number","text":"The format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache rather than re-creating or reusing an existing cache. To save space, you can remove all existing shared caches unless they are in use by an earlier release. As a result of the format change, a layer column now appears in the output of the -Xshareclasses:listAllCaches option. This change is to support a future enhancement. For more information about the -Xshareclasses option, including the destroy options that you can use to remove caches, see -Xshareclasses .","title":"Changes to the shared classes cache generation number"},{"location":"version0.16/#the-xverifynone-and-noverify-options-are-deprecated","text":"The option -Xverify:none (and its equivalent -noverify ) is deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions.","title":"The -Xverify:none and -noverify options are deprecated"},{"location":"version0.16/#new-jdk-13-features","text":"The following features are implemented in OpenJDK and available in any builds of OpenJDK 13 with OpenJ9: JEP 353 : Reimplement the Legacy Socket API JEP 354 : Switch Expressions (Preview) JEP 355 : Text Blocks (Preview) You can find the full list of features for JDK 13 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9.","title":"New JDK 13 features"},{"location":"version0.16/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.15.1 and version 0.16.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.17/","text":"What's new in version 0.17.0 The following new features and notable changes since version 0.16.0 are included in this release: New binaries and changes to supported environments New shared classes cache suboptions for layered caches New shared classes cache suboption to skip disk space check Option to share 'Unsafe' classes Option to record class relationships in the verifier Support for the IBM z15\u00ae processor Digest algorithm is re-enabled Direct Dump Reader (DDR) VM restriction removed The format of the HOOKS section of a Java dump has changed LUDCL caching disabled by default Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.17.0 supports OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: The Windows\u00ae and macOS\u00ae binaries from the AdoptOpenJDK community for OpenJDK 8, 11, and 13 have been updated to OpenSSL v1.1.1d. Look for the following release names to identify these packages: OpenJDK 8: jdk8u232-b09.1_openj9-0.17.0 OpenJDK 11: jdk-11.0.5+10.1_openj9-0.17.0 OpenjDK 13: jdk-13.0.1+9.1_openj9-0.17.0) Note: The last release of OpenJDK 8 and 11 from AdoptOpenJDK is Eclipse OpenJ9 0.15.1. To read about other features and changes in the VM since 0.15.1, check the Version 0.16.0 release notes too. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . New shared classes cache suboptions for layered caches (Experimental, 64-bit only) New suboptions are available for creating layered caches, where a cache builds on another cache with the same name. You can use these suboptions to save space when building a Docker container, for example. Note: Because these suboptions are experimental, do not use them in a production environment. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers New shared classes cache suboption to skip disk space check When creating a persistent shared classes cache, the OpenJ9 VM checks that there is sufficient disk space available on the file system. For file systems that do not support the checking of free space, you can set the -Xshareclasses:noPersistentDiskSpaceCheck option, which causes the VM to skip the space checking operation. If there isn't enough disk space available when the cache is written, a SIGBUS or SIGSEGV signal occurs and the VM ends. For more information, see the -Xshareclasses:noPersistentDiskSpaceCheck option. Option to share 'Unsafe' classes Classes created through Unsafe.defineClass are now stored by default in the shared classes cache. You can use the -XX:-ShareUnsafeClasses option to change the default behavior. For more information, see -XX:[+|-]ShareUnsafeClasses . Option to record class relationships in the verifier A new command line option -XX:+ClassRelationshipVerifier allows you to record class relationships in the verifier, which avoids unnecessary class loading and reduces VM startup time. This is a new approach to bytecode verification that delays validating the relationships between classes until the classes are required to be loaded for a program's execution thus loading only those classes that are needed. For more information, see -XX:[+|-]ClassRelationshipVerifier . Support for the IBM z15 processor This release adds JIT compiler support for exploiting z15 instructions. Digest algorithm is re-enabled Issue #5611 is fixed, so support for the Digest algorithm is re-enabled. For more information about this support, see Cryptographic operations . Direct Dump Reader (DDR) VM restriction removed Prior to this version, you had to use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core when using DDR. This restriction has now been removed. The format of the HOOKS section of a Java dump has changed The format of the HOOKS section of a Java dump, which shows internal VM event callbacks, has changed: Recorded times have been changed from milliseconds to microseconds to provide increased precision. A new field, 3HKTOTALTIME , is included, which gives the total duration of previous events. The hook data is now reset after each Java dump. For more information and an example of the new format, see Java dump: HOOKS LUDCL caching disabled by default By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now disabled by default due to issue #7332 . Note: Versions of the documentation before 0.17.0 incorrectly identified this property as disabled by default when it was actually enabled by default in the VM. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.16 and version 0.17.0 releases, see the Release notes .","title":"Version 0.17.0"},{"location":"version0.17/#whats-new-in-version-0170","text":"The following new features and notable changes since version 0.16.0 are included in this release: New binaries and changes to supported environments New shared classes cache suboptions for layered caches New shared classes cache suboption to skip disk space check Option to share 'Unsafe' classes Option to record class relationships in the verifier Support for the IBM z15\u00ae processor Digest algorithm is re-enabled Direct Dump Reader (DDR) VM restriction removed The format of the HOOKS section of a Java dump has changed LUDCL caching disabled by default","title":"What's new in version 0.17.0"},{"location":"version0.17/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.17/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.17.0 supports OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: The Windows\u00ae and macOS\u00ae binaries from the AdoptOpenJDK community for OpenJDK 8, 11, and 13 have been updated to OpenSSL v1.1.1d. Look for the following release names to identify these packages: OpenJDK 8: jdk8u232-b09.1_openj9-0.17.0 OpenJDK 11: jdk-11.0.5+10.1_openj9-0.17.0 OpenjDK 13: jdk-13.0.1+9.1_openj9-0.17.0) Note: The last release of OpenJDK 8 and 11 from AdoptOpenJDK is Eclipse OpenJ9 0.15.1. To read about other features and changes in the VM since 0.15.1, check the Version 0.16.0 release notes too. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.17/#new-shared-classes-cache-suboptions-for-layered-caches","text":"(Experimental, 64-bit only) New suboptions are available for creating layered caches, where a cache builds on another cache with the same name. You can use these suboptions to save space when building a Docker container, for example. Note: Because these suboptions are experimental, do not use them in a production environment. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers","title":"New shared classes cache suboptions for layered caches"},{"location":"version0.17/#new-shared-classes-cache-suboption-to-skip-disk-space-check","text":"When creating a persistent shared classes cache, the OpenJ9 VM checks that there is sufficient disk space available on the file system. For file systems that do not support the checking of free space, you can set the -Xshareclasses:noPersistentDiskSpaceCheck option, which causes the VM to skip the space checking operation. If there isn't enough disk space available when the cache is written, a SIGBUS or SIGSEGV signal occurs and the VM ends. For more information, see the -Xshareclasses:noPersistentDiskSpaceCheck option.","title":"New shared classes cache suboption to skip disk space check"},{"location":"version0.17/#option-to-share-unsafe-classes","text":"Classes created through Unsafe.defineClass are now stored by default in the shared classes cache. You can use the -XX:-ShareUnsafeClasses option to change the default behavior. For more information, see -XX:[+|-]ShareUnsafeClasses .","title":"Option to share 'Unsafe' classes"},{"location":"version0.17/#option-to-record-class-relationships-in-the-verifier","text":"A new command line option -XX:+ClassRelationshipVerifier allows you to record class relationships in the verifier, which avoids unnecessary class loading and reduces VM startup time. This is a new approach to bytecode verification that delays validating the relationships between classes until the classes are required to be loaded for a program's execution thus loading only those classes that are needed. For more information, see -XX:[+|-]ClassRelationshipVerifier .","title":"Option to record class relationships in the verifier"},{"location":"version0.17/#support-for-the-ibm-z15-processor","text":"This release adds JIT compiler support for exploiting z15 instructions.","title":"Support for the IBM z15 processor"},{"location":"version0.17/#digest-algorithm-is-re-enabled","text":"Issue #5611 is fixed, so support for the Digest algorithm is re-enabled. For more information about this support, see Cryptographic operations .","title":"Digest algorithm is re-enabled"},{"location":"version0.17/#direct-dump-reader-ddr-vm-restriction-removed","text":"Prior to this version, you had to use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core when using DDR. This restriction has now been removed.","title":"Direct Dump Reader (DDR) VM restriction removed"},{"location":"version0.17/#the-format-of-the-hooks-section-of-a-java-dump-has-changed","text":"The format of the HOOKS section of a Java dump, which shows internal VM event callbacks, has changed: Recorded times have been changed from milliseconds to microseconds to provide increased precision. A new field, 3HKTOTALTIME , is included, which gives the total duration of previous events. The hook data is now reset after each Java dump. For more information and an example of the new format, see Java dump: HOOKS","title":"The format of the HOOKS section of a Java dump has changed"},{"location":"version0.17/#ludcl-caching-disabled-by-default","text":"By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now disabled by default due to issue #7332 . Note: Versions of the documentation before 0.17.0 incorrectly identified this property as disabled by default when it was actually enabled by default in the VM.","title":"LUDCL caching disabled by default"},{"location":"version0.17/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.16 and version 0.17.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.18/","text":"What's new in version 0.18.1 The following new features and notable changes since version 0.17.0 are included in this release: Binaries and supported environments Technical preview of JITServer technology jextract now available on macOS\u00ae for OpenJDK version 8 New shared-classes cache suboption to turn off timestamp checking Removal of restriction on layered shared cache -Xmso 1 MB minimum value on z/OS\u00ae 64-bit jstat : new Java\u2122 statistics monitoring tool -XX:+TransparentHugePage is enabled by default on more Linux\u00ae systems New exit dump agent and ExitOnOutOfMemoryError option LUDCL caching enabled by default Terabytes suffix support for -X and -XX options that take a size Improved support for pause-less garbage collection -Xgc:noConcurrentScavenge option Support for OpenJDK HotSpot options Shared classes cache suboptions for layered caches no longer experimental -Djava.lang.string.substring.nocopy option Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 releases 0.18.0 and 0.18.1 support OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: Binaries at AdoptOpenJDK that are labeled 0.18.1 include additional bug fixes. For more information, see the release notes . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Technical preview of JITServer technology A technical preview of JITServer technology is included in this release. It's currently available for OpenJDK 8 and OpenJDK 11 running on Linux on x86-64. JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and even performance of Java applications. For more information, see JITServer technology . jextract now available on macOS for OpenJDK version 8 The jextract tool is now available on macOS platforms (as well as AIX\u00ae and Linux) for all current versions of OpenJDK: 8, 11, and 13. New shared-classes cache suboption to turn off timestamp checking You can set the -Xshareclasses:noTimestampChecks option to turn off timestamp checking in shared classes. For more information, see the -Xshareclasses:noTimestampChecks option. Removal of restriction on layered shared cache In the previous release, there is a restriction that the jvmtiSharedCacheInfo.isCorrupt field and the SharedClassCacheInfo.isCacheCorrupt() method cannot detect a corrupted cache that has a layer number other than 0 . This restriction is now removed. See the Shared classes API documentation . -Xmso 1 MB minimum value on z/OS 64-bit On z/OS 64-bit, -Xmso has a 1 MB minimum value, to match the minimum stack space provided by the operating system. If you set a value smaller than 1 MB, the value is ignored. jstat : new Java statistics monitoring tool For compatibility with the HotSpot implementation, OpenJ9 now includes an independent implementation of the jstat tool for retrieving statistics on a VM. For more information, see Java statistics monitoring tool . -XX:+TransparentHugePage is enabled by default on more Linux systems -XX:+TransparentHugePage is enabled by default on Linux systems for POWER\u00ae and IBM Z\u00ae as well as x86 systems. This option takes affect only when Transparent Huge Pages (THP) is set to madvise on your system. When Transparent Huge Pages are used, your application footprint might increase. New exit dump agent and ExitOnOutOfMemoryError option The new exit dump agent shuts down the VM when the specified event occurs. The exit agent is at priority level 0 and the tool agent has been moved to priority level 1 to aid in mimicking the behavior of HotSpot options. For more information about dump agents, see -Xdump . OpenJ9 now supports the HotSpot option -XX:[+|-]ExitOnOutOfMemoryError . You can set this option to have the VM shut down when a java.lang.OutOfMemory error is thrown by the VM or in Java code. The exit dump agent is used in the implementation of -XX:[+|-]ExitOnOutOfMemoryError . LUDCL caching enabled by default By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now enabled by default. This feature was disabled for the 0.17.0 release due to issue #7332 which has now been resolved. Terabytes suffix support for -X and -XX options that take a size OpenJ9 now supports 't' and 'T' suffixes (indicating terabytes) for -X and -XX options that take a <size> parameter. Improved support for pause-less garbage collection Support for Concurrent scavenge mode is now extended to macOS. For more information, see -Xgc:concurrentScavenge . -Xgc:noConcurrentScavenge option The previously undocumented option -Xgc:noConcurrentScavenge disables pause-less garbage collection. Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:ParallelGCThreads -XX:ConcGCThreads -XX:ParallelCMSThreads Shared classes cache suboptions for layered caches no longer experimental The suboptions for creating layered caches are no longer marked experimental. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers -Djava.lang.string.substring.nocopy option The previously undocumented Java 8 option -Djava.lang.string.substring.nocopy=true avoids String sharing by String.substring(), which is the same behavior as the Oracle HotSpot VM. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.17.0 and version 0.18.0 releases, see the Release notes .","title":"Version 0.18.1"},{"location":"version0.18/#whats-new-in-version-0181","text":"The following new features and notable changes since version 0.17.0 are included in this release: Binaries and supported environments Technical preview of JITServer technology jextract now available on macOS\u00ae for OpenJDK version 8 New shared-classes cache suboption to turn off timestamp checking Removal of restriction on layered shared cache -Xmso 1 MB minimum value on z/OS\u00ae 64-bit jstat : new Java\u2122 statistics monitoring tool -XX:+TransparentHugePage is enabled by default on more Linux\u00ae systems New exit dump agent and ExitOnOutOfMemoryError option LUDCL caching enabled by default Terabytes suffix support for -X and -XX options that take a size Improved support for pause-less garbage collection -Xgc:noConcurrentScavenge option Support for OpenJDK HotSpot options Shared classes cache suboptions for layered caches no longer experimental -Djava.lang.string.substring.nocopy option","title":"What's new in version 0.18.1"},{"location":"version0.18/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.18/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 releases 0.18.0 and 0.18.1 support OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: Binaries at AdoptOpenJDK that are labeled 0.18.1 include additional bug fixes. For more information, see the release notes . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.18/#technical-preview-of-jitserver-technology","text":"A technical preview of JITServer technology is included in this release. It's currently available for OpenJDK 8 and OpenJDK 11 running on Linux on x86-64. JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and even performance of Java applications. For more information, see JITServer technology .","title":"Technical preview of JITServer technology"},{"location":"version0.18/#jextract-now-available-on-macos-for-openjdk-version-8","text":"The jextract tool is now available on macOS platforms (as well as AIX\u00ae and Linux) for all current versions of OpenJDK: 8, 11, and 13.","title":"jextract now available on macOS for OpenJDK version 8"},{"location":"version0.18/#new-shared-classes-cache-suboption-to-turn-off-timestamp-checking","text":"You can set the -Xshareclasses:noTimestampChecks option to turn off timestamp checking in shared classes. For more information, see the -Xshareclasses:noTimestampChecks option.","title":"New shared-classes cache suboption to turn off timestamp checking"},{"location":"version0.18/#removal-of-restriction-on-layered-shared-cache","text":"In the previous release, there is a restriction that the jvmtiSharedCacheInfo.isCorrupt field and the SharedClassCacheInfo.isCacheCorrupt() method cannot detect a corrupted cache that has a layer number other than 0 . This restriction is now removed. See the Shared classes API documentation .","title":"Removal of restriction on layered shared cache"},{"location":"version0.18/#-xmso-1-mb-minimum-value-on-zos-64-bit","text":"On z/OS 64-bit, -Xmso has a 1 MB minimum value, to match the minimum stack space provided by the operating system. If you set a value smaller than 1 MB, the value is ignored.","title":"-Xmso 1 MB minimum value on z/OS 64-bit"},{"location":"version0.18/#jstat-new-java-statistics-monitoring-tool","text":"For compatibility with the HotSpot implementation, OpenJ9 now includes an independent implementation of the jstat tool for retrieving statistics on a VM. For more information, see Java statistics monitoring tool .","title":"jstat: new Java statistics monitoring tool"},{"location":"version0.18/#-xxtransparenthugepage-is-enabled-by-default-on-more-linux-systems","text":"-XX:+TransparentHugePage is enabled by default on Linux systems for POWER\u00ae and IBM Z\u00ae as well as x86 systems. This option takes affect only when Transparent Huge Pages (THP) is set to madvise on your system. When Transparent Huge Pages are used, your application footprint might increase.","title":"-XX:+TransparentHugePage is enabled by default on more Linux systems"},{"location":"version0.18/#new-exit-dump-agent-and-exitonoutofmemoryerror-option","text":"The new exit dump agent shuts down the VM when the specified event occurs. The exit agent is at priority level 0 and the tool agent has been moved to priority level 1 to aid in mimicking the behavior of HotSpot options. For more information about dump agents, see -Xdump . OpenJ9 now supports the HotSpot option -XX:[+|-]ExitOnOutOfMemoryError . You can set this option to have the VM shut down when a java.lang.OutOfMemory error is thrown by the VM or in Java code. The exit dump agent is used in the implementation of -XX:[+|-]ExitOnOutOfMemoryError .","title":"New exit dump agent and ExitOnOutOfMemoryError option"},{"location":"version0.18/#ludcl-caching-enabled-by-default","text":"By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now enabled by default. This feature was disabled for the 0.17.0 release due to issue #7332 which has now been resolved.","title":"LUDCL caching enabled by default"},{"location":"version0.18/#terabytes-suffix-support-for-x-and-xx-options-that-take-a-size","text":"OpenJ9 now supports 't' and 'T' suffixes (indicating terabytes) for -X and -XX options that take a <size> parameter.","title":"Terabytes suffix support for -X and -XX options that take a size"},{"location":"version0.18/#improved-support-for-pause-less-garbage-collection","text":"Support for Concurrent scavenge mode is now extended to macOS. For more information, see -Xgc:concurrentScavenge .","title":"Improved support for pause-less garbage collection"},{"location":"version0.18/#-xgcnoconcurrentscavenge-option","text":"The previously undocumented option -Xgc:noConcurrentScavenge disables pause-less garbage collection.","title":"-Xgc:noConcurrentScavenge option"},{"location":"version0.18/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:ParallelGCThreads -XX:ConcGCThreads -XX:ParallelCMSThreads","title":"Support for OpenJDK HotSpot options"},{"location":"version0.18/#shared-classes-cache-suboptions-for-layered-caches-no-longer-experimental","text":"The suboptions for creating layered caches are no longer marked experimental. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers","title":"Shared classes cache suboptions for layered caches no longer experimental"},{"location":"version0.18/#-djavalangstringsubstringnocopy-option","text":"The previously undocumented Java 8 option -Djava.lang.string.substring.nocopy=true avoids String sharing by String.substring(), which is the same behavior as the Oracle HotSpot VM.","title":"-Djava.lang.string.substring.nocopy option"},{"location":"version0.18/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.17.0 and version 0.18.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.19/","text":"What's new in version 0.19.0 The following new features and notable changes since version 0.18.0 are included in this release: New binaries and changes to supported environments Option to print code cache usage to stderr at VM shutdown StringBuffer and StringBuilder above 1 G grow to the maximum size jpackage packaging tool platform support Extended messages for NullPointerException not yet implemented Compiler changes for Linux New JDK 14 features Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.19.0 supports OpenJDK 14, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 14 OpenJDK 14 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.18.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.19.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Option to print code cache usage to stderr at VM shutdown A new command line option -XX:+PrintCodeCache allows you to print the code cache memory usage to stderr when the VM shuts down. StringBuffer and StringBuilder above 1 G grow to the maximum size A 1 G char[] or larger StringBuffer and StringBuilder now immediately grows to the maximum possible size for all current versions of Java, including Java 8. For Java 8 only, you can revert to the previous behavior of growing only as much as necessary to accommodate the String being added, by using the option, -Djava.lang.stringBuffer.growAggressively=false . jpackage packaging tool platform support The jpackage utility is described in JEP 343 as a tool that \"packages a Java application into a platform-specific package that includes all of the necessary dependencies.\" Full details of the tool are available at JEP 343: Packaging Tool . Be aware that jpackage is supported on only the following OpenJ9 platforms: Linux\u00ae, macOS\u00ae, and Windows\u2122. It is not supported on AIX\u00ae or z/OS\u00ae platforms. Extended messages for NullPointerException not yet implemented JEP 358: Helpful NullPointerExceptions provides extended messages when a NullPointerException is generated by the Java 14 VM and you have enabled the feature. However, be aware that this is not implemented in OpenJ9 at this time. Compiler changes for Linux Linux x86 64-bit, Linux on POWER\u00ae LE 64-bit, and Linux on IBM Z\u00ae 64-bit have all moved to the gcc 7.5 compiler. See Supported environments . New JDK 14 features The following features are supported by OpenJ9: JEP 343 : Packaging Tool (Incubator) Restrictions: jpackage is supported on only the following OpenJ9 platforms: Linux\u00ae, macOS\u00ae, and Windows\u2122. It is not supported on AIX\u00ae or z/OS\u00ae platforms. JEP 352 : Non-Volatile Mapped Byte Buffers JEP 358 : Helpful NullPointerExceptions JEP 359 : Records (Preview) The following features are implemented in OpenJDK and available in any builds of OpenJDK 14 with OpenJ9: JEP 305 : Pattern Matching for instanceof (Preview) JEP 361 : Switch Expressions (Standard) JEP 367 : Remove the Pack200 Tools and API JEP 368 : Text Blocks (Second Preview) You can find the full list of features for JDK 14 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.18.0 and version 0.19.0 releases, see the Release notes .","title":"Version 0.19.0"},{"location":"version0.19/#whats-new-in-version-0190","text":"The following new features and notable changes since version 0.18.0 are included in this release: New binaries and changes to supported environments Option to print code cache usage to stderr at VM shutdown StringBuffer and StringBuilder above 1 G grow to the maximum size jpackage packaging tool platform support Extended messages for NullPointerException not yet implemented Compiler changes for Linux New JDK 14 features","title":"What's new in version 0.19.0"},{"location":"version0.19/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.19/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.19.0 supports OpenJDK 14, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 14 OpenJDK 14 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.18.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.19.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.19/#option-to-print-code-cache-usage-to-stderr-at-vm-shutdown","text":"A new command line option -XX:+PrintCodeCache allows you to print the code cache memory usage to stderr when the VM shuts down.","title":"Option to print code cache usage to stderr at VM shutdown"},{"location":"version0.19/#stringbuffer-and-stringbuilder-above-1-g-grow-to-the-maximum-size","text":"A 1 G char[] or larger StringBuffer and StringBuilder now immediately grows to the maximum possible size for all current versions of Java, including Java 8. For Java 8 only, you can revert to the previous behavior of growing only as much as necessary to accommodate the String being added, by using the option, -Djava.lang.stringBuffer.growAggressively=false .","title":"StringBuffer and StringBuilder above 1 G grow to the maximum size"},{"location":"version0.19/#jpackage-packaging-tool-platform-support","text":"The jpackage utility is described in JEP 343 as a tool that \"packages a Java application into a platform-specific package that includes all of the necessary dependencies.\" Full details of the tool are available at JEP 343: Packaging Tool . Be aware that jpackage is supported on only the following OpenJ9 platforms: Linux\u00ae, macOS\u00ae, and Windows\u2122. It is not supported on AIX\u00ae or z/OS\u00ae platforms.","title":"jpackage packaging tool platform support"},{"location":"version0.19/#extended-messages-for-nullpointerexception-not-yet-implemented","text":"JEP 358: Helpful NullPointerExceptions provides extended messages when a NullPointerException is generated by the Java 14 VM and you have enabled the feature. However, be aware that this is not implemented in OpenJ9 at this time.","title":"Extended messages for NullPointerException not yet implemented"},{"location":"version0.19/#compiler-changes-for-linux","text":"Linux x86 64-bit, Linux on POWER\u00ae LE 64-bit, and Linux on IBM Z\u00ae 64-bit have all moved to the gcc 7.5 compiler. See Supported environments .","title":"Compiler changes for Linux"},{"location":"version0.19/#new-jdk-14-features","text":"The following features are supported by OpenJ9: JEP 343 : Packaging Tool (Incubator) Restrictions: jpackage is supported on only the following OpenJ9 platforms: Linux\u00ae, macOS\u00ae, and Windows\u2122. It is not supported on AIX\u00ae or z/OS\u00ae platforms. JEP 352 : Non-Volatile Mapped Byte Buffers JEP 358 : Helpful NullPointerExceptions JEP 359 : Records (Preview) The following features are implemented in OpenJDK and available in any builds of OpenJDK 14 with OpenJ9: JEP 305 : Pattern Matching for instanceof (Preview) JEP 361 : Switch Expressions (Standard) JEP 367 : Remove the Pack200 Tools and API JEP 368 : Text Blocks (Second Preview) You can find the full list of features for JDK 14 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9.","title":"New JDK 14 features"},{"location":"version0.19/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.18.0 and version 0.19.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.20/","text":"What's new in version 0.20.0 The following new features and notable changes since version 0.19.0 are included in this release: Binaries and supported environments Limited support for 64-bit Linux on ARM -XX:[+|-]ExitOnOutOfMemoryError option behavior update New -XX:[+|-]GlobalLockReservation option added Change to default maximum heap size for Java 8 Change to jcmd default options Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.20.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Limited support for 64-bit Linux on ARM Limited support is available in this release for the 64-bit ARM (AArch64) architecture. An early access build on OpenJDK 11 is available from the AdoptOpenJDK community . See the OpenJ9 release notes for any known issues that are still being worked on before this platform is fully supported. -XX:[+|-]ExitOnOutOfMemoryError option behavior update The -XX:[+|-]ExitOnOutOfMemoryError option is updated to exit only on VM OutOfMemoryErrors instead of both VM and Java\u2122 thrown errors to match the HotSpot option. See -XX:[+|-]ExitOnOutOfMemoryError for more details about this option. New -XX:[+|-]GlobalLockReservation option added (AIX\u00ae and Linux on Power Systems\u2122 only) Option -XX:[+|-]GlobalLockReservation enables a new optimization targeted towards more efficient handling of locking and unlocking Java objects. See -XX:[+|-]GlobalLockReservation for more details about this option. Change to default maximum heap size for Java 8 For consistency with Java 11, the default maximum heap size ( -Xmx ) is changed to be 25% of the available memory with a maximum of 25 GB. Where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. If you want to revert to the default setting in earlier releases of OpenJ9, use the -XX:+OriginalJDK8HeapSizeCompatibilityMode option. Change to jcmd default options The Java diagnostic command ( jcmd ) tool no longer requires a filename when used with the Dump.java , Dump.snap , or Dump.system options. See jcmd for more information about the tool. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.19.0 and version 0.20.0 releases, see the Release notes .","title":"Version 0.20.0"},{"location":"version0.20/#whats-new-in-version-0200","text":"The following new features and notable changes since version 0.19.0 are included in this release: Binaries and supported environments Limited support for 64-bit Linux on ARM -XX:[+|-]ExitOnOutOfMemoryError option behavior update New -XX:[+|-]GlobalLockReservation option added Change to default maximum heap size for Java 8 Change to jcmd default options","title":"What's new in version 0.20.0"},{"location":"version0.20/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.20/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.20.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.20/#limited-support-for-64-bit-linux-on-arm","text":"Limited support is available in this release for the 64-bit ARM (AArch64) architecture. An early access build on OpenJDK 11 is available from the AdoptOpenJDK community . See the OpenJ9 release notes for any known issues that are still being worked on before this platform is fully supported.","title":"Limited support for 64-bit Linux on ARM"},{"location":"version0.20/#-xx-exitonoutofmemoryerror-option-behavior-update","text":"The -XX:[+|-]ExitOnOutOfMemoryError option is updated to exit only on VM OutOfMemoryErrors instead of both VM and Java\u2122 thrown errors to match the HotSpot option. See -XX:[+|-]ExitOnOutOfMemoryError for more details about this option.","title":"-XX:[+|-]ExitOnOutOfMemoryError option behavior update"},{"location":"version0.20/#new-xx-globallockreservation-option-added","text":"(AIX\u00ae and Linux on Power Systems\u2122 only) Option -XX:[+|-]GlobalLockReservation enables a new optimization targeted towards more efficient handling of locking and unlocking Java objects. See -XX:[+|-]GlobalLockReservation for more details about this option.","title":"New -XX:[+|-]GlobalLockReservation option added"},{"location":"version0.20/#change-to-default-maximum-heap-size-for-java-8","text":"For consistency with Java 11, the default maximum heap size ( -Xmx ) is changed to be 25% of the available memory with a maximum of 25 GB. Where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. If you want to revert to the default setting in earlier releases of OpenJ9, use the -XX:+OriginalJDK8HeapSizeCompatibilityMode option.","title":"Change to default maximum heap size for Java 8"},{"location":"version0.20/#change-to-jcmd-default-options","text":"The Java diagnostic command ( jcmd ) tool no longer requires a filename when used with the Dump.java , Dump.snap , or Dump.system options. See jcmd for more information about the tool.","title":"Change to jcmd default options"},{"location":"version0.20/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.19.0 and version 0.20.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.21/","text":"What's new in version 0.21.0 The following new features and notable changes since version 0.20.0 are included in this release: New binaries and changes to supported environments Application Programming Interface (API) documentation Performance improvements New -XX:[+|-]HandleSIGABRT option added New -XX:[+|-]PrintFlagsFinal option added Update to NoClassDefFoundError exception message macOS\u00ae shared libraries version updated Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.21.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Application Programming Interface (API) documentation API documentation that applies to OpenJ9 can now be found in this user documentation for both JDK 8 and JDK 11. The documentation includes links to Oracle API documentation for information that is not specific to OpenJ9. See API overview . Performance improvements If the -Xtune:virtualized command line option is used, the default JIT scratch memory limit is now reduced from 256 MB to 16 MB. This reduces the peak from JIT compilation activity, allowing you to size containers more easily, based on the particular application's memory usage. If the JIT is running in a container and no swap space is defined, the JIT dynamically adjusts its scratch memory consumption based on the amount of free physical memory available, to avoid out-of-memory (OOM) occurrences. Several performance features were added to the AArch64 JIT compiler implementation that led to a throughput improvement on multiple applications of at least 20%. The most notable improvements were seen in global register allocation, recompilation (without profiling), CUDA support, concurrent scavenge GC policy, and the inlined code sequence for object allocations. New -XX:[+|-]HandleSIGABRT option added This option affects the handling of the operating system signal SIGABRT . For compatibility with the reference implementation, set -XX:-HandleSIGABRT . For more information, see -XX:[+|-]HandleSIGABRT . New -XX:[+|-]PrintFlagsFinal option added This release provides an initial implementation of the -XX:[+|-]PrintFlagsFinal option. It is currently incomplete and outputs only a subset of parameters. Over time, we expect more options to be added to the output. See -XX:[+|-]PrintFlagsFinal for more details about this option. Update to NoClassDefFoundError exception message The order in which class names are printed in a NoClassDefFoundError exception message now matches the output reported by HotSpot. For example, in the following exception message: java.lang.NoClassDefFoundError: mypackage/Main (wrong name: Main) mypackage/Main is the class name encountered by the VM in the .class file, but \"wrong name\" Main was the provided class name. Prior to this update to the exception message, the encountered class name and the provided class name were swapped in the NoClassDefFoundError exception message. macOS shared libraries version updated The version information for shared libraries on macOS has been updated from 0.0.0 to 1.0.0. If an application has linked against a shared library from a previous OpenJ9 release, it needs to be re-linked against the new release. Failure to re-link causes an error Incompatible library version , requires version 0.0.0 . Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.20.0 and version 0.21.0 releases, see the Release notes .","title":"Version 0.21.0"},{"location":"version0.21/#whats-new-in-version-0210","text":"The following new features and notable changes since version 0.20.0 are included in this release: New binaries and changes to supported environments Application Programming Interface (API) documentation Performance improvements New -XX:[+|-]HandleSIGABRT option added New -XX:[+|-]PrintFlagsFinal option added Update to NoClassDefFoundError exception message macOS\u00ae shared libraries version updated","title":"What's new in version 0.21.0"},{"location":"version0.21/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.21/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.21.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.21/#application-programming-interface-api-documentation","text":"API documentation that applies to OpenJ9 can now be found in this user documentation for both JDK 8 and JDK 11. The documentation includes links to Oracle API documentation for information that is not specific to OpenJ9. See API overview .","title":"Application Programming Interface (API) documentation"},{"location":"version0.21/#performance-improvements","text":"If the -Xtune:virtualized command line option is used, the default JIT scratch memory limit is now reduced from 256 MB to 16 MB. This reduces the peak from JIT compilation activity, allowing you to size containers more easily, based on the particular application's memory usage. If the JIT is running in a container and no swap space is defined, the JIT dynamically adjusts its scratch memory consumption based on the amount of free physical memory available, to avoid out-of-memory (OOM) occurrences. Several performance features were added to the AArch64 JIT compiler implementation that led to a throughput improvement on multiple applications of at least 20%. The most notable improvements were seen in global register allocation, recompilation (without profiling), CUDA support, concurrent scavenge GC policy, and the inlined code sequence for object allocations.","title":"Performance improvements"},{"location":"version0.21/#new-xx-handlesigabrt-option-added","text":"This option affects the handling of the operating system signal SIGABRT . For compatibility with the reference implementation, set -XX:-HandleSIGABRT . For more information, see -XX:[+|-]HandleSIGABRT .","title":"New -XX:[+|-]HandleSIGABRT option added"},{"location":"version0.21/#new-xx-printflagsfinal-option-added","text":"This release provides an initial implementation of the -XX:[+|-]PrintFlagsFinal option. It is currently incomplete and outputs only a subset of parameters. Over time, we expect more options to be added to the output. See -XX:[+|-]PrintFlagsFinal for more details about this option.","title":"New -XX:[+|-]PrintFlagsFinal option added"},{"location":"version0.21/#update-to-noclassdeffounderror-exception-message","text":"The order in which class names are printed in a NoClassDefFoundError exception message now matches the output reported by HotSpot. For example, in the following exception message: java.lang.NoClassDefFoundError: mypackage/Main (wrong name: Main) mypackage/Main is the class name encountered by the VM in the .class file, but \"wrong name\" Main was the provided class name. Prior to this update to the exception message, the encountered class name and the provided class name were swapped in the NoClassDefFoundError exception message.","title":"Update to NoClassDefFoundError exception message"},{"location":"version0.21/#macos-shared-libraries-version-updated","text":"The version information for shared libraries on macOS has been updated from 0.0.0 to 1.0.0. If an application has linked against a shared library from a previous OpenJ9 release, it needs to be re-linked against the new release. Failure to re-link causes an error Incompatible library version , requires version 0.0.0 .","title":"macOS shared libraries version updated"},{"location":"version0.21/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.20.0 and version 0.21.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.22/","text":"What's new in version 0.22.0 The following new features and notable changes since version 0.21.0 are included in this release: New binaries and changes to supported environments Performance improvements New -XX:[+|-]PortableSharedCache option added Methods in com.ibm.lang.management.MemoryMXBean deprecated and replaced java.lang.System.mapLibraryName() string suffix New JDK 15 features Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.22.0 supports OpenJDK 15. Binaries are available from the AdoptOpenJDK community at the following link: OpenJDK version 15 OpenJDK 15 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.21.0. Features mentioned in these release notes are not available in these Java 8 and 11 builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.22.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Performance improvements The performance of zero initializing Java heap memory improved on the IBM Z\u00ae platform because of a change to use memset instead of an outdated handcrafted assembly sequence in the JVM. New -XX:[+|-]PortableSharedCache option added On x86 only, the -XX:[+|-]PortableSharedCache option enables you to choose whether AOT code should be generated using an older processor (Intel\u00ae Sandybridge) feature set, which therefore allows the AOT code to be portable. This feature is particularly relevant for packaging a shared classes cache into a container image (for example, applications deployed on the cloud in the form of Docker containers) because the processor on which the container image is built is likely to be different from the processor on which the container is deployed. For more information, see -XX:[+|-]PortableSharedCache . Methods in com.ibm.lang.management.MemoryMXBean deprecated and replaced The methods com.ibm.lang.management.MemoryMXBean.getGCMasterThreadCpuUsed() and com.ibm.lang.management.MemoryMXBean.getGCSlaveThreadsCpuUsed() are deprecated for removal in Java 16. The recommended methods to be used are com.ibm.lang.management.MemoryMXBean.getGCMainThreadCpuUsed() and com.ibm.lang.management.MemoryMXBean.getGCWorkerThreadsCpuUsed() respectively. For more information see Java 8: com.ibm.lang.management.MemoryMXBean and for Java 11: com.ibm.lang.management.MemoryMXBean java.lang.System.mapLibraryName() string suffix On AIX\u00ae systems, java.lang.System.mapLibraryName(libname) returns a representation of a native library in a platform-specific string with a .so suffix. New JDK 15 features The following features are supported by OpenJ9: JEP 360 : Sealed Classes (Preview) JEP 371 : Hidden Classes JEP 384 : Records (Second Preview) The following features are implemented in OpenJDK and available in any builds of OpenJDK 14 with OpenJ9: JEP 339 : Edwards-Curve Digital Signature Algorithm (EdDSA) JEP 372 : Remove the Nashorn JavaScript Engine JEP 373 : Reimplement the Legacy DatagramSocket API JEP 375 : Pattern Matching for instanceof (Second Preview) JEP 378 : Text Blocks JEP 385 : Deprecate RMI Activation for Removal You can find the full list of features for JDK 15 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.21.0 and version 0.22.0 releases, see the Release notes .","title":"Version 0.22.0"},{"location":"version0.22/#whats-new-in-version-0220","text":"The following new features and notable changes since version 0.21.0 are included in this release: New binaries and changes to supported environments Performance improvements New -XX:[+|-]PortableSharedCache option added Methods in com.ibm.lang.management.MemoryMXBean deprecated and replaced java.lang.System.mapLibraryName() string suffix New JDK 15 features","title":"What's new in version 0.22.0"},{"location":"version0.22/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.22/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.22.0 supports OpenJDK 15. Binaries are available from the AdoptOpenJDK community at the following link: OpenJDK version 15 OpenJDK 15 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.21.0. Features mentioned in these release notes are not available in these Java 8 and 11 builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.22.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.22/#performance-improvements","text":"The performance of zero initializing Java heap memory improved on the IBM Z\u00ae platform because of a change to use memset instead of an outdated handcrafted assembly sequence in the JVM.","title":"Performance improvements"},{"location":"version0.22/#new-xx-portablesharedcache-option-added","text":"On x86 only, the -XX:[+|-]PortableSharedCache option enables you to choose whether AOT code should be generated using an older processor (Intel\u00ae Sandybridge) feature set, which therefore allows the AOT code to be portable. This feature is particularly relevant for packaging a shared classes cache into a container image (for example, applications deployed on the cloud in the form of Docker containers) because the processor on which the container image is built is likely to be different from the processor on which the container is deployed. For more information, see -XX:[+|-]PortableSharedCache .","title":"New -XX:[+|-]PortableSharedCache option added"},{"location":"version0.22/#methods-in-comibmlangmanagementmemorymxbean-deprecated-and-replaced","text":"The methods com.ibm.lang.management.MemoryMXBean.getGCMasterThreadCpuUsed() and com.ibm.lang.management.MemoryMXBean.getGCSlaveThreadsCpuUsed() are deprecated for removal in Java 16. The recommended methods to be used are com.ibm.lang.management.MemoryMXBean.getGCMainThreadCpuUsed() and com.ibm.lang.management.MemoryMXBean.getGCWorkerThreadsCpuUsed() respectively. For more information see Java 8: com.ibm.lang.management.MemoryMXBean and for Java 11: com.ibm.lang.management.MemoryMXBean","title":"Methods in com.ibm.lang.management.MemoryMXBean deprecated and replaced"},{"location":"version0.22/#javalangsystemmaplibraryname-string-suffix","text":"On AIX\u00ae systems, java.lang.System.mapLibraryName(libname) returns a representation of a native library in a platform-specific string with a .so suffix.","title":"java.lang.System.mapLibraryName() string suffix"},{"location":"version0.22/#new-jdk-15-features","text":"The following features are supported by OpenJ9: JEP 360 : Sealed Classes (Preview) JEP 371 : Hidden Classes JEP 384 : Records (Second Preview) The following features are implemented in OpenJDK and available in any builds of OpenJDK 14 with OpenJ9: JEP 339 : Edwards-Curve Digital Signature Algorithm (EdDSA) JEP 372 : Remove the Nashorn JavaScript Engine JEP 373 : Reimplement the Legacy DatagramSocket API JEP 375 : Pattern Matching for instanceof (Second Preview) JEP 378 : Text Blocks JEP 385 : Deprecate RMI Activation for Removal You can find the full list of features for JDK 15 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9.","title":"New JDK 15 features"},{"location":"version0.22/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.21.0 and version 0.22.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.23/","text":"What's new in version 0.23.0 The following new features and notable changes since version 0.22.0 are included in this release: New binaries and changes to supported environments -XX:[+|-]PortableSharedCache option behavior update -XX:[+|-]IdleTuningCompactOnIdle option now inactive Support for OpenJDK HotSpot options Extended platform support for the JITServer technology preview Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.23.0 supports OpenJDK 8, 11, and 15. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 15 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . -XX:[+|-]PortableSharedCache option behavior update The -XX:[+|-]PortableSharedCache option is updated to improve the portability of AOT-compiled code further. This update allows AOT-compiled code to be portable across OpenJ9 VMs that use compressed references and have a heap size of 1 MB to 28 GB when this option is enabled. This option might introduce a small (1-2%) steady-state throughput penalty when compressed references are used and the heap size is between 1 MB and 3 GB. See -XX:[+|-]PortableSharedCache for more details about this option. -XX:[+|-]IdleTuningCompactOnIdle option now inactive Setting the -XX:[+|-]IdleTuningCompactOnIdle option now has no effect. A compaction is triggered by internal heuristics that look into the number of fragmented pages. Typically there is no need to force a compaction. This option was deprecated in release 0.15.0, and will be removed in the future. See -XX:[+|-]IdleTuningCompactOnIdle for details about this option. Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:[+|-]AlwaysPreTouch Extended platform support for the JITServer technology preview Platform support for the JITServer technology preview is now extended to 64-bit Linux\u00ae on IBM Power\u00ae systems, and 64-bit Linux on IBM Z\u00ae systems. JITServer decouples the JIT compiler from the OpenJ9 VM, freeing up CPU and memory for an application. JITServer runs in its own process, either locally or on a remote machine, where resources can be separately managed. This preview was initially introduced in Eclipse OpenJ9 V0.18.1 for Linux on 64-bit x86 systems. For more information, see JITServer technology (technical preview) . Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.22.0 and version 0.23.0 releases, see the Release notes .","title":"Version 0.23.0"},{"location":"version0.23/#whats-new-in-version-0230","text":"The following new features and notable changes since version 0.22.0 are included in this release: New binaries and changes to supported environments -XX:[+|-]PortableSharedCache option behavior update -XX:[+|-]IdleTuningCompactOnIdle option now inactive Support for OpenJDK HotSpot options Extended platform support for the JITServer technology preview","title":"What's new in version 0.23.0"},{"location":"version0.23/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.23/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.23.0 supports OpenJDK 8, 11, and 15. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 15 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.23/#-xx-portablesharedcache-option-behavior-update","text":"The -XX:[+|-]PortableSharedCache option is updated to improve the portability of AOT-compiled code further. This update allows AOT-compiled code to be portable across OpenJ9 VMs that use compressed references and have a heap size of 1 MB to 28 GB when this option is enabled. This option might introduce a small (1-2%) steady-state throughput penalty when compressed references are used and the heap size is between 1 MB and 3 GB. See -XX:[+|-]PortableSharedCache for more details about this option.","title":"-XX:[+|-]PortableSharedCache option behavior update"},{"location":"version0.23/#-xx-idletuningcompactonidle-option-now-inactive","text":"Setting the -XX:[+|-]IdleTuningCompactOnIdle option now has no effect. A compaction is triggered by internal heuristics that look into the number of fragmented pages. Typically there is no need to force a compaction. This option was deprecated in release 0.15.0, and will be removed in the future. See -XX:[+|-]IdleTuningCompactOnIdle for details about this option.","title":"-XX:[+|-]IdleTuningCompactOnIdle option now inactive"},{"location":"version0.23/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:[+|-]AlwaysPreTouch","title":"Support for OpenJDK HotSpot options"},{"location":"version0.23/#extended-platform-support-for-the-jitserver-technology-preview","text":"Platform support for the JITServer technology preview is now extended to 64-bit Linux\u00ae on IBM Power\u00ae systems, and 64-bit Linux on IBM Z\u00ae systems. JITServer decouples the JIT compiler from the OpenJ9 VM, freeing up CPU and memory for an application. JITServer runs in its own process, either locally or on a remote machine, where resources can be separately managed. This preview was initially introduced in Eclipse OpenJ9 V0.18.1 for Linux on 64-bit x86 systems. For more information, see JITServer technology (technical preview) .","title":"Extended platform support for the JITServer technology preview"},{"location":"version0.23/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.22.0 and version 0.23.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.24/","text":"What's new in version 0.24.0 The following new features and notable changes since version 0.23.0 are included in this release: New binaries and changes to supported environments Changes to message logging Support for the JAVA_OPTIONS environment variable -XX:[+|-]PortableSharedCache option support update -XX:[+|-]ShareAnonymousClasses option behavior update Additional parameters for jcmd Dump commands Change in behavior for the jextract utility New diagnostic suboption for -Xcheck:jni for fatal JNI errors Improved diagnostic information in a Java dump file on processor features Helm chart available for deploying JITServer Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.24.0 supports OpenJDK 8, 11, and 15. Windows\u00ae builds for Java\u2122 8 are now compiled with Microsoft\u00ae Visual Studio 2013. The Visual Studio redistributable files included with the build are updated to match. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Changes to message logging JEP 158 introduces the -Xlog option as a common logging system for all components of a Java virtual machine. To avoid confusion with the reference implementation, the -Xsyslog option replaces the existing OpenJ9 -Xlog option for message logging. For compatibility with the reference implementation, a limited set of -Xlog suboptions are supported. A new option, -XX:[+|-]LegacyXlogOption , controls how -Xlog is processed when set on the command line. When -XX:-LegacyXlogOption is set, the -Xlog option is recognized when a form of this option runs that requests garbage collection (GC) logging. If any -Xlog GC log requests are set, these options are mapped to the equivalent OpenJ9 verbose GC command line options. For more information, see -Xlog . Setting -XX:+LegacyXLogOption provides backward compatibility with the legacy -Xlog option, which can be specified on the command line with the parameters documented for the -Xsyslog option. That is, these options can be used interchangeably. If you rely on the legacy -Xlog option and cannot easily migrate to the -Xsyslog option, you must set this option on the command line. Support for the JAVA_OPTIONS environment variable For compatibility with the reference implementation, OpenJ9 now supports the JAVA_OPTIONS environment variable. This environment variable can be used to set command line options, as described in OpenJ9 command-line options and Environment variables . Options specified by JAVA_OPTIONS can be overridden by options specified by OPENJ9_JAVA_OPTIONS . -XX:[+|-]PortableSharedCache option support update The -XX:[+|-]PortableSharedCache option is now supported on IBM Z\u00ae and POWER\u00ae platforms. AOT-compiled code that is generated with this option is guaranteed to be portable across IBM z10 or newer microarchitectures on IBM Z platforms and IBM POWER8\u00ae or newer microarchitectures on POWER platforms. See -XX:[+|-]PortableSharedCache for more details about this option. -XX:[+|-]ShareAnonymousClasses option behavior update In earlier releases of OpenJ9, the -XX:[+|-]ShareAnonymousClasses option enables and disables the storage of VM anonymous classes in the shared classes cache. From OpenJ9 0.24.0 for OpenJDK 15 binaries, this option also controls the storage of hidden classes. See -XX:[+|-]ShareAnonymousClasses for more details about this option. Additional parameters for jcmd Dump commands You can now include additional parameters for jcmd Dump commands as indicated in the following list: Dump.system , Dump.heap , Dump.java , and Dump.snap accept an optional request=<requests> parameter. Dump.heap accepts an optional opts=<options> parameter. These parameters, including the <file path> parameter, can be in any order. The default for both system and heap dumps is now: request=exclusive+prepwalk . For further details, refer to the following -Xdump suboptions: request=<requests> and opts=<options> . For more information about jcmd , see Java diagnostic command (jcmd) tool . Change in behavior for the jextract utility The jextract utility gathers relevant files following a system dump to assist with problem determination. It is important that the jextract utility is run from the same SDK that generated the dump. From this release, if the build ID of the jextract utility does not match the build ID of the SDK that is recorded in the system dump, an exception message is generated. To force jextract to continue, a new option, -r , is introduced. For more information, see Dump extractor . New diagnostic suboption for -Xcheck:jni for fatal JNI errors A new abortonerror suboption for -Xcheck:jni provides diagnostic data when fatal JNI errors occur. For more information, run -Xcheck:jni:help . Improved diagnostic information in a Java dump file on processor features The ENVINFO section of a Java dump file now includes further information about processor features. This information helps to diagnose problems associated with JIT and AOT compilations that depend on underlying hardware. For an example that shows the information provided when JIT is enabled, see the CPU Information ( 2CIJITFEATURE , 2CIAOTFEATURE ) section in the Java dump topic. Helm chart available for deploying JITServer A Helm Chart is now available for easier deployment of JITServer technology in a Kubernetes or OpenShift cluster. You can find the chart ( openj9-jitserver-chart ) in the JITServer Helm repository , which contains a complete set of usage instructions. For an introduction to JITServer technology, see JITServer (tech. preview) . Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.23.0 and version 0.24.0 releases, see the Release notes .","title":"Version 0.24.0"},{"location":"version0.24/#whats-new-in-version-0240","text":"The following new features and notable changes since version 0.23.0 are included in this release: New binaries and changes to supported environments Changes to message logging Support for the JAVA_OPTIONS environment variable -XX:[+|-]PortableSharedCache option support update -XX:[+|-]ShareAnonymousClasses option behavior update Additional parameters for jcmd Dump commands Change in behavior for the jextract utility New diagnostic suboption for -Xcheck:jni for fatal JNI errors Improved diagnostic information in a Java dump file on processor features Helm chart available for deploying JITServer","title":"What's new in version 0.24.0"},{"location":"version0.24/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.24/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.24.0 supports OpenJDK 8, 11, and 15. Windows\u00ae builds for Java\u2122 8 are now compiled with Microsoft\u00ae Visual Studio 2013. The Visual Studio redistributable files included with the build are updated to match. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.24/#changes-to-message-logging","text":"JEP 158 introduces the -Xlog option as a common logging system for all components of a Java virtual machine. To avoid confusion with the reference implementation, the -Xsyslog option replaces the existing OpenJ9 -Xlog option for message logging. For compatibility with the reference implementation, a limited set of -Xlog suboptions are supported. A new option, -XX:[+|-]LegacyXlogOption , controls how -Xlog is processed when set on the command line. When -XX:-LegacyXlogOption is set, the -Xlog option is recognized when a form of this option runs that requests garbage collection (GC) logging. If any -Xlog GC log requests are set, these options are mapped to the equivalent OpenJ9 verbose GC command line options. For more information, see -Xlog . Setting -XX:+LegacyXLogOption provides backward compatibility with the legacy -Xlog option, which can be specified on the command line with the parameters documented for the -Xsyslog option. That is, these options can be used interchangeably. If you rely on the legacy -Xlog option and cannot easily migrate to the -Xsyslog option, you must set this option on the command line.","title":"Changes to message logging"},{"location":"version0.24/#support-for-the-java_options-environment-variable","text":"For compatibility with the reference implementation, OpenJ9 now supports the JAVA_OPTIONS environment variable. This environment variable can be used to set command line options, as described in OpenJ9 command-line options and Environment variables . Options specified by JAVA_OPTIONS can be overridden by options specified by OPENJ9_JAVA_OPTIONS .","title":"Support for the JAVA_OPTIONS environment variable"},{"location":"version0.24/#-xx-portablesharedcache-option-support-update","text":"The -XX:[+|-]PortableSharedCache option is now supported on IBM Z\u00ae and POWER\u00ae platforms. AOT-compiled code that is generated with this option is guaranteed to be portable across IBM z10 or newer microarchitectures on IBM Z platforms and IBM POWER8\u00ae or newer microarchitectures on POWER platforms. See -XX:[+|-]PortableSharedCache for more details about this option.","title":"-XX:[+|-]PortableSharedCache option support update"},{"location":"version0.24/#-xx-shareanonymousclasses-option-behavior-update","text":"In earlier releases of OpenJ9, the -XX:[+|-]ShareAnonymousClasses option enables and disables the storage of VM anonymous classes in the shared classes cache. From OpenJ9 0.24.0 for OpenJDK 15 binaries, this option also controls the storage of hidden classes. See -XX:[+|-]ShareAnonymousClasses for more details about this option.","title":"-XX:[+|-]ShareAnonymousClasses option behavior update"},{"location":"version0.24/#additional-parameters-for-jcmd-dump-commands","text":"You can now include additional parameters for jcmd Dump commands as indicated in the following list: Dump.system , Dump.heap , Dump.java , and Dump.snap accept an optional request=<requests> parameter. Dump.heap accepts an optional opts=<options> parameter. These parameters, including the <file path> parameter, can be in any order. The default for both system and heap dumps is now: request=exclusive+prepwalk . For further details, refer to the following -Xdump suboptions: request=<requests> and opts=<options> . For more information about jcmd , see Java diagnostic command (jcmd) tool .","title":"Additional parameters for jcmd Dump commands"},{"location":"version0.24/#change-in-behavior-for-the-jextract-utility","text":"The jextract utility gathers relevant files following a system dump to assist with problem determination. It is important that the jextract utility is run from the same SDK that generated the dump. From this release, if the build ID of the jextract utility does not match the build ID of the SDK that is recorded in the system dump, an exception message is generated. To force jextract to continue, a new option, -r , is introduced. For more information, see Dump extractor .","title":"Change in behavior for the jextract utility"},{"location":"version0.24/#new-diagnostic-suboption-for-xcheckjni-for-fatal-jni-errors","text":"A new abortonerror suboption for -Xcheck:jni provides diagnostic data when fatal JNI errors occur. For more information, run -Xcheck:jni:help .","title":"New diagnostic suboption for -Xcheck:jni for fatal JNI errors"},{"location":"version0.24/#improved-diagnostic-information-in-a-java-dump-file-on-processor-features","text":"The ENVINFO section of a Java dump file now includes further information about processor features. This information helps to diagnose problems associated with JIT and AOT compilations that depend on underlying hardware. For an example that shows the information provided when JIT is enabled, see the CPU Information ( 2CIJITFEATURE , 2CIAOTFEATURE ) section in the Java dump topic.","title":"Improved diagnostic information in a Java dump file on processor features"},{"location":"version0.24/#helm-chart-available-for-deploying-jitserver","text":"A Helm Chart is now available for easier deployment of JITServer technology in a Kubernetes or OpenShift cluster. You can find the chart ( openj9-jitserver-chart ) in the JITServer Helm repository , which contains a complete set of usage instructions. For an introduction to JITServer technology, see JITServer (tech. preview) .","title":"Helm chart available for deploying JITServer"},{"location":"version0.24/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.23.0 and version 0.24.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.25/","text":"What's new in version 0.25.0 The following new features and notable changes since version 0.24.0 are included in this release: New binaries and changes to supported environments New JDK 16 features Support for the -verbose:module option Enabling zlibNX hardware-accelerated data compression and decompression on AIX z/OS support for the %sysname dump token Single build for compressed references and non-compressed references Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.25.0 supports OpenJDK 16. OpenJDK 16 with Eclipse OpenJ9 is not a long term support (LTS) release. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 release 0.25.0, testing at the project is not complete and therefore support for new features that apply to these Java versions is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . New JDK 16 features The following features are supported by OpenJ9: JEP 338 : Vector API (incubator) OpenJ9 adds optimizations for this feature. JEP 390 : Warnings for value-based classes OpenJ9 adds option -XX:DiagnoseSyncOnValueBasedClasses=<number> for compatibility with the reference implementation. JEP 395 : Records JEP 397 : Sealed Classes (second preview) The following features will be supported by OpenJ9 in a future release: JEP 389 : Foreign linker API (incubator) JEP 393 : Foreign-memory access API (third incubator) The following features are implemented in OpenJDK and available in any builds of OpenJDK 16 with OpenJ9: JEP 347 : Enable C++ 14 language features JEP 380 : Unix-domain socket channels JEP 394 : Pattern matching for instanceof JEP 396 : Strongly encapsulate JDK internals by default JEP 392 : Packaging tool (Linux\u00ae, macOS\u00ae, and Windows\u2122 only) Promoted from incubation to a production-ready feature in this release. See Using jpackage for details. You can find the full list of features for JDK 16 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Note: Applications might be adversely affected by JEP 396 if they make use of internal APIs. You should update your application to use standard APIs. To temporarily work around this problem, set --illegal-access=permit on the command line, which prints a warning that is similar to the following example when an illegal access call is made: WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.openj9.test.com.ibm.jit.Test_JITHelpers (file:/home/jenkins/workspace/Test_openjdk11_j9.functional_ppc64_aix_Nightly_testList_1/jvmtest/functional/Java8andUp/GeneralTest.jar) to field java.lang.String.value WARNING: Please consider reporting this to the maintainers of org.openj9.test.com.ibm.jit.Test_JITHelpers WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release Support for the -verbose:module option The -verbose:module option is now supported for Java 11 and later releases. This option writes information to stderr for each module that is loaded and unloaded. Enabling zlibNX hardware-accelerated data compression and decompression on AIX By default, AIX\u00ae uses the system zlib library for data compression and decompression. On systems that contain the Nest accelerator (NX) co-processor, OpenJ9 now uses the zlibNX library instead, if it is installed. To learn more about hardware acceleration and the zlibNX library, see Hardware acceleration . z/OS support for the %sysname dump token The %sysname dump token is added on z/OS, which equates to the SYSNAME sysparm. See Dump agent tokens . Single build for compressed references and non-compressed references A single build now supports both compressed references and non-compressed references. The object reference mode is selected at run time based on the specified heap size ( -Xmx ) or by using command-line options that control the selection of compressed references. If you used a large heap build for an earlier release of OpenJ9 because you did not require compressed references, you might need to turn it off if compressed references mode is being selected automatically at run time. Use the -Xnocompressedrefs option when you start your application. The compressedrefs directory is no longer present in the single build. To learn about the benefits of using compressed references, see Compressed references . Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.24.0 and version 0.25.0 releases, see the Release notes .","title":"Version 0.25.0"},{"location":"version0.25/#whats-new-in-version-0250","text":"The following new features and notable changes since version 0.24.0 are included in this release: New binaries and changes to supported environments New JDK 16 features Support for the -verbose:module option Enabling zlibNX hardware-accelerated data compression and decompression on AIX z/OS support for the %sysname dump token Single build for compressed references and non-compressed references","title":"What's new in version 0.25.0"},{"location":"version0.25/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.25/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.25.0 supports OpenJDK 16. OpenJDK 16 with Eclipse OpenJ9 is not a long term support (LTS) release. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 release 0.25.0, testing at the project is not complete and therefore support for new features that apply to these Java versions is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.25/#new-jdk-16-features","text":"The following features are supported by OpenJ9: JEP 338 : Vector API (incubator) OpenJ9 adds optimizations for this feature. JEP 390 : Warnings for value-based classes OpenJ9 adds option -XX:DiagnoseSyncOnValueBasedClasses=<number> for compatibility with the reference implementation. JEP 395 : Records JEP 397 : Sealed Classes (second preview) The following features will be supported by OpenJ9 in a future release: JEP 389 : Foreign linker API (incubator) JEP 393 : Foreign-memory access API (third incubator) The following features are implemented in OpenJDK and available in any builds of OpenJDK 16 with OpenJ9: JEP 347 : Enable C++ 14 language features JEP 380 : Unix-domain socket channels JEP 394 : Pattern matching for instanceof JEP 396 : Strongly encapsulate JDK internals by default JEP 392 : Packaging tool (Linux\u00ae, macOS\u00ae, and Windows\u2122 only) Promoted from incubation to a production-ready feature in this release. See Using jpackage for details. You can find the full list of features for JDK 16 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Note: Applications might be adversely affected by JEP 396 if they make use of internal APIs. You should update your application to use standard APIs. To temporarily work around this problem, set --illegal-access=permit on the command line, which prints a warning that is similar to the following example when an illegal access call is made: WARNING: An illegal reflective access operation has occurred WARNING: Illegal reflective access by org.openj9.test.com.ibm.jit.Test_JITHelpers (file:/home/jenkins/workspace/Test_openjdk11_j9.functional_ppc64_aix_Nightly_testList_1/jvmtest/functional/Java8andUp/GeneralTest.jar) to field java.lang.String.value WARNING: Please consider reporting this to the maintainers of org.openj9.test.com.ibm.jit.Test_JITHelpers WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations WARNING: All illegal access operations will be denied in a future release","title":"New JDK 16 features"},{"location":"version0.25/#support-for-the-verbosemodule-option","text":"The -verbose:module option is now supported for Java 11 and later releases. This option writes information to stderr for each module that is loaded and unloaded.","title":"Support for the -verbose:module option"},{"location":"version0.25/#enabling-zlibnx-hardware-accelerated-data-compression-and-decompression-on-aix","text":"By default, AIX\u00ae uses the system zlib library for data compression and decompression. On systems that contain the Nest accelerator (NX) co-processor, OpenJ9 now uses the zlibNX library instead, if it is installed. To learn more about hardware acceleration and the zlibNX library, see Hardware acceleration .","title":"Enabling zlibNX hardware-accelerated data compression and decompression on AIX"},{"location":"version0.25/#zos-support-for-the-sysname-dump-token","text":"The %sysname dump token is added on z/OS, which equates to the SYSNAME sysparm. See Dump agent tokens .","title":"z/OS support for the %sysname dump token"},{"location":"version0.25/#single-build-for-compressed-references-and-non-compressed-references","text":"A single build now supports both compressed references and non-compressed references. The object reference mode is selected at run time based on the specified heap size ( -Xmx ) or by using command-line options that control the selection of compressed references. If you used a large heap build for an earlier release of OpenJ9 because you did not require compressed references, you might need to turn it off if compressed references mode is being selected automatically at run time. Use the -Xnocompressedrefs option when you start your application. The compressedrefs directory is no longer present in the single build. To learn about the benefits of using compressed references, see Compressed references .","title":"Single build for compressed references and non-compressed references"},{"location":"version0.25/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.24.0 and version 0.25.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.26/","text":"What's new in version 0.26.0 The following new features and notable changes since version 0.25.0 are included in this release: New binaries and changes to supported environments Dump extractor tool deprecated Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.26.0 supports OpenJDK 8, 11, and 16. For OpenJDK 8 and 11 builds that contain OpenJ9, see Version 0.25.0 for additional changes that have now been fully tested for these versions. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Dump extractor tool deprecated The dump extractor tool, jextract , is deprecated in this release and replaced with the jpackcore tool. This tool uses the same syntax and parameters as jextract to collect diagnostic files for analysis. The change is necessary because the reference implementation will be introducing a tool in a future release that is also called jextract . For more information, see Dump extractor . Full release information To see a complete list of changes between Eclipse OpenJ9 v0.25.0 and v0.26.0 releases, see the Release notes .","title":"Version 0.26.0"},{"location":"version0.26/#whats-new-in-version-0260","text":"The following new features and notable changes since version 0.25.0 are included in this release: New binaries and changes to supported environments Dump extractor tool deprecated","title":"What's new in version 0.26.0"},{"location":"version0.26/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.26/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.26.0 supports OpenJDK 8, 11, and 16. For OpenJDK 8 and 11 builds that contain OpenJ9, see Version 0.25.0 for additional changes that have now been fully tested for these versions. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.26/#dump-extractor-tool-deprecated","text":"The dump extractor tool, jextract , is deprecated in this release and replaced with the jpackcore tool. This tool uses the same syntax and parameters as jextract to collect diagnostic files for analysis. The change is necessary because the reference implementation will be introducing a tool in a future release that is also called jextract . For more information, see Dump extractor .","title":"Dump extractor tool deprecated"},{"location":"version0.26/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v0.25.0 and v0.26.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.27/","text":"What's new in version 0.27.1 The following new features and notable changes since version 0.26.0 are included in this release: New binaries and changes to supported environments New -XX:[+|-]AdaptiveGCThreading option added Improved time zone information added to Java dump files Change in default behavior for the balanced garbage collection policy Stop parsing the JAVA_OPTIONS environment variable Global lock reservation enabled by default Increase in default operating system stack size on PPC64 platforms New -x option added to jpackcore / jextract Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.27.1 supports OpenJDK 8, 11, and 16. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . New -XX:[+|-]AdaptiveGCThreading option added Adaptive threading is enabled by default, which automatically tunes the number of active parallel garbage collection (GC) threads. When this feature is enabled, the GC thread count is dynamically adjusted from collection cycle to cycle to account for changes in the the amount of time that parallel threads spend doing useful GC work (such as object graph traversal) compared to time spent synchronizing among themselves. When GC work decreases, fewer threads are used, which reduces the overhead, effectively reducing GC pause times. Resources are freed up for other processing activities. Use the -xgcmaxthreads option with the -XX:+AdaptiveGCThreading option to specify a thread count limit. Improved time zone information added to Java dump files To help with troubleshooting, additional time zone information is added to Java\u2122 dump files. Two new fields are included, the date and time in UTC ( 1TIDATETIMEUTC ) and the time zone according to the local system ( 1TITIMEZONE ). For more information, see the Java dump TITLE section . Change in default behavior for the balanced garbage collection (GC) policy In this release, a new scan mode, -Xgc:dynamicBreadthFirstScanOrdering , is used during balanced GC copy forward operations that is expected to improve performance. For more information about this type of operation, see GC copy forward operation . You can revert to the behavior in earlier releases by setting -Xgc:breadthFirstScanOrdering when you start your application. Stop parsing the JAVA_OPTIONS environment variable The 0.24 release started parsing the JAVA_OPTIONS environment variable. This variable was added in error and has been removed. The _JAVA_OPTIONS environment variable (with different behavior) is added for compatibility. Global lock reservation enabled by default (AIX\u00ae and Linux on Power Systems\u2122 only) Global lock reservation is now enabled by default. This is an optimization targeted towards more efficient handling of locking and unlocking Java objects. The older locking behavior can be restored via the -XX:-GlobalLockReservation option. See -XX:[+|-]GlobalLockReservation for more details. Increase in default operating system stack size on PPC64 platforms The default operating system stack size on AIX and Linux PPC64 is increased from 256KB to 512KB. You can change the operating system stack size by using the -Xmso option. New -x option recognized by jpackcore / jextract The new option, -x , causes the system dump to be omitted from the archive created. In its place, the file excluded-files.txt is added, which names the excluded file. For more information, see Dump extractor . Full release information To see a complete list of changes between Eclipse OpenJ9 v0.26.0 and v0.27.1 releases, see the Release notes .","title":"Version 0.27.1"},{"location":"version0.27/#whats-new-in-version-0271","text":"The following new features and notable changes since version 0.26.0 are included in this release: New binaries and changes to supported environments New -XX:[+|-]AdaptiveGCThreading option added Improved time zone information added to Java dump files Change in default behavior for the balanced garbage collection policy Stop parsing the JAVA_OPTIONS environment variable Global lock reservation enabled by default Increase in default operating system stack size on PPC64 platforms New -x option added to jpackcore / jextract","title":"What's new in version 0.27.1"},{"location":"version0.27/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.27/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.27.1 supports OpenJDK 8, 11, and 16. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.27/#new-xx-adaptivegcthreading-option-added","text":"Adaptive threading is enabled by default, which automatically tunes the number of active parallel garbage collection (GC) threads. When this feature is enabled, the GC thread count is dynamically adjusted from collection cycle to cycle to account for changes in the the amount of time that parallel threads spend doing useful GC work (such as object graph traversal) compared to time spent synchronizing among themselves. When GC work decreases, fewer threads are used, which reduces the overhead, effectively reducing GC pause times. Resources are freed up for other processing activities. Use the -xgcmaxthreads option with the -XX:+AdaptiveGCThreading option to specify a thread count limit.","title":"New -XX:[+|-]AdaptiveGCThreading option added"},{"location":"version0.27/#improved-time-zone-information-added-to-java-dump-files","text":"To help with troubleshooting, additional time zone information is added to Java\u2122 dump files. Two new fields are included, the date and time in UTC ( 1TIDATETIMEUTC ) and the time zone according to the local system ( 1TITIMEZONE ). For more information, see the Java dump TITLE section .","title":"Improved time zone information added to Java dump files"},{"location":"version0.27/#change-in-default-behavior-for-the-balanced-garbage-collection-gc-policy","text":"In this release, a new scan mode, -Xgc:dynamicBreadthFirstScanOrdering , is used during balanced GC copy forward operations that is expected to improve performance. For more information about this type of operation, see GC copy forward operation . You can revert to the behavior in earlier releases by setting -Xgc:breadthFirstScanOrdering when you start your application.","title":"Change in default behavior for the balanced garbage collection (GC) policy"},{"location":"version0.27/#stop-parsing-the-java_options-environment-variable","text":"The 0.24 release started parsing the JAVA_OPTIONS environment variable. This variable was added in error and has been removed. The _JAVA_OPTIONS environment variable (with different behavior) is added for compatibility.","title":"Stop parsing the JAVA_OPTIONS environment variable"},{"location":"version0.27/#global-lock-reservation-enabled-by-default","text":"(AIX\u00ae and Linux on Power Systems\u2122 only) Global lock reservation is now enabled by default. This is an optimization targeted towards more efficient handling of locking and unlocking Java objects. The older locking behavior can be restored via the -XX:-GlobalLockReservation option. See -XX:[+|-]GlobalLockReservation for more details.","title":"Global lock reservation enabled by default"},{"location":"version0.27/#increase-in-default-operating-system-stack-size-on-ppc64-platforms","text":"The default operating system stack size on AIX and Linux PPC64 is increased from 256KB to 512KB. You can change the operating system stack size by using the -Xmso option.","title":"Increase in default operating system stack size on PPC64 platforms"},{"location":"version0.27/#new-x-option-recognized-by-jpackcore-jextract","text":"The new option, -x , causes the system dump to be omitted from the archive created. In its place, the file excluded-files.txt is added, which names the excluded file. For more information, see Dump extractor .","title":"New -x option recognized by jpackcore / jextract"},{"location":"version0.27/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v0.26.0 and v0.27.1 releases, see the Release notes .","title":"Full release information"},{"location":"version0.29.1/","text":"What's new in version 0.29.1 The following new features and notable changes since version 0.29.0 are included in this release: New binaries and changes to supported environments New JDK 17 features Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.29.1 supports OpenJDK 17. AArch64 Linux is now a fully supported, production-ready target for OpenJDK 17. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . New JDK 17 features The following features are supported by OpenJ9: JEP 409 : Sealed Classes Promoted from preview to a production-ready feature in this release. JEP 411 : Deprecate the Security Manager for Removal The following features will be supported by OpenJ9 in a future release: JEP 391 : macOS/AArch64 Port JEP 412 : Foreign Function & Memory API (Incubator) JEP 414 : Vector API (Second Incubator) The following features are implemented in OpenJDK and available in any build of OpenJDK 17 with OpenJ9: JEP 306 : Restore Always-Strict Floating-Point Semantics JEP 356 : Enhanced Pseudo-Random Number Generators JEP 382 : New macOS Rendering Pipeline JEP 398 : Deprecate the Applet API for Removal JEP 403 : Strongly Encapsulate JDK Internals JEP 406 : Pattern Matching for switch (Preview) JEP 407 : Remove RMI Activation JEP 415 : Context-Specific Deserialization Filters You can find the full list of features for JDK 17 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Note: Applications might be adversely affected by JEP 403 if they make use of internal APIs. You should update your application to use standard APIs. To temporarily work around this problem, use --add-opens , --add-exports on the command line for each package required. Full release information To see a complete list of changes between Eclipse OpenJ9 v0.29.0 and v0.29.1 releases, see the Release notes .","title":"Version 0.29.1"},{"location":"version0.29.1/#whats-new-in-version-0291","text":"The following new features and notable changes since version 0.29.0 are included in this release: New binaries and changes to supported environments New JDK 17 features","title":"What's new in version 0.29.1"},{"location":"version0.29.1/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.29.1/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.29.1 supports OpenJDK 17. AArch64 Linux is now a fully supported, production-ready target for OpenJDK 17. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.29.1/#new-jdk-17-features","text":"The following features are supported by OpenJ9: JEP 409 : Sealed Classes Promoted from preview to a production-ready feature in this release. JEP 411 : Deprecate the Security Manager for Removal The following features will be supported by OpenJ9 in a future release: JEP 391 : macOS/AArch64 Port JEP 412 : Foreign Function & Memory API (Incubator) JEP 414 : Vector API (Second Incubator) The following features are implemented in OpenJDK and available in any build of OpenJDK 17 with OpenJ9: JEP 306 : Restore Always-Strict Floating-Point Semantics JEP 356 : Enhanced Pseudo-Random Number Generators JEP 382 : New macOS Rendering Pipeline JEP 398 : Deprecate the Applet API for Removal JEP 403 : Strongly Encapsulate JDK Internals JEP 406 : Pattern Matching for switch (Preview) JEP 407 : Remove RMI Activation JEP 415 : Context-Specific Deserialization Filters You can find the full list of features for JDK 17 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Note: Applications might be adversely affected by JEP 403 if they make use of internal APIs. You should update your application to use standard APIs. To temporarily work around this problem, use --add-opens , --add-exports on the command line for each package required.","title":"New JDK 17 features"},{"location":"version0.29.1/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v0.29.0 and v0.29.1 releases, see the Release notes .","title":"Full release information"},{"location":"version0.29/","text":"What's new in version 0.29.0 The following new features and notable changes since version 0.27.0 are included in this release: New binaries and changes to supported environments JITServer technology is fully supported on some systems New -XX:[+|-]UTFCache option added -Xsoftmx updates for gencon Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.29.0 supports OpenJDK 8 and 11. AArch64 Linux is now a fully supported, production-ready target for OpenJDK 8 and 11. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . JITServer technology is fully supported on some systems JITServer technology is now a fully supported feature on Linux\u00ae on x86 and Linux on IBM Power\u00ae systems (64-bit only). This feature remains a technical preview for Linux on IBM Z\u00ae systems (64-bit only). For more information, see JITServer technology . New -XX:[+|-]UTFCache option added A UTF to String cache is added to enhance reflection performance. The cache is enabled by default but can be disabled using the -XX:[+|-]UTFCache option. -Xsoftmx updates for gencon When using gencon, the -Xsoftmx limit is proportional to the maximum amount of nursery space specified relative to the -Xmx value. Full release information To see a complete list of changes between Eclipse OpenJ9 v0.27.0 and v0.29.0 releases, see the Release notes .","title":"Version 0.29.0"},{"location":"version0.29/#whats-new-in-version-0290","text":"The following new features and notable changes since version 0.27.0 are included in this release: New binaries and changes to supported environments JITServer technology is fully supported on some systems New -XX:[+|-]UTFCache option added -Xsoftmx updates for gencon","title":"What's new in version 0.29.0"},{"location":"version0.29/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.29/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.29.0 supports OpenJDK 8 and 11. AArch64 Linux is now a fully supported, production-ready target for OpenJDK 8 and 11. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.29/#jitserver-technology-is-fully-supported-on-some-systems","text":"JITServer technology is now a fully supported feature on Linux\u00ae on x86 and Linux on IBM Power\u00ae systems (64-bit only). This feature remains a technical preview for Linux on IBM Z\u00ae systems (64-bit only). For more information, see JITServer technology .","title":"JITServer technology is fully supported on some systems"},{"location":"version0.29/#new-xx-utfcache-option-added","text":"A UTF to String cache is added to enhance reflection performance. The cache is enabled by default but can be disabled using the -XX:[+|-]UTFCache option.","title":"New -XX:[+|-]UTFCache option added"},{"location":"version0.29/#-xsoftmx-updates-for-gencon","text":"When using gencon, the -Xsoftmx limit is proportional to the maximum amount of nursery space specified relative to the -Xmx value.","title":"-Xsoftmx updates for gencon"},{"location":"version0.29/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v0.27.0 and v0.29.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.30.1/","text":"What's new in version 0.30.1 The following new features and notable changes since version 0.30.0 are included in this release: New binaries and changes to supported environments Creation of system dumps on macOS 12 Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.30.1 supports OpenJDK 8, 11 and 17. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Creation of system dumps on macOS 12 Creation of system (core) dumps on macOS 12 or later is now possible. Known problems and full release information To see known problems and a complete list of changes between Eclipse OpenJ9 v0.30.0 and v0.30.1 releases, see the Release notes .","title":"Version 0.30.1"},{"location":"version0.30.1/#whats-new-in-version-0301","text":"The following new features and notable changes since version 0.30.0 are included in this release: New binaries and changes to supported environments Creation of system dumps on macOS 12","title":"What's new in version 0.30.1"},{"location":"version0.30.1/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.30.1/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.30.1 supports OpenJDK 8, 11 and 17. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.30.1/#creation-of-system-dumps-on-macos-12","text":"Creation of system (core) dumps on macOS 12 or later is now possible.","title":"Creation of system dumps on macOS 12"},{"location":"version0.30.1/#known-problems-and-full-release-information","text":"To see known problems and a complete list of changes between Eclipse OpenJ9 v0.30.0 and v0.30.1 releases, see the Release notes .","title":"Known problems and full release information"},{"location":"version0.30/","text":"What's new in version 0.30.0 The following new features and notable changes since version 0.29.0 are included in this release: New binaries and changes to supported environments Changes to the shared classes cache generation number Ignored options now captured in java dumps New -XX:[+|-]EnsureHashed option added Redesigned heap resizing for the balanced GC policy Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.30.0 supports OpenJDK 8, 11 and 17. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Changes to the shared classes cache generation number The format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache rather than re-creating or reusing an existing cache. To save space, you can remove all existing shared caches unless they are in use by an earlier release. For more information about the -Xshareclasses option, including the destroy options that you can use to remove caches, see -Xshareclasses . Ignored options captured in java dumps For improved compatibility with other Java implementations, OpenJ9 ignores many command-line options. If any were ignored, they are now listed in the java dump files. For example, the command java -Xdump:java:events=vmstop -XX:+UseCompressedOop -XX:CompressedClassSpaceSize=528482304 -version would yield the following in the ENVINFO section after the complete list of all command-line arguments 1CIIGNOREDARGS Ignored Args: 2CIIGNOREDARG -XX:+UseCompressedOop 2CIIGNOREDARG -XX:CompressedClassSpaceSize=528482304 New -XX:[+|-]EnsureHashed option added This option specifies the classes whose objects should be assigned hash values or those classes that should be ignored. This option might improve performance for applications that frequently hash objects of a certain type. See -XX:[+|-]EnsureHashed for more details. Redesigned heap resizing for the balanced GC policy Heap resizing heuristics have been redesigned for the balanced GC policy. This includes both total heap resizing including eden and non-eden components independently, and also balancing between these two components when the heap is fully expanded. The heuristics now combine both the CPU overhead (for Partial GCs as well as Global Mark Phase) and the heap occupancy criteria. The balancing between eden and non-eden for fully expanded heaps is far more dynamic (instead of being mostly fixed in the ratio 1:4). As a consequence, there should typically be less need for heap sizing tuning options, most notably for eden sizing options -Xmn, -Xmns, and -Xmnx . Also, a new soft limit pause target is added for Partial GCs, which defaults to 200ms. This criterion is combined with the PGC CPU overhead criterion for a balanced compromise between minimizing footprint, maximizing throughput, and meeting the paused time target. More details about the new heuristics can be found at: https://blog.openj9.org/2021/09/24/balanced-gc-performance-improvements-eden-heap-sizing-improvements/ The heuristics now obey the following existing options that were previously used for the optthruput , optavgpause , and gencon GC policies: -Xmint/-Xmaxt -Xgc:dnssExpectedTimeRatioMaximum/Minimum The heuristics also use the -Xgc:targetPausetime option that was previously used only for the metronome GC policy. For more information about GC policies, see Garbage collection policies . Known problems and full release information To see known problems and a complete list of changes between Eclipse OpenJ9 v0.29.0 and v0.30.0 releases, see the Release notes .","title":"Version 0.30.0"},{"location":"version0.30/#whats-new-in-version-0300","text":"The following new features and notable changes since version 0.29.0 are included in this release: New binaries and changes to supported environments Changes to the shared classes cache generation number Ignored options now captured in java dumps New -XX:[+|-]EnsureHashed option added Redesigned heap resizing for the balanced GC policy","title":"What's new in version 0.30.0"},{"location":"version0.30/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.30/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.30.0 supports OpenJDK 8, 11 and 17. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.30/#changes-to-the-shared-classes-cache-generation-number","text":"The format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache rather than re-creating or reusing an existing cache. To save space, you can remove all existing shared caches unless they are in use by an earlier release. For more information about the -Xshareclasses option, including the destroy options that you can use to remove caches, see -Xshareclasses .","title":"Changes to the shared classes cache generation number"},{"location":"version0.30/#ignored-options-captured-in-java-dumps","text":"For improved compatibility with other Java implementations, OpenJ9 ignores many command-line options. If any were ignored, they are now listed in the java dump files. For example, the command java -Xdump:java:events=vmstop -XX:+UseCompressedOop -XX:CompressedClassSpaceSize=528482304 -version would yield the following in the ENVINFO section after the complete list of all command-line arguments 1CIIGNOREDARGS Ignored Args: 2CIIGNOREDARG -XX:+UseCompressedOop 2CIIGNOREDARG -XX:CompressedClassSpaceSize=528482304","title":"Ignored options captured in java dumps"},{"location":"version0.30/#new-xx-ensurehashed-option-added","text":"This option specifies the classes whose objects should be assigned hash values or those classes that should be ignored. This option might improve performance for applications that frequently hash objects of a certain type. See -XX:[+|-]EnsureHashed for more details.","title":"New -XX:[+|-]EnsureHashed option added"},{"location":"version0.30/#redesigned-heap-resizing-for-the-balanced-gc-policy","text":"Heap resizing heuristics have been redesigned for the balanced GC policy. This includes both total heap resizing including eden and non-eden components independently, and also balancing between these two components when the heap is fully expanded. The heuristics now combine both the CPU overhead (for Partial GCs as well as Global Mark Phase) and the heap occupancy criteria. The balancing between eden and non-eden for fully expanded heaps is far more dynamic (instead of being mostly fixed in the ratio 1:4). As a consequence, there should typically be less need for heap sizing tuning options, most notably for eden sizing options -Xmn, -Xmns, and -Xmnx . Also, a new soft limit pause target is added for Partial GCs, which defaults to 200ms. This criterion is combined with the PGC CPU overhead criterion for a balanced compromise between minimizing footprint, maximizing throughput, and meeting the paused time target. More details about the new heuristics can be found at: https://blog.openj9.org/2021/09/24/balanced-gc-performance-improvements-eden-heap-sizing-improvements/ The heuristics now obey the following existing options that were previously used for the optthruput , optavgpause , and gencon GC policies: -Xmint/-Xmaxt -Xgc:dnssExpectedTimeRatioMaximum/Minimum The heuristics also use the -Xgc:targetPausetime option that was previously used only for the metronome GC policy. For more information about GC policies, see Garbage collection policies .","title":"Redesigned heap resizing for the balanced GC policy"},{"location":"version0.30/#known-problems-and-full-release-information","text":"To see known problems and a complete list of changes between Eclipse OpenJ9 v0.29.0 and v0.30.0 releases, see the Release notes .","title":"Known problems and full release information"},{"location":"version0.32/","text":"What's new in version 0.32.0 The following new features and notable changes since version 0.30.0 are included in this release: New binaries and changes to supported environments Creation of system dumps on macOS 12 Support for OpenJDK HotSpot options SharedClassStatistics API updated Support for OpenSSL 3.0.x New -XX:[+|-]OpenJ9CommandLineEnv option added JITServer technology support for Linux on IBM Z\u00ae systems Modified default value for -XX:MaxDirectMemorySize New JDK 18 features Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.32.0 supports OpenJDK 8, 11, 17, and 18. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Creation of system dumps on macOS\u00ae 12 You can now create system (core) dumps on macOS 12 or later. Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:[+|-]ShowHiddenFrames . This option specifies whether generated hidden MethodHandle frames are displayed in a stack trace. SharedClassStatistics API updated You can now use the SharedClassStatistics API to get the name, path, and directory of a shared classes cache. Depending on the operating system, you can also get the number of attached VMs for a non-persistent cache. This information is available through the following new methods: cacheDir() , cacheName() , cachePath() , and numberAttached() . For more information, see the API documentation. Support for OpenSSL 3.0.x OpenSSL 3.0.x is supported but on Linux only. The JITServer technology feature currently does not support OpenSSL 3.0.x. For more information about OpenSSL support, see Cryptographic operations . New -XX:[+|-]OpenJ9CommandLineEnv option added This option specifies whether the VM captures the command line in the environment variable OPENJ9_JAVA_COMMAND_LINE . For more information, see -XX:[+|-]OpenJ9CommandLineEnv . JITServer support for Linux on IBM Z\u00ae systems JITServer technology is now a fully supported feature on Linux on IBM Z\u00ae systems (64-bit only). For more information, see JITServer technology . Modified default value for -XX:MaxDirectMemorySize The default value of the -XX:MaxDirectMemorySize option, which limits the amount of heap memory that is used for direct byte buffers, is now the same as the maximum heap size. New JDK 18 features The following features are supported by OpenJ9: JEP 400 : UTF-8 by Default JEP 416 : Reimplement Core Reflection with Method Handles JEP 421 : Deprecate Finalization for Removal The following features will be supported by OpenJ9 in a future release: JEP 391 : macOS/AArch64 Port An early access build is available in this release JEP 417 : Vector API (Third Incubator) JEP 419 : Foreign Function & Memory API (Second Incubator) The following features are implemented in OpenJDK and available in any build of OpenJDK 18 with OpenJ9: JEP 408 : Simple Web Server JEP 413 : Code Snippets in Java API Documentation JEP 418 : Internet-Address Resolution SPI JEP 420 : Pattern Matching for switch (Second Preview) You can find the full list of features for JDK 18 at the OpenJDK project . Known problems and full release information To see known problems and a complete list of changes between Eclipse OpenJ9 v0.30.0 and v0.32.0 releases, see the Release notes .","title":"Version 0.32.0"},{"location":"version0.32/#whats-new-in-version-0320","text":"The following new features and notable changes since version 0.30.0 are included in this release: New binaries and changes to supported environments Creation of system dumps on macOS 12 Support for OpenJDK HotSpot options SharedClassStatistics API updated Support for OpenSSL 3.0.x New -XX:[+|-]OpenJ9CommandLineEnv option added JITServer technology support for Linux on IBM Z\u00ae systems Modified default value for -XX:MaxDirectMemorySize New JDK 18 features","title":"What's new in version 0.32.0"},{"location":"version0.32/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.32/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.32.0 supports OpenJDK 8, 11, 17, and 18. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.32/#creation-of-system-dumps-on-macos-12","text":"You can now create system (core) dumps on macOS 12 or later.","title":"Creation of system dumps on macOS&reg; 12"},{"location":"version0.32/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:[+|-]ShowHiddenFrames . This option specifies whether generated hidden MethodHandle frames are displayed in a stack trace.","title":"Support for OpenJDK HotSpot options"},{"location":"version0.32/#sharedclassstatistics-api-updated","text":"You can now use the SharedClassStatistics API to get the name, path, and directory of a shared classes cache. Depending on the operating system, you can also get the number of attached VMs for a non-persistent cache. This information is available through the following new methods: cacheDir() , cacheName() , cachePath() , and numberAttached() . For more information, see the API documentation.","title":"SharedClassStatistics API updated"},{"location":"version0.32/#support-for-openssl-30x","text":"OpenSSL 3.0.x is supported but on Linux only. The JITServer technology feature currently does not support OpenSSL 3.0.x. For more information about OpenSSL support, see Cryptographic operations .","title":"Support for OpenSSL 3.0.x"},{"location":"version0.32/#new-xx-openj9commandlineenv-option-added","text":"This option specifies whether the VM captures the command line in the environment variable OPENJ9_JAVA_COMMAND_LINE . For more information, see -XX:[+|-]OpenJ9CommandLineEnv .","title":"New -XX:[+|-]OpenJ9CommandLineEnv option added"},{"location":"version0.32/#jitserver-support-for-linux-on-ibm-z-systems","text":"JITServer technology is now a fully supported feature on Linux on IBM Z\u00ae systems (64-bit only). For more information, see JITServer technology .","title":"JITServer support for Linux on IBM Z&reg; systems"},{"location":"version0.32/#modified-default-value-for-xxmaxdirectmemorysize","text":"The default value of the -XX:MaxDirectMemorySize option, which limits the amount of heap memory that is used for direct byte buffers, is now the same as the maximum heap size.","title":"Modified default value for -XX:MaxDirectMemorySize"},{"location":"version0.32/#new-jdk-18-features","text":"The following features are supported by OpenJ9: JEP 400 : UTF-8 by Default JEP 416 : Reimplement Core Reflection with Method Handles JEP 421 : Deprecate Finalization for Removal The following features will be supported by OpenJ9 in a future release: JEP 391 : macOS/AArch64 Port An early access build is available in this release JEP 417 : Vector API (Third Incubator) JEP 419 : Foreign Function & Memory API (Second Incubator) The following features are implemented in OpenJDK and available in any build of OpenJDK 18 with OpenJ9: JEP 408 : Simple Web Server JEP 413 : Code Snippets in Java API Documentation JEP 418 : Internet-Address Resolution SPI JEP 420 : Pattern Matching for switch (Second Preview) You can find the full list of features for JDK 18 at the OpenJDK project .","title":"New JDK 18 features"},{"location":"version0.32/#known-problems-and-full-release-information","text":"To see known problems and a complete list of changes between Eclipse OpenJ9 v0.30.0 and v0.32.0 releases, see the Release notes .","title":"Known problems and full release information"},{"location":"version0.33/","text":"What's new in version 0.33.x The following new features and notable changes since version 0.32.0 are included in this release: New binaries and changes to supported environments JITServer technology feature updated XL C++ Runtime required on AIX Linux reference compiler updated to gcc 10.3 The maximum number of JIT compilation threads is increased Default operating system stack size increased on x64 platforms Control groups v2 support Support for OpenSSL 3.0.x Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.33.x supports OpenJDK 8, 11, 17, and 18. OpenJ9 Windows\u00ae builds for OpenJDK 8 are now compiled with Microsoft\u00ae Visual Studio 2017. The Visual Studio redistributable files included with the build are updated to match. Note: Binaries that are labeled 0.33.1 include additional bug fixes. For more information, see the release notes . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . JITServer technology feature updated The JITServer technology feature is updated to provide the following new capabilities, which are disabled by default: The caching of AOT-compiled methods on the server. The AOT cache improves CPU usage when clients request the compilation of methods that were previously cached. Use the -XX:+JITServerUseAOTCache command line option to enable this feature. The provision of metrics to a monitoring tool that follows the OpenMetrics standard. The following metrics are available for a JITServer server: CPU usage, available memory, number of clients connected, and number of active compilation threads. Use the -XX:+JITServerMetrics command line option to enable this feature. XL C++ Runtime required on AIX AIX OpenJ9 builds now require version 16.1 of the IBM XL C++ Runtime . This was already required for OpenJDK 17 and is now also required from 11.0.16 to accommodate a security update to the HarfBuzz text shaping library. Linux reference compiler updated to gcc 10.3 Linux\u00ae builds for all platforms now use gcc 10.3 instead of gcc 7.5. See the list of build environments . The maximum number of JIT compilation threads is increased The maximum number of JIT compilation threads is increased from 7 to 15. If the JITServer feature is enabled, the maximum number of JIT compilation threads is increased further on the server, to 999. You can set the number of compilation threads to be used by specifying the -XcompilationThreads command line option. Default operating system stack size increased on x64 platforms The default operating system stack size on Windows x64, macOS\u00ae x64, and Linux x64 platforms is increased from 256 KB to 512 KB to accommodate vector support. You can change the operating system stack size by using the -Xmso option. Control groups v2 support The Linux kernel has two variants of control groups (cgroups): v1 and v2 . Many Linux operating systems are gradually transitioning from cgroups v1 to v2 as their default choice. Now, OpenJ9 has added cgroups v2 support, which is identical to the support for cgroups v1. Support for OpenSSL 3.0.x The JITServer technology feature now supports OpenSSL 3.0.x. For more information about OpenSSL support, see Cryptographic operations . Known problems and full release information To see known problems and a complete list of changes between Eclipse OpenJ9 v0.32.0 and v0.33.x, see the Release notes .","title":"Version 0.33.x"},{"location":"version0.33/#whats-new-in-version-033x","text":"The following new features and notable changes since version 0.32.0 are included in this release: New binaries and changes to supported environments JITServer technology feature updated XL C++ Runtime required on AIX Linux reference compiler updated to gcc 10.3 The maximum number of JIT compilation threads is increased Default operating system stack size increased on x64 platforms Control groups v2 support Support for OpenSSL 3.0.x","title":"What's new in version 0.33.x"},{"location":"version0.33/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.33/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.33.x supports OpenJDK 8, 11, 17, and 18. OpenJ9 Windows\u00ae builds for OpenJDK 8 are now compiled with Microsoft\u00ae Visual Studio 2017. The Visual Studio redistributable files included with the build are updated to match. Note: Binaries that are labeled 0.33.1 include additional bug fixes. For more information, see the release notes . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.33/#jitserver-technology-feature-updated","text":"The JITServer technology feature is updated to provide the following new capabilities, which are disabled by default: The caching of AOT-compiled methods on the server. The AOT cache improves CPU usage when clients request the compilation of methods that were previously cached. Use the -XX:+JITServerUseAOTCache command line option to enable this feature. The provision of metrics to a monitoring tool that follows the OpenMetrics standard. The following metrics are available for a JITServer server: CPU usage, available memory, number of clients connected, and number of active compilation threads. Use the -XX:+JITServerMetrics command line option to enable this feature.","title":"JITServer technology feature updated"},{"location":"version0.33/#xl-c-runtime-required-on-aix","text":"AIX OpenJ9 builds now require version 16.1 of the IBM XL C++ Runtime . This was already required for OpenJDK 17 and is now also required from 11.0.16 to accommodate a security update to the HarfBuzz text shaping library.","title":"XL C++ Runtime required on AIX"},{"location":"version0.33/#linux-reference-compiler-updated-to-gcc-103","text":"Linux\u00ae builds for all platforms now use gcc 10.3 instead of gcc 7.5. See the list of build environments .","title":"Linux reference compiler updated to gcc 10.3"},{"location":"version0.33/#the-maximum-number-of-jit-compilation-threads-is-increased","text":"The maximum number of JIT compilation threads is increased from 7 to 15. If the JITServer feature is enabled, the maximum number of JIT compilation threads is increased further on the server, to 999. You can set the number of compilation threads to be used by specifying the -XcompilationThreads command line option.","title":"The maximum number of JIT compilation threads is increased"},{"location":"version0.33/#default-operating-system-stack-size-increased-on-x64-platforms","text":"The default operating system stack size on Windows x64, macOS\u00ae x64, and Linux x64 platforms is increased from 256 KB to 512 KB to accommodate vector support. You can change the operating system stack size by using the -Xmso option.","title":"Default operating system stack size increased on x64 platforms"},{"location":"version0.33/#control-groups-v2-support","text":"The Linux kernel has two variants of control groups (cgroups): v1 and v2 . Many Linux operating systems are gradually transitioning from cgroups v1 to v2 as their default choice. Now, OpenJ9 has added cgroups v2 support, which is identical to the support for cgroups v1.","title":"Control groups v2 support"},{"location":"version0.33/#support-for-openssl-30x","text":"The JITServer technology feature now supports OpenSSL 3.0.x. For more information about OpenSSL support, see Cryptographic operations .","title":"Support for OpenSSL 3.0.x"},{"location":"version0.33/#known-problems-and-full-release-information","text":"To see known problems and a complete list of changes between Eclipse OpenJ9 v0.32.0 and v0.33.x, see the Release notes .","title":"Known problems and full release information"},{"location":"version0.35/","text":"What's new in version 0.35.0 The following new features and notable changes since version 0.33.1 are included in this release: New binaries and changes to supported environments Java\u2122 dump files contain more information about waiting threads New -XX:[+|-]ShowNativeStackSymbols option added New user2 event added for the -Xdump option New -XX:[+|-]PerfTool option added New default options added in the options.default file New options added to encrypt the JITServer exported metrics XL C++ Runtime 16.1.0.7 or later required on AIX -XX:[+|-]JITServerLocalSyncCompiles enabled by default Support for changes to the maintenance specifications of JSR 337 in Java 8 Features and changes Binaries and supported environments Eclipse OpenJ9\u2122 release 0.35.0 supports OpenJDK 8, 11, and 17. OpenJ9 Windows\u00ae builds for OpenJDK 11 are now compiled with Microsoft\u00ae Visual Studio 2019. The Visual Studio redistributable files included with the build are updated to match. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Java dump files contain more information about waiting threads For threads that are waiting for a class initialization lock, the Java dump output now shows the thread that is currently working to progress the initialization of the class. This thread is indicated by the new Initializing thread: <thread_name> string in the existing 3XMTHREADBLOCK line in the Java dump output. For example: 3XMTHREADBLOCK Waiting on: java/lang/J9VMInternals$ClassInitializationLock@0x00000000FFF5DC90 Owned by: <unowned> Initializing thread: \"Class Initialization Thread 1\" For more information, see Threads . New -XX:[+|-]ShowNativeStackSymbols option added This option controls whether Java dumps show the names of functions in native call stacks. For more information, see -XX:[+|-]ShowNativeStackSymbols . New user2 event added for the -Xdump option On operating systems other than Windows\u2122, you can now use the user2 event for the -Xdump option. This event is triggered when the VM receives the SIGUSR2 signal. There is a change in the SIGUSR2 signal behavior as well whereby, the process does not exit in response to this signal. For more information, see -Xdump and Signal handling . New -XX:[+|-]PerfTool option added This option enables or disables the JIT support for the perf tool without affecting the existing Xjit options. Since this option creates a file that is used by the Linux\u00ae system profiler, perf , it applies only to Linux. For more information, see -XX:[+|-]PerfTool . New default options added in the options.default file -XX:+EnsureHashed:java/lang/Class,java/lang/Thread is added to the list of default options in the options.default file to improve performance. For more information, see XX:[+|-]EnsureHashed . New options added to encrypt the JITServer exported metrics You can use the -XX:JITServerMetricsSSLKey and -XX:JITServerMetricsSSLCert options to encrypt the custom metrics with TLS or SSL. XL C++ Runtime 16.1.0.7 or later required on AIX AIX OpenJ9 builds now require version 16.1.0.7 or later of the IBM XL C++ Runtime . -XX:[+|-]JITServerLocalSyncCompiles enabled by default The -XX:[+|-]JITServerLocalSyncCompiles option is now enabled by default in most cases. For more information, see -XX:[+|-]JITServerLocalSyncCompiles . Support for changes to the maintenance specifications of JSR 337 in Java 8 OpenJ9 now supports changes to the maintenance specifications in Java 8 as listed in the JSR 337 Maintenance Release 4 document. These changes include the change in the garbage collector behavior for handling the phantom references in Java 8. The garbage collector handles both the phantom as well as the weak references similarly, which is the current behavior in Java 11 and later. For more information, see Weak reference processing . Known problems and full release information To see known problems and a complete list of changes between Eclipse OpenJ9 v0.33.1 and v0.35.0 releases, see the Release notes .","title":"Version 0.35.0"},{"location":"version0.35/#whats-new-in-version-0350","text":"The following new features and notable changes since version 0.33.1 are included in this release: New binaries and changes to supported environments Java\u2122 dump files contain more information about waiting threads New -XX:[+|-]ShowNativeStackSymbols option added New user2 event added for the -Xdump option New -XX:[+|-]PerfTool option added New default options added in the options.default file New options added to encrypt the JITServer exported metrics XL C++ Runtime 16.1.0.7 or later required on AIX -XX:[+|-]JITServerLocalSyncCompiles enabled by default Support for changes to the maintenance specifications of JSR 337 in Java 8","title":"What's new in version 0.35.0"},{"location":"version0.35/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.35/#binaries-and-supported-environments","text":"Eclipse OpenJ9\u2122 release 0.35.0 supports OpenJDK 8, 11, and 17. OpenJ9 Windows\u00ae builds for OpenJDK 11 are now compiled with Microsoft\u00ae Visual Studio 2019. The Visual Studio redistributable files included with the build are updated to match. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.35/#java-dump-files-contain-more-information-about-waiting-threads","text":"For threads that are waiting for a class initialization lock, the Java dump output now shows the thread that is currently working to progress the initialization of the class. This thread is indicated by the new Initializing thread: <thread_name> string in the existing 3XMTHREADBLOCK line in the Java dump output. For example: 3XMTHREADBLOCK Waiting on: java/lang/J9VMInternals$ClassInitializationLock@0x00000000FFF5DC90 Owned by: <unowned> Initializing thread: \"Class Initialization Thread 1\" For more information, see Threads .","title":"Java dump files contain more information about waiting threads"},{"location":"version0.35/#new-xx-shownativestacksymbols-option-added","text":"This option controls whether Java dumps show the names of functions in native call stacks. For more information, see -XX:[+|-]ShowNativeStackSymbols .","title":"New -XX:[+|-]ShowNativeStackSymbols option added"},{"location":"version0.35/#new-user2-event-added-for-the-xdump-option","text":"On operating systems other than Windows\u2122, you can now use the user2 event for the -Xdump option. This event is triggered when the VM receives the SIGUSR2 signal. There is a change in the SIGUSR2 signal behavior as well whereby, the process does not exit in response to this signal. For more information, see -Xdump and Signal handling .","title":"New user2 event added for the -Xdump option"},{"location":"version0.35/#new-xx-perftool-option-added","text":"This option enables or disables the JIT support for the perf tool without affecting the existing Xjit options. Since this option creates a file that is used by the Linux\u00ae system profiler, perf , it applies only to Linux. For more information, see -XX:[+|-]PerfTool .","title":"New -XX:[+|-]PerfTool option added"},{"location":"version0.35/#new-default-options-added-in-the-optionsdefault-file","text":"-XX:+EnsureHashed:java/lang/Class,java/lang/Thread is added to the list of default options in the options.default file to improve performance. For more information, see XX:[+|-]EnsureHashed .","title":"New default options added in the options.default file"},{"location":"version0.35/#new-options-added-to-encrypt-the-jitserver-exported-metrics","text":"You can use the -XX:JITServerMetricsSSLKey and -XX:JITServerMetricsSSLCert options to encrypt the custom metrics with TLS or SSL.","title":"New options added to encrypt the JITServer exported metrics"},{"location":"version0.35/#xl-c-runtime-16107-or-later-required-on-aix","text":"AIX OpenJ9 builds now require version 16.1.0.7 or later of the IBM XL C++ Runtime .","title":"XL C++ Runtime 16.1.0.7 or later required on AIX"},{"location":"version0.35/#-xx-jitserverlocalsynccompiles-enabled-by-default","text":"The -XX:[+|-]JITServerLocalSyncCompiles option is now enabled by default in most cases. For more information, see -XX:[+|-]JITServerLocalSyncCompiles .","title":"-XX:[+|-]JITServerLocalSyncCompiles enabled by default"},{"location":"version0.35/#support-for-changes-to-the-maintenance-specifications-of-jsr-337-in-java-8","text":"OpenJ9 now supports changes to the maintenance specifications in Java 8 as listed in the JSR 337 Maintenance Release 4 document. These changes include the change in the garbage collector behavior for handling the phantom references in Java 8. The garbage collector handles both the phantom as well as the weak references similarly, which is the current behavior in Java 11 and later. For more information, see Weak reference processing .","title":"Support for changes to the maintenance specifications of JSR 337 in Java 8"},{"location":"version0.35/#known-problems-and-full-release-information","text":"To see known problems and a complete list of changes between Eclipse OpenJ9 v0.33.1 and v0.35.0 releases, see the Release notes .","title":"Known problems and full release information"},{"location":"version0.8/","text":"Release notes - version 0.8.0 Version 0.8.0 is the first release of Eclipse OpenJ9\u2122, as defined in the release plan . This release supports OpenJDK Version 8 binaries at AdoptOpenJDK.net that contain the Eclipse OpenJ9 virtual machine. For more information about supported platforms, and any issues and limitations, read the OpenJ9 GitHub release notes .","title":"Version 0.8.0"},{"location":"version0.8/#release-notes-version-080","text":"Version 0.8.0 is the first release of Eclipse OpenJ9\u2122, as defined in the release plan . This release supports OpenJDK Version 8 binaries at AdoptOpenJDK.net that contain the Eclipse OpenJ9 virtual machine. For more information about supported platforms, and any issues and limitations, read the OpenJ9 GitHub release notes .","title":"Release notes - version 0.8.0"},{"location":"version0.9/","text":"What's new in version 0.9.0 The following new features and notable changes from v.0.8.0 are included in this release: New binaries and supported environments. The idle tuning feature is now supported on Linux running on Power\u00ae Systems and IBM Z\u00ae Systems. A new Garbage Collection (GC) policy is available that performs no housekeeping. A command line option is provided to automatically set a larger Java heap size for applications that run in containers. You can now specify the maximum Java heap size as a percentage value. The shared classes feature now supports nested jar files. System dump data can now be read to help diagnose problems on Linux and Windows platforms. There are notable changes to the java.lang.String class. There are notable changes to the com.ibm.oti.shared.SharedClassCacheInfo class. New JDK 9 features New JDK 10 features Features and changes Binaries and supported platforms The following additional OpenJDK binaries that contain the Eclipse OpenJ9\u2122 VM are now available from the AdoptOpenJDK community: OpenJDK version 10 OpenJDK version 8 for 32-bit Windows OpenJDK version 8 for x86 64-bit Linux (Large Heap) for Java heaps >57 GB. Complete platform support information for OpenJ9 can be found in Supported environments Idle tuning feature The idle tuning feature in OpenJ9 keeps your memory footprint small by releasing unused memory back to the operating system. Prior to Eclipse version 0.9.0 this feature was available only on Linux x86 architectures with the gencon garbage collection policy. From version 0.9.0, this feature is now available on Linux for IBM POWER\u00ae and IBM Z\u00ae architectures. For more information about this feature, see the following command line options, which control this behavior: -XX:[+|-]IdleTuningCompactOnIdle -XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle The following blog post describes the benefits of using this feature: Are you still paying for unused memory when your Java app is idle? New GC policy A new GC policy is introduced for JEP 318: Epsilon: A No-Op Garbage Collector . When this policy is enabled, the Java object heap is expanded in the normal way until the limit is reached, but memory is not reclaimed through garbage collection. When the limit is reached the VM shuts down. This JEP has a number of use cases including short-lived applications and certain test scenarios. To enable this policy you can use one of the following options: -Xgcpolicy:nogc -XX:+UseNoGC Modifying the default Java heap size for applications that run in containers When using container technology, applications are typically run on their own and do not need to compete for memory. In this release, changes are introduced to detect when OpenJ9 is running inside a container. If your application is running in a container and you want the VM to allocate a larger fraction of memory to the Java heap, set the -XX:+UseContainerSupport option on the command line. The following table shows the maximum Java heap size that gets set, depending on the memory available: Physical memory <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512M Greater than 2 GB 75% <size> The default heap size for containers only takes affect when running in a container environment and when -XX:+UseContainerSupport is specified, which is expected to be the default in a future release. Specifying the maximum Java heap size as a percentage value OpenJ9 now supports setting the heap size as a percentage of the physical memory. The following OpenJDK options are recognized and can be set for the VM: -XX:MaxRAMPercentage -XX:InitialRAMPercentage To understand how to set these options, see -XX:InitialRAMPercentage / -XX:MaxRAMPercentage . If your application is running in a container and you have specified -XX:+UseContainerSupport , as described in Modifying the default Java heap size for applications that run in containers , both the default heap size for containers and the -XX:MaxRAMPercentage and -XX:InitialRAMPercentage options are based on the available container memory. Shared classes support for nested jar files Changes are made to the com.ibm.oti.shared API to support nested jar files. Direct Dump Reader enabled on Linux and Windows Direct Dump Reader (DDR) support is now enabled for the OpenJ9 VM on all Linux architectures and on Windows. The DDR code enables the VM to read system dump data by using the OpenJ9 Diagnostic Tool Framework for Java (DTFJ) API or the jdmpview tool. If you use the Eclipse Memory Analyzer\u2122 tool (MAT) , you can also analyze OpenJ9 or IBM VMs by installing the DTFJ plugin. (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java) You must use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core. This restriction will be fixed in a later version of OpenJ9. Changes to the java.lang.String class To match the behavior of OpenJDK, java.lang.String no longer has a count field, which changes the way that String.subString() works compared to Java 8. String.subString() now copies the value array. Similarly, StringBuffer and StringBuilder do not share the value array with any String created by toString() . For performance and compatibility with the new String object layout, the OpenJ9 implementations of StringBuffer and StringBuilder have been deprecated in favor of the OpenJDK implementations. Changes to the SharedClassCacheInfo class SharedClassCacheInfo.getCacheJVMLevel() used to return the JVMLEVEL constant that maps to a Java version number, for example JVMLEVEL_JAVA8 . This call now returns only the Java version number, for example 10 for Java 10. New JDK 9 features The following features are supported by OpenJ9: JEP 102 : Process API Updates JEP 110 : HTTP 2 Client JEP 143 : Improve Contended Locking JEP 193 : Variable Handles JEP 199 : Smart Java Compilation, Phase Two JEP 200 : The Modular JDK JEP 201 : Modular Source Code JEP 211 : Elide Deprecation Warnings on Import Statements JEP 213 : Milling Project Coin JEP 215 : Tiered Attribution for javac JEP 216 : Process Import Statements Correctly JEP 217 : Annotations Pipeline 2.0 JEP 219 : Datagram Transport Layer Security (DTLS) JEP 220 : Modular Run-Time Images JEP 221 : Simplified Doclet API JEP 222 : jshell: The Java Shell (Read-Eval-Print Loop) JEP 223 : New Version-String Scheme JEP 224 : HTML5 Javadoc JEP 225 : Javadoc Search JEP 226 : UTF-8 Property Files JEP 227 : Unicode 7.0 JEP 229 : Create PKCS12 Keystores by Default JEP 232 : Improve Secure Application Performance JEP 235 : Test Class-File Attributes Generated by javac JEP 236 : Parser API for Nashorn JEP 238 : Multi-Release JAR Files JEP 240 : Remove the JVM TI hprof Agent JEP 241 : Remove the jhat Tool JEP 244 : TLS Application-Layer Protocol Negotiation Extension JEP 247 : Compile for Older Platform Versions JEP 249 : OCSP Stapling for TLS JEP 251 : Multi-Resolution Images JEP 252 : Use CLDR Locale Data by Default JEP 253 : Prepare JavaFX UI Controls and CSS APIs for Modularization JEP 254 : Compact Strings (not enabled by default) JEP 255 : Merge Selected Xerces 2.11.0 Updates into JAXP JEP 256 : BeanInfo Annotations JEP 257 : Update JavaFX/Media to Newer Version of GStreamer JEP 258 : HarfBuzz Font-Layout Engine JEP 259 : Stack-Walking API JEP 260 : Encapsulate Most Internal APIs JEP 261 : Module System JEP 262 : TIFF Image I/O JEP 263 : HiDPI Graphics on Windows and Linux\u00ae JEP 264 : Platform Logging API and Service JEP 265 : Marlin Graphics Renderer JEP 266 : More Concurrency Updates JEP 267 : Unicode 8.0 JEP 268 : XML Catalogs JEP 269 : Convenience Factory Methods for Collections JEP 272 : Platform-Specific Desktop Features JEP 273 : DRBG-Based SecureRandom Implementations JEP 274 : Enhanced Method Handles JEP 275 : Modular Java Application Packaging JEP 276 : Dynamic Linking of Language-Defined Object Models JEP 277 : Enhanced Deprecation JEP 280 : Indify String Concatenation JEP 282 : jlink: The Java Linker JEP 283 : Enable GTK 3 on Linux JEP 285 : Spin-Wait Hints JEP 287 : SHA-3 Hash Algorithms JEP 288 : Disable SHA-1 Certificates JEP 289 : Deprecate the Applet API JEP 290 : Filter Incoming Serialization Data JEP 292 : Implement Selected ECMAScript 6 Features in Nashorn JEP 298 : Remove Demos and Samples JEP 299 : Reorganize Documentation You can find the full list of features for JDK 9 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. New JDK 10 features The following features are supported by OpenJ9: JEP 286 : Local-Variable Type Inference JEP 313 : Remove the Native-Header Generation Tool (javah) JEP 314 : Additional Unicode Language-Tag Extensions JEP 319 : Root Certificates JEP 322 : Time-Based Release Versioning You can find the full list of features for JDK 10 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9. Full release information To see a complete list of changes between Eclipse OpenJ9 version 0.8.0 and version 0.9.0 releases, see the Release notes .","title":"Version 0.9.0"},{"location":"version0.9/#whats-new-in-version-090","text":"The following new features and notable changes from v.0.8.0 are included in this release: New binaries and supported environments. The idle tuning feature is now supported on Linux running on Power\u00ae Systems and IBM Z\u00ae Systems. A new Garbage Collection (GC) policy is available that performs no housekeeping. A command line option is provided to automatically set a larger Java heap size for applications that run in containers. You can now specify the maximum Java heap size as a percentage value. The shared classes feature now supports nested jar files. System dump data can now be read to help diagnose problems on Linux and Windows platforms. There are notable changes to the java.lang.String class. There are notable changes to the com.ibm.oti.shared.SharedClassCacheInfo class. New JDK 9 features New JDK 10 features","title":"What's new in version 0.9.0"},{"location":"version0.9/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.9/#binaries-and-supported-platforms","text":"The following additional OpenJDK binaries that contain the Eclipse OpenJ9\u2122 VM are now available from the AdoptOpenJDK community: OpenJDK version 10 OpenJDK version 8 for 32-bit Windows OpenJDK version 8 for x86 64-bit Linux (Large Heap) for Java heaps >57 GB. Complete platform support information for OpenJ9 can be found in Supported environments","title":"Binaries and supported platforms"},{"location":"version0.9/#idle-tuning-feature","text":"The idle tuning feature in OpenJ9 keeps your memory footprint small by releasing unused memory back to the operating system. Prior to Eclipse version 0.9.0 this feature was available only on Linux x86 architectures with the gencon garbage collection policy. From version 0.9.0, this feature is now available on Linux for IBM POWER\u00ae and IBM Z\u00ae architectures. For more information about this feature, see the following command line options, which control this behavior: -XX:[+|-]IdleTuningCompactOnIdle -XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle The following blog post describes the benefits of using this feature: Are you still paying for unused memory when your Java app is idle?","title":"Idle tuning feature"},{"location":"version0.9/#new-gc-policy","text":"A new GC policy is introduced for JEP 318: Epsilon: A No-Op Garbage Collector . When this policy is enabled, the Java object heap is expanded in the normal way until the limit is reached, but memory is not reclaimed through garbage collection. When the limit is reached the VM shuts down. This JEP has a number of use cases including short-lived applications and certain test scenarios. To enable this policy you can use one of the following options: -Xgcpolicy:nogc -XX:+UseNoGC","title":"New GC policy"},{"location":"version0.9/#modifying-the-default-java-heap-size-for-applications-that-run-in-containers","text":"When using container technology, applications are typically run on their own and do not need to compete for memory. In this release, changes are introduced to detect when OpenJ9 is running inside a container. If your application is running in a container and you want the VM to allocate a larger fraction of memory to the Java heap, set the -XX:+UseContainerSupport option on the command line. The following table shows the maximum Java heap size that gets set, depending on the memory available: Physical memory <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512M Greater than 2 GB 75% <size> The default heap size for containers only takes affect when running in a container environment and when -XX:+UseContainerSupport is specified, which is expected to be the default in a future release.","title":"Modifying the default Java heap size for applications that run in containers"},{"location":"version0.9/#specifying-the-maximum-java-heap-size-as-a-percentage-value","text":"OpenJ9 now supports setting the heap size as a percentage of the physical memory. The following OpenJDK options are recognized and can be set for the VM: -XX:MaxRAMPercentage -XX:InitialRAMPercentage To understand how to set these options, see -XX:InitialRAMPercentage / -XX:MaxRAMPercentage . If your application is running in a container and you have specified -XX:+UseContainerSupport , as described in Modifying the default Java heap size for applications that run in containers , both the default heap size for containers and the -XX:MaxRAMPercentage and -XX:InitialRAMPercentage options are based on the available container memory.","title":"Specifying the maximum Java heap size as a percentage value"},{"location":"version0.9/#shared-classes-support-for-nested-jar-files","text":"Changes are made to the com.ibm.oti.shared API to support nested jar files.","title":"Shared classes support for nested jar files"},{"location":"version0.9/#direct-dump-reader-enabled-on-linux-and-windows","text":"Direct Dump Reader (DDR) support is now enabled for the OpenJ9 VM on all Linux architectures and on Windows. The DDR code enables the VM to read system dump data by using the OpenJ9 Diagnostic Tool Framework for Java (DTFJ) API or the jdmpview tool. If you use the Eclipse Memory Analyzer\u2122 tool (MAT) , you can also analyze OpenJ9 or IBM VMs by installing the DTFJ plugin. (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java) You must use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core. This restriction will be fixed in a later version of OpenJ9.","title":"Direct Dump Reader enabled on Linux and Windows"},{"location":"version0.9/#changes-to-the-javalangstring-class","text":"To match the behavior of OpenJDK, java.lang.String no longer has a count field, which changes the way that String.subString() works compared to Java 8. String.subString() now copies the value array. Similarly, StringBuffer and StringBuilder do not share the value array with any String created by toString() . For performance and compatibility with the new String object layout, the OpenJ9 implementations of StringBuffer and StringBuilder have been deprecated in favor of the OpenJDK implementations.","title":"Changes to the java.lang.String class"},{"location":"version0.9/#changes-to-the-sharedclasscacheinfo-class","text":"SharedClassCacheInfo.getCacheJVMLevel() used to return the JVMLEVEL constant that maps to a Java version number, for example JVMLEVEL_JAVA8 . This call now returns only the Java version number, for example 10 for Java 10.","title":"Changes to the SharedClassCacheInfo class"},{"location":"version0.9/#new-jdk-9-features","text":"The following features are supported by OpenJ9: JEP 102 : Process API Updates JEP 110 : HTTP 2 Client JEP 143 : Improve Contended Locking JEP 193 : Variable Handles JEP 199 : Smart Java Compilation, Phase Two JEP 200 : The Modular JDK JEP 201 : Modular Source Code JEP 211 : Elide Deprecation Warnings on Import Statements JEP 213 : Milling Project Coin JEP 215 : Tiered Attribution for javac JEP 216 : Process Import Statements Correctly JEP 217 : Annotations Pipeline 2.0 JEP 219 : Datagram Transport Layer Security (DTLS) JEP 220 : Modular Run-Time Images JEP 221 : Simplified Doclet API JEP 222 : jshell: The Java Shell (Read-Eval-Print Loop) JEP 223 : New Version-String Scheme JEP 224 : HTML5 Javadoc JEP 225 : Javadoc Search JEP 226 : UTF-8 Property Files JEP 227 : Unicode 7.0 JEP 229 : Create PKCS12 Keystores by Default JEP 232 : Improve Secure Application Performance JEP 235 : Test Class-File Attributes Generated by javac JEP 236 : Parser API for Nashorn JEP 238 : Multi-Release JAR Files JEP 240 : Remove the JVM TI hprof Agent JEP 241 : Remove the jhat Tool JEP 244 : TLS Application-Layer Protocol Negotiation Extension JEP 247 : Compile for Older Platform Versions JEP 249 : OCSP Stapling for TLS JEP 251 : Multi-Resolution Images JEP 252 : Use CLDR Locale Data by Default JEP 253 : Prepare JavaFX UI Controls and CSS APIs for Modularization JEP 254 : Compact Strings (not enabled by default) JEP 255 : Merge Selected Xerces 2.11.0 Updates into JAXP JEP 256 : BeanInfo Annotations JEP 257 : Update JavaFX/Media to Newer Version of GStreamer JEP 258 : HarfBuzz Font-Layout Engine JEP 259 : Stack-Walking API JEP 260 : Encapsulate Most Internal APIs JEP 261 : Module System JEP 262 : TIFF Image I/O JEP 263 : HiDPI Graphics on Windows and Linux\u00ae JEP 264 : Platform Logging API and Service JEP 265 : Marlin Graphics Renderer JEP 266 : More Concurrency Updates JEP 267 : Unicode 8.0 JEP 268 : XML Catalogs JEP 269 : Convenience Factory Methods for Collections JEP 272 : Platform-Specific Desktop Features JEP 273 : DRBG-Based SecureRandom Implementations JEP 274 : Enhanced Method Handles JEP 275 : Modular Java Application Packaging JEP 276 : Dynamic Linking of Language-Defined Object Models JEP 277 : Enhanced Deprecation JEP 280 : Indify String Concatenation JEP 282 : jlink: The Java Linker JEP 283 : Enable GTK 3 on Linux JEP 285 : Spin-Wait Hints JEP 287 : SHA-3 Hash Algorithms JEP 288 : Disable SHA-1 Certificates JEP 289 : Deprecate the Applet API JEP 290 : Filter Incoming Serialization Data JEP 292 : Implement Selected ECMAScript 6 Features in Nashorn JEP 298 : Remove Demos and Samples JEP 299 : Reorganize Documentation You can find the full list of features for JDK 9 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9.","title":"New JDK 9 features"},{"location":"version0.9/#new-jdk-10-features","text":"The following features are supported by OpenJ9: JEP 286 : Local-Variable Type Inference JEP 313 : Remove the Native-Header Generation Tool (javah) JEP 314 : Additional Unicode Language-Tag Extensions JEP 319 : Root Certificates JEP 322 : Time-Based Release Versioning You can find the full list of features for JDK 10 at the OpenJDK project . Any remaining features that are listed do not apply to OpenJ9.","title":"New JDK 10 features"},{"location":"version0.9/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 version 0.8.0 and version 0.9.0 releases, see the Release notes .","title":"Full release information"},{"location":"vgclog/","text":"Verbose garbage collection logs Garbage collection (GC) reclaims used memory in the Java\u2122 object heap for reuse. During cleanup of the heap, the verbose GC logs, when enabled, capture information about the different GC operations that are involved in the GC cycles. GC operations aim to reorganize or reclaim memory. Verbose GC logs contain information about GC operations to assist with the following actions: Tuning GC and improving application performance. Troubleshooting GC operations and policies. For example, analyzing long pauses, or determining how free memory is divided in the Java object heap before and after a GC cycle. Verbose GC logs, when enabled, begin capturing information as soon as GC is initialized. To help you visualize and analyze the GC, you can feed verbose GC log files into various diagnostic tools and interfaces. Examples include tools such as Garbage Collection and Memory Visualizer (GCMV) and online services such as GCEasy . For examples of log output, including guidance on how to analyze the logs, see Log examples . A further diagnostic step is to run one or more traces on GC activity by using the -Xtgc option . Trace output provides more granular information to help diagnose GC problems or perform finer tuning. How to generate a verbose GC log You can enable verbose GC logs by specifying the -verbose:gc standard option when you start your application. For more information, see standard command-line options . The output of -verbose:gc is printed to STDERR by default. To print the log output to a file, append the -Xverbosegclog option. You can also use this option to print to a succession of files, where each file logs a specified number of GC cycles. Verbose GC log contents and structure The verbose GC logs are printed in XML format and consist of the following sections: A summary of your GC configuration, which is captured in the <initialized> XML element. Information about the GC cycles that ran, including GC operations and GC increments. For definitions of GC cycles and operations, see Garbage collection . For definitions of GC increments, see GC increments and interleaving . The logs record when GC cycles and their increments start and end, and list the GC operations that run within these increments to manage or reclaim memory. You can also determine which type of event triggered the cycle or increment, and the amount of memory available to your application before and after processing. Initialization The log begins by recording the configuration of the Eclipse OpenJ9\u2122 runtime virtual environment (VM) and details of the GC configuration(GC). The configuration is recorded by using child elements of the <initialized> element, for example: <initialized id=\"1\" timestamp=\"2020-10-18T13:27:07.691\"> <attribute name=\"gcPolicy\" value=\"-Xgcpolicy:gencon\" /> <attribute name=\"maxHeapSize\" value=\"0x40000000\" /> <attribute name=\"initialHeapSize\" value=\"0x40000000\" /> <attribute name=\"compressedRefs\" value=\"true\" /> <attribute name=\"compressedRefsDisplacement\" value=\"0x0\" /> <attribute name=\"compressedRefsShift\" value=\"0x0\" /> <attribute name=\"pageSize\" value=\"0x1000\" /> <attribute name=\"pageType\" value=\"not used\" /> <attribute name=\"requestedPageSize\" value=\"0x1000\" /> <attribute name=\"requestedPageType\" value=\"not used\" /> <attribute name=\"gcthreads\" value=\"4\" /> <attribute name=\"gcthreads Concurrent Mark\" value=\"1\" /> <attribute name=\"packetListSplit\" value=\"1\" /> <attribute name=\"cacheListSplit\" value=\"1\" /> <attribute name=\"splitFreeListSplitAmount\" value=\"1\" /> <attribute name=\"numaNodes\" value=\"0\" /> <system> <attribute name=\"physicalMemory\" value=\"100335456256\" /> <attribute name=\"numCPUs\" value=\"28\" /> <attribute name=\"architecture\" value=\"amd64\" /> <attribute name=\"os\" value=\"Linux\" /> <attribute name=\"osVersion\" value=\"3.10.0-1160.el7.x86_64\" /> </system> <vmargs> <vmarg name=\"-Dfile.encoding=bestfit936\" /> ... <vmarg name=\"-Xms1024m\" /> <vmarg name=\"-Xmx1024m\" /> ... <vmarg name=\"-Xverbosegclog:verbosegc.xml\" /> ... </vmargs> </initialized> The first set of <attribute> elements records the configuration of the garbage collector, such as the GC policy type, configuration of the Java object heap, and the number of threads that are used for garbage collection. For example, the GCThreads attribute records that the garbage collector is configured to use four threads. The <system> section records information about the operating system and available hardware, such as the physical memory, number of CPUs, and operating system type and version. In the example, the VM is running on Linux\u00ae amd64 V3.10 and has access to 28 CPUs and over 100 GB. The <vmargs> section records any VM configuration command-line options (VM arguments) that are specified. The following types of options are recorded: non-standard JVM -X options and JVM -XX options . In the example output, the log records the location of the file that contains VM options and definitions as java/perffarm/sdks/O11_j9_x64_linux-20201014/sdk/lib/options.default . The verbose GC log option is set to -Xverbosegclog:verbosegc.xml to write the verbose GC log output to an XML file. The initial and maximum Java object heap sizes are both set to 1024 KB by using the -Xms and -Xmx options. system property options . In the example output, the system property file.encoding is set to bestfit936 to force the GBK converter to follow unicode 2.0 rather than 3.0 standards. These command-line options can be set by using the command line, or by passing a manifest file, options file, or environment variable to the VM. After the configurations are recorded in the Initialization section, the verbose GC log begins recording GC activities and details. GC cycles The start of a GC cycle is recorded by the <cycle-start> XML element. The trigger for the start of a GC cycle is captured in a preceding element to the <cycle-start> element. A GC cycle or GC increment is triggered for one of the following reasons: an allocation failure occurs. Allocation failures occur when a request for memory fails because the Java object heap does not have enough memory available. The element <af-start> logs an allocation failure trigger. a memory threshold is reached. Memory threshold values, which set the conditions for triggering certain types of GC cycles or increments, are defined by the policy type and configuration options. For more information about the particular elements or attributes that are used to record a memory threshold trigger, see specific policies and cycles in Log examples . The following XML structure is an example of the verbose GC logs that are generated from the Generational Concurrent GC policy ( -Xgcpolicy:gencon ). In this example, the lines are indented to help illustrate the flow and attributes and some child elements are omitted for clarity: <exclusive-start/> <af-start/> <cycle-start/> <gc-start> <mem-info> <mem/> </mem-info> </gc-start> <allocation-stats/> <gc-op/> <gc-end> <mem-info> <mem/> </mem-info> </gc-end> <cycle-end/> <allocation-satisfied/> <af-end/> <exclusive-end/> Some elements serve as markers for starting and ending parts of the GC cycle and do not contain child elements, while other elements do contain child elements. In this example, the <af-start/> , <cycle-start/> , <cycle-end/> , <allocation-satisfied/> , and <af-end/> XML elements are empty and contain only attributes. All other XML elements contain child XML elements, which are omitted from this simplified example. For detailed examples of log output for a specific cycle, see Log examples ). GC increments and interleaving Some GC cycle types are run in piecemeal blocks of operations called GC increments. Using GC increments reduces pause times by enabling blocks of operations or operation steps to interleave with operations or operation steps from other types of cycle. For example, consider the garbage collector for the gencon policy, which uses partial cycles and global cycles. The partial cycle consists of just 1 GC operation, scavenge, that runs on the nursery area during a stop-the-world (STW) pause. However, the gencon global cycle, which runs when the tenure area is close to full, is split into three increments. The initial and final global cycle increments run during a relatively short STW pause. The intermediate global cycle increment, which consists of the majority of the GC cycle's work, runs its GC operations concurrently. Splitting the global cycle operations into these increments reduces pause times by running most of the GC operations concurrently with application threads. The gencon global cycle's concurrent increment is paused when a gencon partial GC cycle is triggered and resumes when the partial cycle, or multiple partial cycles, complete. In this way, a global cycle can progress while other types of cycle are run by pausing and resuming the concurrent work. In some policies, concurrent operations are split further into multiple concurrent increments for better control of progress of the concurrent operation. You can see this interleaving of the increments in the verbose GC log. The following table illustrates how the interleaving of the gencon policy's partial scavenge and global cycles appears in the logs. Line numbers of an example gencon policy's verbose GC log are displayed, alongside columns that show the status of each cycle that is recorded in the logs. (for clarity, not all GC activities are listed): Table showing how the `gencon` policy's global and partial scavenge cycles, which interleave with each other, are recorded in an example log. Example log line number `gencon` global GC cycle status recorded in log `gencon` partial GC cycle status recorded in log 1-87 Initialization section of the logs 87-51676 - series of partial scavenge cycles start and finish 51677 global cycle's trigger and target logged - 51680 STW pause starts - 51683 global cycle starts - 51684 STW pause ends - 518685 blank line in logs. (Concurrent increment runs) - 51686 (concurrent increment paused) STW pause starts 51690 (concurrent increment paused) partial scavenge cycle starts 51691 (concurrent increment paused) partial scavenge increment runs 51730 (concurrent increment paused) partial cycle ends 51733 (concurrent increment resumes) STW pause ends 51734 blank line in logs. (Concurrent increment resumes) - 51735 STW pause starts - 51741 final global increment logged - 51793 global cycle ends - 51795 STW pause ends - Note: Zero, one, or multiple GC cycles might run between the start and end of a gencon global GC cycle. The XML elements and attribute values that define operations and increments of a particular cycle are specific to the policy and type of cycle. To follow how the different cycle's increments interleave in a log, you can locate the elements and attributes that record the increments and operations that belong to a particular type of cycle. For example, for the gencon policy, you can locate the start of the intermediate, concurrent increment of the global cycle by searching for the <concurrent-kickoff> element. For more information about the XML elements and attribute values that are used for a particular type of cycle for a particular policy, and examples of log output, see Log examples . You can determine the GC increments and operations that are associated with a particular instance of a cycle by using the contextid and id attributes: Determine the ID of the GC cycle: find the value of the id attribute of the <cycle-start> element that denotes the start of the GC cycle. Note: the id attribute increases incrementally with each GC event. Search for the contextid attribute values that match the GC cycle's ID. All GC increments, operations, and concurrent events that are associated with a particular cycle have a contextid attribute whose value matches the GC cycle's ID.","title":"Verbose GC logs"},{"location":"vgclog/#verbose-garbage-collection-logs","text":"Garbage collection (GC) reclaims used memory in the Java\u2122 object heap for reuse. During cleanup of the heap, the verbose GC logs, when enabled, capture information about the different GC operations that are involved in the GC cycles. GC operations aim to reorganize or reclaim memory. Verbose GC logs contain information about GC operations to assist with the following actions: Tuning GC and improving application performance. Troubleshooting GC operations and policies. For example, analyzing long pauses, or determining how free memory is divided in the Java object heap before and after a GC cycle. Verbose GC logs, when enabled, begin capturing information as soon as GC is initialized. To help you visualize and analyze the GC, you can feed verbose GC log files into various diagnostic tools and interfaces. Examples include tools such as Garbage Collection and Memory Visualizer (GCMV) and online services such as GCEasy . For examples of log output, including guidance on how to analyze the logs, see Log examples . A further diagnostic step is to run one or more traces on GC activity by using the -Xtgc option . Trace output provides more granular information to help diagnose GC problems or perform finer tuning.","title":"Verbose garbage collection logs"},{"location":"vgclog/#how-to-generate-a-verbose-gc-log","text":"You can enable verbose GC logs by specifying the -verbose:gc standard option when you start your application. For more information, see standard command-line options . The output of -verbose:gc is printed to STDERR by default. To print the log output to a file, append the -Xverbosegclog option. You can also use this option to print to a succession of files, where each file logs a specified number of GC cycles.","title":"How to generate a verbose GC log"},{"location":"vgclog/#verbose-gc-log-contents-and-structure","text":"The verbose GC logs are printed in XML format and consist of the following sections: A summary of your GC configuration, which is captured in the <initialized> XML element. Information about the GC cycles that ran, including GC operations and GC increments. For definitions of GC cycles and operations, see Garbage collection . For definitions of GC increments, see GC increments and interleaving . The logs record when GC cycles and their increments start and end, and list the GC operations that run within these increments to manage or reclaim memory. You can also determine which type of event triggered the cycle or increment, and the amount of memory available to your application before and after processing.","title":"Verbose GC log contents and structure"},{"location":"vgclog/#initialization","text":"The log begins by recording the configuration of the Eclipse OpenJ9\u2122 runtime virtual environment (VM) and details of the GC configuration(GC). The configuration is recorded by using child elements of the <initialized> element, for example: <initialized id=\"1\" timestamp=\"2020-10-18T13:27:07.691\"> <attribute name=\"gcPolicy\" value=\"-Xgcpolicy:gencon\" /> <attribute name=\"maxHeapSize\" value=\"0x40000000\" /> <attribute name=\"initialHeapSize\" value=\"0x40000000\" /> <attribute name=\"compressedRefs\" value=\"true\" /> <attribute name=\"compressedRefsDisplacement\" value=\"0x0\" /> <attribute name=\"compressedRefsShift\" value=\"0x0\" /> <attribute name=\"pageSize\" value=\"0x1000\" /> <attribute name=\"pageType\" value=\"not used\" /> <attribute name=\"requestedPageSize\" value=\"0x1000\" /> <attribute name=\"requestedPageType\" value=\"not used\" /> <attribute name=\"gcthreads\" value=\"4\" /> <attribute name=\"gcthreads Concurrent Mark\" value=\"1\" /> <attribute name=\"packetListSplit\" value=\"1\" /> <attribute name=\"cacheListSplit\" value=\"1\" /> <attribute name=\"splitFreeListSplitAmount\" value=\"1\" /> <attribute name=\"numaNodes\" value=\"0\" /> <system> <attribute name=\"physicalMemory\" value=\"100335456256\" /> <attribute name=\"numCPUs\" value=\"28\" /> <attribute name=\"architecture\" value=\"amd64\" /> <attribute name=\"os\" value=\"Linux\" /> <attribute name=\"osVersion\" value=\"3.10.0-1160.el7.x86_64\" /> </system> <vmargs> <vmarg name=\"-Dfile.encoding=bestfit936\" /> ... <vmarg name=\"-Xms1024m\" /> <vmarg name=\"-Xmx1024m\" /> ... <vmarg name=\"-Xverbosegclog:verbosegc.xml\" /> ... </vmargs> </initialized> The first set of <attribute> elements records the configuration of the garbage collector, such as the GC policy type, configuration of the Java object heap, and the number of threads that are used for garbage collection. For example, the GCThreads attribute records that the garbage collector is configured to use four threads. The <system> section records information about the operating system and available hardware, such as the physical memory, number of CPUs, and operating system type and version. In the example, the VM is running on Linux\u00ae amd64 V3.10 and has access to 28 CPUs and over 100 GB. The <vmargs> section records any VM configuration command-line options (VM arguments) that are specified. The following types of options are recorded: non-standard JVM -X options and JVM -XX options . In the example output, the log records the location of the file that contains VM options and definitions as java/perffarm/sdks/O11_j9_x64_linux-20201014/sdk/lib/options.default . The verbose GC log option is set to -Xverbosegclog:verbosegc.xml to write the verbose GC log output to an XML file. The initial and maximum Java object heap sizes are both set to 1024 KB by using the -Xms and -Xmx options. system property options . In the example output, the system property file.encoding is set to bestfit936 to force the GBK converter to follow unicode 2.0 rather than 3.0 standards. These command-line options can be set by using the command line, or by passing a manifest file, options file, or environment variable to the VM. After the configurations are recorded in the Initialization section, the verbose GC log begins recording GC activities and details.","title":"Initialization"},{"location":"vgclog/#gc-cycles","text":"The start of a GC cycle is recorded by the <cycle-start> XML element. The trigger for the start of a GC cycle is captured in a preceding element to the <cycle-start> element. A GC cycle or GC increment is triggered for one of the following reasons: an allocation failure occurs. Allocation failures occur when a request for memory fails because the Java object heap does not have enough memory available. The element <af-start> logs an allocation failure trigger. a memory threshold is reached. Memory threshold values, which set the conditions for triggering certain types of GC cycles or increments, are defined by the policy type and configuration options. For more information about the particular elements or attributes that are used to record a memory threshold trigger, see specific policies and cycles in Log examples . The following XML structure is an example of the verbose GC logs that are generated from the Generational Concurrent GC policy ( -Xgcpolicy:gencon ). In this example, the lines are indented to help illustrate the flow and attributes and some child elements are omitted for clarity: <exclusive-start/> <af-start/> <cycle-start/> <gc-start> <mem-info> <mem/> </mem-info> </gc-start> <allocation-stats/> <gc-op/> <gc-end> <mem-info> <mem/> </mem-info> </gc-end> <cycle-end/> <allocation-satisfied/> <af-end/> <exclusive-end/> Some elements serve as markers for starting and ending parts of the GC cycle and do not contain child elements, while other elements do contain child elements. In this example, the <af-start/> , <cycle-start/> , <cycle-end/> , <allocation-satisfied/> , and <af-end/> XML elements are empty and contain only attributes. All other XML elements contain child XML elements, which are omitted from this simplified example. For detailed examples of log output for a specific cycle, see Log examples ).","title":"GC cycles"},{"location":"vgclog/#gc-increments-and-interleaving","text":"Some GC cycle types are run in piecemeal blocks of operations called GC increments. Using GC increments reduces pause times by enabling blocks of operations or operation steps to interleave with operations or operation steps from other types of cycle. For example, consider the garbage collector for the gencon policy, which uses partial cycles and global cycles. The partial cycle consists of just 1 GC operation, scavenge, that runs on the nursery area during a stop-the-world (STW) pause. However, the gencon global cycle, which runs when the tenure area is close to full, is split into three increments. The initial and final global cycle increments run during a relatively short STW pause. The intermediate global cycle increment, which consists of the majority of the GC cycle's work, runs its GC operations concurrently. Splitting the global cycle operations into these increments reduces pause times by running most of the GC operations concurrently with application threads. The gencon global cycle's concurrent increment is paused when a gencon partial GC cycle is triggered and resumes when the partial cycle, or multiple partial cycles, complete. In this way, a global cycle can progress while other types of cycle are run by pausing and resuming the concurrent work. In some policies, concurrent operations are split further into multiple concurrent increments for better control of progress of the concurrent operation. You can see this interleaving of the increments in the verbose GC log. The following table illustrates how the interleaving of the gencon policy's partial scavenge and global cycles appears in the logs. Line numbers of an example gencon policy's verbose GC log are displayed, alongside columns that show the status of each cycle that is recorded in the logs. (for clarity, not all GC activities are listed): Table showing how the `gencon` policy's global and partial scavenge cycles, which interleave with each other, are recorded in an example log. Example log line number `gencon` global GC cycle status recorded in log `gencon` partial GC cycle status recorded in log 1-87 Initialization section of the logs 87-51676 - series of partial scavenge cycles start and finish 51677 global cycle's trigger and target logged - 51680 STW pause starts - 51683 global cycle starts - 51684 STW pause ends - 518685 blank line in logs. (Concurrent increment runs) - 51686 (concurrent increment paused) STW pause starts 51690 (concurrent increment paused) partial scavenge cycle starts 51691 (concurrent increment paused) partial scavenge increment runs 51730 (concurrent increment paused) partial cycle ends 51733 (concurrent increment resumes) STW pause ends 51734 blank line in logs. (Concurrent increment resumes) - 51735 STW pause starts - 51741 final global increment logged - 51793 global cycle ends - 51795 STW pause ends - Note: Zero, one, or multiple GC cycles might run between the start and end of a gencon global GC cycle. The XML elements and attribute values that define operations and increments of a particular cycle are specific to the policy and type of cycle. To follow how the different cycle's increments interleave in a log, you can locate the elements and attributes that record the increments and operations that belong to a particular type of cycle. For example, for the gencon policy, you can locate the start of the intermediate, concurrent increment of the global cycle by searching for the <concurrent-kickoff> element. For more information about the XML elements and attribute values that are used for a particular type of cycle for a particular policy, and examples of log output, see Log examples . You can determine the GC increments and operations that are associated with a particular instance of a cycle by using the contextid and id attributes: Determine the ID of the GC cycle: find the value of the id attribute of the <cycle-start> element that denotes the start of the GC cycle. Note: the id attribute increases incrementally with each GC event. Search for the contextid attribute values that match the GC cycle's ID. All GC increments, operations, and concurrent events that are associated with a particular cycle have a contextid attribute whose value matches the GC cycle's ID.","title":"GC increments and interleaving"},{"location":"vgclog_examples/","text":"Log examples To help you understand how garbage collection (GC) processes memory for your application and how these processes are recorded, a number of annotated log examples are provided from different GC policies. Each example covers a particular type of cycle from a particular policy. By following the examples, you can learn how to interpret the XML elements in a log. gencon examples The gencon policy uses two types of cycle; a partial GC cycle and a global GC cycle. By default, the partial GC cycle runs a stop-the-world (STW) scavenge operation. On specific platforms, gencon can run a concurrent scavenge operation ( -Xgc:concurrentScavenge ) instead, if enabled at run time. The start of a gencon cycle is recorded in the log by the following elements and attributes: Table showing types of gencon cycle along with the corresponding trigger reason and XML elements for each type. GC cycle Value of type attribute of the <cycle-start> and <cycle-end> elements Element that logs the cycle trigger Trigger reason Global global <concurrent-kickoff> Low free memory tenure area threshold reached. Cycle trigger element is located before the <cycle-start> element. Partial scavenge <af-start> Allocation failure. Cycle trigger element is located before the <cycle-start> element. You can use the type attribute of the <gc-start> and <gc-end> elements to locate a particular cycle. You can also locate a particular type of cycle by searching for the element that records the cycle trigger, which is located before the <cycle-start> element. You can analyze the increments and operations that are associated with a particular type of cycle by locating and interpreting the elements in the following table: Table showing increments and operations that are associated with the gencon partial scavenge and global cycles. GC process Elements that log the start and end of the event Details GC cycle <cycle-start> , <cycle-end> The start and end of a GC cycle. GC STW increment <gc-start> , <gc-end> The start and end of a GC increment that begins with a pause. GC STW increment <concurrent-kickoff> The start of the initial GC increment of the global concurrent cycle that begins the initial mark operation. GC STW increment <concurrent-global-final> The start of the final GC increment of the global concurrent cycle that executes the final collection. GC operations and suboperations <gc-op> A GC operation such as mark or sweep, or a suboperation such as class unload. Note: For more information about the XML structure of GC cycles, see GC cycles . For more information about GC cycle increments, see GC increments and interleaving . The following examples use log excerpts to show how the different types of gencon cycle are logged. Scavenge partial GC cycle The following example is taken from a gencon log. The output is broken down into sections with supporting text to explain the GC processing that is taking place. To search for a scavenge partial GC cycle, you can search for the type attribute value scavenge in cycle-start and cycle-end elements, or search for the <af> element that logs the allocation failure trigger. By default, the gencon partial GC cycle runs by using a single STW pause. The cycle performs only one operation, a scavenge operation, which runs only on the nursery area. The cycle consists of a single GC increment, which is labeled by using the elements that are shown in the following table: Table showing the gencon default partial scavenge cycle's GC increment and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment Details scavenge single STW <gc-start> , <gc-end> Contains detailed information about copied objects and the weak roots processing operation The scavenge partial GC cycle follows a general structure in the verbose GC log as shown. Some elements are omitted for clarity: <exclusive-start/> (STW Pause starts) <af-start/> (allocation failure trigger recorded) <cycle-start/> (scavenge cycle starts) <gc-start> (scavenge cycle increment starts) <mem-info> (memory status before operation) <mem></mem> (status of different areas of heap) </mem-info> </gc-start> <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <gc-op> \u201cscavenge\"</gc-op> (scavenge operation completed) <gc-end> (scavenge cycle increment ends) <mem-info> (memory status after operation) <mem></mem> (status of different areas of heap) </mem-info> </gc-end> </cycle-end> (scavenge cycle ends) <allocation-satisfied/> (required allocation has been achieved) <af-end/> <exclusive-end> (STW for scavenge cycle ends) ... The first activity in the cycle is recorded by an <exclusive-start> element, which indicates the start of the STW pause. Application (or mutator ) threads are halted to give the garbage collector exclusive access to the Java\u2122 object heap: <!-- Start of gencon scavenge partial GC cycle example --> <exclusive-start id=\"12392\" timestamp=\"2020-10-18T13:35:45.000\" intervalms=\"406.180\"> <response-info timems=\"0.070\" idlems=\"0.070\" threads=\"0\" lastid=\"00000000013D6900\" lastname=\"LargeThreadPool-thread-68\" /> </exclusive-start> The <af-start> element indicates that the cycle was triggered by an allocation failure in the nursery ( type=\"nursery\" ) area of the heap: <af-start id=\"12393\" threadId=\"00000000013D7280\" totalBytesRequested=\"8200\" timestamp=\"2020-10-18T13:35:45.000\" intervalms=\"418.233\" type=\"nursery\" /> The <cycle-start> element marks the start of the cycle. The attribute type=\"scavenge\" confirms that this activity is a scavenge partial GC cycle: <cycle-start id=\"12394\" type=\"scavenge\" contextid=\"0\" timestamp=\"2020-10-18T13:35:45.000\" intervalms=\"418.231\" /> Most elements are labeled with an id attribute that increases in value incrementally, a timestamp attribute, and a contextid attribute. All elements that record GC increments and operations that are associated with a particular cycle have a contextid value that matches the id value of the cycle. The <cycle-start> element of this example cycle has an id=\"12394\" , so all subsequent elements that have a contextid=\"4\" , such as the <gc-start> increment element and the <gc-op> operation element, are associated with this particular example cycle. The <gc-start> element records the first GC increment. In this <gc-start> section, you can find information about the amount of memory available ( <mem-info> ) and where it is located in the Java object heap. The memory snapshot within the <gc-start> element is taken before the scavenge operation and can be compared with a similar snapshot that is taken afterward to understand the effect on the heap. <gc-start id=\"12395\" type=\"scavenge\" contextid=\"12394\" timestamp=\"2020-10-18T13:35:45.000\"> <mem-info id=\"12396\" free=\"414960320\" total=\"1073741824\" percent=\"38\"> <mem type=\"nursery\" free=\"0\" total=\"268435456\" percent=\"0\"> <mem type=\"allocate\" free=\"0\" total=\"241565696\" percent=\"0\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"414960320\" total=\"805306368\" percent=\"51\"> <mem type=\"soa\" free=\"374694592\" total=\"765040640\" percent=\"48\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <remembered-set count=\"21474\" /> </mem-info> </gc-start> The following statements describe the object heap memory allocation at the start of the increment: The allocate space of the nursery area is full, or close to full. The allocation failure was triggered by the lack of available memory in this space. The survivor space of the nursery area is reported as 'full' to reflect that no available memory is available to allocate to the mutator threads. The entire survivor space is reserved for GC operations during the GC increment. The tenure area has 395.7 MB (414,960,320B) of free memory available. The next element <allocation-stats> shows a snapshot, which was taken before the cycle started, of how memory was divided up between application threads. In this example, the thread that used the most memory was LargeThreadPool-thread-79 . <allocation-stats totalBytes=\"235362176\" > <allocated-bytes non-tlh=\"32880\" tlh=\"235329296\" /> <largest-consumer threadName=\"LargeThreadPool-thread-79\" threadId=\"00000000013F0C00\" bytes=\"6288544\" /> </allocation-stats> The scavenge GC operation is recorded by the <gc-op> element; child elements record details about the operation. For example, <gc-op id=\"12397\" type=\"scavenge\" timems=\"11.649\" contextid=\"12394\" timestamp=\"2020-10-18T13:35:45.012\"> <scavenger-info tenureage=\"7\" tenuremask=\"4080\" tiltratio=\"89\" /> <memory-copied type=\"nursery\" objects=\"154910\" bytes=\"6027440\" bytesdiscarded=\"394832\" /> <memory-copied type=\"tenure\" objects=\"16171\" bytes=\"562848\" bytesdiscarded=\"3064\" /> <ownableSynchronizers candidates=\"10838\" cleared=\"10824\" /> <references type=\"soft\" candidates=\"24\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"16\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"390\" cleared=\"269\" enqueued=\"269\" /> <references type=\"phantom\" candidates=\"1\" cleared=\"0\" enqueued=\"0\" /> <object-monitors candidates=\"132\" cleared=\"0\" /> </gc-op> The <memory-copied> element indicates that 5.75 MB (6,027,440B) of reachable objects were moved by the scavenge operation from the allocate space to the survivor space in the nursery area, and 0.54 MB(562,848 B) were moved to the tenure area. The <scavenger-info> element shows that the tenure age is set to 7 . Any object in the allocate space with an age less than or equal to 7 is copied to the survivor space during this scavenge operation. Any object that is copied between the allocate and survivor areas more than 7 times is moved to the tenure area. For more information about how the scavenge operation acts on the Java object heap, see GC processing . The end of the increment is recorded with <gc-end> and provides another snapshot of memory allocation on the heap, similar to <gc-start> . <gc-end id=\"12398\" type=\"scavenge\" contextid=\"12394\" durationms=\"11.785\" usertimems=\"46.278\" systemtimems=\"0.036\" stalltimems=\"0.145\" timestamp=\"2020-10-18T13:35:45.012\" activeThreads=\"4\"> <mem-info id=\"12399\" free=\"649473560\" total=\"1073741824\" percent=\"60\"> <mem type=\"nursery\" free=\"235142120\" total=\"268435456\" percent=\"87\"> <mem type=\"allocate\" free=\"235142120\" total=\"241565696\" percent=\"97\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"414331440\" total=\"805306368\" percent=\"51\" macro-fragmented=\"0\"> <mem type=\"soa\" free=\"374065712\" total=\"765040640\" percent=\"48\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <pending-finalizers system=\"0\" default=\"0\" reference=\"269\" classloader=\"0\" /> <remembered-set count=\"13792\" /> </mem-info> </gc-end> The Java object heap memory allocation at the end of the increment is as follows: 97% of the allocate space of the nursery area is now available as free memory. The survivor space of the nursery area is still reported as 'full' to reflect that the entire survivor space is reserved for GC operations during the next GC increment. The tenure area has 395 MB (414,331,440B) of free memory available. The scavenge operation copied 562 KB from the nursery area to the tenure area so less memory is now available in the tenure area. The scavenge operation successfully reclaimed memory in the allocate space of the nursery area by copying objects from the allocate space into the survivor space of the nursery area, and copying objects from the survivor space into the tenure area. The cycle ends ( <cycle-end> ). The following <allocation-satisfied> element indicates that the allocation request that caused the allocation failure can now complete successfully. The STW pause ends with the <exclusive-end> element: <cycle-end id=\"12400\" type=\"scavenge\" contextid=\"12394\" timestamp=\"2020-10-18T13:35:45.012\" /> <allocation-satisfied id=\"12401\" threadId=\"00000000013D6900\" bytesRequested=\"8200\" /> <af-end id=\"12402\" timestamp=\"2020-10-18T13:35:45.012\" threadId=\"00000000013D7280\" success=\"true\" from=\"nursery\"/> <exclusive-end id=\"12403\" timestamp=\"2020-10-18T13:35:45.012\" durationms=\"12.319\" /> <!-- End of gencon partial GC cycle example --> Summary Analyzing the structure and elements of this example log output shows that this example global cycle has the following characteristics: The GC cycle begins with an STW pause due to an allocation failure. All GC operations and suboperations that are associated with this cycle occur during the STW pause The cycle consists of only 1 GC increment, which runs a single scavenge operation. The GC cycle reclaims memory in the allocate area of the nursery area by coping objects from the allocate area to the survivor area and also to the tenure area. Concurrent scavenge partial GC cycle (non-default) When concurrent scavenge mode is enabled, the partial GC cycle is run as a Concurrent Scavenge cycle. This partial GC cycle is divided into increments to enable the majority of the scavenge operation to run concurrently with running application (or mutator ) threads. The concurrent increment can run while application threads run, and also while the intermediate concurrent increment of the global GC cycle runs. The interleaving of the concurrent scavenge partial GC cycle with the global cycle can be seen in the logs. The following elements log the GC increments and operations of the concurrent scavenge partial GC cycle: Table showing the gencon concurrent (non-default) partial scavenge cycle's GC increment and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment Details scavenge initial STW <gc-start> , <gc-end> Root scanning, reported as a single scavenge operation. scavenge intermediate concurrent <concurrent-start> , <concurrent-end> Live objects are traversed and evacuated (*copy forward*). Operation is reported as a scavenge operation. scavenge final STW <gc-start> , <gc-end> weak roots scanning, reported as a complex scavenge operation. <gc-op> contains specific details for each of the weak root groups. To search for a concurrent scavenge partial GC cycle, you can search for the type attribute value scavenge in cycle-start and cycle-end elements, or search for the <af> element that logs the allocation failure trigger. You can locate the concurrent scavenge partial cycle's concurrent increment by searching for <concurrent-start> and <concurrent-end> . The global cycle's intermediate concurrent increment, which can run at the same time, is not logged by an element, but begins immediately after application threads are restarted following the <cycle-start type=\"global\"/> element. For more information about the global cycle's intermediate concurrent increment, see gencon global GC cycle . For more information about GC increments, see GC increments and interleaving . gencon global GC cycle The following example shows how a global GC cycle is recorded in a gencon policy verbose GC log. The output is broken down into sections with supporting text to explain the GC processing that is taking place. The global GC cycle runs when the tenure area is close to full, which typically occurs after many partial cycles. As such, the output can be found part way down a full log. For more information about the GC initialization section, see Initialization . For an example log output for a gencon partial cycle, see Scavenge partial GC cycle . The global GC cycle is split into three increments, as shown in GC increments and interleaving . Splitting the cycle operations into the following increments reduces pause times by running the majority of the GC work concurrently. The concurrent increment pauses when a partial GC cycle is triggered and resumes after the partial cycle, or multiple cycles, finish. The interleaving of partial GC cycles with the global cycle's intermediate concurrent increment can be seen in the following gencon global GC cycle log output. A single partial GC cycle is logged between the initial and final increments of the global cycle. To search for a global cycle, you can search for the type attribute value global in cycle-start and cycle-end elements, or search for the element that logs the initial concurrent increment, <concurrent-kickoff> . The following elements log the GC increments and operations of the global GC cycle: Table showing the gencon global cycle's GC increment and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment Details n/a - initiates cycle initial STW <concurrent-kickoff> No <gc-op> is logged. This increment just initiates the concurrent mark increment. concurrent mark intermediate concurrent none <concurrent-trace-info> records the progress of the concurrent mark increment. final collection final STW <concurrent-global-final> The increment is typically triggered when a card cleaning threshold is reached. The completion of a tracing phase can also trigger the increment. Operations include a final concurrent mark, a sweep, and an optional class unload and compact. The global GC cycle follows a general structure in the verbose GC log. Some child elements are omitted for clarity. Multiple partial GC cycles can start and finish between the start and end of a global GC cycle. In the following example, the structure includes a single partial GC cycle within the global cycle: <concurrent-kickoff/> (global cycle 1st increment recorded) <exclusive-start/> (STW pause starts) <cycle-start/> (global cycle starts) <exclusive-end/> (STW pause ends) (mutator threads running, global cycle concurrent increment running concurrently) <exclusive-start/> (STW for partial GC cycle starts) ... (partial GC cycle starts and completes) <exclusive-end/> (STW for partial GC cycle ends) (mutator threads running, global cycle concurrent increment running concurrently) <exclusive-start/> (STW pause starts) <concurrent-global-final/> (global cycle final increment recorded) <gc-start/> (global cycle final increment starts) <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <mem-info> (memory status before operations) <mem></mem> (status of different areas of heap) </mem-info> </gc-start> <gc-op> \u201ctype=rs-scan\"</gc-op> (remembered set scan completed) <gc-op>\u201dtype=card-cleaning\" </gc-op> (card cleaning completed) <gc-op> \u201ctype=mark\u201d</gc-op> (final mark operation and weak roots processing completed) <gc-op> \u201ctype=classunload\u201d</gc-op> (class unload operation completed) <gc-op \u201dtype=sweep\u201d /> (sweep operation completed) <gc-end> (global cycle final increment ends) <mem-info> (memory status after operations) <mem></mem> (status of different areas of heap) </mem-info> </gc-end> </cycle-end> (global cycle ends) <exclusive-end> (STW pause ends) <exclusive-start> (STW pause starts) ... The first activity in the cycle is recorded by a <concurrent-kickoff> element, which records the start of the first of three increments that make up a gencon global GC cycle. The <concurrent-kickoff> element records the following information: The reason why the GC cycle was triggered. For a gencon global cycle, the cycle is triggered when the amount of free memory decreases to a threshold value, the thresholdFreeBytes value. The target number of bytes, targetBytes , that the cycle aims to mark concurrently. The current available memory in the different parts of the heap. <concurrent-kickoff id=\"12362\" timestamp=\"2020-10-18T13:35:44.341\"> <kickoff reason=\"threshold reached\" targetBytes=\"239014924\" thresholdFreeBytes=\"33024922\" remainingFree=\"32933776\" tenureFreeBytes=\"42439200\" nurseryFreeBytes=\"32933776\" /> </concurrent-kickoff> For this example, the remainingFree bytes value of 31.4 MB (32,933,776B) is approaching the thresholdFreeBytes value of 31.5 MB (33,024,922B) so a global cycle is triggered. This cycle aims to trace 228 MB (239,014,924B) during the concurrent increment. If the concurrent increment is interrupted by a card cleaning threshold value before it traces all 228 MB, the final STW increment completes the tracing during the STW pause. Note: To analyze specific parts of a cycle, you can search for the elements that mark a specific increment of the cycle. For example, you can search for the element to locate the final increment of the gencon global cycle. See the details of a particular cycle, such as the gencon global GC cycle , to determine the element names for particular STW or concurrent GC increments or operations. The next element recorded in the log, the <exclusive-start> element, records the start of an STW pause: <exclusive-start id=\"12363\" timestamp=\"2020-10-18T13:35:44.344\" intervalms=\"342.152\"> <response-info timems=\"0.135\" idlems=\"0.068\" threads=\"3\" lastid=\"00000000015DE600\" lastname=\"LargeThreadPool-thread-24\" /> </exclusive-start> The following <gc-start> element records details of the start of a new cycle. <cycle-start id=\"12364\" type=\"global\" contextid=\"0\" timestamp=\"2020-10-18T13:35:44.344\" intervalms=\"516655.052\" /> The type attribute records the cycle as a global cycle. The contextid of the cycle is, which indicates that all GC events that are associated with this cycle are tagged in relation to the id of this cycle. In particular, all subsequent elements that are associated with this particular example cycle have a contextid value equal to the <cycle-start> id attribute value of \u201c12634\u201d . The next element in the log is <exclusive-end> , which records the end of the STW pause: <exclusive-end id=\"12365\" timestamp=\"2020-10-18T13:35:44.344\" durationms=\"0.048\" /> The operations and suboperations of the second increment of the gencon global cycle are now running concurrently. The next section of the logs records an STW pause that is associated with an allocation failure. The <cycle-start> element that follows this STW pause indicates that the cycle is a scavenge cycle, which is the partial GC cycle that is used by the gencon GC: ... <cycle-start id=\"12368\" type=\"scavenge\" contextid=\"0\" timestamp=\"2020-10-18T13:35:44.582\" intervalms=\"580.047\" /> ... Subsequent elements have a contextid=\u201c12368\u201d , which matches the id of this new scavenge cycle. For more information about how this cycle is recorded in the logs, see Scavenge partial GC cycle . The operations and suboperations of the second, concurrent increment of the gencon global cycle are paused while the STW scavenge operation is running, and resume when the STW pause finishes. After the partial GC cycle completes and the STW pause finishes, the log records a new STW pause, which is triggered to enable the final gencon global GC increment to run. This final increment finishes marking the nursery area and completes the global cycle. The <exclusive-start> element is followed by a <concurrent-global-final> element, which logs the beginning of this final increment (and by implication, the end of the second increment). <exclusive-start id=\"12378\" timestamp=\"2020-10-18T13:35:44.594\" intervalms=\"12.075\"> <response-info timems=\"0.108\" idlems=\"0.040\" threads=\"3\" lastid=\"00000000018D3800\" lastname=\"LargeThreadPool-thread-33\" /> </exclusive-start> <concurrent-global-final id=\"12379\" timestamp=\"2020-10-18T13:35:44.594\" intervalms=\"516905.029\" > <concurrent-trace-info reason=\"card cleaning threshold reached\" tracedByMutators=\"200087048\" tracedByHelpers=\"12164180\" cardsCleaned=\"4966\" workStackOverflowCount=\"0\" /> </concurrent-global-final> The reason attribute of the <concurrent-trace-info> child element indicates that this final STW increment of the global cycle was triggered because a card-cleaning threshold was reached. The concurrent tracing was stopped prematurely and the targetBytes concurrent tracing target, recorded at the cycle start by <concurrent-kickoff> , was not achieved concurrently. If the concurrent tracing completes without interruption, the <concurrent-trace-info element logs reason=tracing completed . In the next section that begins with the gc-start element, you can find information about the amount of memory available ( <mem-info> ) and where it is located in the java object heap. This snapshot is taken before the final increment's operations and suboperations are run and can be compared with a similar snapshot that is taken afterward to understand the effect on the heap. The child element attribute values of the <mem> and <mem-info> elements indicate the status of the memory. Note: You can double check that the increment is associated with the GC global cycle in the example by checking the contextid attribute value matches the id=12364 attribute value of the cycle's element. <gc-start id=\"12380\" type=\"global\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.594\"> <mem-info id=\"12381\" free=\"277048640\" total=\"1073741824\" percent=\"25\"> <mem type=\"nursery\" free=\"234609440\" total=\"268435456\" percent=\"87\"> <mem type=\"allocate\" free=\"234609440\" total=\"241565696\" percent=\"97\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"42439200\" total=\"805306368\" percent=\"5\"> <mem type=\"soa\" free=\"2173472\" total=\"765040640\" percent=\"0\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <pending-finalizers system=\"0\" default=\"0\" reference=\"405\" classloader=\"0\" /> <remembered-set count=\"17388\" /> </mem-info> </gc-start> <allocation-stats totalBytes=\"827488\" > <allocated-bytes non-tlh=\"96\" tlh=\"827392\" /> <largest-consumer threadName=\"LargeThreadPool-thread-68\" threadId=\"00000000013D6900\" bytes=\"65632\" /> </allocation-stats> The next element <allocation-stats> shows a snapshot of how memory was divided up between application threads before the current cycle started. In this example, the thread that used the most memory was LargeThreadPool-thread-68 . For this example, at the start of this GC increment, the tenure area is low on free memory, as expected. 25% of the total heap is available as free memory, which is split between the following areas of the heap: The nursery area, which has 223.7 MB (234,609,440B) of free memory available. The free memory is only available in the allocate space of the nursery area. The survivor space of the nursery area is reported as 'full' to reflect that no available memory is available to allocate to the mutator threads. The entire survivor space is reserved for GC operations during the GC increment. The tenure area, which has 40.5 MB (42,439,200B) available as free memory, which is only 5% of its total memory. Most of this free memory is in the large object area (LOA). Almost no free memory is available in the small object area (SOA). The <gc-op> elements and their child elements contain information about the operations and suboperations in the increment. The final increment of the gencon global cycle consists of multiple operations, each logged with a <gc-op> element. The type of operation is shown by the <gc-op> type attribute. The final increment of the example log runs five types of operation: rs-scan card-cleaning mark classunload sweep Note: The final increment of a gencon global cycle can include an optional compact suboperation. For more information about the different types of GC operation, see GC operations . <gc-op id=\"12382\" type=\"rs-scan\" timems=\"3.525\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.598\"> <scan objectsFound=\"11895\" bytesTraced=\"5537600\" workStackOverflowCount=\"0\" /> </gc-op> <gc-op id=\"12383\" type=\"card-cleaning\" timems=\"2.910\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.601\"> <card-cleaning cardsCleaned=\"3603\" bytesTraced=\"5808348\" workStackOverflowCount=\"0\" /> </gc-op> <gc-op id=\"12384\" type=\"mark\" timems=\"6.495\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.607\"> <trace-info objectcount=\"1936\" scancount=\"1698\" scanbytes=\"61200\" /> <finalization candidates=\"389\" enqueued=\"1\" /> <ownableSynchronizers candidates=\"5076\" cleared=\"523\" /> <references type=\"soft\" candidates=\"18420\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"32\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"19920\" cleared=\"114\" enqueued=\"60\" /> <references type=\"phantom\" candidates=\"671\" cleared=\"50\" enqueued=\"50\" /> <stringconstants candidates=\"40956\" cleared=\"109\" /> <object-monitors candidates=\"182\" cleared=\"51\" /> </gc-op> <gc-op id=\"12385\" type=\"classunload\" timems=\"1.607\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.609\"> <classunload-info classloadercandidates=\"425\" classloadersunloaded=\"6\" classesunloaded=\"2\" anonymousclassesunloaded=\"1\" quiescems=\"0.000\" setupms=\"1.581\" scanms=\"0.019\" postms=\"0.007\" /> </gc-op> <gc-op id=\"12386\" type=\"sweep\" timems=\"9.464\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.618\" /> The end of the increment is recorded with <gc-end> and provides another snapshot of memory in the heap, similar to <gc-start> . <gc-end id=\"12387\" type=\"global\" contextid=\"12364\" durationms=\"24.220\" usertimems=\"86.465\" systemtimems=\"0.000\" stalltimems=\"2.846\" timestamp=\"2020-10-18T13:35:44.618\" activeThreads=\"4\"> <mem-info id=\"12388\" free=\"650476504\" total=\"1073741824\" percent=\"60\"> <mem type=\"nursery\" free=\"235516088\" total=\"268435456\" percent=\"87\"> <mem type=\"allocate\" free=\"235516088\" total=\"241565696\" percent=\"97\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"414960416\" total=\"805306368\" percent=\"51\" micro-fragmented=\"98245682\" macro-fragmented=\"0\"> <mem type=\"soa\" free=\"374694688\" total=\"765040640\" percent=\"48\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <pending-finalizers system=\"1\" default=\"0\" reference=\"515\" classloader=\"0\" /> <remembered-set count=\"13554\" /> </mem-info> </gc-end> 60% of the heap now contains free memory as a result of the final global cycle increment, which is split between the following areas of the heap: The nursery area, which gained 0.9 MB of free memory. The nursery area now has 224.6 MB (235,516,088B) available as free memory. At the start of the final increment, the nursery area had 223.7 MB (234,609,440B) of free memory available. The tenure area, which gained 355.2 MB (372,521,216B) of free memory. (the tenure area now has 395.7 MB (414,960,416B) available as free memory. At the start of the final increment, the tenure area had 40.5 MB (42,439,200B) of free memory available). Note: The global GC cycle runs to reclaim memory in the tenure area. The freeing up of memory in the nursery area is achieved by using the partial GC cycle. For more information, see gencon policy (default) . After the final increment of the global cycle completes, the global cycle ends and the STW pause ends, as shown in the following output: <cycle-end id=\"12389\" type=\"global\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.619\" /> <exclusive-end id=\"12391\" timestamp=\"2020-10-18T13:35:44.619\" durationms=\"24.679\" /> Summary Analyzing the structure and elements of this example log output shows that this example global cycle has the following characteristics: The GC global cycle is triggered when a memory threshold is reached and begins with an STW pause. After the first increment of the GC global cycle completes, the STW pause ends and the second increment runs concurrently. A single partial GC cycle starts and finishes between the start and end of the concurrent increment. An STW pause begins after the concurrent increments completes, during which the third and final increment of the global cycle, which consists of five operations, runs. The global GC cycle reclaims memory in the tenure area and a small amount of memory in the nursery area. balanced examples The balanced policy ( -Xgcpolicy:balanced ) uses two types of cycle to perform GC; a partial GC cycle and a global GC mark cycle. The policy might also run a third type of cycle, which is a global cycle, to reclaim memory after an allocation failure that results from tight memory conditions. For more information about the cycles used in a particular policy, see GC policies . The start of a balanced cycle is recorded in the log by the following elements and attributes: Table showing types of balanced cycle, the corresponding trigger, and XML elements for each `type`. GC cycle or increment Value of type attribute of the cycle or increment elements Element that logs the cycle trigger Trigger reason partial cycle partial gc <allocation-taxation> Allocation taxation threshold reached. global mark cycle global mark phase <allocation-taxation> Allocation taxation threshold reached. global mark STW subincrement of global mark cycle mark increment n/a Allocation taxation threshold reached global mark concurrent subincrement of global mark cycle GMP work packet processing n/a Allocation taxation threshold reached global cycle global garbage collect <af-start> (or <sys-start reason=\"explicit\"> if triggered explicitly) Allocation failure. Occurs under tight memory conditions. Cycle runs rarely. To locate a particular type of cycle, you can search for the type attribute of the <cycle-start> and <cycle-end> elements. When memory in the Java object heap reaches a memory threshold, called an allocation taxation threshold, a balanced partial GC cycle, balanced global mark cycle, or balanced global mark cycle increment, is triggered. If the available memory in the heap is low, the GC triggers a balanced global mark cycle, or a global mark cycle increment if the global mark cycle is in progress. Otherwise, the GC triggers a partial cycle. Partial GC cycles, global mark cycles, and global GC cycles set the allocation taxation threshold at the end of their cycle or increment to schedule the next cycle or increment. For balanced cycles, the taxation on the mutator threads refers to pausing the mutator threads while GC work is run. When a partial cycle ends, if the cycle is not run between global mark phase increments of a global mark cycle, and a global mark cycle is not scheduled as the next cycle, the allocation taxation threshold is set to trigger the next partial cycle when the eden space is full. Specifically, the allocation threshold is set to be equal to the size of the eden space. If a partial cycle runs within a global mark cycle, or if a global mark cycle is scheduled as the next cycle, the allocation taxation threshold, set at the end of the partial cycle, is set to be smaller than the size of the eden space. Specifically, the allocation taxation threshold is set to be half the size of the eden space so that the next global mark cycle or global mark cycle increment has enough memory available in the eden space to run. For more information about GC increments, see GC increments and interleaving . You can analyze the increments and operations that are associated with a particular type of cycle by locating and interpreting the elements in the following table: Table showing increments and operations that are associated with the balanced partial and global mark cycles GC process Elements that log the start and end of the event> Details GC cycle <cycle-start> , <cycle-end> The start and end of a GC cycle GC STW increment <gc-start> <gc-end> The start and end of a GC increment or subincrement that begins with a STW pause. For example, a global mark phase global mark GC cycle increment or a partial GC cycle increment GC concurrent increment <concurrent-start> , <concurrent-end> The start of the concurrent global mark phase work packet processing subincrements of the global mark cycle GC operations and phases <gc-op> A GC operation such as mark or sweep, or a suboperation such as class unload. For more information about the XML structure of GC cycles, see GC cycles . The following sections use log excerpts to show how the different GC processes are logged. balanced partial GC cycle The following example is taken from a balanced policy verbose GC log. The output is broken down into sections to explain the GC processing that is taking place. To search for a balanced partial GC cycle, you can search for the type attribute value partial gc in <cycle-start> and <cycle-end> elements. The partial GC cycle reclaims memory in the heap for the allocation of new objects by reducing the number of used regions. The partial GC cycle always reduces used regions in the eden space and might also reclaim memory from older regions. Multiple partial GC cycles often run in between global mark phase increments of the balanced global mark GC cycle . All the operations in a partial GC cycle run during a single STW pause, as shown in the following table: Table showing the balanced partial GC cycle operation and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment copy forward, and optionally class unload, sweep, and compact single STW <gc-start> , <gc-end> The following general structure shows a balanced partial GC cycle. Some child elements are omitted for clarity: <exclusive-start/> (STW pause starts) <allocation-taxation/> (memory threshold trigger recorded) <cycle-start/> (partial cycle starts) <gc-start/> (partial cycle increment starts) <mem-info> (memory status before operations) <mem></mem> (status of different types of memory) </mem-info> </gc-start> <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <gc-op> type=\"copy forward\" </gc-op> (copy forward operation completed) <gc-op> type=\"class unload\" </gc-op> (class unload operation completed) <gc-op> type=\"sweep\" </gc-op> (sweep operation completed) <gc-op> type=\"compact\" </gc-op> (compact operation completed) <gc-end> (partial cycle increment ends) <mem-info> (memory status after operations) <mem></mem> (status of different types of memory) </mem-info> </gc-end> <cycle-end> (partial cycle ends) <exclusive-end> (STW pause ends) When the balanced partial GC cycle is triggered, the GC runs an STW pause. Application (or mutator ) threads are halted to give the garbage collector exclusive access to the heap. The STW pause is recorded in the logs by the <exclusive-start> element. <exclusive-start id=\"184\" timestamp=\"2021-02-26T11:11:42.310\" intervalms=\"3745.790\"> <response-info timems=\"3.138\" idlems=\"1.056\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> An allocation taxation threshold triggers a balanced partial GC cycle. The logs record this trigger reason by using the <allocation-taxation> element. <allocation-taxation id=\"185\" taxation-threshold=\"2147483648\" timestamp=\"2021-02-26T11:11:42.311\" intervalms=\"3745.785\" /> Details about the start of the cycle are recorded by the <cycle-start> element. The cycle is recorded as a partial gc with an id=336 . Any subsequent elements that are associated with this cycle have a contextid=186 to match the cycle id . You can use this contextid value to distinguish the partial GC cycle increment and operations from interleaving increments and operations of other balanced cycles, such as global mark cycles. <cycle-start id=\"186\" type=\"partial gc\" contextid=\"0\" timestamp=\"2021-02-26T11:11:42.311\" intervalms=\"3745.805\" /> The partial cycle begins its only GC increment, recorded by using the <gc-start> element. You can understand the effect that the increment operations have on the heap by comparing snapshots of the memory that are taken at the start and the end of the increment. The child elements <mem-info> and <mem> of the <gc-start> and <gc-end> elements record the amount of memory available and where it is located in the heap. <gc-start id=\"187\" type=\"partial gc\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.311\"> <mem-info id=\"188\" free=\"897581056\" total=\"4294967296\" percent=\"20\"> <mem type=\"eden\" free=\"0\" total=\"2147483648\" percent=\"0\" /> <arraylet-primitive objects=\"1\" leaves=\"4\" largest=\"4\" /> <remembered-set count=\"2749664\" freebytes=\"160705664\" totalbytes=\"171704320\" percent=\"93\" regionsoverflowed=\"1\" regionsstable=\"12\" regionsrebuilding=\"0\"/> </mem-info> </gc-start> As expected, at the start of this increment, the eden regions are full. 856 MB (897,581,056 B) of the total 4096 MB (4294,967,296 B) heap, equivalent to 20% of the heap, is available as free memory. The status of the remembered set , a metastructure specific to Eclipse OpenJ9\u2122 generational garbage collectors, is reported by the <remembered-set> element. The remembered set metastructure keeps a record of any object references that cross different regions. Each region corresponds to a single remembered set. The partial GC cycle uses and prunes the remembered set. The regionsoverflowed value records the number of regions that exceeded the non-object heap memory allocation that is reserved for the remembered set. The partial GC cycle cannot reclaim memory from these overflow regions. The partial GC cycle also cannot reclaim memory from any regions whose remembered set is being rebuilt by an increment of a global mark cycle that is in progress. At the start of the partial GC cycle, the remembered set is using 93% of its available memory capacity, with 153.26 MB (160705664 B) available. The set consists of 2,749,664 cards and has one overflow region. The following element, <allocation-stats> , records information about how memory was divided between application (or mutator ) threads before the start of the current cycle. For this example, the thread Group1.Backend.CompositeBackend{Tier1}.7 was the largest consumer of memory. <allocation-stats totalBytes=\"2146431360\" > <allocated-bytes non-tlh=\"96417448\" tlh=\"2050013912\" arrayletleaf=\"0\"/> <largest-consumer threadName=\"Group1.Backend.CompositeBackend{Tier1}.7\" threadId=\"00000000007E9300\" bytes=\"275750048\" /> </allocation-stats> The operations of the GC increment are run and details are recorded in the <gc-op> elements. The logs show that this increment begins with a copy forward operation followed by a class unload. Other balanced partial GC cycles can also include sweep and compact operations. For more information about the operations involved in balanced partial GC cycles, see GC Processing . <gc-op id=\"189\" type=\"copy forward\" timems=\"400.637\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.713\"> <memory-copied type=\"eden\" objects=\"4434622\" bytes=\"119281928\" bytesdiscarded=\"1382272\" /> <memory-copied type=\"other\" objects=\"8847813\" bytes=\"244414264\" bytesdiscarded=\"6243176\" /> <memory-cardclean objects=\"1446970\" bytes=\"64143048\" /> <regions eden=\"512\" other=\"80\" /> <remembered-set-cleared processed=\"2435794\" cleared=\"887129\" durationms=\"8.667\" /> <finalization candidates=\"66\" enqueued=\"56\" /> <ownableSynchronizers candidates=\"256500\" cleared=\"78012\" /> <references type=\"soft\" candidates=\"153648\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"22\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"1266\" cleared=\"610\" enqueued=\"430\" /> <stringconstants candidates=\"9479\" cleared=\"0\" /> <object-monitors candidates=\"13576\" cleared=\"13505\" /> </gc-op> <gc-op id=\"190\" type=\"classunload\" timems=\"0.010\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.713\"> <classunload-info classloadercandidates=\"179\" classloadersunloaded=\"0\" classesunloaded=\"0\" anonymousclassesunloaded=\"0\" quiescems=\"0.000\" setupms=\"0.010\" scanms=\"0.000\" postms=\"0.000\" /> </gc-op> The logs show that the copy forward operation acts on the entire eden space (512 regions), recorded as type=eden , and 80 older regions, which are recorded as type=other . 113.76 MB (119281928 B) of memory was copied from the eden space to 1st generation regions and 233.10 MB (244414264 B) of memory in non-eden regions was copied to the next generation of regions. The copy forward operation is followed by a class unload operation. In some cases, a copy forward operation moves some regions by copying forward the objects in those regions, but only marks the objects in other regions. For example, the following log excerpt is taken from a different partial cycle, which corresponds to a contextid of 2049 . The copy forward operation in the following example involves marking some regions and copying forward other regions. <gc-op id=\"2052\" type=\"copy forward\" timems=\"649.059\" contextid=\"2049\" timestamp=\"2021-02-26T11:22:34.901\"> <memory-copied type=\"eden\" objects=\"95989\" bytes=\"7882704\" bytesdiscarded=\"501088\" /> <memory-copied type=\"other\" objects=\"2955854\" bytes=\"86854064\" bytesdiscarded=\"626024\" /> <memory-cardclean objects=\"1304\" bytes=\"56840\" /> <memory-traced type=\"eden\" objects=\"23392785\" bytes=\"553756840\" /> <memory-traced type=\"other\" objects=\"5461302\" bytes=\"131394216\" /> <regions eden=\"488\" other=\"138\" /> <remembered-set-cleared processed=\"156775\" cleared=\"4897\" durationms=\"1.759\" /> <finalization candidates=\"31\" enqueued=\"12\" /> <ownableSynchronizers candidates=\"1992467\" cleared=\"1600904\" /> <references type=\"soft\" candidates=\"329190\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"8\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"697\" cleared=\"105\" enqueued=\"6\" /> <stringconstants candidates=\"9848\" cleared=\"0\" /> <object-monitors candidates=\"1437\" cleared=\"1353\" /> <heap-resize type=\"expand\" space=\"default\" amount=\"0\" count=\"1\" timems=\"0.000\" reason=\"continue current collection\" /> <warning details=\"operation aborted due to insufficient free space\" /> </gc-op> The logs record these two concurrent parts of a copy forward operation in the <gc-op type=\"copy forward\"> section by using a <memory-traced> child element. In addition, evacuated and marked attributes for the <regions> child element are used to distinguish between the number of regions that were copied-forward (recorded as evacuated ) and the number of regions that were only marked and not copied-forward. For example, <regions eden=\"256\" other=\"308\" evacuated=\"308\" marked=\"256\" /> . Returning to the contextid=186 partial cycle example, the next element in the logs, <gc-end> , records the end of the increment and provides another snapshot of memory allocation on the heap, similar to <gc-start> . <gc-end id=\"191\" type=\"partial gc\" contextid=\"186\" durationms=\"402.645\" usertimems=\"3157.520\" systemtimems=\"4.000\" stalltimems=\"47.689\" timestamp=\"2021-02-26T11:11:42.714\" activeThreads=\"8\"> <mem-info id=\"192\" free=\"3003121664\" total=\"4294967296\" percent=\"69\"> <mem type=\"eden\" free=\"2147483648\" total=\"2147483648\" percent=\"100\" /> <arraylet-primitive objects=\"1\" leaves=\"4\" largest=\"4\" /> <pending-finalizers system=\"56\" default=\"0\" reference=\"430\" classloader=\"0\" /> <remembered-set count=\"2922048\" freebytes=\"160016128\" totalbytes=\"171704320\" percent=\"93\" regionsoverflowed=\"1\" regionsstable=\"12\" regionsrebuilding=\"0\"/> </mem-info> </gc-end> The following information describes the heap memory allocation at the end of the increment: The heap now has 2864 MB (3,003,121,664 bytes) of memory available compared to the 856 MB available at the start of the increment. The increment reclaimed 2,008 MB of memory in the heap, which is slightly less than the size of the eden space, as is typically the case. The eden space is recorded to have 100% memory available as free memory. The eden space, which consists of regions containing the youngest objects, was fully re-created by reclaiming almost all of the eden regions and assigning some other empty regions of the heap to the eden space. Note that some objects from eden regions always survive. The remembered set count increased by 172,384 cards, and the number of free bytes in the remembered set decreased by 0.66 MB (689,536 B). The cycle completes and the GC restarts application threads. <cycle-end id=\"193\" type=\"partial gc\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.714\" /> <exclusive-end id=\"194\" timestamp=\"2021-02-26T11:11:42.714\" durationms=\"404.145\" /> The next cycle that is recorded in the logs is another partial GC cycle. The <gc-start> element records the following information: <gc-start id=\"198\" type=\"partial gc\" contextid=\"197\" timestamp=\"2021-02-26T11:11:46.072\"> <mem-info id=\"199\" free=\"855638016\" total=\"4294967296\" percent=\"19\"> <mem type=\"eden\" free=\"0\" total=\"2147483648\" percent=\"0\" /> <arraylet-primitive objects=\"1\" leaves=\"4\" largest=\"4\" /> <remembered-set count=\"2922048\" freebytes=\"160016128\" totalbytes=\"171704320\" percent=\"93\" regionsoverflowed=\"1\" regionsstable=\"12\" regionsrebuilding=\"0\"/> </mem-info> </gc-start> The <mem-info> element shows that the following events occurred in between the end of the last (partial) GC cycle and the start of this cycle: All available memory in the eden area was allocated to application threads. Application threads also used some memory from non-eden heap areas. The total available memory in the heap reduced from 69% to 19%. The remembered set status is unchanged, as shown by the <remembered-set> element. When mutator threads run, they build data about object references that cross boundaries by using a card table. However, the processing of card table data into the remembered set, and the reporting of the remembered set counts, are run during other cycle operations. Summary Analyzing the structure and elements of this example log output shows that this example balanced partial GC cycle has the following characteristics: The partial GC cycle is triggered when the eden space is full by an allocation taxation threshold. All GC operations that are associated with this cycle occur during the STW pause. The partial GC cycle consists of only one increment, which runs a copy forward operation on 512 eden regions and 80 other regions, followed by a class-unload operation. The partial GC cycle re-creates a free eden space by reclaiming all possible regions from the eden space (some objects always survive) and assigning other free regions to the eden space. The GC cycle also reclaims memory from some other regions. 2864 MB of the total 4096 MB heap was reclaimed. 100% of the eden space is available as free memory, and some older regions were also reclaimed. Between the start and end of the partial GC cycle, the remembered set count increases by 172,384 cards and the number of free bytes decreases by 0.66 MB (689,536 B). After performing a copy forward operation on objects to move them to older regions, the partial GC cycle rebuilds the remembered set of any regions that received these moved objects. During a partial cycle, the remembered set is also pruned. Overall, the rebuilding and pruning can lead to either an increase or a decrease in the remembered set count and free memory available. The remembered set metastructure remains unchanged between GC cycles, even though the mutator threads build new data about object references when the threads run. The remembered set count is identical at the end of one partial GC cycle and the beginning of the next because the remembered set consumes this data and reports to the verbose GC logs only during a cycle's operation. balanced global mark GC cycle The global mark GC cycle uses a mixture of STW and concurrent operations to build a new record of object liveness across the heap for use by the balanced partial GC cycle. The balanced GC runs a balanced global mark cycle , or a balanced global mark cycle increment if the global mark cycle is in progress, if the heap satisfies a low memory condition when the allocation taxation threshold is reached. The global mark cycle runs a global mark phase and also triggers an associated sweep phase within the partial GC cycle that immediately follows the end of the global mark cycle. To search for a balanced global mark cycle, you can search for the type attribute value global mark phase in <cycle-start> and <cycle-end> elements. The global cycle is split into multiple increments, each recorded as type=\"global mark phase\" . A global mark phase increment involves an STW subincrement, which runs a global mark operation during an STW pause, followed by a global mark phase (GMP) work packet subincrement. The GMP work packet subincrement involves a processing operation that runs concurrently. The GMP work packet subincrement might also use an STW pause to complete if the subincrement is interrupted by a partial or global cycle trigger. Splitting the global mark phase into these increments and subincrements reduces pause times by running the majority of the GC work concurrently and interleaving global mark phase increments with partial GC cycles, and, rarely a balanced global GC cycles . The following elements log the GC increments, subincrements, and operations of the global mark GC cycle: Table showing the global mark cycle GC increments and corresponding XML elements GC increment GC operations> STW or concurrent XML element of GC increment Details global mark phase subincrement mark STW <gc-start> , <gc-end> The global mark phase operations start at the beginning of the cycle and run through all regions until the final region GMP work packet processing subincrement Work packet processing (WPP) operations concurrent and sometimes final operations during an STW to complete the subincrement <concurrent-start> , <concurrent-end> The GMP work packet processing subincrement runs immediately after the global mark phase final global mark phase increment final global mark phase operations including class unload STW <gc-start> , <gc-end> Final increment. Runs the final global mark phase operations, including weak roots processing, followed by operations to finish the cycle The following structure shows a balanced global mark GC cycle. The lines are indented to help illustrate the flow and some child elements are omitted for clarity: <exclusive-start/> (STW pause starts) <allocation-taxation/> (memory threshold trigger recorded) <cycle-start type=\"global mark phase\"/> (global mark cycle starts) <gc-start type=\"global mark phase\"/> (1st GMP STW subincrement starts) <mem-info> (memory status before operations) <remembered-set> </mem-info> </gc-start> <gc-op type=\"mark increment\" /> (STW copy forward operation completed) <gc-end> (1st GMP STW subincrement ends) <mem-info> (memory status after operations) <remembered-set> </mem-info> <gc-end> <concurrent-start type=\"GMP work packet processing\"/> (1st GMP concurrent subincrement starts) <exclusive-end/> (STW pause ends and application threads resume) <concurrent-end type=\"GMP work packet processing\"/> (1st GMP concurrent subincrement ends) <gc-op type=\"mark increment\"/> (marking operation runs concurrently) </concurrent-end type=\"GMP work packet processing\"/> ... (application threads run. STW pauses stop and start application threads to run partial GC cycles.) <exclusive-start/> (STW pause starts) <gc-start type=\"global mark phase\"/> (2nd STW GMP subincrement starts) ... <concurrent-start type=\"GMP work packet processing\"/> (2nd concurrent GMP subincrement starts) ... <exclusive-end/> ... (application threads run. Partial GC cycles may run) <concurrent-end type=\"GMP work packet processing\" /> (2nd concurrent GMP subincrement ends) ... </concurrent-end> ... (application threads run. Partial cycles and GMP increments interleave) <exclusive-start/> (STW pause starts) ... <gc-start type=\"global mark phase\"/> (final STW GMP subincrement starts.) <gc-op type=\"mark increment\" /> (STW copy forward operation completed) <gc-op type=\"class unload\" /> (STW class unload operation completed) <gc-end> (1st GMP STW subincrement ends) ... <gc-end type=\"global mark phase\"/> (final STW GMP subincrement ends. No concurrent subincrement runs) <cycle-end type=\"global mark phase\"/> (end of global mark cycle) <exclusive-end/> (STW pause ends) <exclusive-start/> (STW pause starts) <cycle-start type=\"partial gc\" /> (partial cycle starts) ... <gc-op type=\"sweep\" /> (Sweep operation associated with global mark cycle runs) ... <cycle-end type=\"partial gc\"/> (partial GC cycle ends) <exclusive-end/> (STw pause ends) Global mark phase The first activity of the global mark cycle is an STW pause, recorded by an <exclusive-start> element that precedes the <cycle-start type=\"global mark phase\"/> element. The garbage collector pauses application threads to run the initial operations. <exclusive-start id=\"1152\" timestamp=\"2021-02-26T11:17:25.033\" intervalms=\"1931.263\"> <response-info timems=\"3.082\" idlems=\"1.041\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> The <allocation-taxation> element indicates that an allocation taxation threshold triggered the cycle. The taxation threshold is recorded as 1024 MB (1,073,741,824), which is half the total memory of the eden space (2048 MB), as expected for threshold triggers of global mark cycles and increments. For more information about taxation thresholds for the balanced policy, see balanced examples . <allocation-taxation id=\"1153\" taxation-threshold=\"1073741824\" timestamp=\"2021-02-26T11:17:25.034\" intervalms=\"1931.251\" /> Details about the start of the global mark GC cycle are recorded by the <cycle-start> element. The cycle is recorded as type global mark phase with id=1154 . Any subsequent elements that are associated with this cycle have a contextid=1154 to match the global mark GC cycle id . You can use the contextid value to distinguish increments and operations of the global mark GC cycle from the partial cycles that interleave with it. <cycle-start id=\"1154\" type=\"global mark phase\" contextid=\"0\" timestamp=\"2021-02-26T11:17:25.034\" intervalms=\"374365.075\" /> The cycle begins with the STW subincrement of a global mark phase increment. The STW subincrement is recorded by using the <gc-start> element of type global mark phase . <gc-start id=\"1155\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.034\"> <mem-info id=\"1156\" free=\"1442840576\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"2197888\" freebytes=\"162912768\" totalbytes=\"171704320\" percent=\"94\" regionsoverflowed=\"3\" regionsstable=\"130\" regionsrebuilding=\"0\"/> </mem-info> </gc-start> The <gc-start> element provides a snapshot of the free memory available in the heap and the status of the remembered set. At the start of the increment, the heap is 33% free; 1376 MB (1442840576 B) of the total 4096 MB (4294967296 B). The <remembered-set> element records the status of the remembered set metastructure, a structure that records object references that cross different regions. During the rebuilding of the remembered set metastructure, any regions that cannot be rebuilt into a remembered set due to a lack of memory resource in the metastructure are marked as overflow regions. Partial GC cycles cannot reclaim memory from overflow regions. The aim of the global mark cycle is to create a new record of object liveness by populating the remembered set. The global mark cycle also attempts to rebuild the remembered set information for the overflowed regions, which can be seen in the remembered set statistics. After the global mark cycle completes, the remembered set reflects a closer snapshot of the current liveness of the heap. This more accurate snapshot of object liveness optimizes the pruning of the set, which is run by the partial GC cycle when it consumes the object liveness snapshot. The logs show that at the start of this STW subincrement, the remembered set count is 2,197,888 cards, the metastructure is using 94% of its total available memory, and three overflow regions need to be rebuilt. The <gc-op> element records that the STW subincrement runs a mark operation . This operation begins the process of building a record of object liveness across the heap. <gc-op id=\"1157\" type=\"mark increment\" timems=\"122.825\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.157\"> <trace-info objectcount=\"7726701\" scancount=\"7584109\" scanbytes=\"213445656\" /> </gc-op> The <trace-info> element records information about the marking and scanning stages of the mark increment operation. objectcount records the number of objects that were marked, ready for tracing. After marking live objects, a scan is run to trace objects and references. The following values are recorded: scancount records the number of marked objects that were scanned. scanbytes records the total memory of all marked objects that were scanned. In the example, the mark increment operation marked 7,726,701 objects and scanned 7,584,109 of these marked objects. The 7,584,109 of scanned objects take up 203.5 MB (213445656 B) of memory. The number of scanned objects is less than the number of marked objects because only objects that have children require scanning. Also, the scanning part of the marking operation might be interrupted by the garbage collector if a trigger threshold for a partial cycle or global cycle is reached during the marking operation. The STW global mark phase subincrement ends, as recorded by <gc-end> , which records a snapshot of the memory status in the heap in a similar way to <gc-start> . <gc-end id=\"1158\" type=\"global mark phase\" contextid=\"1154\" durationms=\"123.139\" usertimems=\"977.851\" systemtimems=\"0.000\" stalltimems=\"1.453\" timestamp=\"2021-02-26T11:17:25.157\" activeThreads=\"8\"> <mem-info id=\"1159\" free=\"1442840576\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3263968\" freebytes=\"158648448\" totalbytes=\"171704320\" percent=\"92\" regionsoverflowed=\"0\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-end> The following comparison can be made between the snapshot at the beginning and end of this STW global mark phase subincrement: The marking operation has increased the count value of the <remembered-set> by 1,066,080 cards (from 2,197,888 to 3,263,968). As regions are rebuilt, the new cards record the new remembered set data that is associated with these regions. The number of overflow regions went from three to zero. As expected with a global mark cycle, there is no change in the amount of free memory available, which is 1376 MB. The beginning of the second part of the global mark phase increment, the GMP work packet processing subincrememt, is recorded by <concurrent-start> . The child element <concurrent-mark-start> records the scan target of this subincrement as 242.74 MB (254,532,672 B). <concurrent-start id=\"1160\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.157\"> <concurrent-mark-start scanTarget=\"254532672\" /> </concurrent-start> Now that the STW global mark phase subincrement is complete, application threads are restarted. <exclusive-end id=\"1161\" timestamp=\"2021-02-26T11:17:25.157\" durationms=\"123.936\" /> The GMP work packet processing subincrement continues to run concurrently. The end of this operation is recorded by using the <concurrent-end> element. <concurrent-end id=\"1162\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.469\" terminationReason=\"Work target met\"> <gc-op id=\"1163\" type=\"mark increment\" timems=\"311.867\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.469\"> <trace-info scanbytes=\"254708852\" /> </gc-op> </concurrent-end> The child element <trace-info> shows that the processing scanned 242.91 MB (254,708,852 B), which slightly exceeds the 108.25 MB scan target. Application threads continue to run and allocate memory. The garbage collector stops and starts the application threads to run partial GC cycles that reclaim free space in the eden space and some older regions. To see an example of how a balanced partial GC cycle appears in the logs, see the balanced partial GC cycle . Following some partial GC cycles, an allocation taxation threshold is reached that triggers an STW pause followed by another global mark phase increment. The element <gc-start> in the following log excerpt has a contextid=1154 and type global mark phase , which indicates that this is a global mark phase subincrement associated with the global mark cycle example. <exclusive-start id=\"1175\" timestamp=\"2021-02-26T11:17:28.993\" intervalms=\"1978.886\"> <response-info timems=\"5.111\" idlems=\"1.714\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> <allocation-taxation id=\"1176\" taxation-threshold=\"1073741824\" timestamp=\"2021-02-26T11:17:28.994\" intervalms=\"1978.879\" /> <gc-start id=\"1177\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:28.994\"> <mem-info id=\"1178\" free=\"1451229184\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3325824\" freebytes=\"158401024\" totalbytes=\"171704320\" percent=\"92\" regionsoverflowed=\"2\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-start> The <allocation-taxation> element shows that the allocation taxation threshold, which triggers this global mark phase increment, is set to 1024 MB, half of the size of the eden space, as expected. <gc-start> records that the heap has 1384 MB (1,451,229,184 B) of free memory available at the beginning of this global mark phase increment. This value compares to the 1376 MB (1,442,840,576 B) of free memory available at the end of the previous global mark phase increment. Although free memory was reclaimed by the partial GC cycles that ran between these global mark phase increments, free memory was allocated to objects when application threads ran, resulting in a net reduction of free memory available. The status of the heap at the beginning and end of STW subincrements are automatically recorded. For this STW subincrement, there are no <gc-op> elements recorded; <gc-end> immediately follows <gc-start> in the logs. For some STW subincrements, a mark operation is run. <gc-end id=\"1179\" type=\"global mark phase\" contextid=\"1154\" durationms=\"0.289\" usertimems=\"1.000\" systemtimems=\"0.000\" stalltimems=\"0.000\" timestamp=\"2021-02-26T11:17:28.994\" activeThreads=\"8\"> <mem-info id=\"1180\" free=\"1451229184\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3325824\" freebytes=\"158401024\" totalbytes=\"171704320\" percent=\"92\" regionsoverflowed=\"2\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-end> The second part of the increment, the GMP work packet processing subincrement, is recorded by using the <concurrent-start> and <concurrent-end> elements. <concurrent-start id=\"1181\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:28.994\"> <concurrent-mark-start scanTarget=\"258671414\" /> </concurrent-start> <exclusive-end id=\"1182\" timestamp=\"2021-02-26T11:17:28.994\" durationms=\"0.816\" /> <concurrent-end id=\"1183\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:29.273\" terminationReason=\"Work target met\"> <gc-op id=\"1184\" type=\"mark increment\" timems=\"279.311\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:29.274\"> <trace-info scanbytes=\"258767612\" /> </gc-op> </concurrent-end> The log excerpt shows the concurrent GMP work packet processing subincrement achieved the scan target of 246.69 MB (258671414 B). 246.78 MB (258767612 B) were scanned. More partial cycles run. This pattern of interleaving of global mark increments with partial GC cycles repeats until a final global mark increment completes the global mark cycle. The final global mark phase increment consists of an STW global mark phase subincrement that includes mark increment and class unload operations. <exclusive-start id=\"1217\" timestamp=\"2021-02-26T11:17:36.864\" intervalms=\"1986.124\"> <response-info timems=\"0.287\" idlems=\"0.104\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> <allocation-taxation id=\"1218\" taxation-threshold=\"1073741824\" timestamp=\"2021-02-26T11:17:36.865\" intervalms=\"1986.101\" /> <gc-start id=\"1219\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:36.865\"> <mem-info id=\"1220\" free=\"1438646272\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3514496\" freebytes=\"157646336\" totalbytes=\"171704320\" percent=\"91\" regionsoverflowed=\"3\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-start> <gc-op id=\"1221\" type=\"mark increment\" timems=\"164.843\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:37.030\"> <trace-info objectcount=\"7715572\" scancount=\"7665293\" scanbytes=\"214739196\" /> <cardclean-info objects=\"3962203\" bytes=\"117924792\" /> <finalization candidates=\"206\" enqueued=\"30\" /> <ownableSynchronizers candidates=\"601780\" cleared=\"16925\" /> <references type=\"soft\" candidates=\"718240\" cleared=\"2858\" enqueued=\"2832\" dynamicThreshold=\"18\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"2321\" cleared=\"142\" enqueued=\"0\" /> <references type=\"phantom\" candidates=\"8\" cleared=\"0\" enqueued=\"0\" /> <stringconstants candidates=\"9522\" cleared=\"0\" /> <object-monitors candidates=\"7142\" cleared=\"7066\" /> </gc-op> <gc-op id=\"1222\" type=\"classunload\" timems=\"0.704\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:37.030\"> <classunload-info classloadercandidates=\"185\" classloadersunloaded=\"13\" classesunloaded=\"13\" anonymousclassesunloaded=\"0\" quiescems=\"0.000\" setupms=\"0.644\" scanms=\"0.043\" postms=\"0.016\" /> </gc-op> <gc-end id=\"1223\" type=\"global mark phase\" contextid=\"1154\" durationms=\"169.521\" usertimems=\"1244.810\" systemtimems=\"3.000\" stalltimems=\"27.792\" timestamp=\"2021-02-26T11:17:37.034\" activeThreads=\"8\"> <mem-info id=\"1224\" free=\"1438646272\" total=\"4294967296\" percent=\"33\"> <pending-finalizers system=\"30\" default=\"0\" reference=\"2832\" classloader=\"0\" /> <remembered-set count=\"2241440\" freebytes=\"162738560\" totalbytes=\"171704320\" percent=\"94\" regionsoverflowed=\"3\" regionsstable=\"127\" regionsrebuilding=\"0\"/> </mem-info> </gc-end> Comparing the memory at the start and end of this final global mark phase increment shows the following status: As expected, the final global mark phase increment does not reclaim any free memory. The remembered set metastructure was marginally rebuilt. The card count has increased slightly, and the number of stable regions dropped from 130 to 127. The number of overflow regions remains unchanged. The final global mark phase increment did not manage to rebuild any overflow regions. Following the final global mark increment, the global mark cycle completes and the GC ends the STW pause. <cycle-end id=\"1225\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:37.034\" /> <exclusive-end id=\"1226\" timestamp=\"2021-02-26T11:17:37.034\" durationms=\"170.186\" /> The operations to create a record of object liveness across the heap, which began with the global mark cycle, is followed by a sweep phase. The sweep phase is triggered by the end of the global mark cycle to be included in the next partial GC cycle that runs. Sweep phase The sweep operation has the following two objectives: To directly reclaim some memory by creating empty regions. To build information about occupancy and fragmentation for regions that still contain live objects. The next partial GC cycle uses this information to defragment older regions. While the global sweep operation is logically associated with the global mark phase, it does not run in the same global mark cycle. Instead, the sweep operation runs in the same STW increment as the first partial GC cycle that runs after the completion of the global mark cycle. This can be seen in the following log excerpt. After the log records the end of the global mark cycle, it records an STW pause followed by a partial gc cycle of id=1229 . The global sweep operation that runs after the global mark phase is recorded in the <gc-op> element that is tagged as id=1229 . <exclusive-start id=\"1227\" timestamp=\"2021-02-26T11:17:38.804\" intervalms=\"1940.125\"> ... <cycle-start id=\"1229\" type=\"partial gc\" contextid=\"0\" timestamp=\"2021-02-26T11:17:38.805\" intervalms=\"3926.202\" /> ... </gc-start> ... </gc-start> <gc-op id=\"1232\" type=\"sweep\" timems=\"9.472\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:38.815\" /> <gc-op id=\"1233\" type=\"copy forward\" timems=\"308.258\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:39.124\"> ... <gc-op id=\"1234\" type=\"classunload\" timems=\"0.012\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:39.125\"> ... <gc-end> ... </gc-end> <cycle-end id=\"1237\" type=\"partial gc\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:39.125\" /> <exclusive-end id=\"1238\" timestamp=\"2021-02-26T11:17:39.125\" durationms=\"320.792\" /> A record of object liveness is now complete. Summary Analyzing the structure and elements of this example log output shows that this example balanced global mark GC cycle has the following characteristics: If the total free memory is low when the taxation allocation threshold is reached, the GC triggers a global mark cycle. The allocation taxation threshold is set by the previous cycle to trigger a new cycle when the eden space is half full. This threshold value frees up eden space to enable a global mark cycle to interleave with the GC operations of partial GC cycles. Each global mark phase increment is triggered by an allocation taxation threshold value that is set to half of the eden space. Global mark GC cycle and global mark cycle increments begin with an STW pause. The global mark cycle does not reclaim memory. The cycle creates an updated record of object liveness by rebuilding the mark map, and also attempts to rebuild the remembered set for overflowed and stable regions. The change in status of the remembered set metastructure can be seen in the logs by inspecting the <remembered-set> attributes. Partial cycles run in between global mark phase increments. The final global mark phase increment includes a class unload. The final increment also triggers a sweep phase to run in the next partial cycle. balanced global GC cycle The following global GC cycle example is taken from a balanced verbose GC log. The output is broken down into sections to explain the GC processing that is taking place. A balanced global cycle is triggered if the VM is close to throwing an out of memory exception. This situation occurs only under tight memory conditions when the garbage collector cannot reclaim enough memory by using only partial and global mark cycles. To search for a balanced global cycle or increment, you can search for the type attribute value global garbage collect of the cycle or increment element. If the balanced global cycle is triggered during a balanced global mark GC cycle , a new global cycle is not recorded. Instead, the global mark cycle's global mark phase increment switches to a global garbage collect increment that is run as an STW increment. This switch is recorded in the logs by using a <cycle-continue> element, which precedes the gc-start element that records the new global garbage collect increment. If the balanced global cycle is not triggered during a balanced global mark cycle, the global cycle is recorded as a new cycle by using the <cycle-start> element. The element <sys-start reason=\"explicit\"> is used in the logs to record a cycle that was triggered explicitly rather than by the garbage collector. For example, the trigger reason is recorded as explicit if a cycle is triggered by an application calling System.gc() . For more information about explicitly or implicitly triggering a GC cycle, see Garbage collection . The global cycle operations run as a single GC increment during an STW pause. Table showing the balanced global cycle's GC increment and corresponding XML elements. GC increment GC operations STW or concurrent XML element of GC increment Details single STW mark-sweep operations, optionally followed by a compact operation STW <cycle-start> , <gc-end> Contains detailed information about where free memory is located and remembered set statistics If the global cycle is triggered during a global mark cycle, the global cycle follows a general structure in the verbose GC log as shown. Some child elements are omitted for clarity: ... (global mark cycle increment runs) <af-start/> (allocation failure trigger recorded) <concurrent-end/> (global mark cycle concurrent subincrement finishes ) <allocation-taxation/> (memory threshold trigger recorded) <cycle-continue/> (change of cycle type from global mark to global) </gc-start type=\"global garbage collect\"/> (global cycle STW increment starts) <mem-info> (memory status before operations) <mem></mem> (status of different types of memory) </mem-info> </gc-start type=\"global garbage collect\"/> <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <gc-op> type=\"mark\" </gc-op> (mark operation completed) <gc-op> type=\"class unload\" </gc-op> (class unload operation completed) <gc-op> type=\"sweep\" </gc-op> (sweep operation completed) <gc-op> type=\"compact\" </gc-op> (compact operation completed) <gc-end type=\"global garbage collect\"> (global cycle STW increment ends) <mem-info> (memory status after operations) <mem></mem> (status of different types of memory) </mem-info> </gc-end type=\"global garbage collect\"> <cycle-end type = \"global garbage collect\"/> (cycle ends) <allocation-satisfed/> (required allocation has been achieved) <exclusive-end> (STW pause ends) The following example shows a balanced global cycle that is triggered during a global mark cycle . The start of the GMP work processing subincrement of the global mark cycle, which runs concurrently with application threads, is recorded by using the <concurrent-start> element. <concurrent-start id=\"2009\" type=\"GMP work packet processing\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.109\"> <concurrent-mark-start scanTarget=\"18446744073709551615\" /> </concurrent-start> After the start of the concurrent subincrement, the logs record an allocation failure by using <af-start> . The <concurrent-end> element attribute terminationReason shows that a termination of the concurrent increment was requested by the garbage collector. <af-start id=\"2010\" threadId=\"00000000008AA780\" totalBytesRequested=\"24\" timestamp=\"2021-03-05T12:16:43.109\" intervalms=\"1212.727\" /> <concurrent-end id=\"2011\" type=\"GMP work packet processing\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\" terminationReason=\"Termination requested\"> <gc-op id=\"2012\" type=\"mark increment\" timems=\"0.893\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\"> <trace-info scanbytes=\"584612\" /> </gc-op> </concurrent-end> The next element, the <cycle-continue> element, records information about the switch of cycle type from a global mark cycle, recorded as type global mark phase , to a global cycle, recorded as type global garbage collect . <cycle-continue id=\"2013\" oldtype=\"global mark phase\" newtype=\"global garbage collect\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\" /> A global cycle increment is recorded by <gc-start> and has the same contextid as the global mark cycle's elements. The global cycle operations are run during an STW pause and as a modification to the global mark cycle rather than a new cycle. The memory snapshot within the <gc-start> element is taken before the global increment's operations run and can be compared with a similar snapshot that is taken afterward to understand the effect on the heap. <gc-start id=\"2014\" type=\"global garbage collect\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\"> <mem-info id=\"2015\" free=\"0\" total=\"838860800\" percent=\"0\"> <mem type=\"eden\" free=\"0\" total=\"524288\" percent=\"0\" /> <remembered-set count=\"12832\" freebytes=\"33331072\" totalbytes=\"33382400\" percent=\"99\" regionsoverflowed=\"0\" regionsstable=\"0\" regionsrebuilding=\"1593\"/> </mem-info> </gc-start> At the start of the global cycle's increment, the amount of memory available in the heap is zero. In some cases, the heap is close to full, and in other cases, the memory is full. The next element <allocation-stats> shows a snapshot of how memory was divided up between application threads before the current cycle started. <allocation-stats totalBytes=\"524200\" > <allocated-bytes non-tlh=\"0\" tlh=\"524200\" arrayletleaf=\"0\"/> </allocation-stats> The <allocation-stats> element shows that very little allocation took place. Global cycles are triggered due to an allocation failure, so the low memory allocation values are expected. The following operations, each recorded by a <gc-op> element, run as part of the global cycle's increment: global mark class unload sweep compact <gc-op id=\"2016\" type=\"global mark\" timems=\"357.859\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.468\"> <trace-info objectcount=\"37461962\" scancount=\"37447916\" scanbytes=\"828311396\" /> <cardclean-info objects=\"311\" bytes=\"22632\" /> <finalization candidates=\"195\" enqueued=\"2\" /> <ownableSynchronizers candidates=\"2089\" cleared=\"0\" /> <references type=\"soft\" candidates=\"3059\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"0\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"10797\" cleared=\"0\" enqueued=\"0\" /> <references type=\"phantom\" candidates=\"6\" cleared=\"0\" enqueued=\"0\" /> <stringconstants candidates=\"10031\" cleared=\"0\" /> </gc-op> <gc-op id=\"2017\" type=\"classunload\" timems=\"0.123\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.468\"> <classunload-info classloadercandidates=\"25\" classloadersunloaded=\"0\" classesunloaded=\"0\" anonymousclassesunloaded=\"0\" quiescems=\"0.000\" setupms=\"0.123\" scanms=\"0.000\" postms=\"0.000\" /> </gc-op> <gc-op id=\"2018\" type=\"sweep\" timems=\"5.120\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.474\" /> <gc-op id=\"2019\" type=\"compact\" timems=\"762.323\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:44.236\"> <compact-info movecount=\"8024461\" movebytes=\"163375400\" /> <remembered-set-cleared processed=\"777104\" cleared=\"777104\" durationms=\"2.188\" /> </gc-op> The global cycle's increment ends. The end of the increment is recorded with <gc-end> and provides another snapshot of memory allocation on the heap, similar to <gc-start> . <gc-end id=\"2020\" type=\"global garbage collect\" contextid=\"2003\" durationms=\"1126.788\" usertimems=\"7971.788\" systemtimems=\"1.000\" stalltimems=\"1016.256\" timestamp=\"2021-03-05T12:16:44.237\" activeThreads=\"8\"> <mem-info id=\"2021\" free=\"1572864\" total=\"838860800\" percent=\"0\"> <mem type=\"eden\" free=\"1572864\" total=\"1572864\" percent=\"100\" /> <pending-finalizers system=\"2\" default=\"0\" reference=\"0\" classloader=\"0\" /> <remembered-set count=\"874496\" freebytes=\"29884416\" totalbytes=\"33382400\" percent=\"89\" regionsoverflowed=\"0\" regionsstable=\"0\" regionsrebuilding=\"0\"/> </mem-info> </gc-end> Comparing the snapshot at the beginning and end of this STW global mark phase subincrement shows that memory was reclaimed and regions reassigned to create an empty eden space, equal to 1.5 MB (1,572,864 B). Because global cycles are triggered when memory conditions are tight, the global cycle is able to reclaim only a small amount of memory. The cycle ends ( <cycle-end> ). The following <allocation-satisfied> element indicates that the allocation request that caused the allocation failure can now complete successfully. <cycle-end id=\"2022\" type=\"global garbage collect\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:44.237\" /> <allocation-satisfied id=\"2023\" threadId=\"00000000008A9E00\" bytesRequested=\"24\" /> <af-end id=\"2024\" timestamp=\"2021-03-05T12:16:44.237\" threadId=\"00000000008AA780\" success=\"true\" /> The STW pause ends with the <exclusive-end> element. <exclusive-end id=\"2025\" timestamp=\"2021-03-05T12:16:44.237\" durationms=\"1130.358\" /> Summary Analyzing the structure and elements of this example log output shows that this global cycle has the following characteristics: The global GC cycle was triggered during a global mark GC cycle when the heap was very low in memory. The memory could not be reclaimed by just using partial GC cycles and global mark cycles. The concurrent subincrement of the global mark GC cycle was interrupted by an allocation failure that triggered the concurrent subincrement to end and the global mark cycle type to change to a global type. The global GC cycle consists of only 1 GC increment, which runs mark, sweep, and compact operations during an STW pause. The global GC cycle reclaimed the eden space (1.5 MB of memory). When global GC cycle's are triggered, which occurs when memory conditions are tight, the amount of memory that the global GC cycle reclaims is often small.","title":"Log examples"},{"location":"vgclog_examples/#log-examples","text":"To help you understand how garbage collection (GC) processes memory for your application and how these processes are recorded, a number of annotated log examples are provided from different GC policies. Each example covers a particular type of cycle from a particular policy. By following the examples, you can learn how to interpret the XML elements in a log.","title":"Log examples"},{"location":"vgclog_examples/#gencon-examples","text":"The gencon policy uses two types of cycle; a partial GC cycle and a global GC cycle. By default, the partial GC cycle runs a stop-the-world (STW) scavenge operation. On specific platforms, gencon can run a concurrent scavenge operation ( -Xgc:concurrentScavenge ) instead, if enabled at run time. The start of a gencon cycle is recorded in the log by the following elements and attributes: Table showing types of gencon cycle along with the corresponding trigger reason and XML elements for each type. GC cycle Value of type attribute of the <cycle-start> and <cycle-end> elements Element that logs the cycle trigger Trigger reason Global global <concurrent-kickoff> Low free memory tenure area threshold reached. Cycle trigger element is located before the <cycle-start> element. Partial scavenge <af-start> Allocation failure. Cycle trigger element is located before the <cycle-start> element. You can use the type attribute of the <gc-start> and <gc-end> elements to locate a particular cycle. You can also locate a particular type of cycle by searching for the element that records the cycle trigger, which is located before the <cycle-start> element. You can analyze the increments and operations that are associated with a particular type of cycle by locating and interpreting the elements in the following table: Table showing increments and operations that are associated with the gencon partial scavenge and global cycles. GC process Elements that log the start and end of the event Details GC cycle <cycle-start> , <cycle-end> The start and end of a GC cycle. GC STW increment <gc-start> , <gc-end> The start and end of a GC increment that begins with a pause. GC STW increment <concurrent-kickoff> The start of the initial GC increment of the global concurrent cycle that begins the initial mark operation. GC STW increment <concurrent-global-final> The start of the final GC increment of the global concurrent cycle that executes the final collection. GC operations and suboperations <gc-op> A GC operation such as mark or sweep, or a suboperation such as class unload. Note: For more information about the XML structure of GC cycles, see GC cycles . For more information about GC cycle increments, see GC increments and interleaving . The following examples use log excerpts to show how the different types of gencon cycle are logged.","title":"gencon examples"},{"location":"vgclog_examples/#scavenge-partial-gc-cycle","text":"The following example is taken from a gencon log. The output is broken down into sections with supporting text to explain the GC processing that is taking place. To search for a scavenge partial GC cycle, you can search for the type attribute value scavenge in cycle-start and cycle-end elements, or search for the <af> element that logs the allocation failure trigger. By default, the gencon partial GC cycle runs by using a single STW pause. The cycle performs only one operation, a scavenge operation, which runs only on the nursery area. The cycle consists of a single GC increment, which is labeled by using the elements that are shown in the following table: Table showing the gencon default partial scavenge cycle's GC increment and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment Details scavenge single STW <gc-start> , <gc-end> Contains detailed information about copied objects and the weak roots processing operation The scavenge partial GC cycle follows a general structure in the verbose GC log as shown. Some elements are omitted for clarity: <exclusive-start/> (STW Pause starts) <af-start/> (allocation failure trigger recorded) <cycle-start/> (scavenge cycle starts) <gc-start> (scavenge cycle increment starts) <mem-info> (memory status before operation) <mem></mem> (status of different areas of heap) </mem-info> </gc-start> <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <gc-op> \u201cscavenge\"</gc-op> (scavenge operation completed) <gc-end> (scavenge cycle increment ends) <mem-info> (memory status after operation) <mem></mem> (status of different areas of heap) </mem-info> </gc-end> </cycle-end> (scavenge cycle ends) <allocation-satisfied/> (required allocation has been achieved) <af-end/> <exclusive-end> (STW for scavenge cycle ends) ... The first activity in the cycle is recorded by an <exclusive-start> element, which indicates the start of the STW pause. Application (or mutator ) threads are halted to give the garbage collector exclusive access to the Java\u2122 object heap: <!-- Start of gencon scavenge partial GC cycle example --> <exclusive-start id=\"12392\" timestamp=\"2020-10-18T13:35:45.000\" intervalms=\"406.180\"> <response-info timems=\"0.070\" idlems=\"0.070\" threads=\"0\" lastid=\"00000000013D6900\" lastname=\"LargeThreadPool-thread-68\" /> </exclusive-start> The <af-start> element indicates that the cycle was triggered by an allocation failure in the nursery ( type=\"nursery\" ) area of the heap: <af-start id=\"12393\" threadId=\"00000000013D7280\" totalBytesRequested=\"8200\" timestamp=\"2020-10-18T13:35:45.000\" intervalms=\"418.233\" type=\"nursery\" /> The <cycle-start> element marks the start of the cycle. The attribute type=\"scavenge\" confirms that this activity is a scavenge partial GC cycle: <cycle-start id=\"12394\" type=\"scavenge\" contextid=\"0\" timestamp=\"2020-10-18T13:35:45.000\" intervalms=\"418.231\" /> Most elements are labeled with an id attribute that increases in value incrementally, a timestamp attribute, and a contextid attribute. All elements that record GC increments and operations that are associated with a particular cycle have a contextid value that matches the id value of the cycle. The <cycle-start> element of this example cycle has an id=\"12394\" , so all subsequent elements that have a contextid=\"4\" , such as the <gc-start> increment element and the <gc-op> operation element, are associated with this particular example cycle. The <gc-start> element records the first GC increment. In this <gc-start> section, you can find information about the amount of memory available ( <mem-info> ) and where it is located in the Java object heap. The memory snapshot within the <gc-start> element is taken before the scavenge operation and can be compared with a similar snapshot that is taken afterward to understand the effect on the heap. <gc-start id=\"12395\" type=\"scavenge\" contextid=\"12394\" timestamp=\"2020-10-18T13:35:45.000\"> <mem-info id=\"12396\" free=\"414960320\" total=\"1073741824\" percent=\"38\"> <mem type=\"nursery\" free=\"0\" total=\"268435456\" percent=\"0\"> <mem type=\"allocate\" free=\"0\" total=\"241565696\" percent=\"0\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"414960320\" total=\"805306368\" percent=\"51\"> <mem type=\"soa\" free=\"374694592\" total=\"765040640\" percent=\"48\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <remembered-set count=\"21474\" /> </mem-info> </gc-start> The following statements describe the object heap memory allocation at the start of the increment: The allocate space of the nursery area is full, or close to full. The allocation failure was triggered by the lack of available memory in this space. The survivor space of the nursery area is reported as 'full' to reflect that no available memory is available to allocate to the mutator threads. The entire survivor space is reserved for GC operations during the GC increment. The tenure area has 395.7 MB (414,960,320B) of free memory available. The next element <allocation-stats> shows a snapshot, which was taken before the cycle started, of how memory was divided up between application threads. In this example, the thread that used the most memory was LargeThreadPool-thread-79 . <allocation-stats totalBytes=\"235362176\" > <allocated-bytes non-tlh=\"32880\" tlh=\"235329296\" /> <largest-consumer threadName=\"LargeThreadPool-thread-79\" threadId=\"00000000013F0C00\" bytes=\"6288544\" /> </allocation-stats> The scavenge GC operation is recorded by the <gc-op> element; child elements record details about the operation. For example, <gc-op id=\"12397\" type=\"scavenge\" timems=\"11.649\" contextid=\"12394\" timestamp=\"2020-10-18T13:35:45.012\"> <scavenger-info tenureage=\"7\" tenuremask=\"4080\" tiltratio=\"89\" /> <memory-copied type=\"nursery\" objects=\"154910\" bytes=\"6027440\" bytesdiscarded=\"394832\" /> <memory-copied type=\"tenure\" objects=\"16171\" bytes=\"562848\" bytesdiscarded=\"3064\" /> <ownableSynchronizers candidates=\"10838\" cleared=\"10824\" /> <references type=\"soft\" candidates=\"24\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"16\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"390\" cleared=\"269\" enqueued=\"269\" /> <references type=\"phantom\" candidates=\"1\" cleared=\"0\" enqueued=\"0\" /> <object-monitors candidates=\"132\" cleared=\"0\" /> </gc-op> The <memory-copied> element indicates that 5.75 MB (6,027,440B) of reachable objects were moved by the scavenge operation from the allocate space to the survivor space in the nursery area, and 0.54 MB(562,848 B) were moved to the tenure area. The <scavenger-info> element shows that the tenure age is set to 7 . Any object in the allocate space with an age less than or equal to 7 is copied to the survivor space during this scavenge operation. Any object that is copied between the allocate and survivor areas more than 7 times is moved to the tenure area. For more information about how the scavenge operation acts on the Java object heap, see GC processing . The end of the increment is recorded with <gc-end> and provides another snapshot of memory allocation on the heap, similar to <gc-start> . <gc-end id=\"12398\" type=\"scavenge\" contextid=\"12394\" durationms=\"11.785\" usertimems=\"46.278\" systemtimems=\"0.036\" stalltimems=\"0.145\" timestamp=\"2020-10-18T13:35:45.012\" activeThreads=\"4\"> <mem-info id=\"12399\" free=\"649473560\" total=\"1073741824\" percent=\"60\"> <mem type=\"nursery\" free=\"235142120\" total=\"268435456\" percent=\"87\"> <mem type=\"allocate\" free=\"235142120\" total=\"241565696\" percent=\"97\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"414331440\" total=\"805306368\" percent=\"51\" macro-fragmented=\"0\"> <mem type=\"soa\" free=\"374065712\" total=\"765040640\" percent=\"48\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <pending-finalizers system=\"0\" default=\"0\" reference=\"269\" classloader=\"0\" /> <remembered-set count=\"13792\" /> </mem-info> </gc-end> The Java object heap memory allocation at the end of the increment is as follows: 97% of the allocate space of the nursery area is now available as free memory. The survivor space of the nursery area is still reported as 'full' to reflect that the entire survivor space is reserved for GC operations during the next GC increment. The tenure area has 395 MB (414,331,440B) of free memory available. The scavenge operation copied 562 KB from the nursery area to the tenure area so less memory is now available in the tenure area. The scavenge operation successfully reclaimed memory in the allocate space of the nursery area by copying objects from the allocate space into the survivor space of the nursery area, and copying objects from the survivor space into the tenure area. The cycle ends ( <cycle-end> ). The following <allocation-satisfied> element indicates that the allocation request that caused the allocation failure can now complete successfully. The STW pause ends with the <exclusive-end> element: <cycle-end id=\"12400\" type=\"scavenge\" contextid=\"12394\" timestamp=\"2020-10-18T13:35:45.012\" /> <allocation-satisfied id=\"12401\" threadId=\"00000000013D6900\" bytesRequested=\"8200\" /> <af-end id=\"12402\" timestamp=\"2020-10-18T13:35:45.012\" threadId=\"00000000013D7280\" success=\"true\" from=\"nursery\"/> <exclusive-end id=\"12403\" timestamp=\"2020-10-18T13:35:45.012\" durationms=\"12.319\" /> <!-- End of gencon partial GC cycle example -->","title":"Scavenge partial GC cycle"},{"location":"vgclog_examples/#summary","text":"Analyzing the structure and elements of this example log output shows that this example global cycle has the following characteristics: The GC cycle begins with an STW pause due to an allocation failure. All GC operations and suboperations that are associated with this cycle occur during the STW pause The cycle consists of only 1 GC increment, which runs a single scavenge operation. The GC cycle reclaims memory in the allocate area of the nursery area by coping objects from the allocate area to the survivor area and also to the tenure area.","title":"Summary"},{"location":"vgclog_examples/#concurrent-scavenge-partial-gc-cycle-non-default","text":"When concurrent scavenge mode is enabled, the partial GC cycle is run as a Concurrent Scavenge cycle. This partial GC cycle is divided into increments to enable the majority of the scavenge operation to run concurrently with running application (or mutator ) threads. The concurrent increment can run while application threads run, and also while the intermediate concurrent increment of the global GC cycle runs. The interleaving of the concurrent scavenge partial GC cycle with the global cycle can be seen in the logs. The following elements log the GC increments and operations of the concurrent scavenge partial GC cycle: Table showing the gencon concurrent (non-default) partial scavenge cycle's GC increment and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment Details scavenge initial STW <gc-start> , <gc-end> Root scanning, reported as a single scavenge operation. scavenge intermediate concurrent <concurrent-start> , <concurrent-end> Live objects are traversed and evacuated (*copy forward*). Operation is reported as a scavenge operation. scavenge final STW <gc-start> , <gc-end> weak roots scanning, reported as a complex scavenge operation. <gc-op> contains specific details for each of the weak root groups. To search for a concurrent scavenge partial GC cycle, you can search for the type attribute value scavenge in cycle-start and cycle-end elements, or search for the <af> element that logs the allocation failure trigger. You can locate the concurrent scavenge partial cycle's concurrent increment by searching for <concurrent-start> and <concurrent-end> . The global cycle's intermediate concurrent increment, which can run at the same time, is not logged by an element, but begins immediately after application threads are restarted following the <cycle-start type=\"global\"/> element. For more information about the global cycle's intermediate concurrent increment, see gencon global GC cycle . For more information about GC increments, see GC increments and interleaving .","title":"Concurrent scavenge partial GC cycle (non-default)"},{"location":"vgclog_examples/#gencon-global-gc-cycle","text":"The following example shows how a global GC cycle is recorded in a gencon policy verbose GC log. The output is broken down into sections with supporting text to explain the GC processing that is taking place. The global GC cycle runs when the tenure area is close to full, which typically occurs after many partial cycles. As such, the output can be found part way down a full log. For more information about the GC initialization section, see Initialization . For an example log output for a gencon partial cycle, see Scavenge partial GC cycle . The global GC cycle is split into three increments, as shown in GC increments and interleaving . Splitting the cycle operations into the following increments reduces pause times by running the majority of the GC work concurrently. The concurrent increment pauses when a partial GC cycle is triggered and resumes after the partial cycle, or multiple cycles, finish. The interleaving of partial GC cycles with the global cycle's intermediate concurrent increment can be seen in the following gencon global GC cycle log output. A single partial GC cycle is logged between the initial and final increments of the global cycle. To search for a global cycle, you can search for the type attribute value global in cycle-start and cycle-end elements, or search for the element that logs the initial concurrent increment, <concurrent-kickoff> . The following elements log the GC increments and operations of the global GC cycle: Table showing the gencon global cycle's GC increment and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment Details n/a - initiates cycle initial STW <concurrent-kickoff> No <gc-op> is logged. This increment just initiates the concurrent mark increment. concurrent mark intermediate concurrent none <concurrent-trace-info> records the progress of the concurrent mark increment. final collection final STW <concurrent-global-final> The increment is typically triggered when a card cleaning threshold is reached. The completion of a tracing phase can also trigger the increment. Operations include a final concurrent mark, a sweep, and an optional class unload and compact. The global GC cycle follows a general structure in the verbose GC log. Some child elements are omitted for clarity. Multiple partial GC cycles can start and finish between the start and end of a global GC cycle. In the following example, the structure includes a single partial GC cycle within the global cycle: <concurrent-kickoff/> (global cycle 1st increment recorded) <exclusive-start/> (STW pause starts) <cycle-start/> (global cycle starts) <exclusive-end/> (STW pause ends) (mutator threads running, global cycle concurrent increment running concurrently) <exclusive-start/> (STW for partial GC cycle starts) ... (partial GC cycle starts and completes) <exclusive-end/> (STW for partial GC cycle ends) (mutator threads running, global cycle concurrent increment running concurrently) <exclusive-start/> (STW pause starts) <concurrent-global-final/> (global cycle final increment recorded) <gc-start/> (global cycle final increment starts) <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <mem-info> (memory status before operations) <mem></mem> (status of different areas of heap) </mem-info> </gc-start> <gc-op> \u201ctype=rs-scan\"</gc-op> (remembered set scan completed) <gc-op>\u201dtype=card-cleaning\" </gc-op> (card cleaning completed) <gc-op> \u201ctype=mark\u201d</gc-op> (final mark operation and weak roots processing completed) <gc-op> \u201ctype=classunload\u201d</gc-op> (class unload operation completed) <gc-op \u201dtype=sweep\u201d /> (sweep operation completed) <gc-end> (global cycle final increment ends) <mem-info> (memory status after operations) <mem></mem> (status of different areas of heap) </mem-info> </gc-end> </cycle-end> (global cycle ends) <exclusive-end> (STW pause ends) <exclusive-start> (STW pause starts) ... The first activity in the cycle is recorded by a <concurrent-kickoff> element, which records the start of the first of three increments that make up a gencon global GC cycle. The <concurrent-kickoff> element records the following information: The reason why the GC cycle was triggered. For a gencon global cycle, the cycle is triggered when the amount of free memory decreases to a threshold value, the thresholdFreeBytes value. The target number of bytes, targetBytes , that the cycle aims to mark concurrently. The current available memory in the different parts of the heap. <concurrent-kickoff id=\"12362\" timestamp=\"2020-10-18T13:35:44.341\"> <kickoff reason=\"threshold reached\" targetBytes=\"239014924\" thresholdFreeBytes=\"33024922\" remainingFree=\"32933776\" tenureFreeBytes=\"42439200\" nurseryFreeBytes=\"32933776\" /> </concurrent-kickoff> For this example, the remainingFree bytes value of 31.4 MB (32,933,776B) is approaching the thresholdFreeBytes value of 31.5 MB (33,024,922B) so a global cycle is triggered. This cycle aims to trace 228 MB (239,014,924B) during the concurrent increment. If the concurrent increment is interrupted by a card cleaning threshold value before it traces all 228 MB, the final STW increment completes the tracing during the STW pause. Note: To analyze specific parts of a cycle, you can search for the elements that mark a specific increment of the cycle. For example, you can search for the element to locate the final increment of the gencon global cycle. See the details of a particular cycle, such as the gencon global GC cycle , to determine the element names for particular STW or concurrent GC increments or operations. The next element recorded in the log, the <exclusive-start> element, records the start of an STW pause: <exclusive-start id=\"12363\" timestamp=\"2020-10-18T13:35:44.344\" intervalms=\"342.152\"> <response-info timems=\"0.135\" idlems=\"0.068\" threads=\"3\" lastid=\"00000000015DE600\" lastname=\"LargeThreadPool-thread-24\" /> </exclusive-start> The following <gc-start> element records details of the start of a new cycle. <cycle-start id=\"12364\" type=\"global\" contextid=\"0\" timestamp=\"2020-10-18T13:35:44.344\" intervalms=\"516655.052\" /> The type attribute records the cycle as a global cycle. The contextid of the cycle is, which indicates that all GC events that are associated with this cycle are tagged in relation to the id of this cycle. In particular, all subsequent elements that are associated with this particular example cycle have a contextid value equal to the <cycle-start> id attribute value of \u201c12634\u201d . The next element in the log is <exclusive-end> , which records the end of the STW pause: <exclusive-end id=\"12365\" timestamp=\"2020-10-18T13:35:44.344\" durationms=\"0.048\" /> The operations and suboperations of the second increment of the gencon global cycle are now running concurrently. The next section of the logs records an STW pause that is associated with an allocation failure. The <cycle-start> element that follows this STW pause indicates that the cycle is a scavenge cycle, which is the partial GC cycle that is used by the gencon GC: ... <cycle-start id=\"12368\" type=\"scavenge\" contextid=\"0\" timestamp=\"2020-10-18T13:35:44.582\" intervalms=\"580.047\" /> ... Subsequent elements have a contextid=\u201c12368\u201d , which matches the id of this new scavenge cycle. For more information about how this cycle is recorded in the logs, see Scavenge partial GC cycle . The operations and suboperations of the second, concurrent increment of the gencon global cycle are paused while the STW scavenge operation is running, and resume when the STW pause finishes. After the partial GC cycle completes and the STW pause finishes, the log records a new STW pause, which is triggered to enable the final gencon global GC increment to run. This final increment finishes marking the nursery area and completes the global cycle. The <exclusive-start> element is followed by a <concurrent-global-final> element, which logs the beginning of this final increment (and by implication, the end of the second increment). <exclusive-start id=\"12378\" timestamp=\"2020-10-18T13:35:44.594\" intervalms=\"12.075\"> <response-info timems=\"0.108\" idlems=\"0.040\" threads=\"3\" lastid=\"00000000018D3800\" lastname=\"LargeThreadPool-thread-33\" /> </exclusive-start> <concurrent-global-final id=\"12379\" timestamp=\"2020-10-18T13:35:44.594\" intervalms=\"516905.029\" > <concurrent-trace-info reason=\"card cleaning threshold reached\" tracedByMutators=\"200087048\" tracedByHelpers=\"12164180\" cardsCleaned=\"4966\" workStackOverflowCount=\"0\" /> </concurrent-global-final> The reason attribute of the <concurrent-trace-info> child element indicates that this final STW increment of the global cycle was triggered because a card-cleaning threshold was reached. The concurrent tracing was stopped prematurely and the targetBytes concurrent tracing target, recorded at the cycle start by <concurrent-kickoff> , was not achieved concurrently. If the concurrent tracing completes without interruption, the <concurrent-trace-info element logs reason=tracing completed . In the next section that begins with the gc-start element, you can find information about the amount of memory available ( <mem-info> ) and where it is located in the java object heap. This snapshot is taken before the final increment's operations and suboperations are run and can be compared with a similar snapshot that is taken afterward to understand the effect on the heap. The child element attribute values of the <mem> and <mem-info> elements indicate the status of the memory. Note: You can double check that the increment is associated with the GC global cycle in the example by checking the contextid attribute value matches the id=12364 attribute value of the cycle's element. <gc-start id=\"12380\" type=\"global\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.594\"> <mem-info id=\"12381\" free=\"277048640\" total=\"1073741824\" percent=\"25\"> <mem type=\"nursery\" free=\"234609440\" total=\"268435456\" percent=\"87\"> <mem type=\"allocate\" free=\"234609440\" total=\"241565696\" percent=\"97\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"42439200\" total=\"805306368\" percent=\"5\"> <mem type=\"soa\" free=\"2173472\" total=\"765040640\" percent=\"0\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <pending-finalizers system=\"0\" default=\"0\" reference=\"405\" classloader=\"0\" /> <remembered-set count=\"17388\" /> </mem-info> </gc-start> <allocation-stats totalBytes=\"827488\" > <allocated-bytes non-tlh=\"96\" tlh=\"827392\" /> <largest-consumer threadName=\"LargeThreadPool-thread-68\" threadId=\"00000000013D6900\" bytes=\"65632\" /> </allocation-stats> The next element <allocation-stats> shows a snapshot of how memory was divided up between application threads before the current cycle started. In this example, the thread that used the most memory was LargeThreadPool-thread-68 . For this example, at the start of this GC increment, the tenure area is low on free memory, as expected. 25% of the total heap is available as free memory, which is split between the following areas of the heap: The nursery area, which has 223.7 MB (234,609,440B) of free memory available. The free memory is only available in the allocate space of the nursery area. The survivor space of the nursery area is reported as 'full' to reflect that no available memory is available to allocate to the mutator threads. The entire survivor space is reserved for GC operations during the GC increment. The tenure area, which has 40.5 MB (42,439,200B) available as free memory, which is only 5% of its total memory. Most of this free memory is in the large object area (LOA). Almost no free memory is available in the small object area (SOA). The <gc-op> elements and their child elements contain information about the operations and suboperations in the increment. The final increment of the gencon global cycle consists of multiple operations, each logged with a <gc-op> element. The type of operation is shown by the <gc-op> type attribute. The final increment of the example log runs five types of operation: rs-scan card-cleaning mark classunload sweep Note: The final increment of a gencon global cycle can include an optional compact suboperation. For more information about the different types of GC operation, see GC operations . <gc-op id=\"12382\" type=\"rs-scan\" timems=\"3.525\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.598\"> <scan objectsFound=\"11895\" bytesTraced=\"5537600\" workStackOverflowCount=\"0\" /> </gc-op> <gc-op id=\"12383\" type=\"card-cleaning\" timems=\"2.910\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.601\"> <card-cleaning cardsCleaned=\"3603\" bytesTraced=\"5808348\" workStackOverflowCount=\"0\" /> </gc-op> <gc-op id=\"12384\" type=\"mark\" timems=\"6.495\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.607\"> <trace-info objectcount=\"1936\" scancount=\"1698\" scanbytes=\"61200\" /> <finalization candidates=\"389\" enqueued=\"1\" /> <ownableSynchronizers candidates=\"5076\" cleared=\"523\" /> <references type=\"soft\" candidates=\"18420\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"32\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"19920\" cleared=\"114\" enqueued=\"60\" /> <references type=\"phantom\" candidates=\"671\" cleared=\"50\" enqueued=\"50\" /> <stringconstants candidates=\"40956\" cleared=\"109\" /> <object-monitors candidates=\"182\" cleared=\"51\" /> </gc-op> <gc-op id=\"12385\" type=\"classunload\" timems=\"1.607\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.609\"> <classunload-info classloadercandidates=\"425\" classloadersunloaded=\"6\" classesunloaded=\"2\" anonymousclassesunloaded=\"1\" quiescems=\"0.000\" setupms=\"1.581\" scanms=\"0.019\" postms=\"0.007\" /> </gc-op> <gc-op id=\"12386\" type=\"sweep\" timems=\"9.464\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.618\" /> The end of the increment is recorded with <gc-end> and provides another snapshot of memory in the heap, similar to <gc-start> . <gc-end id=\"12387\" type=\"global\" contextid=\"12364\" durationms=\"24.220\" usertimems=\"86.465\" systemtimems=\"0.000\" stalltimems=\"2.846\" timestamp=\"2020-10-18T13:35:44.618\" activeThreads=\"4\"> <mem-info id=\"12388\" free=\"650476504\" total=\"1073741824\" percent=\"60\"> <mem type=\"nursery\" free=\"235516088\" total=\"268435456\" percent=\"87\"> <mem type=\"allocate\" free=\"235516088\" total=\"241565696\" percent=\"97\" /> <mem type=\"survivor\" free=\"0\" total=\"26869760\" percent=\"0\" /> </mem> <mem type=\"tenure\" free=\"414960416\" total=\"805306368\" percent=\"51\" micro-fragmented=\"98245682\" macro-fragmented=\"0\"> <mem type=\"soa\" free=\"374694688\" total=\"765040640\" percent=\"48\" /> <mem type=\"loa\" free=\"40265728\" total=\"40265728\" percent=\"100\" /> </mem> <pending-finalizers system=\"1\" default=\"0\" reference=\"515\" classloader=\"0\" /> <remembered-set count=\"13554\" /> </mem-info> </gc-end> 60% of the heap now contains free memory as a result of the final global cycle increment, which is split between the following areas of the heap: The nursery area, which gained 0.9 MB of free memory. The nursery area now has 224.6 MB (235,516,088B) available as free memory. At the start of the final increment, the nursery area had 223.7 MB (234,609,440B) of free memory available. The tenure area, which gained 355.2 MB (372,521,216B) of free memory. (the tenure area now has 395.7 MB (414,960,416B) available as free memory. At the start of the final increment, the tenure area had 40.5 MB (42,439,200B) of free memory available). Note: The global GC cycle runs to reclaim memory in the tenure area. The freeing up of memory in the nursery area is achieved by using the partial GC cycle. For more information, see gencon policy (default) . After the final increment of the global cycle completes, the global cycle ends and the STW pause ends, as shown in the following output: <cycle-end id=\"12389\" type=\"global\" contextid=\"12364\" timestamp=\"2020-10-18T13:35:44.619\" /> <exclusive-end id=\"12391\" timestamp=\"2020-10-18T13:35:44.619\" durationms=\"24.679\" />","title":"gencon global GC cycle"},{"location":"vgclog_examples/#summary_1","text":"Analyzing the structure and elements of this example log output shows that this example global cycle has the following characteristics: The GC global cycle is triggered when a memory threshold is reached and begins with an STW pause. After the first increment of the GC global cycle completes, the STW pause ends and the second increment runs concurrently. A single partial GC cycle starts and finishes between the start and end of the concurrent increment. An STW pause begins after the concurrent increments completes, during which the third and final increment of the global cycle, which consists of five operations, runs. The global GC cycle reclaims memory in the tenure area and a small amount of memory in the nursery area.","title":"Summary"},{"location":"vgclog_examples/#balanced-examples","text":"The balanced policy ( -Xgcpolicy:balanced ) uses two types of cycle to perform GC; a partial GC cycle and a global GC mark cycle. The policy might also run a third type of cycle, which is a global cycle, to reclaim memory after an allocation failure that results from tight memory conditions. For more information about the cycles used in a particular policy, see GC policies . The start of a balanced cycle is recorded in the log by the following elements and attributes: Table showing types of balanced cycle, the corresponding trigger, and XML elements for each `type`. GC cycle or increment Value of type attribute of the cycle or increment elements Element that logs the cycle trigger Trigger reason partial cycle partial gc <allocation-taxation> Allocation taxation threshold reached. global mark cycle global mark phase <allocation-taxation> Allocation taxation threshold reached. global mark STW subincrement of global mark cycle mark increment n/a Allocation taxation threshold reached global mark concurrent subincrement of global mark cycle GMP work packet processing n/a Allocation taxation threshold reached global cycle global garbage collect <af-start> (or <sys-start reason=\"explicit\"> if triggered explicitly) Allocation failure. Occurs under tight memory conditions. Cycle runs rarely. To locate a particular type of cycle, you can search for the type attribute of the <cycle-start> and <cycle-end> elements. When memory in the Java object heap reaches a memory threshold, called an allocation taxation threshold, a balanced partial GC cycle, balanced global mark cycle, or balanced global mark cycle increment, is triggered. If the available memory in the heap is low, the GC triggers a balanced global mark cycle, or a global mark cycle increment if the global mark cycle is in progress. Otherwise, the GC triggers a partial cycle. Partial GC cycles, global mark cycles, and global GC cycles set the allocation taxation threshold at the end of their cycle or increment to schedule the next cycle or increment. For balanced cycles, the taxation on the mutator threads refers to pausing the mutator threads while GC work is run. When a partial cycle ends, if the cycle is not run between global mark phase increments of a global mark cycle, and a global mark cycle is not scheduled as the next cycle, the allocation taxation threshold is set to trigger the next partial cycle when the eden space is full. Specifically, the allocation threshold is set to be equal to the size of the eden space. If a partial cycle runs within a global mark cycle, or if a global mark cycle is scheduled as the next cycle, the allocation taxation threshold, set at the end of the partial cycle, is set to be smaller than the size of the eden space. Specifically, the allocation taxation threshold is set to be half the size of the eden space so that the next global mark cycle or global mark cycle increment has enough memory available in the eden space to run. For more information about GC increments, see GC increments and interleaving . You can analyze the increments and operations that are associated with a particular type of cycle by locating and interpreting the elements in the following table: Table showing increments and operations that are associated with the balanced partial and global mark cycles GC process Elements that log the start and end of the event> Details GC cycle <cycle-start> , <cycle-end> The start and end of a GC cycle GC STW increment <gc-start> <gc-end> The start and end of a GC increment or subincrement that begins with a STW pause. For example, a global mark phase global mark GC cycle increment or a partial GC cycle increment GC concurrent increment <concurrent-start> , <concurrent-end> The start of the concurrent global mark phase work packet processing subincrements of the global mark cycle GC operations and phases <gc-op> A GC operation such as mark or sweep, or a suboperation such as class unload. For more information about the XML structure of GC cycles, see GC cycles . The following sections use log excerpts to show how the different GC processes are logged.","title":"balanced examples"},{"location":"vgclog_examples/#balanced-partial-gc-cycle","text":"The following example is taken from a balanced policy verbose GC log. The output is broken down into sections to explain the GC processing that is taking place. To search for a balanced partial GC cycle, you can search for the type attribute value partial gc in <cycle-start> and <cycle-end> elements. The partial GC cycle reclaims memory in the heap for the allocation of new objects by reducing the number of used regions. The partial GC cycle always reduces used regions in the eden space and might also reclaim memory from older regions. Multiple partial GC cycles often run in between global mark phase increments of the balanced global mark GC cycle . All the operations in a partial GC cycle run during a single STW pause, as shown in the following table: Table showing the balanced partial GC cycle operation and corresponding XML elements. GC operation GC increment STW or concurrent XML element of GC increment copy forward, and optionally class unload, sweep, and compact single STW <gc-start> , <gc-end> The following general structure shows a balanced partial GC cycle. Some child elements are omitted for clarity: <exclusive-start/> (STW pause starts) <allocation-taxation/> (memory threshold trigger recorded) <cycle-start/> (partial cycle starts) <gc-start/> (partial cycle increment starts) <mem-info> (memory status before operations) <mem></mem> (status of different types of memory) </mem-info> </gc-start> <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <gc-op> type=\"copy forward\" </gc-op> (copy forward operation completed) <gc-op> type=\"class unload\" </gc-op> (class unload operation completed) <gc-op> type=\"sweep\" </gc-op> (sweep operation completed) <gc-op> type=\"compact\" </gc-op> (compact operation completed) <gc-end> (partial cycle increment ends) <mem-info> (memory status after operations) <mem></mem> (status of different types of memory) </mem-info> </gc-end> <cycle-end> (partial cycle ends) <exclusive-end> (STW pause ends) When the balanced partial GC cycle is triggered, the GC runs an STW pause. Application (or mutator ) threads are halted to give the garbage collector exclusive access to the heap. The STW pause is recorded in the logs by the <exclusive-start> element. <exclusive-start id=\"184\" timestamp=\"2021-02-26T11:11:42.310\" intervalms=\"3745.790\"> <response-info timems=\"3.138\" idlems=\"1.056\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> An allocation taxation threshold triggers a balanced partial GC cycle. The logs record this trigger reason by using the <allocation-taxation> element. <allocation-taxation id=\"185\" taxation-threshold=\"2147483648\" timestamp=\"2021-02-26T11:11:42.311\" intervalms=\"3745.785\" /> Details about the start of the cycle are recorded by the <cycle-start> element. The cycle is recorded as a partial gc with an id=336 . Any subsequent elements that are associated with this cycle have a contextid=186 to match the cycle id . You can use this contextid value to distinguish the partial GC cycle increment and operations from interleaving increments and operations of other balanced cycles, such as global mark cycles. <cycle-start id=\"186\" type=\"partial gc\" contextid=\"0\" timestamp=\"2021-02-26T11:11:42.311\" intervalms=\"3745.805\" /> The partial cycle begins its only GC increment, recorded by using the <gc-start> element. You can understand the effect that the increment operations have on the heap by comparing snapshots of the memory that are taken at the start and the end of the increment. The child elements <mem-info> and <mem> of the <gc-start> and <gc-end> elements record the amount of memory available and where it is located in the heap. <gc-start id=\"187\" type=\"partial gc\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.311\"> <mem-info id=\"188\" free=\"897581056\" total=\"4294967296\" percent=\"20\"> <mem type=\"eden\" free=\"0\" total=\"2147483648\" percent=\"0\" /> <arraylet-primitive objects=\"1\" leaves=\"4\" largest=\"4\" /> <remembered-set count=\"2749664\" freebytes=\"160705664\" totalbytes=\"171704320\" percent=\"93\" regionsoverflowed=\"1\" regionsstable=\"12\" regionsrebuilding=\"0\"/> </mem-info> </gc-start> As expected, at the start of this increment, the eden regions are full. 856 MB (897,581,056 B) of the total 4096 MB (4294,967,296 B) heap, equivalent to 20% of the heap, is available as free memory. The status of the remembered set , a metastructure specific to Eclipse OpenJ9\u2122 generational garbage collectors, is reported by the <remembered-set> element. The remembered set metastructure keeps a record of any object references that cross different regions. Each region corresponds to a single remembered set. The partial GC cycle uses and prunes the remembered set. The regionsoverflowed value records the number of regions that exceeded the non-object heap memory allocation that is reserved for the remembered set. The partial GC cycle cannot reclaim memory from these overflow regions. The partial GC cycle also cannot reclaim memory from any regions whose remembered set is being rebuilt by an increment of a global mark cycle that is in progress. At the start of the partial GC cycle, the remembered set is using 93% of its available memory capacity, with 153.26 MB (160705664 B) available. The set consists of 2,749,664 cards and has one overflow region. The following element, <allocation-stats> , records information about how memory was divided between application (or mutator ) threads before the start of the current cycle. For this example, the thread Group1.Backend.CompositeBackend{Tier1}.7 was the largest consumer of memory. <allocation-stats totalBytes=\"2146431360\" > <allocated-bytes non-tlh=\"96417448\" tlh=\"2050013912\" arrayletleaf=\"0\"/> <largest-consumer threadName=\"Group1.Backend.CompositeBackend{Tier1}.7\" threadId=\"00000000007E9300\" bytes=\"275750048\" /> </allocation-stats> The operations of the GC increment are run and details are recorded in the <gc-op> elements. The logs show that this increment begins with a copy forward operation followed by a class unload. Other balanced partial GC cycles can also include sweep and compact operations. For more information about the operations involved in balanced partial GC cycles, see GC Processing . <gc-op id=\"189\" type=\"copy forward\" timems=\"400.637\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.713\"> <memory-copied type=\"eden\" objects=\"4434622\" bytes=\"119281928\" bytesdiscarded=\"1382272\" /> <memory-copied type=\"other\" objects=\"8847813\" bytes=\"244414264\" bytesdiscarded=\"6243176\" /> <memory-cardclean objects=\"1446970\" bytes=\"64143048\" /> <regions eden=\"512\" other=\"80\" /> <remembered-set-cleared processed=\"2435794\" cleared=\"887129\" durationms=\"8.667\" /> <finalization candidates=\"66\" enqueued=\"56\" /> <ownableSynchronizers candidates=\"256500\" cleared=\"78012\" /> <references type=\"soft\" candidates=\"153648\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"22\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"1266\" cleared=\"610\" enqueued=\"430\" /> <stringconstants candidates=\"9479\" cleared=\"0\" /> <object-monitors candidates=\"13576\" cleared=\"13505\" /> </gc-op> <gc-op id=\"190\" type=\"classunload\" timems=\"0.010\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.713\"> <classunload-info classloadercandidates=\"179\" classloadersunloaded=\"0\" classesunloaded=\"0\" anonymousclassesunloaded=\"0\" quiescems=\"0.000\" setupms=\"0.010\" scanms=\"0.000\" postms=\"0.000\" /> </gc-op> The logs show that the copy forward operation acts on the entire eden space (512 regions), recorded as type=eden , and 80 older regions, which are recorded as type=other . 113.76 MB (119281928 B) of memory was copied from the eden space to 1st generation regions and 233.10 MB (244414264 B) of memory in non-eden regions was copied to the next generation of regions. The copy forward operation is followed by a class unload operation. In some cases, a copy forward operation moves some regions by copying forward the objects in those regions, but only marks the objects in other regions. For example, the following log excerpt is taken from a different partial cycle, which corresponds to a contextid of 2049 . The copy forward operation in the following example involves marking some regions and copying forward other regions. <gc-op id=\"2052\" type=\"copy forward\" timems=\"649.059\" contextid=\"2049\" timestamp=\"2021-02-26T11:22:34.901\"> <memory-copied type=\"eden\" objects=\"95989\" bytes=\"7882704\" bytesdiscarded=\"501088\" /> <memory-copied type=\"other\" objects=\"2955854\" bytes=\"86854064\" bytesdiscarded=\"626024\" /> <memory-cardclean objects=\"1304\" bytes=\"56840\" /> <memory-traced type=\"eden\" objects=\"23392785\" bytes=\"553756840\" /> <memory-traced type=\"other\" objects=\"5461302\" bytes=\"131394216\" /> <regions eden=\"488\" other=\"138\" /> <remembered-set-cleared processed=\"156775\" cleared=\"4897\" durationms=\"1.759\" /> <finalization candidates=\"31\" enqueued=\"12\" /> <ownableSynchronizers candidates=\"1992467\" cleared=\"1600904\" /> <references type=\"soft\" candidates=\"329190\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"8\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"697\" cleared=\"105\" enqueued=\"6\" /> <stringconstants candidates=\"9848\" cleared=\"0\" /> <object-monitors candidates=\"1437\" cleared=\"1353\" /> <heap-resize type=\"expand\" space=\"default\" amount=\"0\" count=\"1\" timems=\"0.000\" reason=\"continue current collection\" /> <warning details=\"operation aborted due to insufficient free space\" /> </gc-op> The logs record these two concurrent parts of a copy forward operation in the <gc-op type=\"copy forward\"> section by using a <memory-traced> child element. In addition, evacuated and marked attributes for the <regions> child element are used to distinguish between the number of regions that were copied-forward (recorded as evacuated ) and the number of regions that were only marked and not copied-forward. For example, <regions eden=\"256\" other=\"308\" evacuated=\"308\" marked=\"256\" /> . Returning to the contextid=186 partial cycle example, the next element in the logs, <gc-end> , records the end of the increment and provides another snapshot of memory allocation on the heap, similar to <gc-start> . <gc-end id=\"191\" type=\"partial gc\" contextid=\"186\" durationms=\"402.645\" usertimems=\"3157.520\" systemtimems=\"4.000\" stalltimems=\"47.689\" timestamp=\"2021-02-26T11:11:42.714\" activeThreads=\"8\"> <mem-info id=\"192\" free=\"3003121664\" total=\"4294967296\" percent=\"69\"> <mem type=\"eden\" free=\"2147483648\" total=\"2147483648\" percent=\"100\" /> <arraylet-primitive objects=\"1\" leaves=\"4\" largest=\"4\" /> <pending-finalizers system=\"56\" default=\"0\" reference=\"430\" classloader=\"0\" /> <remembered-set count=\"2922048\" freebytes=\"160016128\" totalbytes=\"171704320\" percent=\"93\" regionsoverflowed=\"1\" regionsstable=\"12\" regionsrebuilding=\"0\"/> </mem-info> </gc-end> The following information describes the heap memory allocation at the end of the increment: The heap now has 2864 MB (3,003,121,664 bytes) of memory available compared to the 856 MB available at the start of the increment. The increment reclaimed 2,008 MB of memory in the heap, which is slightly less than the size of the eden space, as is typically the case. The eden space is recorded to have 100% memory available as free memory. The eden space, which consists of regions containing the youngest objects, was fully re-created by reclaiming almost all of the eden regions and assigning some other empty regions of the heap to the eden space. Note that some objects from eden regions always survive. The remembered set count increased by 172,384 cards, and the number of free bytes in the remembered set decreased by 0.66 MB (689,536 B). The cycle completes and the GC restarts application threads. <cycle-end id=\"193\" type=\"partial gc\" contextid=\"186\" timestamp=\"2021-02-26T11:11:42.714\" /> <exclusive-end id=\"194\" timestamp=\"2021-02-26T11:11:42.714\" durationms=\"404.145\" /> The next cycle that is recorded in the logs is another partial GC cycle. The <gc-start> element records the following information: <gc-start id=\"198\" type=\"partial gc\" contextid=\"197\" timestamp=\"2021-02-26T11:11:46.072\"> <mem-info id=\"199\" free=\"855638016\" total=\"4294967296\" percent=\"19\"> <mem type=\"eden\" free=\"0\" total=\"2147483648\" percent=\"0\" /> <arraylet-primitive objects=\"1\" leaves=\"4\" largest=\"4\" /> <remembered-set count=\"2922048\" freebytes=\"160016128\" totalbytes=\"171704320\" percent=\"93\" regionsoverflowed=\"1\" regionsstable=\"12\" regionsrebuilding=\"0\"/> </mem-info> </gc-start> The <mem-info> element shows that the following events occurred in between the end of the last (partial) GC cycle and the start of this cycle: All available memory in the eden area was allocated to application threads. Application threads also used some memory from non-eden heap areas. The total available memory in the heap reduced from 69% to 19%. The remembered set status is unchanged, as shown by the <remembered-set> element. When mutator threads run, they build data about object references that cross boundaries by using a card table. However, the processing of card table data into the remembered set, and the reporting of the remembered set counts, are run during other cycle operations.","title":"balanced partial GC cycle"},{"location":"vgclog_examples/#summary_2","text":"Analyzing the structure and elements of this example log output shows that this example balanced partial GC cycle has the following characteristics: The partial GC cycle is triggered when the eden space is full by an allocation taxation threshold. All GC operations that are associated with this cycle occur during the STW pause. The partial GC cycle consists of only one increment, which runs a copy forward operation on 512 eden regions and 80 other regions, followed by a class-unload operation. The partial GC cycle re-creates a free eden space by reclaiming all possible regions from the eden space (some objects always survive) and assigning other free regions to the eden space. The GC cycle also reclaims memory from some other regions. 2864 MB of the total 4096 MB heap was reclaimed. 100% of the eden space is available as free memory, and some older regions were also reclaimed. Between the start and end of the partial GC cycle, the remembered set count increases by 172,384 cards and the number of free bytes decreases by 0.66 MB (689,536 B). After performing a copy forward operation on objects to move them to older regions, the partial GC cycle rebuilds the remembered set of any regions that received these moved objects. During a partial cycle, the remembered set is also pruned. Overall, the rebuilding and pruning can lead to either an increase or a decrease in the remembered set count and free memory available. The remembered set metastructure remains unchanged between GC cycles, even though the mutator threads build new data about object references when the threads run. The remembered set count is identical at the end of one partial GC cycle and the beginning of the next because the remembered set consumes this data and reports to the verbose GC logs only during a cycle's operation.","title":"Summary"},{"location":"vgclog_examples/#balanced-global-mark-gc-cycle","text":"The global mark GC cycle uses a mixture of STW and concurrent operations to build a new record of object liveness across the heap for use by the balanced partial GC cycle. The balanced GC runs a balanced global mark cycle , or a balanced global mark cycle increment if the global mark cycle is in progress, if the heap satisfies a low memory condition when the allocation taxation threshold is reached. The global mark cycle runs a global mark phase and also triggers an associated sweep phase within the partial GC cycle that immediately follows the end of the global mark cycle. To search for a balanced global mark cycle, you can search for the type attribute value global mark phase in <cycle-start> and <cycle-end> elements. The global cycle is split into multiple increments, each recorded as type=\"global mark phase\" . A global mark phase increment involves an STW subincrement, which runs a global mark operation during an STW pause, followed by a global mark phase (GMP) work packet subincrement. The GMP work packet subincrement involves a processing operation that runs concurrently. The GMP work packet subincrement might also use an STW pause to complete if the subincrement is interrupted by a partial or global cycle trigger. Splitting the global mark phase into these increments and subincrements reduces pause times by running the majority of the GC work concurrently and interleaving global mark phase increments with partial GC cycles, and, rarely a balanced global GC cycles . The following elements log the GC increments, subincrements, and operations of the global mark GC cycle: Table showing the global mark cycle GC increments and corresponding XML elements GC increment GC operations> STW or concurrent XML element of GC increment Details global mark phase subincrement mark STW <gc-start> , <gc-end> The global mark phase operations start at the beginning of the cycle and run through all regions until the final region GMP work packet processing subincrement Work packet processing (WPP) operations concurrent and sometimes final operations during an STW to complete the subincrement <concurrent-start> , <concurrent-end> The GMP work packet processing subincrement runs immediately after the global mark phase final global mark phase increment final global mark phase operations including class unload STW <gc-start> , <gc-end> Final increment. Runs the final global mark phase operations, including weak roots processing, followed by operations to finish the cycle The following structure shows a balanced global mark GC cycle. The lines are indented to help illustrate the flow and some child elements are omitted for clarity: <exclusive-start/> (STW pause starts) <allocation-taxation/> (memory threshold trigger recorded) <cycle-start type=\"global mark phase\"/> (global mark cycle starts) <gc-start type=\"global mark phase\"/> (1st GMP STW subincrement starts) <mem-info> (memory status before operations) <remembered-set> </mem-info> </gc-start> <gc-op type=\"mark increment\" /> (STW copy forward operation completed) <gc-end> (1st GMP STW subincrement ends) <mem-info> (memory status after operations) <remembered-set> </mem-info> <gc-end> <concurrent-start type=\"GMP work packet processing\"/> (1st GMP concurrent subincrement starts) <exclusive-end/> (STW pause ends and application threads resume) <concurrent-end type=\"GMP work packet processing\"/> (1st GMP concurrent subincrement ends) <gc-op type=\"mark increment\"/> (marking operation runs concurrently) </concurrent-end type=\"GMP work packet processing\"/> ... (application threads run. STW pauses stop and start application threads to run partial GC cycles.) <exclusive-start/> (STW pause starts) <gc-start type=\"global mark phase\"/> (2nd STW GMP subincrement starts) ... <concurrent-start type=\"GMP work packet processing\"/> (2nd concurrent GMP subincrement starts) ... <exclusive-end/> ... (application threads run. Partial GC cycles may run) <concurrent-end type=\"GMP work packet processing\" /> (2nd concurrent GMP subincrement ends) ... </concurrent-end> ... (application threads run. Partial cycles and GMP increments interleave) <exclusive-start/> (STW pause starts) ... <gc-start type=\"global mark phase\"/> (final STW GMP subincrement starts.) <gc-op type=\"mark increment\" /> (STW copy forward operation completed) <gc-op type=\"class unload\" /> (STW class unload operation completed) <gc-end> (1st GMP STW subincrement ends) ... <gc-end type=\"global mark phase\"/> (final STW GMP subincrement ends. No concurrent subincrement runs) <cycle-end type=\"global mark phase\"/> (end of global mark cycle) <exclusive-end/> (STW pause ends) <exclusive-start/> (STW pause starts) <cycle-start type=\"partial gc\" /> (partial cycle starts) ... <gc-op type=\"sweep\" /> (Sweep operation associated with global mark cycle runs) ... <cycle-end type=\"partial gc\"/> (partial GC cycle ends) <exclusive-end/> (STw pause ends)","title":"balanced global mark GC cycle"},{"location":"vgclog_examples/#global-mark-phase","text":"The first activity of the global mark cycle is an STW pause, recorded by an <exclusive-start> element that precedes the <cycle-start type=\"global mark phase\"/> element. The garbage collector pauses application threads to run the initial operations. <exclusive-start id=\"1152\" timestamp=\"2021-02-26T11:17:25.033\" intervalms=\"1931.263\"> <response-info timems=\"3.082\" idlems=\"1.041\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> The <allocation-taxation> element indicates that an allocation taxation threshold triggered the cycle. The taxation threshold is recorded as 1024 MB (1,073,741,824), which is half the total memory of the eden space (2048 MB), as expected for threshold triggers of global mark cycles and increments. For more information about taxation thresholds for the balanced policy, see balanced examples . <allocation-taxation id=\"1153\" taxation-threshold=\"1073741824\" timestamp=\"2021-02-26T11:17:25.034\" intervalms=\"1931.251\" /> Details about the start of the global mark GC cycle are recorded by the <cycle-start> element. The cycle is recorded as type global mark phase with id=1154 . Any subsequent elements that are associated with this cycle have a contextid=1154 to match the global mark GC cycle id . You can use the contextid value to distinguish increments and operations of the global mark GC cycle from the partial cycles that interleave with it. <cycle-start id=\"1154\" type=\"global mark phase\" contextid=\"0\" timestamp=\"2021-02-26T11:17:25.034\" intervalms=\"374365.075\" /> The cycle begins with the STW subincrement of a global mark phase increment. The STW subincrement is recorded by using the <gc-start> element of type global mark phase . <gc-start id=\"1155\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.034\"> <mem-info id=\"1156\" free=\"1442840576\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"2197888\" freebytes=\"162912768\" totalbytes=\"171704320\" percent=\"94\" regionsoverflowed=\"3\" regionsstable=\"130\" regionsrebuilding=\"0\"/> </mem-info> </gc-start> The <gc-start> element provides a snapshot of the free memory available in the heap and the status of the remembered set. At the start of the increment, the heap is 33% free; 1376 MB (1442840576 B) of the total 4096 MB (4294967296 B). The <remembered-set> element records the status of the remembered set metastructure, a structure that records object references that cross different regions. During the rebuilding of the remembered set metastructure, any regions that cannot be rebuilt into a remembered set due to a lack of memory resource in the metastructure are marked as overflow regions. Partial GC cycles cannot reclaim memory from overflow regions. The aim of the global mark cycle is to create a new record of object liveness by populating the remembered set. The global mark cycle also attempts to rebuild the remembered set information for the overflowed regions, which can be seen in the remembered set statistics. After the global mark cycle completes, the remembered set reflects a closer snapshot of the current liveness of the heap. This more accurate snapshot of object liveness optimizes the pruning of the set, which is run by the partial GC cycle when it consumes the object liveness snapshot. The logs show that at the start of this STW subincrement, the remembered set count is 2,197,888 cards, the metastructure is using 94% of its total available memory, and three overflow regions need to be rebuilt. The <gc-op> element records that the STW subincrement runs a mark operation . This operation begins the process of building a record of object liveness across the heap. <gc-op id=\"1157\" type=\"mark increment\" timems=\"122.825\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.157\"> <trace-info objectcount=\"7726701\" scancount=\"7584109\" scanbytes=\"213445656\" /> </gc-op> The <trace-info> element records information about the marking and scanning stages of the mark increment operation. objectcount records the number of objects that were marked, ready for tracing. After marking live objects, a scan is run to trace objects and references. The following values are recorded: scancount records the number of marked objects that were scanned. scanbytes records the total memory of all marked objects that were scanned. In the example, the mark increment operation marked 7,726,701 objects and scanned 7,584,109 of these marked objects. The 7,584,109 of scanned objects take up 203.5 MB (213445656 B) of memory. The number of scanned objects is less than the number of marked objects because only objects that have children require scanning. Also, the scanning part of the marking operation might be interrupted by the garbage collector if a trigger threshold for a partial cycle or global cycle is reached during the marking operation. The STW global mark phase subincrement ends, as recorded by <gc-end> , which records a snapshot of the memory status in the heap in a similar way to <gc-start> . <gc-end id=\"1158\" type=\"global mark phase\" contextid=\"1154\" durationms=\"123.139\" usertimems=\"977.851\" systemtimems=\"0.000\" stalltimems=\"1.453\" timestamp=\"2021-02-26T11:17:25.157\" activeThreads=\"8\"> <mem-info id=\"1159\" free=\"1442840576\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3263968\" freebytes=\"158648448\" totalbytes=\"171704320\" percent=\"92\" regionsoverflowed=\"0\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-end> The following comparison can be made between the snapshot at the beginning and end of this STW global mark phase subincrement: The marking operation has increased the count value of the <remembered-set> by 1,066,080 cards (from 2,197,888 to 3,263,968). As regions are rebuilt, the new cards record the new remembered set data that is associated with these regions. The number of overflow regions went from three to zero. As expected with a global mark cycle, there is no change in the amount of free memory available, which is 1376 MB. The beginning of the second part of the global mark phase increment, the GMP work packet processing subincrememt, is recorded by <concurrent-start> . The child element <concurrent-mark-start> records the scan target of this subincrement as 242.74 MB (254,532,672 B). <concurrent-start id=\"1160\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.157\"> <concurrent-mark-start scanTarget=\"254532672\" /> </concurrent-start> Now that the STW global mark phase subincrement is complete, application threads are restarted. <exclusive-end id=\"1161\" timestamp=\"2021-02-26T11:17:25.157\" durationms=\"123.936\" /> The GMP work packet processing subincrement continues to run concurrently. The end of this operation is recorded by using the <concurrent-end> element. <concurrent-end id=\"1162\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.469\" terminationReason=\"Work target met\"> <gc-op id=\"1163\" type=\"mark increment\" timems=\"311.867\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:25.469\"> <trace-info scanbytes=\"254708852\" /> </gc-op> </concurrent-end> The child element <trace-info> shows that the processing scanned 242.91 MB (254,708,852 B), which slightly exceeds the 108.25 MB scan target. Application threads continue to run and allocate memory. The garbage collector stops and starts the application threads to run partial GC cycles that reclaim free space in the eden space and some older regions. To see an example of how a balanced partial GC cycle appears in the logs, see the balanced partial GC cycle . Following some partial GC cycles, an allocation taxation threshold is reached that triggers an STW pause followed by another global mark phase increment. The element <gc-start> in the following log excerpt has a contextid=1154 and type global mark phase , which indicates that this is a global mark phase subincrement associated with the global mark cycle example. <exclusive-start id=\"1175\" timestamp=\"2021-02-26T11:17:28.993\" intervalms=\"1978.886\"> <response-info timems=\"5.111\" idlems=\"1.714\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> <allocation-taxation id=\"1176\" taxation-threshold=\"1073741824\" timestamp=\"2021-02-26T11:17:28.994\" intervalms=\"1978.879\" /> <gc-start id=\"1177\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:28.994\"> <mem-info id=\"1178\" free=\"1451229184\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3325824\" freebytes=\"158401024\" totalbytes=\"171704320\" percent=\"92\" regionsoverflowed=\"2\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-start> The <allocation-taxation> element shows that the allocation taxation threshold, which triggers this global mark phase increment, is set to 1024 MB, half of the size of the eden space, as expected. <gc-start> records that the heap has 1384 MB (1,451,229,184 B) of free memory available at the beginning of this global mark phase increment. This value compares to the 1376 MB (1,442,840,576 B) of free memory available at the end of the previous global mark phase increment. Although free memory was reclaimed by the partial GC cycles that ran between these global mark phase increments, free memory was allocated to objects when application threads ran, resulting in a net reduction of free memory available. The status of the heap at the beginning and end of STW subincrements are automatically recorded. For this STW subincrement, there are no <gc-op> elements recorded; <gc-end> immediately follows <gc-start> in the logs. For some STW subincrements, a mark operation is run. <gc-end id=\"1179\" type=\"global mark phase\" contextid=\"1154\" durationms=\"0.289\" usertimems=\"1.000\" systemtimems=\"0.000\" stalltimems=\"0.000\" timestamp=\"2021-02-26T11:17:28.994\" activeThreads=\"8\"> <mem-info id=\"1180\" free=\"1451229184\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3325824\" freebytes=\"158401024\" totalbytes=\"171704320\" percent=\"92\" regionsoverflowed=\"2\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-end> The second part of the increment, the GMP work packet processing subincrement, is recorded by using the <concurrent-start> and <concurrent-end> elements. <concurrent-start id=\"1181\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:28.994\"> <concurrent-mark-start scanTarget=\"258671414\" /> </concurrent-start> <exclusive-end id=\"1182\" timestamp=\"2021-02-26T11:17:28.994\" durationms=\"0.816\" /> <concurrent-end id=\"1183\" type=\"GMP work packet processing\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:29.273\" terminationReason=\"Work target met\"> <gc-op id=\"1184\" type=\"mark increment\" timems=\"279.311\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:29.274\"> <trace-info scanbytes=\"258767612\" /> </gc-op> </concurrent-end> The log excerpt shows the concurrent GMP work packet processing subincrement achieved the scan target of 246.69 MB (258671414 B). 246.78 MB (258767612 B) were scanned. More partial cycles run. This pattern of interleaving of global mark increments with partial GC cycles repeats until a final global mark increment completes the global mark cycle. The final global mark phase increment consists of an STW global mark phase subincrement that includes mark increment and class unload operations. <exclusive-start id=\"1217\" timestamp=\"2021-02-26T11:17:36.864\" intervalms=\"1986.124\"> <response-info timems=\"0.287\" idlems=\"0.104\" threads=\"2\" lastid=\"00000000006EDE00\" lastname=\"RunDataWriter.1\" /> </exclusive-start> <allocation-taxation id=\"1218\" taxation-threshold=\"1073741824\" timestamp=\"2021-02-26T11:17:36.865\" intervalms=\"1986.101\" /> <gc-start id=\"1219\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:36.865\"> <mem-info id=\"1220\" free=\"1438646272\" total=\"4294967296\" percent=\"33\"> <remembered-set count=\"3514496\" freebytes=\"157646336\" totalbytes=\"171704320\" percent=\"91\" regionsoverflowed=\"3\" regionsstable=\"0\" regionsrebuilding=\"133\"/> </mem-info> </gc-start> <gc-op id=\"1221\" type=\"mark increment\" timems=\"164.843\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:37.030\"> <trace-info objectcount=\"7715572\" scancount=\"7665293\" scanbytes=\"214739196\" /> <cardclean-info objects=\"3962203\" bytes=\"117924792\" /> <finalization candidates=\"206\" enqueued=\"30\" /> <ownableSynchronizers candidates=\"601780\" cleared=\"16925\" /> <references type=\"soft\" candidates=\"718240\" cleared=\"2858\" enqueued=\"2832\" dynamicThreshold=\"18\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"2321\" cleared=\"142\" enqueued=\"0\" /> <references type=\"phantom\" candidates=\"8\" cleared=\"0\" enqueued=\"0\" /> <stringconstants candidates=\"9522\" cleared=\"0\" /> <object-monitors candidates=\"7142\" cleared=\"7066\" /> </gc-op> <gc-op id=\"1222\" type=\"classunload\" timems=\"0.704\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:37.030\"> <classunload-info classloadercandidates=\"185\" classloadersunloaded=\"13\" classesunloaded=\"13\" anonymousclassesunloaded=\"0\" quiescems=\"0.000\" setupms=\"0.644\" scanms=\"0.043\" postms=\"0.016\" /> </gc-op> <gc-end id=\"1223\" type=\"global mark phase\" contextid=\"1154\" durationms=\"169.521\" usertimems=\"1244.810\" systemtimems=\"3.000\" stalltimems=\"27.792\" timestamp=\"2021-02-26T11:17:37.034\" activeThreads=\"8\"> <mem-info id=\"1224\" free=\"1438646272\" total=\"4294967296\" percent=\"33\"> <pending-finalizers system=\"30\" default=\"0\" reference=\"2832\" classloader=\"0\" /> <remembered-set count=\"2241440\" freebytes=\"162738560\" totalbytes=\"171704320\" percent=\"94\" regionsoverflowed=\"3\" regionsstable=\"127\" regionsrebuilding=\"0\"/> </mem-info> </gc-end> Comparing the memory at the start and end of this final global mark phase increment shows the following status: As expected, the final global mark phase increment does not reclaim any free memory. The remembered set metastructure was marginally rebuilt. The card count has increased slightly, and the number of stable regions dropped from 130 to 127. The number of overflow regions remains unchanged. The final global mark phase increment did not manage to rebuild any overflow regions. Following the final global mark increment, the global mark cycle completes and the GC ends the STW pause. <cycle-end id=\"1225\" type=\"global mark phase\" contextid=\"1154\" timestamp=\"2021-02-26T11:17:37.034\" /> <exclusive-end id=\"1226\" timestamp=\"2021-02-26T11:17:37.034\" durationms=\"170.186\" /> The operations to create a record of object liveness across the heap, which began with the global mark cycle, is followed by a sweep phase. The sweep phase is triggered by the end of the global mark cycle to be included in the next partial GC cycle that runs.","title":"Global mark phase"},{"location":"vgclog_examples/#sweep-phase","text":"The sweep operation has the following two objectives: To directly reclaim some memory by creating empty regions. To build information about occupancy and fragmentation for regions that still contain live objects. The next partial GC cycle uses this information to defragment older regions. While the global sweep operation is logically associated with the global mark phase, it does not run in the same global mark cycle. Instead, the sweep operation runs in the same STW increment as the first partial GC cycle that runs after the completion of the global mark cycle. This can be seen in the following log excerpt. After the log records the end of the global mark cycle, it records an STW pause followed by a partial gc cycle of id=1229 . The global sweep operation that runs after the global mark phase is recorded in the <gc-op> element that is tagged as id=1229 . <exclusive-start id=\"1227\" timestamp=\"2021-02-26T11:17:38.804\" intervalms=\"1940.125\"> ... <cycle-start id=\"1229\" type=\"partial gc\" contextid=\"0\" timestamp=\"2021-02-26T11:17:38.805\" intervalms=\"3926.202\" /> ... </gc-start> ... </gc-start> <gc-op id=\"1232\" type=\"sweep\" timems=\"9.472\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:38.815\" /> <gc-op id=\"1233\" type=\"copy forward\" timems=\"308.258\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:39.124\"> ... <gc-op id=\"1234\" type=\"classunload\" timems=\"0.012\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:39.125\"> ... <gc-end> ... </gc-end> <cycle-end id=\"1237\" type=\"partial gc\" contextid=\"1229\" timestamp=\"2021-02-26T11:17:39.125\" /> <exclusive-end id=\"1238\" timestamp=\"2021-02-26T11:17:39.125\" durationms=\"320.792\" /> A record of object liveness is now complete.","title":"Sweep phase"},{"location":"vgclog_examples/#summary_3","text":"Analyzing the structure and elements of this example log output shows that this example balanced global mark GC cycle has the following characteristics: If the total free memory is low when the taxation allocation threshold is reached, the GC triggers a global mark cycle. The allocation taxation threshold is set by the previous cycle to trigger a new cycle when the eden space is half full. This threshold value frees up eden space to enable a global mark cycle to interleave with the GC operations of partial GC cycles. Each global mark phase increment is triggered by an allocation taxation threshold value that is set to half of the eden space. Global mark GC cycle and global mark cycle increments begin with an STW pause. The global mark cycle does not reclaim memory. The cycle creates an updated record of object liveness by rebuilding the mark map, and also attempts to rebuild the remembered set for overflowed and stable regions. The change in status of the remembered set metastructure can be seen in the logs by inspecting the <remembered-set> attributes. Partial cycles run in between global mark phase increments. The final global mark phase increment includes a class unload. The final increment also triggers a sweep phase to run in the next partial cycle.","title":"Summary"},{"location":"vgclog_examples/#balanced-global-gc-cycle","text":"The following global GC cycle example is taken from a balanced verbose GC log. The output is broken down into sections to explain the GC processing that is taking place. A balanced global cycle is triggered if the VM is close to throwing an out of memory exception. This situation occurs only under tight memory conditions when the garbage collector cannot reclaim enough memory by using only partial and global mark cycles. To search for a balanced global cycle or increment, you can search for the type attribute value global garbage collect of the cycle or increment element. If the balanced global cycle is triggered during a balanced global mark GC cycle , a new global cycle is not recorded. Instead, the global mark cycle's global mark phase increment switches to a global garbage collect increment that is run as an STW increment. This switch is recorded in the logs by using a <cycle-continue> element, which precedes the gc-start element that records the new global garbage collect increment. If the balanced global cycle is not triggered during a balanced global mark cycle, the global cycle is recorded as a new cycle by using the <cycle-start> element. The element <sys-start reason=\"explicit\"> is used in the logs to record a cycle that was triggered explicitly rather than by the garbage collector. For example, the trigger reason is recorded as explicit if a cycle is triggered by an application calling System.gc() . For more information about explicitly or implicitly triggering a GC cycle, see Garbage collection . The global cycle operations run as a single GC increment during an STW pause. Table showing the balanced global cycle's GC increment and corresponding XML elements. GC increment GC operations STW or concurrent XML element of GC increment Details single STW mark-sweep operations, optionally followed by a compact operation STW <cycle-start> , <gc-end> Contains detailed information about where free memory is located and remembered set statistics If the global cycle is triggered during a global mark cycle, the global cycle follows a general structure in the verbose GC log as shown. Some child elements are omitted for clarity: ... (global mark cycle increment runs) <af-start/> (allocation failure trigger recorded) <concurrent-end/> (global mark cycle concurrent subincrement finishes ) <allocation-taxation/> (memory threshold trigger recorded) <cycle-continue/> (change of cycle type from global mark to global) </gc-start type=\"global garbage collect\"/> (global cycle STW increment starts) <mem-info> (memory status before operations) <mem></mem> (status of different types of memory) </mem-info> </gc-start type=\"global garbage collect\"/> <allocation-stats/> (Snapshot of how memory was divided up between ... application threads before current cycle started) <gc-op> type=\"mark\" </gc-op> (mark operation completed) <gc-op> type=\"class unload\" </gc-op> (class unload operation completed) <gc-op> type=\"sweep\" </gc-op> (sweep operation completed) <gc-op> type=\"compact\" </gc-op> (compact operation completed) <gc-end type=\"global garbage collect\"> (global cycle STW increment ends) <mem-info> (memory status after operations) <mem></mem> (status of different types of memory) </mem-info> </gc-end type=\"global garbage collect\"> <cycle-end type = \"global garbage collect\"/> (cycle ends) <allocation-satisfed/> (required allocation has been achieved) <exclusive-end> (STW pause ends) The following example shows a balanced global cycle that is triggered during a global mark cycle . The start of the GMP work processing subincrement of the global mark cycle, which runs concurrently with application threads, is recorded by using the <concurrent-start> element. <concurrent-start id=\"2009\" type=\"GMP work packet processing\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.109\"> <concurrent-mark-start scanTarget=\"18446744073709551615\" /> </concurrent-start> After the start of the concurrent subincrement, the logs record an allocation failure by using <af-start> . The <concurrent-end> element attribute terminationReason shows that a termination of the concurrent increment was requested by the garbage collector. <af-start id=\"2010\" threadId=\"00000000008AA780\" totalBytesRequested=\"24\" timestamp=\"2021-03-05T12:16:43.109\" intervalms=\"1212.727\" /> <concurrent-end id=\"2011\" type=\"GMP work packet processing\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\" terminationReason=\"Termination requested\"> <gc-op id=\"2012\" type=\"mark increment\" timems=\"0.893\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\"> <trace-info scanbytes=\"584612\" /> </gc-op> </concurrent-end> The next element, the <cycle-continue> element, records information about the switch of cycle type from a global mark cycle, recorded as type global mark phase , to a global cycle, recorded as type global garbage collect . <cycle-continue id=\"2013\" oldtype=\"global mark phase\" newtype=\"global garbage collect\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\" /> A global cycle increment is recorded by <gc-start> and has the same contextid as the global mark cycle's elements. The global cycle operations are run during an STW pause and as a modification to the global mark cycle rather than a new cycle. The memory snapshot within the <gc-start> element is taken before the global increment's operations run and can be compared with a similar snapshot that is taken afterward to understand the effect on the heap. <gc-start id=\"2014\" type=\"global garbage collect\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.110\"> <mem-info id=\"2015\" free=\"0\" total=\"838860800\" percent=\"0\"> <mem type=\"eden\" free=\"0\" total=\"524288\" percent=\"0\" /> <remembered-set count=\"12832\" freebytes=\"33331072\" totalbytes=\"33382400\" percent=\"99\" regionsoverflowed=\"0\" regionsstable=\"0\" regionsrebuilding=\"1593\"/> </mem-info> </gc-start> At the start of the global cycle's increment, the amount of memory available in the heap is zero. In some cases, the heap is close to full, and in other cases, the memory is full. The next element <allocation-stats> shows a snapshot of how memory was divided up between application threads before the current cycle started. <allocation-stats totalBytes=\"524200\" > <allocated-bytes non-tlh=\"0\" tlh=\"524200\" arrayletleaf=\"0\"/> </allocation-stats> The <allocation-stats> element shows that very little allocation took place. Global cycles are triggered due to an allocation failure, so the low memory allocation values are expected. The following operations, each recorded by a <gc-op> element, run as part of the global cycle's increment: global mark class unload sweep compact <gc-op id=\"2016\" type=\"global mark\" timems=\"357.859\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.468\"> <trace-info objectcount=\"37461962\" scancount=\"37447916\" scanbytes=\"828311396\" /> <cardclean-info objects=\"311\" bytes=\"22632\" /> <finalization candidates=\"195\" enqueued=\"2\" /> <ownableSynchronizers candidates=\"2089\" cleared=\"0\" /> <references type=\"soft\" candidates=\"3059\" cleared=\"0\" enqueued=\"0\" dynamicThreshold=\"0\" maxThreshold=\"32\" /> <references type=\"weak\" candidates=\"10797\" cleared=\"0\" enqueued=\"0\" /> <references type=\"phantom\" candidates=\"6\" cleared=\"0\" enqueued=\"0\" /> <stringconstants candidates=\"10031\" cleared=\"0\" /> </gc-op> <gc-op id=\"2017\" type=\"classunload\" timems=\"0.123\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.468\"> <classunload-info classloadercandidates=\"25\" classloadersunloaded=\"0\" classesunloaded=\"0\" anonymousclassesunloaded=\"0\" quiescems=\"0.000\" setupms=\"0.123\" scanms=\"0.000\" postms=\"0.000\" /> </gc-op> <gc-op id=\"2018\" type=\"sweep\" timems=\"5.120\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:43.474\" /> <gc-op id=\"2019\" type=\"compact\" timems=\"762.323\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:44.236\"> <compact-info movecount=\"8024461\" movebytes=\"163375400\" /> <remembered-set-cleared processed=\"777104\" cleared=\"777104\" durationms=\"2.188\" /> </gc-op> The global cycle's increment ends. The end of the increment is recorded with <gc-end> and provides another snapshot of memory allocation on the heap, similar to <gc-start> . <gc-end id=\"2020\" type=\"global garbage collect\" contextid=\"2003\" durationms=\"1126.788\" usertimems=\"7971.788\" systemtimems=\"1.000\" stalltimems=\"1016.256\" timestamp=\"2021-03-05T12:16:44.237\" activeThreads=\"8\"> <mem-info id=\"2021\" free=\"1572864\" total=\"838860800\" percent=\"0\"> <mem type=\"eden\" free=\"1572864\" total=\"1572864\" percent=\"100\" /> <pending-finalizers system=\"2\" default=\"0\" reference=\"0\" classloader=\"0\" /> <remembered-set count=\"874496\" freebytes=\"29884416\" totalbytes=\"33382400\" percent=\"89\" regionsoverflowed=\"0\" regionsstable=\"0\" regionsrebuilding=\"0\"/> </mem-info> </gc-end> Comparing the snapshot at the beginning and end of this STW global mark phase subincrement shows that memory was reclaimed and regions reassigned to create an empty eden space, equal to 1.5 MB (1,572,864 B). Because global cycles are triggered when memory conditions are tight, the global cycle is able to reclaim only a small amount of memory. The cycle ends ( <cycle-end> ). The following <allocation-satisfied> element indicates that the allocation request that caused the allocation failure can now complete successfully. <cycle-end id=\"2022\" type=\"global garbage collect\" contextid=\"2003\" timestamp=\"2021-03-05T12:16:44.237\" /> <allocation-satisfied id=\"2023\" threadId=\"00000000008A9E00\" bytesRequested=\"24\" /> <af-end id=\"2024\" timestamp=\"2021-03-05T12:16:44.237\" threadId=\"00000000008AA780\" success=\"true\" /> The STW pause ends with the <exclusive-end> element. <exclusive-end id=\"2025\" timestamp=\"2021-03-05T12:16:44.237\" durationms=\"1130.358\" />","title":"balanced global GC cycle"},{"location":"vgclog_examples/#summary_4","text":"Analyzing the structure and elements of this example log output shows that this global cycle has the following characteristics: The global GC cycle was triggered during a global mark GC cycle when the heap was very low in memory. The memory could not be reclaimed by just using partial GC cycles and global mark cycles. The concurrent subincrement of the global mark GC cycle was interrupted by an allocation failure that triggered the concurrent subincrement to end and the global mark cycle type to change to a global type. The global GC cycle consists of only 1 GC increment, which runs mark, sweep, and compact operations during an STW pause. The global GC cycle reclaimed the eden space (1.5 MB of memory). When global GC cycle's are triggered, which occurs when memory conditions are tight, the amount of memory that the global GC cycle reclaims is often small.","title":"Summary"},{"location":"x/","text":"-X Displays help on nonstandard options. Syntax -X","title":"-X"},{"location":"x/#-x","text":"Displays help on nonstandard options.","title":"-X"},{"location":"x/#syntax","text":"-X","title":"Syntax"},{"location":"x_jvm_commands/","text":"Using -X command-line options Use these options to configure the Eclipse OpenJ9\u2122 virtual machine (VM). Unlike standard options, options prefixed with -X are nonstandard and are typically unique to a Java\u2122 virtual machine implementation. However, in some cases, -X option names are common to different VM implementations and might have the same function. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -Xmx value to 16 MB, you can specify -Xmx16M , -Xmx16m , -Xmx16384K , -Xmx16384k , or -Xmx16777216 on the command line.","title":"Using -X options"},{"location":"x_jvm_commands/#using-x-command-line-options","text":"Use these options to configure the Eclipse OpenJ9\u2122 virtual machine (VM). Unlike standard options, options prefixed with -X are nonstandard and are typically unique to a Java\u2122 virtual machine implementation. However, in some cases, -X option names are common to different VM implementations and might have the same function. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -Xmx value to 16 MB, you can specify -Xmx16M , -Xmx16m , -Xmx16384K , -Xmx16384k , or -Xmx16777216 on the command line.","title":"Using -X command-line options"},{"location":"xaggressive/","text":"-Xaggressive Enables performance optimizations and new platform exploitation that are expected to be the default in future releases. Syntax -Xaggressive","title":"-Xaggressive"},{"location":"xaggressive/#-xaggressive","text":"Enables performance optimizations and new platform exploitation that are expected to be the default in future releases.","title":"-Xaggressive"},{"location":"xaggressive/#syntax","text":"-Xaggressive","title":"Syntax"},{"location":"xalwaysclassgc/","text":"-Xalwaysclassgc Always perform dynamic class unloading during global garbage collection. Syntax -Xalwaysclassgc Default behavior If you don't set this option, the default behavior is defined by -Xclassgc . This option can be used with all Eclipse OpenJ9\u2122 GC policies. See also -Xclassgc / -Xnoclassgc","title":"-Xalwaysclassgc"},{"location":"xalwaysclassgc/#-xalwaysclassgc","text":"Always perform dynamic class unloading during global garbage collection.","title":"-Xalwaysclassgc"},{"location":"xalwaysclassgc/#syntax","text":"-Xalwaysclassgc","title":"Syntax"},{"location":"xalwaysclassgc/#default-behavior","text":"If you don't set this option, the default behavior is defined by -Xclassgc . This option can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"Default behavior"},{"location":"xalwaysclassgc/#see-also","text":"-Xclassgc / -Xnoclassgc","title":"See also"},{"location":"xaot/","text":"-Xaot / -Xnoaot Use this option to control the behavior of the ahead-of-time (AOT) compiler. When the AOT compiler is active, the compiler selects the methods to be AOT compiled with the primary goal of improving startup time. AOT compilation allows the compilation of Java\u2122 classes into native code for subsequent executions of the same program. The AOT compiler works with the class data sharing framework. The AOT compiler generates native code dynamically while an application runs and caches any generated AOT code in the shared data cache. Subsequent VMs that execute the method can load and use the AOT code from the shared data cache without incurring the performance decrease experienced with JIT-compiled native code. Performance Because AOT code must persist over different program executions, AOT-generated code does not perform as well as JIT-generated code. AOT code usually performs better than interpreted code. In a VM without an AOT compiler or with the AOT compiler disabled, the JIT compiler selectively compiles frequently used methods into optimized native code. There is a time cost associated with compiling methods because the JIT compiler operates while the application is running. Because methods begin by being interpreted and most JIT compilations occur during startup, startup times can be increased. Startup performance can be improved by using the shared AOT code to provide native code without compiling. There is a small time cost to load the AOT code for a method from the shared data cache and bind it into a running program. The time cost is low compared to the time it takes the JIT compiler to compile that method. Default behavior The AOT compiler is enabled by default, but is only active for classes that are found in the shared classes cache. See Introduction to class data sharing for information about the shared classes cache, how class sharing is enabled, and what options are available to modify class sharing behavior. Syntax Setting Action Default -Xaot Enable AOT yes -Xaot:<parameter>[=<value>] (See Note ) Enable AOT with modifications -Xnoaot Disable AOT Note: You can concatenate several parameters in a comma-separated list, for example: -Xaot:<parameter1>[=<value1>], <parameter2>[=<value2>] Parameters for -Xaot Parameter Effect verbose Reports information about the AOT and JIT compiler configuration and method compilation. count Specifies the number of times a method is called before it is compiled. exclude Excludes specified methods when AOT code is compiled. limit Includes specified methods when AOT code is compiled. limitFile Compiles only the methods listed in the specified limit file. loadExclude Excludes specified methods when AOT code is loaded. loadLimit Includes specified methods when AOT code is loaded. loadLimitFile Loads only the methods listed in the specified limit file. verbose -Xaot:verbose Reports information about the AOT and JIT compiler configuration and method compilation. count -Xaot:count=<n> Specifies the number of times, <n> , a method is called before it is compiled or loaded from an existing shared classes cache. Setting -Xaot:count=0 forces the AOT compiler to compile everything on first execution, which is useful for problem determination. exclude -Xaot:exclude={<method_name>} Excludes a Java method when AOT code is compiled from the shared classes cache. Use this option if the method causes the program to fail. <method_name> is the method or methods that are to be excluded; the wildcard * may be used. Specify as much of the full package, class and method as necessary. For example, -Xaot:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xaot:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xaot:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:exclude , JIT compilation is also prevented and the methods specified are always interpreted. limit -Xaot:limit={<method_name>} Only the Java methods specified are included when AOT code is compiled from the shared classes cache. <method_name> is the method or methods that are to be included (the wildcard * may be used, see -Xaot:exclude for details). Note: limit has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limit , JIT compilation is also restricted to those methods specified; other methods are always interpreted. limitFile -Xaot:limitFile=(<filename>,<m>,<n>) Compiles or loads only the methods listed on lines <m> to, and including, <n> in the specified limit file, <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not compiled or loaded. Note: limitFile has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limitFile , JIT compilation is also restricted to those methods specified; other methods are always interpreted. loadExclude -Xaot:loadExclude={<method_name>} Excludes the specified Java methods when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on those methods instead. <method_name> is the method or methods that are to be excluded (the wildcard * may be used, see -Xaot:exclude for details). This option does not prevent the method from being compiled. Note: loadExclude can only be specified on -Xaot ; it does not have an equivalent on -Xjit . loadLimit -Xaot:loadLimit={<method_name>} Only the Java methods specified are included when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on other methods instead. <method_name> is the method or methods that are to be included (the wildcard * may be used; see -Xaot:exclude for details). Note: loadLimit can only be specified on -Xaot ; it does not have an equivalent on -Xjit . This option filters what AOT code the compiler is allowed to load from the shared classes cache. loadLimitFile -Xaot:loadLimitFile=(<filename>,<m>,<n>) Loads only the methods listed on lines <m> to, and including, <n> in the specified limit file. In consequence, the compiler does a JIT compilation on other methods instead. <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not loaded. Note: loadLimitFile can only be specified on -Xaot ; it does not have an equivalent on -Xjit . See also Introduction to class data sharing -Xquickstart -Xshareclasses -Xjit","title":"-Xnoaot"},{"location":"xaot/#-xaot-xnoaot","text":"Use this option to control the behavior of the ahead-of-time (AOT) compiler. When the AOT compiler is active, the compiler selects the methods to be AOT compiled with the primary goal of improving startup time. AOT compilation allows the compilation of Java\u2122 classes into native code for subsequent executions of the same program. The AOT compiler works with the class data sharing framework. The AOT compiler generates native code dynamically while an application runs and caches any generated AOT code in the shared data cache. Subsequent VMs that execute the method can load and use the AOT code from the shared data cache without incurring the performance decrease experienced with JIT-compiled native code.","title":"-Xaot / -Xnoaot"},{"location":"xaot/#performance","text":"Because AOT code must persist over different program executions, AOT-generated code does not perform as well as JIT-generated code. AOT code usually performs better than interpreted code. In a VM without an AOT compiler or with the AOT compiler disabled, the JIT compiler selectively compiles frequently used methods into optimized native code. There is a time cost associated with compiling methods because the JIT compiler operates while the application is running. Because methods begin by being interpreted and most JIT compilations occur during startup, startup times can be increased. Startup performance can be improved by using the shared AOT code to provide native code without compiling. There is a small time cost to load the AOT code for a method from the shared data cache and bind it into a running program. The time cost is low compared to the time it takes the JIT compiler to compile that method.","title":"Performance"},{"location":"xaot/#default-behavior","text":"The AOT compiler is enabled by default, but is only active for classes that are found in the shared classes cache. See Introduction to class data sharing for information about the shared classes cache, how class sharing is enabled, and what options are available to modify class sharing behavior.","title":"Default behavior"},{"location":"xaot/#syntax","text":"Setting Action Default -Xaot Enable AOT yes -Xaot:<parameter>[=<value>] (See Note ) Enable AOT with modifications -Xnoaot Disable AOT Note: You can concatenate several parameters in a comma-separated list, for example: -Xaot:<parameter1>[=<value1>], <parameter2>[=<value2>]","title":"Syntax"},{"location":"xaot/#parameters-for-xaot","text":"Parameter Effect verbose Reports information about the AOT and JIT compiler configuration and method compilation. count Specifies the number of times a method is called before it is compiled. exclude Excludes specified methods when AOT code is compiled. limit Includes specified methods when AOT code is compiled. limitFile Compiles only the methods listed in the specified limit file. loadExclude Excludes specified methods when AOT code is loaded. loadLimit Includes specified methods when AOT code is loaded. loadLimitFile Loads only the methods listed in the specified limit file.","title":"Parameters for -Xaot"},{"location":"xaot/#verbose","text":"-Xaot:verbose Reports information about the AOT and JIT compiler configuration and method compilation.","title":"verbose"},{"location":"xaot/#count","text":"-Xaot:count=<n> Specifies the number of times, <n> , a method is called before it is compiled or loaded from an existing shared classes cache. Setting -Xaot:count=0 forces the AOT compiler to compile everything on first execution, which is useful for problem determination.","title":"count"},{"location":"xaot/#exclude","text":"-Xaot:exclude={<method_name>} Excludes a Java method when AOT code is compiled from the shared classes cache. Use this option if the method causes the program to fail. <method_name> is the method or methods that are to be excluded; the wildcard * may be used. Specify as much of the full package, class and method as necessary. For example, -Xaot:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xaot:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xaot:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:exclude , JIT compilation is also prevented and the methods specified are always interpreted.","title":"exclude"},{"location":"xaot/#limit","text":"-Xaot:limit={<method_name>} Only the Java methods specified are included when AOT code is compiled from the shared classes cache. <method_name> is the method or methods that are to be included (the wildcard * may be used, see -Xaot:exclude for details). Note: limit has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limit , JIT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limit"},{"location":"xaot/#limitfile","text":"-Xaot:limitFile=(<filename>,<m>,<n>) Compiles or loads only the methods listed on lines <m> to, and including, <n> in the specified limit file, <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not compiled or loaded. Note: limitFile has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limitFile , JIT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limitFile"},{"location":"xaot/#loadexclude","text":"-Xaot:loadExclude={<method_name>} Excludes the specified Java methods when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on those methods instead. <method_name> is the method or methods that are to be excluded (the wildcard * may be used, see -Xaot:exclude for details). This option does not prevent the method from being compiled. Note: loadExclude can only be specified on -Xaot ; it does not have an equivalent on -Xjit .","title":"loadExclude"},{"location":"xaot/#loadlimit","text":"-Xaot:loadLimit={<method_name>} Only the Java methods specified are included when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on other methods instead. <method_name> is the method or methods that are to be included (the wildcard * may be used; see -Xaot:exclude for details). Note: loadLimit can only be specified on -Xaot ; it does not have an equivalent on -Xjit . This option filters what AOT code the compiler is allowed to load from the shared classes cache.","title":"loadLimit"},{"location":"xaot/#loadlimitfile","text":"-Xaot:loadLimitFile=(<filename>,<m>,<n>) Loads only the methods listed on lines <m> to, and including, <n> in the specified limit file. In consequence, the compiler does a JIT compilation on other methods instead. <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not loaded. Note: loadLimitFile can only be specified on -Xaot ; it does not have an equivalent on -Xjit .","title":"loadLimitFile"},{"location":"xaot/#see-also","text":"Introduction to class data sharing -Xquickstart -Xshareclasses -Xjit","title":"See also"},{"location":"xargencoding/","text":"-Xargencoding The java and javaw launchers accept arguments and class names containing any character that is in the character set of the current locale. You can also specify any Unicode character in the class name and arguments by using Java\u2122 escape sequences. To do this, use the -Xargencoding command-line option. Syntax -Xargencoding:<parameter> Parameters No parameter -Xargencoding You can use Unicode escape sequences in the argument list that you pass to this option. To specify a Unicode character, use escape sequences in the form \\u#### , where # is a hexadecimal digit (0-9, A-F). For example, to specify a class that is called HelloWorld and use Unicode encoding for both capital letters, use this command: java -Xargencoding \\u0048ello\\u0057orld utf8 -Xargencoding:utf8 Use utf8 encoding. latin -Xargencoding:latin Use ISO8859_1 encoding.","title":"-Xargencoding"},{"location":"xargencoding/#-xargencoding","text":"The java and javaw launchers accept arguments and class names containing any character that is in the character set of the current locale. You can also specify any Unicode character in the class name and arguments by using Java\u2122 escape sequences. To do this, use the -Xargencoding command-line option.","title":"-Xargencoding"},{"location":"xargencoding/#syntax","text":"-Xargencoding:<parameter>","title":"Syntax"},{"location":"xargencoding/#parameters","text":"","title":"Parameters"},{"location":"xargencoding/#no-parameter","text":"-Xargencoding You can use Unicode escape sequences in the argument list that you pass to this option. To specify a Unicode character, use escape sequences in the form \\u#### , where # is a hexadecimal digit (0-9, A-F). For example, to specify a class that is called HelloWorld and use Unicode encoding for both capital letters, use this command: java -Xargencoding \\u0048ello\\u0057orld","title":"No parameter"},{"location":"xargencoding/#utf8","text":"-Xargencoding:utf8 Use utf8 encoding.","title":"utf8"},{"location":"xargencoding/#latin","text":"-Xargencoding:latin Use ISO8859_1 encoding.","title":"latin"},{"location":"xbootclasspath/","text":"-Xbootclasspath This Oracle\u00ae HotSpot\u2122 option specifies the search path for bootstrap classes and resources. The default is to search for bootstrap classes and resources in the internal VM directories and .jar files. The option is recognized by the Eclipse OpenJ9\u2122 VM. Syntax Limited to... Setting Effect -Xbootclasspath:<path> Sets the search path for bootstrap classes and resources. -Xbootclasspath/p:<path> Prepends the specified resources to the front of the bootstrap class path. -Xbootclasspath/a:<path> Appends the specified resources to the end of the bootstrap class path. where <path> represents directories and compressed or Java\u2122 archive files separated with colons (:). On Windows\u2122 systems, use a semicolon (;) as a separator. Oracle advise that you should \"not deploy applications that use this option to override a class in rt.jar , because this violates the JRE binary code license.\"","title":"-Xbootclasspath"},{"location":"xbootclasspath/#-xbootclasspath","text":"This Oracle\u00ae HotSpot\u2122 option specifies the search path for bootstrap classes and resources. The default is to search for bootstrap classes and resources in the internal VM directories and .jar files. The option is recognized by the Eclipse OpenJ9\u2122 VM.","title":"-Xbootclasspath"},{"location":"xbootclasspath/#syntax","text":"Limited to... Setting Effect -Xbootclasspath:<path> Sets the search path for bootstrap classes and resources. -Xbootclasspath/p:<path> Prepends the specified resources to the front of the bootstrap class path. -Xbootclasspath/a:<path> Appends the specified resources to the end of the bootstrap class path. where <path> represents directories and compressed or Java\u2122 archive files separated with colons (:). On Windows\u2122 systems, use a semicolon (;) as a separator. Oracle advise that you should \"not deploy applications that use this option to override a class in rt.jar , because this violates the JRE binary code license.\"","title":"Syntax"},{"location":"xceehdlr/","text":"-XCEEHDLR (31-bit z/OS\u00ae only) Controls Eclipse OpenJ9\u2122 VM Language Environment\u00ae condition handling. Syntax -XCEEHDLR Explanation Use the -XCEEHDLR option if you want the new behavior for the Java\u2122 and COBOL interoperability batch mode environment, because this option makes signal and condition handling behavior more predictable in a mixed Java and COBOL environment. When the -XCEEHDLR option is enabled, a condition triggered by an arithmetic operation while executing a Java Native Interface (JNI) component causes the VM to convert the Language Environment condition into a Java ConditionException . When the -XCEEHDLR option is used the VM does not install POSIX signal handlers for the following signals: SIGBUS SIGFPE SIGILL SIGSEGV SIGTRAP Instead, user condition handlers are registered by the VM, using the CEEHDLR() method. These condition handlers are registered every time a thread calls into the VM. Threads call into the VM using the Java Native Interface and including the invocation interfaces, for example JNI\\_CreateJavaVM . The Java runtime continues to register POSIX signal handlers for the following signals: SIGABRT SIGINT SIGQUIT SIGTERM Signal chaining using the libjsig.so library is not supported. When the -XCEEHDLR option is used, condition handler actions take place in the following sequence: All severity 0 and severity 1 conditions are percolated. If a Language Environment condition is triggered in JNI code as a result of an arithmetic operation, the VM condition handler resumes executing Java code as if the JNI native code had thrown a com.ibm.le.conditionhandling.ConditionException exception. This exception class is a subclass of java.lang.RuntimeException . Note: The Language Environment conditions that correspond to arithmetic operations are CEE3208S through CEE3234S . However, the Language Environment does not deliver conditions CEE3208S , CEE3213S , or CEE3234S to C applications, so the VM condition handler will not receive them. If the condition handling reaches this step, the condition is considered to be unrecoverable. RAS diagnostic information is generated, and the VM ends by calling the CEE3AB2() service with abend code 3565, reason code 0, and cleanup code 0. Restriction: You cannot use -Xsignal:userConditionHandler=percolate and -XCEEHDLR together. See also -Xsignal:userConditionHandler=percolate Signal handling","title":"-XCEEHDLR"},{"location":"xceehdlr/#-xceehdlr","text":"(31-bit z/OS\u00ae only) Controls Eclipse OpenJ9\u2122 VM Language Environment\u00ae condition handling.","title":"-XCEEHDLR"},{"location":"xceehdlr/#syntax","text":"-XCEEHDLR","title":"Syntax"},{"location":"xceehdlr/#explanation","text":"Use the -XCEEHDLR option if you want the new behavior for the Java\u2122 and COBOL interoperability batch mode environment, because this option makes signal and condition handling behavior more predictable in a mixed Java and COBOL environment. When the -XCEEHDLR option is enabled, a condition triggered by an arithmetic operation while executing a Java Native Interface (JNI) component causes the VM to convert the Language Environment condition into a Java ConditionException . When the -XCEEHDLR option is used the VM does not install POSIX signal handlers for the following signals: SIGBUS SIGFPE SIGILL SIGSEGV SIGTRAP Instead, user condition handlers are registered by the VM, using the CEEHDLR() method. These condition handlers are registered every time a thread calls into the VM. Threads call into the VM using the Java Native Interface and including the invocation interfaces, for example JNI\\_CreateJavaVM . The Java runtime continues to register POSIX signal handlers for the following signals: SIGABRT SIGINT SIGQUIT SIGTERM Signal chaining using the libjsig.so library is not supported. When the -XCEEHDLR option is used, condition handler actions take place in the following sequence: All severity 0 and severity 1 conditions are percolated. If a Language Environment condition is triggered in JNI code as a result of an arithmetic operation, the VM condition handler resumes executing Java code as if the JNI native code had thrown a com.ibm.le.conditionhandling.ConditionException exception. This exception class is a subclass of java.lang.RuntimeException . Note: The Language Environment conditions that correspond to arithmetic operations are CEE3208S through CEE3234S . However, the Language Environment does not deliver conditions CEE3208S , CEE3213S , or CEE3234S to C applications, so the VM condition handler will not receive them. If the condition handling reaches this step, the condition is considered to be unrecoverable. RAS diagnostic information is generated, and the VM ends by calling the CEE3AB2() service with abend code 3565, reason code 0, and cleanup code 0. Restriction: You cannot use -Xsignal:userConditionHandler=percolate and -XCEEHDLR together.","title":"Explanation"},{"location":"xceehdlr/#see-also","text":"-Xsignal:userConditionHandler=percolate Signal handling","title":"See also"},{"location":"xcheck/","text":"-Xcheck You can use the -Xcheck option to run checks during Eclipse OpenJ9\u2122 virtual machine (VM) startup, such as memory checks or checks on JNI functions. Syntax -Xcheck:<parameter> Parameters Parameter Effect classpath Checks the classpath and reports errors such as a missing directory or JAR file. dump Checks the operating system for settings that might truncate system dumps. (AIX\u00ae and Linux\u00ae only) gc Runs additional checks on garbage collection. jni Runs additional checks for JNI functions. memory Identifies memory leaks inside the VM using strict checks that cause the VM to exit on failure. vm Performs additional checks on the VM. classpath -Xcheck:classpath Checks the classpath and reports errors such as a missing directory or JAR file. dump AIX and Linux only -Xcheck:dump Checks operating system settings during VM startup. Messages are issued if the operating system has settings that might truncate system dumps. On AIX systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated This message indicates that the AIX operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM it might be truncated, and therefore of greatly reduced value in investigating the cause of crashes and other issues. For more information about how to set user limits on AIX, see Setting system resource limits on AIX and Linux systems . JVMJ9VM134W The system fullcore option is set to FALSE, system dumps may be truncated This message indicates that the AIX operating system Enable full CORE dump option is set to FALSE . This setting might result in truncated system dumps. For more information about how to set this option correctly on AIX, see Setting system resource limits on AIX and Linux systems . On Linux systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated. This message indicates that the Linux operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM, it might be truncated and therefore of greatly reduced value in investigating the cause of crashes and other issues. Review the documentation that is provided for your operating system to correctly configure the value for ulimits . For further information, see Setting system resource limits on AIX and Linux systems . JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, abrt-hook-ccpp , is configured in the operating system to intercept any system dump files that are generated. This program is part of the Automatic Bug Reporting Tool (ABRT). For more information, see Automatic Bug Reporting Tool . This tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the ABRT tool and messages that are written by the tool in /var/log/messages . If problems occur when generating system dumps from the VM, consider disabling ABRT. JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/share/apport/apport %p %s %c\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, apport , is configured in the operating system to intercept any system dump files that are generated. For more information about this tool, see: Apport The tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the Apport tool and messages that are written by the tool in /var/log/apport.log . If problems occur when generating system dumps from the VM, consider disabling the Apport tool. JVMJ9VM136W \"/proc/sys/kernel/core_pattern setting \"/tmp/cores/core.%e.%p.%h.%t \" specifies a format string for renaming core dumps. The JVM may be unable to locate core dumps and rename them. This message indicates that the Linux /proc/sys/kernel/core_pattern option is set to rename system dumps. The tokens that are used in the operating system dump name might interfere with the VM's system dump file processing, in particular with file names specified in the VM -Xdump options. If problems occur when generating system dumps from the VM, consider changing the /proc/sys/kernel/core_pattern setting to the default value of core . gc -Xcheck:gc[:help][:<scan options>][:<verify options>][:<misc options>] Runs additional checks on garbage collection. By default, no checks are made. There are many scan, verify, and miscellaneous suboptions available. If you do not specify any, all possible scan and verify suboptions are run, plus the miscellaneous verbose and check suboptions. For more information, see the output of -Xcheck:gc:help . jni -Xcheck:jni[:help][:<option>] Runs additional checks for JNI functions. By default, no checks are made. For more information, see the output of -Xcheck:jni:help . memory -Xcheck:memory[:<option>] Identifies memory leaks inside the VM by using strict checks that cause the VM to exit on failure. Restriction: You cannot include -Xcheck:memory in the options file (see -Xoptionsfile ). The available parameters are as follows: :all (Default if no options specified) Enables checking of all allocated and freed blocks on every free and allocate call. This check of the heap is the most thorough. It typically causes the VM to exit on nearly all memory-related problems soon after they are caused. This option has the greatest affect on performance. :callsite=<number_of_allocations> Displays callsite information every <number_of_allocations> . De-allocations are not counted. Callsite information is presented in a table with separate information for each callsite. Statistics include: The number and size of allocation and free requests since the last report. The number of the allocation request responsible for the largest allocation from each site. Callsites are presented as sourcefile:linenumber for C code and assembly function name for assembler code. Callsites that do not provide callsite information are accumulated into an \"unknown\" entry. :failat=<number_of_allocations> Causes memory allocation to fail (return NULL) after <number_of_allocations> . For example, setting <number_of_allocations> to 13 causes the 14th allocation to return NULL. De-allocations are not counted. Use this option to ensure that VM code reliably handles allocation failures. This option is useful for checking allocation site behavior rather than setting a specific allocation limit. :ignoreUnknownBlocks Ignores attempts to free memory that was not allocated using the -Xcheck:memory tool. Instead, the -Xcheck:memory statistics that are printed out at the end of a run indicates the number of \"unknown\" blocks that were freed. :mprotect=[top|bottom] Locks pages of memory on supported platforms, causing the program to stop if padding before or after the allocated block is accessed for reads or writes. An extra page is locked on each side of the block returned to the user. If you do not request an exact multiple of one page of memory, a region on one side of your memory is not locked. The top and bottom options control which side of the memory area is locked. top aligns your memory blocks to the top of the page (lower address), so buffer underruns result in an application failure. bottom aligns your memory blocks to the bottom of the page (higher address) so buffer overruns result in an application failure. Standard padding scans detect buffer underruns when using top and buffer overruns when using bottom . :nofree Keeps a list of blocks that are already used instead of freeing memory. This list, and the list of currently allocated blocks, is checked for memory corruption on every allocation and deallocation. Use this option to detect a dangling pointer (a pointer that is \"dereferenced\" after its target memory is freed). This option cannot be reliably used with long-running applications (such as WebSphere\u00ae Application Server), because \"freed\" memory is never reused or released by the VM. :noscan Checks for blocks that are not freed. This option has little effect on performance, but memory corruption is not detected. This option is compatible only with subAllocator , callsite , and callsitesmall . :quick Enables block padding only and is used to detect basic heap corruption. Every allocated block is padded with sentinel bytes, which are verified on every allocate and free. Block padding is faster than the default of checking every block, but is not as effective. :skipto=<number_of_allocations> Causes the program to check only on allocations that occur after <number_of_allocations> . De-allocations are not counted. Use this option to speed up VM startup when early allocations are not causing the memory problem. The VM performs approximately 250+ allocations during startup. :subAllocator[=<size_in_MB>] Allocates a dedicated and contiguous region of memory for all VM allocations. This option helps to determine if user JNI code or the VM is responsible for memory corruption. Corruption in the VM subAllocator heap suggests that the VM is causing the problem; corruption in the user-allocated memory suggests that user code is corrupting memory. Typically, user and VM allocated memory are interleaved. :zero Newly allocated blocks are set to 0 instead of being filled with the 0xE7E7xxxxxxxxE7E7 pattern. Setting these blocks to 0 helps you to determine whether a callsite is expecting zeroed memory, in which case the allocation request is followed by memset(pointer, 0, size) . vm -Xcheck:vm[:<option>] Performs additional checks on the VM. By default, no checking is performed. For more information, run -Xcheck:vm:help .","title":"-Xcheck"},{"location":"xcheck/#-xcheck","text":"You can use the -Xcheck option to run checks during Eclipse OpenJ9\u2122 virtual machine (VM) startup, such as memory checks or checks on JNI functions.","title":"-Xcheck"},{"location":"xcheck/#syntax","text":"-Xcheck:<parameter>","title":"Syntax"},{"location":"xcheck/#parameters","text":"Parameter Effect classpath Checks the classpath and reports errors such as a missing directory or JAR file. dump Checks the operating system for settings that might truncate system dumps. (AIX\u00ae and Linux\u00ae only) gc Runs additional checks on garbage collection. jni Runs additional checks for JNI functions. memory Identifies memory leaks inside the VM using strict checks that cause the VM to exit on failure. vm Performs additional checks on the VM.","title":"Parameters"},{"location":"xcheck/#classpath","text":"-Xcheck:classpath Checks the classpath and reports errors such as a missing directory or JAR file.","title":"classpath"},{"location":"xcheck/#dump","text":"AIX and Linux only -Xcheck:dump Checks operating system settings during VM startup. Messages are issued if the operating system has settings that might truncate system dumps. On AIX systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated This message indicates that the AIX operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM it might be truncated, and therefore of greatly reduced value in investigating the cause of crashes and other issues. For more information about how to set user limits on AIX, see Setting system resource limits on AIX and Linux systems . JVMJ9VM134W The system fullcore option is set to FALSE, system dumps may be truncated This message indicates that the AIX operating system Enable full CORE dump option is set to FALSE . This setting might result in truncated system dumps. For more information about how to set this option correctly on AIX, see Setting system resource limits on AIX and Linux systems . On Linux systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated. This message indicates that the Linux operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM, it might be truncated and therefore of greatly reduced value in investigating the cause of crashes and other issues. Review the documentation that is provided for your operating system to correctly configure the value for ulimits . For further information, see Setting system resource limits on AIX and Linux systems . JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, abrt-hook-ccpp , is configured in the operating system to intercept any system dump files that are generated. This program is part of the Automatic Bug Reporting Tool (ABRT). For more information, see Automatic Bug Reporting Tool . This tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the ABRT tool and messages that are written by the tool in /var/log/messages . If problems occur when generating system dumps from the VM, consider disabling ABRT. JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/share/apport/apport %p %s %c\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, apport , is configured in the operating system to intercept any system dump files that are generated. For more information about this tool, see: Apport The tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the Apport tool and messages that are written by the tool in /var/log/apport.log . If problems occur when generating system dumps from the VM, consider disabling the Apport tool. JVMJ9VM136W \"/proc/sys/kernel/core_pattern setting \"/tmp/cores/core.%e.%p.%h.%t \" specifies a format string for renaming core dumps. The JVM may be unable to locate core dumps and rename them. This message indicates that the Linux /proc/sys/kernel/core_pattern option is set to rename system dumps. The tokens that are used in the operating system dump name might interfere with the VM's system dump file processing, in particular with file names specified in the VM -Xdump options. If problems occur when generating system dumps from the VM, consider changing the /proc/sys/kernel/core_pattern setting to the default value of core .","title":"dump"},{"location":"xcheck/#gc","text":"-Xcheck:gc[:help][:<scan options>][:<verify options>][:<misc options>] Runs additional checks on garbage collection. By default, no checks are made. There are many scan, verify, and miscellaneous suboptions available. If you do not specify any, all possible scan and verify suboptions are run, plus the miscellaneous verbose and check suboptions. For more information, see the output of -Xcheck:gc:help .","title":"gc"},{"location":"xcheck/#jni","text":"-Xcheck:jni[:help][:<option>] Runs additional checks for JNI functions. By default, no checks are made. For more information, see the output of -Xcheck:jni:help .","title":"jni"},{"location":"xcheck/#memory","text":"-Xcheck:memory[:<option>] Identifies memory leaks inside the VM by using strict checks that cause the VM to exit on failure. Restriction: You cannot include -Xcheck:memory in the options file (see -Xoptionsfile ). The available parameters are as follows: :all (Default if no options specified) Enables checking of all allocated and freed blocks on every free and allocate call. This check of the heap is the most thorough. It typically causes the VM to exit on nearly all memory-related problems soon after they are caused. This option has the greatest affect on performance. :callsite=<number_of_allocations> Displays callsite information every <number_of_allocations> . De-allocations are not counted. Callsite information is presented in a table with separate information for each callsite. Statistics include: The number and size of allocation and free requests since the last report. The number of the allocation request responsible for the largest allocation from each site. Callsites are presented as sourcefile:linenumber for C code and assembly function name for assembler code. Callsites that do not provide callsite information are accumulated into an \"unknown\" entry. :failat=<number_of_allocations> Causes memory allocation to fail (return NULL) after <number_of_allocations> . For example, setting <number_of_allocations> to 13 causes the 14th allocation to return NULL. De-allocations are not counted. Use this option to ensure that VM code reliably handles allocation failures. This option is useful for checking allocation site behavior rather than setting a specific allocation limit. :ignoreUnknownBlocks Ignores attempts to free memory that was not allocated using the -Xcheck:memory tool. Instead, the -Xcheck:memory statistics that are printed out at the end of a run indicates the number of \"unknown\" blocks that were freed. :mprotect=[top|bottom] Locks pages of memory on supported platforms, causing the program to stop if padding before or after the allocated block is accessed for reads or writes. An extra page is locked on each side of the block returned to the user. If you do not request an exact multiple of one page of memory, a region on one side of your memory is not locked. The top and bottom options control which side of the memory area is locked. top aligns your memory blocks to the top of the page (lower address), so buffer underruns result in an application failure. bottom aligns your memory blocks to the bottom of the page (higher address) so buffer overruns result in an application failure. Standard padding scans detect buffer underruns when using top and buffer overruns when using bottom . :nofree Keeps a list of blocks that are already used instead of freeing memory. This list, and the list of currently allocated blocks, is checked for memory corruption on every allocation and deallocation. Use this option to detect a dangling pointer (a pointer that is \"dereferenced\" after its target memory is freed). This option cannot be reliably used with long-running applications (such as WebSphere\u00ae Application Server), because \"freed\" memory is never reused or released by the VM. :noscan Checks for blocks that are not freed. This option has little effect on performance, but memory corruption is not detected. This option is compatible only with subAllocator , callsite , and callsitesmall . :quick Enables block padding only and is used to detect basic heap corruption. Every allocated block is padded with sentinel bytes, which are verified on every allocate and free. Block padding is faster than the default of checking every block, but is not as effective. :skipto=<number_of_allocations> Causes the program to check only on allocations that occur after <number_of_allocations> . De-allocations are not counted. Use this option to speed up VM startup when early allocations are not causing the memory problem. The VM performs approximately 250+ allocations during startup. :subAllocator[=<size_in_MB>] Allocates a dedicated and contiguous region of memory for all VM allocations. This option helps to determine if user JNI code or the VM is responsible for memory corruption. Corruption in the VM subAllocator heap suggests that the VM is causing the problem; corruption in the user-allocated memory suggests that user code is corrupting memory. Typically, user and VM allocated memory are interleaved. :zero Newly allocated blocks are set to 0 instead of being filled with the 0xE7E7xxxxxxxxE7E7 pattern. Setting these blocks to 0 helps you to determine whether a callsite is expecting zeroed memory, in which case the allocation request is followed by memset(pointer, 0, size) .","title":"memory"},{"location":"xcheck/#vm","text":"-Xcheck:vm[:<option>] Performs additional checks on the VM. By default, no checking is performed. For more information, run -Xcheck:vm:help .","title":"vm"},{"location":"xclassgc/","text":"-Xclassgc / -Xnoclassgc Enables and disables the garbage collection (GC) of storage that is associated with Java classes that are no longer being used by the Eclipse OpenJ9\u2122 VM. When enabled, GC occurs only on class loader changes. To always enable dynamic class unloading regardless of class loader changes, set -Xalwaysclassgc . Note: Disabling class GC is not recommended because unlimited native memory growth can occur, which can lead to out-of-memory errors. Syntax Setting Action Default -Xclassgc Enables dynamic class unloading on demand yes -Xnoclassgc Disables dynamic class unloading These options can be used with all OpenJ9 GC policies. See also -Xalwaysclassgc","title":"-Xnoclassgc"},{"location":"xclassgc/#-xclassgc-xnoclassgc","text":"Enables and disables the garbage collection (GC) of storage that is associated with Java classes that are no longer being used by the Eclipse OpenJ9\u2122 VM. When enabled, GC occurs only on class loader changes. To always enable dynamic class unloading regardless of class loader changes, set -Xalwaysclassgc . Note: Disabling class GC is not recommended because unlimited native memory growth can occur, which can lead to out-of-memory errors.","title":"-Xclassgc / -Xnoclassgc"},{"location":"xclassgc/#syntax","text":"Setting Action Default -Xclassgc Enables dynamic class unloading on demand yes -Xnoclassgc Disables dynamic class unloading These options can be used with all OpenJ9 GC policies.","title":"Syntax"},{"location":"xclassgc/#see-also","text":"-Xalwaysclassgc","title":"See also"},{"location":"xcodecache/","text":"-Xcodecache Use this option to tune performance. This option sets the size of each block of memory that is allocated to store the native code of compiled Java\u2122 methods. By default, this size is selected internally according to the processor architecture and the capability of your system. The maximum value you can specify is 32 MB. If you set a value larger than 32 MB, the JIT ignores the input and sets the value to 32 MB. Note: The JIT compiler might allocate more than one code cache for an application. Use the -Xcodecachetotal option to set the maximum amount of memory that is used by all code caches. Syntax -Xcodecache<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"-Xcodecache"},{"location":"xcodecache/#-xcodecache","text":"Use this option to tune performance. This option sets the size of each block of memory that is allocated to store the native code of compiled Java\u2122 methods. By default, this size is selected internally according to the processor architecture and the capability of your system. The maximum value you can specify is 32 MB. If you set a value larger than 32 MB, the JIT ignores the input and sets the value to 32 MB. Note: The JIT compiler might allocate more than one code cache for an application. Use the -Xcodecachetotal option to set the maximum amount of memory that is used by all code caches.","title":"-Xcodecache"},{"location":"xcodecache/#syntax","text":"-Xcodecache<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xcodecachetotal/","text":"-Xcodecachetotal Use this option to set the maximum size limit for the JIT code cache. This option also affects the size of the JIT data cache. Syntax -Xcodecachetotal<size> The default size is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. See Using -X command-line options for more information about specifying the <size> parameter. Explanation By default, the total size of the JIT code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. Long-running, complex, server-type applications can fill the JIT code cache, which can cause performance problems because not all of the important methods can be JIT-compiled. Use the -Xcodecachetotal option to increase or decrease the maximum code cache size to a setting that suits your application. The minimum size of the code cache is restricted to 2 MB. The value that you specify is rounded up to a multiple of the code cache block size, as specified by the -Xcodecache option. If you specify a value for the -Xcodecachetotal option that is smaller than the default setting, that value is ignored. When you use this option, the maximum size limit for the JIT data cache, which holds metadata about compiled methods, is increased or decreased proportionally to support the JIT compilations. The maximum size limits, for both the JIT code and data caches, that are in use by the VM are shown in Javadump output. Look for lines that begin with 1STSEGLIMIT . Use this information together with verbose JIT tracing to determine suitable values for this option on your system. For example Javadump output, see Java dump: Storage Management (MEMINFO) . See also -Xjit","title":"-Xcodecachetotal"},{"location":"xcodecachetotal/#-xcodecachetotal","text":"Use this option to set the maximum size limit for the JIT code cache. This option also affects the size of the JIT data cache.","title":"-Xcodecachetotal"},{"location":"xcodecachetotal/#syntax","text":"-Xcodecachetotal<size> The default size is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xcodecachetotal/#explanation","text":"By default, the total size of the JIT code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. Long-running, complex, server-type applications can fill the JIT code cache, which can cause performance problems because not all of the important methods can be JIT-compiled. Use the -Xcodecachetotal option to increase or decrease the maximum code cache size to a setting that suits your application. The minimum size of the code cache is restricted to 2 MB. The value that you specify is rounded up to a multiple of the code cache block size, as specified by the -Xcodecache option. If you specify a value for the -Xcodecachetotal option that is smaller than the default setting, that value is ignored. When you use this option, the maximum size limit for the JIT data cache, which holds metadata about compiled methods, is increased or decreased proportionally to support the JIT compilations. The maximum size limits, for both the JIT code and data caches, that are in use by the VM are shown in Javadump output. Look for lines that begin with 1STSEGLIMIT . Use this information together with verbose JIT tracing to determine suitable values for this option on your system. For example Javadump output, see Java dump: Storage Management (MEMINFO) .","title":"Explanation"},{"location":"xcodecachetotal/#see-also","text":"-Xjit","title":"See also"},{"location":"xcomp/","text":"-Xcomp The use of this option is deprecated; use -Xjit:count=0 instead. Syntax -Xcomp","title":"-Xcomp"},{"location":"xcomp/#-xcomp","text":"The use of this option is deprecated; use -Xjit:count=0 instead.","title":"-Xcomp"},{"location":"xcomp/#syntax","text":"-Xcomp","title":"Syntax"},{"location":"xcompactexplicitgc/","text":"\u2011Xcompactexplicitgc / \u2011Xnocompactexplicitgc Enables or disables full compaction each time System.gc() is called. Compaction takes place on global garbage collections if you specify -Xcompactgc or if compaction triggers are met. Syntax Setting Action Default -Xcompactexplicitgc Enable compaction yes -Xnocompactexplicitgc Disable compaction See also Global garbage collection: Compaction phase","title":"-Xnocompactexplicitgc"},{"location":"xcompactexplicitgc/#xcompactexplicitgc-xnocompactexplicitgc","text":"Enables or disables full compaction each time System.gc() is called. Compaction takes place on global garbage collections if you specify -Xcompactgc or if compaction triggers are met.","title":"\u2011Xcompactexplicitgc / \u2011Xnocompactexplicitgc"},{"location":"xcompactexplicitgc/#syntax","text":"Setting Action Default -Xcompactexplicitgc Enable compaction yes -Xnocompactexplicitgc Disable compaction","title":"Syntax"},{"location":"xcompactexplicitgc/#see-also","text":"Global garbage collection: Compaction phase","title":"See also"},{"location":"xcompactgc/","text":"-Xcompactgc / -Xnocompactgc Enables or disables full compaction on system and global garbage collection (GC) activities. Syntax Setting Action -Xcompactgc Enable full compaction -Xnocompactgc Disable full compaction Default behavior If a compaction option is not specified, the garbage collector compacts based on a series of triggers. These triggers attempt to compact only when it is beneficial to the future performance of the VM. These options are not applicable to the following GC policies: balanced GC policy ( -Xgcpolicy:balanced ): compaction is always enabled. metronome GC policy ( -Xgcpolicy:metronome ): compaction is not supported. See also GC compact operation","title":"-Xnocompactgc"},{"location":"xcompactgc/#-xcompactgc-xnocompactgc","text":"Enables or disables full compaction on system and global garbage collection (GC) activities.","title":"-Xcompactgc / -Xnocompactgc"},{"location":"xcompactgc/#syntax","text":"Setting Action -Xcompactgc Enable full compaction -Xnocompactgc Disable full compaction","title":"Syntax"},{"location":"xcompactgc/#default-behavior","text":"If a compaction option is not specified, the garbage collector compacts based on a series of triggers. These triggers attempt to compact only when it is beneficial to the future performance of the VM. These options are not applicable to the following GC policies: balanced GC policy ( -Xgcpolicy:balanced ): compaction is always enabled. metronome GC policy ( -Xgcpolicy:metronome ): compaction is not supported.","title":"Default behavior"},{"location":"xcompactgc/#see-also","text":"GC compact operation","title":"See also"},{"location":"xcompilationthreads/","text":"-XcompilationThreads Use this option to specify the number of compilation threads that are used by the JIT compiler. Syntax -XcompilationThreads<n> Where <n> is the number of threads. The minimum value is 1. The default and maximum values depend on whether the VM is running with the JITServer feature enabled and if so, whether the VM is running as a JITServer server, as shown in the following table: JIT compiler scenario Default value Maximum value JIT and JITServer client Determined by internal JIT heuristics that consider the number of CPUs that the VM is allowed to use 15 JITServer server 63 999 Any number outside this range is ignored. Setting the compilation threads to zero does not disable the JIT compiler. If you want to disable the JIT, use the -Xint option. Explanation When multiple compilation threads are used, the JIT might generate several diagnostic log files. A log file is generated for each compilation thread. The naming convention for the log file generated by the first compilation thread uses the following pattern: <specified_filename>.<date>.<time>.<pid> The first compilation thread has ID 0. Log files generated by the second and subsequent compilation threads append the ID of the corresponding compilation thread as a suffix to the log file name. The pattern for these log file names is as follows: <specified_filename>.<date>.<time>.<pid>.<compilation_thread_ID> For example, the second compilation thread has ID 1. The result is that the corresponding log file name has the form: <specified_filename>.<date>.<time>.<pid>.1 See also JITServer technology","title":"-XcompilationThreads"},{"location":"xcompilationthreads/#-xcompilationthreads","text":"Use this option to specify the number of compilation threads that are used by the JIT compiler.","title":"-XcompilationThreads"},{"location":"xcompilationthreads/#syntax","text":"-XcompilationThreads<n> Where <n> is the number of threads. The minimum value is 1. The default and maximum values depend on whether the VM is running with the JITServer feature enabled and if so, whether the VM is running as a JITServer server, as shown in the following table: JIT compiler scenario Default value Maximum value JIT and JITServer client Determined by internal JIT heuristics that consider the number of CPUs that the VM is allowed to use 15 JITServer server 63 999 Any number outside this range is ignored. Setting the compilation threads to zero does not disable the JIT compiler. If you want to disable the JIT, use the -Xint option.","title":"Syntax"},{"location":"xcompilationthreads/#explanation","text":"When multiple compilation threads are used, the JIT might generate several diagnostic log files. A log file is generated for each compilation thread. The naming convention for the log file generated by the first compilation thread uses the following pattern: <specified_filename>.<date>.<time>.<pid> The first compilation thread has ID 0. Log files generated by the second and subsequent compilation threads append the ID of the corresponding compilation thread as a suffix to the log file name. The pattern for these log file names is as follows: <specified_filename>.<date>.<time>.<pid>.<compilation_thread_ID> For example, the second compilation thread has ID 1. The result is that the corresponding log file name has the form: <specified_filename>.<date>.<time>.<pid>.1","title":"Explanation"},{"location":"xcompilationthreads/#see-also","text":"JITServer technology","title":"See also"},{"location":"xcompressedrefs/","text":"-Xcompressedrefs / -Xnocompressedrefs (64-bit only) Enables or disables the use of compressed references. Restriction: You cannot include -Xcompressedrefs in the options file (see -Xoptionsfile ). Syntax Setting Action Default -Xcompressedrefs Enable compression yes (see Default behavior ) -Xnocompressedrefs Disable compression Default behavior Compressed references are enabled by default when -Xmx \u2264 57 GB. z/OS\u00ae: This threshold value assumes that you have APAR OA49416 installed. If you do not have the APAR installed, the threshold value is 25 GB. AIX\u00ae and Linux\u00ae: For the metronome garbage collection policy, the threshold is 25 GB. See also Compressed references","title":"-Xnocompressedrefs"},{"location":"xcompressedrefs/#-xcompressedrefs-xnocompressedrefs","text":"(64-bit only) Enables or disables the use of compressed references. Restriction: You cannot include -Xcompressedrefs in the options file (see -Xoptionsfile ).","title":"-Xcompressedrefs / -Xnocompressedrefs"},{"location":"xcompressedrefs/#syntax","text":"Setting Action Default -Xcompressedrefs Enable compression yes (see Default behavior ) -Xnocompressedrefs Disable compression","title":"Syntax"},{"location":"xcompressedrefs/#default-behavior","text":"Compressed references are enabled by default when -Xmx \u2264 57 GB. z/OS\u00ae: This threshold value assumes that you have APAR OA49416 installed. If you do not have the APAR installed, the threshold value is 25 GB. AIX\u00ae and Linux\u00ae: For the metronome garbage collection policy, the threshold is 25 GB.","title":"Default behavior"},{"location":"xcompressedrefs/#see-also","text":"Compressed references","title":"See also"},{"location":"xconcurrentbackground/","text":"-Xconcurrentbackground Specifies the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark operations. This option maps directly to the HotSpot -XX:ParallelCMSThreads=N and -XX:ConcGCThreads=N options. Syntax -Xconcurrentbackground<n> Default behavior The default value is 1 . Note: This value is reported in the header section of a verbose GC log with the entry <attribute name=\"gcthreads Concurrent Mark\" value=\"1\" /> . This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ). See also -XX:ParallelCMSThreads -XX:ConcGCThreads","title":"-Xconcurrentbackground"},{"location":"xconcurrentbackground/#-xconcurrentbackground","text":"Specifies the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark operations. This option maps directly to the HotSpot -XX:ParallelCMSThreads=N and -XX:ConcGCThreads=N options.","title":"-Xconcurrentbackground"},{"location":"xconcurrentbackground/#syntax","text":"-Xconcurrentbackground<n>","title":"Syntax"},{"location":"xconcurrentbackground/#default-behavior","text":"The default value is 1 . Note: This value is reported in the header section of a verbose GC log with the entry <attribute name=\"gcthreads Concurrent Mark\" value=\"1\" /> . This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ).","title":"Default behavior"},{"location":"xconcurrentbackground/#see-also","text":"-XX:ParallelCMSThreads -XX:ConcGCThreads","title":"See also"},{"location":"xconcurrentlevel/","text":"-Xconcurrentlevel This option indicates the ratio between the amount of heap allocated and the amount of heap marked, which is known as the allocation tax rate. Syntax -Xconcurrentlevel<number> Default behavior The default is 8. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ).","title":"-Xconcurrentlevel"},{"location":"xconcurrentlevel/#-xconcurrentlevel","text":"This option indicates the ratio between the amount of heap allocated and the amount of heap marked, which is known as the allocation tax rate.","title":"-Xconcurrentlevel"},{"location":"xconcurrentlevel/#syntax","text":"-Xconcurrentlevel<number>","title":"Syntax"},{"location":"xconcurrentlevel/#default-behavior","text":"The default is 8. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ).","title":"Default behavior"},{"location":"xconcurrentslack/","text":"-Xconcurrentslack Attempts to keep the specified amount of the heap space free in concurrent collectors by starting the concurrent operations earlier. Using this option can sometimes alleviate pause time problems in concurrent collectors at the cost of longer concurrent cycles, affecting total throughput. Syntax -Xconcurrentslack<size> See Using -X command-line options for more information about specifying the <size> parameter. Default behavior The default value is 0, which is optimal for most applications. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ), the optimize for throughput policy ( -Xgcpolicy:optthruput ), or metronome GC policy ( -Xgcpolicy:metronome ).","title":"-Xconcurrentslack"},{"location":"xconcurrentslack/#-xconcurrentslack","text":"Attempts to keep the specified amount of the heap space free in concurrent collectors by starting the concurrent operations earlier. Using this option can sometimes alleviate pause time problems in concurrent collectors at the cost of longer concurrent cycles, affecting total throughput.","title":"-Xconcurrentslack"},{"location":"xconcurrentslack/#syntax","text":"-Xconcurrentslack<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xconcurrentslack/#default-behavior","text":"The default value is 0, which is optimal for most applications. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ), the optimize for throughput policy ( -Xgcpolicy:optthruput ), or metronome GC policy ( -Xgcpolicy:metronome ).","title":"Default behavior"},{"location":"xconmeter/","text":"-Xconmeter This option determines the usage of which area, LOA (large object area) or SOA (small object area), is metered and therefore which allocations are taxed during concurrent mark operations. Syntax -Xconmeter:<parameter> Parameters soa -Xconmeter:soa (Default) Applies the allocation tax to allocations from the small object area (SOA). loa -Xconmeter:loa Applies the allocation tax to allocations from the large object area (LOA). dynamic -Xconmeter:dynamic The collector dynamically determines which area to meter based on which area is exhausted first, whether it is the SOA or the LOA. Default behavior By default, allocation tax is applied to the SOA. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ).","title":"-Xconmeter"},{"location":"xconmeter/#-xconmeter","text":"This option determines the usage of which area, LOA (large object area) or SOA (small object area), is metered and therefore which allocations are taxed during concurrent mark operations.","title":"-Xconmeter"},{"location":"xconmeter/#syntax","text":"-Xconmeter:<parameter>","title":"Syntax"},{"location":"xconmeter/#parameters","text":"","title":"Parameters"},{"location":"xconmeter/#soa","text":"-Xconmeter:soa (Default) Applies the allocation tax to allocations from the small object area (SOA).","title":"soa"},{"location":"xconmeter/#loa","text":"-Xconmeter:loa Applies the allocation tax to allocations from the large object area (LOA).","title":"loa"},{"location":"xconmeter/#dynamic","text":"-Xconmeter:dynamic The collector dynamically determines which area to meter based on which area is exhausted first, whether it is the SOA or the LOA.","title":"dynamic"},{"location":"xconmeter/#default-behavior","text":"By default, allocation tax is applied to the SOA. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ).","title":"Default behavior"},{"location":"xdisablejavadump/","text":"-Xdisablejavadump Turns off Java dump generation on errors and signals. Syntax -Xdisablejavadump Default behavior By default, Javadump generation is enabled. See also -Xdump","title":"-Xdisablejavadump"},{"location":"xdisablejavadump/#-xdisablejavadump","text":"Turns off Java dump generation on errors and signals.","title":"-Xdisablejavadump"},{"location":"xdisablejavadump/#syntax","text":"-Xdisablejavadump","title":"Syntax"},{"location":"xdisablejavadump/#default-behavior","text":"By default, Javadump generation is enabled.","title":"Default behavior"},{"location":"xdisablejavadump/#see-also","text":"-Xdump","title":"See also"},{"location":"xdump/","text":"-Xdump OpenJ9 produces various types of diagnostic information for analysis when different events occur, such as a general protection fault. The dumps produced are controlled by dump agents, which are initialized when the OpenJ9 virtual machine (VM) starts. The default settings for the dump agents are sufficient for most cases. However, you can use the -Xdump option on the command line to fine tune the dump agent settings. For example, you can use the -Xdump option to add and remove dump agents for various VM events, update default dump settings, and limit the number of dumps that are produced. A large set of options and suboptions are available for controlling dumps, which provides a lot of flexibility. Xdump Option Builder Use the Xdump Option Builder tool to help you specify the correct options and avoid incompatibilities. Syntax -Xdump:<parameter> The following table lists the help options for -Xdump , which provide usage and configuration information: Command Result -Xdump:help Displays general dump help. -Xdump:events Lists available trigger events. -Xdump:request Lists additional VM requests. -Xdump:tokens Lists recognized label tokens. -Xdump:what Shows registered agents on startup. -Xdump:<agent>:help Displays dump agent usage information. The following options can be used to control the production of diagnostic data: Parameter Result -Xdump:none Removes all default dump agents and any preceding dump options. -Xdump:dynamic Enable support for pluggable agents -Xdump:nofailover Discards dumps when the default or specified dump location is full. -Xdump:directory=<path> Specifies a directory for all dump types to be written to. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents. -Xdump:suspendwith=<offset> Modifies the signal that is used to suspend VM threads while a dump file is being written. Use <offset> to change the default signal number. (Linux\u00ae only) -Xdump:<agent>:<suboptions> Provides detailed suboptions per dump agent that provide more granular control. Dump agents can be configured at a very granular level by specifying suboptions. The <events> suboption is the prime trigger mechanism. The full set of suboptions are listed in the following table: Dump agent suboptions Result -Xdump:<agent>:none Removes the dump agent. -Xdump:<agent>:defaults Prints the default options for the dump agent. -Xdump:<agent>:events=<events> Triggers a dump agent when a specific event occurs. -Xdump:<agent>:exec=<command> Starts an external application for the dump agent. -Xdump:<agent>:file=<filename> Specifies where to write the dump for the dump agent. -Xdump:<agent>:filter=<filter> Filters dumps by wildcards or events. -Xdump:<agent>:msg_filter=<filter> Filters on text strings within an exception message. -Xdump:<agent>:opts=<options> Used by specific dump agents to select the type of dump file to produce. -Xdump:<agent>:priority=<0-999> Specifies the priority that the dump agents run in. -Xdump:<agent>:range=<ranges> Starts and stops a dump agent on a particular occurrence of a VM. -Xdump:<agent>:request=<requests> Asks the VM to prepare the state before starting the dump agent. You can have multiple -Xdump options on the command line. You can also have multiple dump types triggered by multiple events. For example, the following command turns off the creation of heap dump files, and creates a dump agent that produces a heap dump file and a Java\u2122 dump file when either a vmstart or vmstop event occurs: java -Xdump:heap:none -Xdump:heap+java:events=vmstart+vmstop -mp . -m <class> [args...] Note: Multiple suboptions that follow an Xdump suboption must be split with a comma (,), for example: java -Xdump:java:events=vmstart,file=/STDERR/ -version For more detailed information on these parameters and suboptions, including examples, see Parameters . Dump agents A dump agent performs diagnostic tasks when triggered. Most dump agents save information on the state of the VM in some form of dump or trace file for later analysis. An exception is the \"tool\" agent, which can be used to trigger external processes when specific events occur. Dump agent Description stack Stack dumps are very basic dumps in which the status and Java stack of the thread is written to stderr. console Console dumps are very basic dumps, in which the status of every Java thread is written to stderr. system System dumps capture the raw process image or address space of an application. tool The tool option allows external processes to be started when an event occurs. java Java dumps are an internally generated and formatted analysis of the VM, giving information that includes the Java threads present, the classes loaded, and heap statistics. heap Heap dumps capture all object instances in the heap, including each object address, type or class name, size, and references to other objects. snap Take a snap of the trace buffers, which contain tracepoint data. ceedump LE CEEDUMP dumps are z/OS\u00ae formatted summary system dumps that show stack traces for each thread that is in the VM process, together with register information and a short dump of storage for each register. jit JIT compiler dumps contain diagnostic data in a binary format. exit Shut down the VM. Default dump agents During VM initialization a set of dump agents are added by default. You can override this set of dump agents using -Xdump on the command line. To show the registered dump agents, user the Xdump:what option on the command line. The following sample output shows the default dump agents that are in place on a Linux system: java -Xdump:what Registered dump agents ---------------------- -Xdump:system: events=gpf+abort+traceassert+corruptcache, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=999, request=serial ---------------------- -Xdump:system: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..1, priority=999, request=exclusive+compact+prepwalk ---------------------- -Xdump:heap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.%seq.phd, range=1..4, priority=500, request=exclusive+compact+prepwalk, opts=PHD ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- -Xdump:java: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..4, priority=400, request=exclusive+preempt ---------------------- -Xdump:snap: events=gpf+abort+traceassert+corruptcache, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..0, priority=300, request=serial ---------------------- -Xdump:snap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..4, priority=300, request=serial ---------------------- -Xdump:jit: events=gpf+abort, label=/home/user/jitdump.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=200, request=serial ---------------------- Dump agent tokens You can use tokens to add context to dump file names and directories, and to pass command-line arguments to the tool agent. The tokens available are listed in the following tables: Token Description %Y Year (4 digits) %y Year (2 digits) %m Month (2 digits) %d Day of the month (2 digits) %H Hour (2 digits) %M Minute (2 digits) %S Second (2 digits) %home Java home directory %last Last dump %pid Process ID %seq Dump counter %tick msec counter %uid User name The following tokens are applicable only to z/OS: Token Description %asid Address space ID %job Job name %jobid Job ID %sysname SYSNAME sysparm &DS Dump Section. An incrementing sequence number used for splitting TDUMP files to be less than 2 GB in size. (64-bit only) Merging dump agents If you configure more than one dump agent, each responds to events according to its configuration. However, the internal structures representing the dump agent configuration might not match the command line because dump agents are merged for efficiency. Two sets of options can be merged as long as none of the agent settings conflict. This means that the list of installed dump agents and their parameters produced by -Xdump:what might not be grouped in the same way as the original -Xdump options that configured them. For example, you can use the following command to specify that a dump agent creates a Java dump file on class unload: java -Xdump:java:events=unload -Xdump:what This command does not create a new agent, as can be seen in the results from the -Xdump:what option. ... ---------------------- -Xdump:java: events=gpf+user+abort+unload+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- The configuration is merged with the existing Java dump agent for events gpf , user , abort , traceassert , and corruptcache , because none of the specified options for the new unload agent conflict with those for the existing agent. In the previous example, if one of the parameters for the unload agent is changed so that it conflicts with the existing agent, then it cannot be merged. For example, the following command specifies a different priority, forcing a separate agent to be created: java -Xdump:java:events=unload,priority=100 -Xdump:what The results of the -Xdump:what option in the command are as follows. ... ---------------------- -Xdump:java: events=unload, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=100, request=exclusive+preempt ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- To merge dump agents, the request , filter , opts , label , and range parameters must match exactly. If you specify multiple agents that filter on the same string, but keep all other parameters the same, the agents are merged. For example: java -Xdump:none -Xdump:java:events=uncaught,filter=java/lang/NullPointerException -Xdump:java:events=unload,filter=java/lang/NullPointerException -Xdump:what The results of this command are as follows: Registered dump agents ---------------------- -Xdump:java: events=unload+uncaught, filter=java/lang/NullPointerException, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- Dump events Dump agents are triggered by events occurring during operation of the OpenJ9 VM. Some events can be filtered to improve the relevance of the output. The following table shows the events that are available as dump agent triggers: Event Triggered when.... Filters on.... gpf A General Protection Fault (GPF) occurs. Not applicable user The VM receives the SIGQUIT (Linux, macOS\u00ae, AIX\u00ae, z/OS) or SIGBREAK (Windows\u2122) signal from the operating system. Not applicable user2 The VM receives the SIGUSR2 (Linux, AIX, z/OS, and macOS) signal from the operating system. Not applicable abort The VM receives the SIGABRT signal from the operating system. Not applicable vmstart The virtual machine is started. Not applicable vmstop The virtual machine stops. Exit code; for example, filter=#129..#192#-42#255 load A class is loaded. Class name; for example, filter=java/lang/String unload A class is unloaded. Not applicable throw An exception is thrown explicitly in Java code. Use 'systhrow' for unexpected VM exceptions. Exception class name; for example, filter=java/lang/OutOfMem* catch An exception is caught. Exception class name; for example, filter=*Memory* uncaught A Java exception is not caught by the application. Exception class name; for example, filter=*MemoryError systhrow A Java exception is about to be thrown by the VM. This is different from the 'throw' event because it is only triggered for error conditions detected internally in the VM. Exception class name; for example, filter=java/lang/OutOfMem* . thrstart A new thread is started. Not applicable blocked A thread becomes blocked. Not applicable thrstop A thread stops. Not applicable fullgc A garbage collection cycle is started. Not applicable slow A thread takes longer than 50 ms to respond to an internal VM request. Time taken; for example, filter=#300ms will trigger when a thread takes longer than 300 ms to respond to an internal VM request. allocation A Java object is allocated with a size matching the given filter specification. Object size; a filter must be supplied. For example, filter=#5m will trigger on objects larger than 5 Mb. Ranges are also supported; for example, filter=#256k..512k will trigger on objects 256 - 512 Kb in size. traceassert An internal error occurs in the VM. Not applicable corruptcache The VM finds that the shared classes cache is corrupt. Not applicable excessivegc An excessive amount of time is being spent in the garbage collector. Not applicable Notes: The gpf , traceassert , and abort events cannot trigger a heap dump, prepare the heap (request=prepwalk), or compact the heap (request=compact). The Java dump agent behaves differently when triggered by the user and user2 events. For more information, see request=<requests> . The user2 event is commonly used for taking system dump files with exclusive access without overriding the user event, which is generally left for taking Java dump files for performance investigations. For example: -Xdump:system:events=user2,request=exclusive+prepwalk Parameters -Xdump:<agent>:<suboptions> descriptions and examples. help To print usage information for a specific dump agent, use -Xdump:<agent>:help none:<options> Use the -Xdump:none option to add and remove dump agents for various VM events, update default dump settings (such as the dump name), and limit the number of dumps that are produced. The option can be used to affect all agents by specifying -Xdump:none:<options> or specific agents by specifying -Xdump:<agent>:none:<suboptions> where <suboptions> is one of the following control types: events=<event> exec=<command> file=<filename> filter=<filter> opts=<options> priority=<0-999> range=<ranges> request=<requests> Explanations for these suboptions are provided elsewhere in this topic. To remove all default dump agents and any preceding dump options, use -Xdump:none . Use this option so that you can subsequently specify a completely new dump configuration. You can also remove dump agents of a particular type. Here are some examples: To turn off all heap dumps (including default agents) but leave Java dumps enabled, use the following option: -Xdump:java+heap:events=vmstop -Xdump:heap:none To turn off all dump agents for corruptcache events: -Xdump:none:events=corruptcache To turn off just system dumps for corruptcache events: -Xdump:system:none:events=corruptcache To turn off all dumps when a java/lang/OutOfMemory error is thrown: -Xdump:none:events=systhrow,filter=java/lang/OutOfMemoryError To turn off just system dumps when a java/lang/OutOfMemory error is thrown: -Xdump:system:none:events=systhrow,filter=java/lang/OutOfMemoryError If you remove all dump agents by using -Xdump:none with no further -Xdump options, the VM still provides these basic diagnostic outputs: If a user signal (kill -QUIT) is sent to the VM, a brief listing of the Java threads including their stacks, status, and monitor information is written to stderr. If a crash occurs, information about the location of the crash, VM options, and native and Java stack traces are written to stderr. A system dump file is also written to the user's home directory. Note: Removing dump agents and specifying a new dump configuration can require a long set of command-line options. To reuse command-line options, save the new dump configuration in a file and use the -Xoptionsfile option. For more information, see -Xoptionsfile . defaults Each dump type has default options. To view the default options for a particular dump type, use -Xdump:<agent>:defaults . You can change the default options at run time. For example, you can direct Java dump files into a separate directory for each process, and guarantee unique files by adding a sequence number to the file name using: -Xdump:java:defaults:file=dumps/%pid/javacore-%seq.txt Or, for example, on z/OS, you can add the jobname to the Java dump file name using: -Xdump:java:defaults:file=javacore.%job.%H%M%S.txt This option does not add a Java dump agent; it updates the default settings for Java dump agents. Further Java dump agents will then create dump files using this specification for filenames, unless overridden. Note: Changing the defaults for a dump type will also affect the default agents for that dump type added by the VM during initialization. For example, if you change the default file name for Java dump files, that will change the file name used by the default Java dump agents. However, changing the default range option will not change the range used by the default Java dump agents, because those agents override the range option with specific values. events=<event> To trigger a dump as a result of an event, use the -Xdump:<agent>:events=<event> suboption. For a list of possible events, see Dump events . For example, the following command instructs the VM to create a dump agent at startup that produces a Heap dump whenever the vmstop event happens: -Xdump:heap:events=vmstop exec=<command> The exec suboption is used by the tool dump agent to specify an external application to start. You can set a specific command to run for a particular dump agent with the following command: -Xdump:<agent>:exec=<command> file=<filename> The file suboption specifies where the diagnostics information is written for the specified dump type. The syntax is -Xdump:<agent>:file=<filename> . For example, to create a Heap dump called my.dmp when a vmstop event is received, use: java -Xdump:heap:events=vmstop,file=my.dmp When producing system dump files on z/OS platforms, use the dsn option instead of the file option. For example: java -Xdump:system:events=vmstop,dsn=%uid.MYDUMP Writing to STDOUT / STDERR Add one of the following options to write a Java dump file to STDOUT or STDERR respectively: -Xdump:java:file=/STDOUT/ -Xdump:java:file=/STDERR/ The keywords /STDOUT/ and /STDERR/ are not case sensitive; /stdout/ and /stderr/ are equivalent. By common convention, you can use a dash ( - ) to refer to STDOUT: -Xdump:java:file=- Tokens You can use tokens to add context to dump file names. For a list of tokens, see Dump agent tokens . File location The location for the dump file is selected from the following options, in this order: The location specified by the -Xdump:<agent>:file suboption on the command line (if that location includes a path). This location applies to the specified dump agent type only. The location specified by the -Xdump:directory option on the command line. This location applies to all dump agent types. The location specified by the relevant environment variable: Dump agent type z/OS operating systems Other operating systems Java dumps _CEE_DMPTARG IBM_JAVACOREDIR Heap dumps _CEE_DMPTARG IBM_HEAPDUMPDIR System dumps JAVA_DUMP_TDUMP_PATTERN IBM_COREDIR JIT dumps _CEE_DMPTARG IBM_COREDIR Snap traces _CEE_DMPTARG IBM_COREDIR The current working directory of the OpenJ9 VM process. If the directory does not exist, it is created. If the dump file cannot be written to the selected location, the VM reverts to using the following locations, in this order: On Windows platforms only, the system default location is C:\\WINDOWS . The location specified by the TMPDIR environment variable. The C:\\Temp on Windows operating systems, or the /tmp directory on other operating systems. This VM action does not apply to system dumps on z/OS operating systems that use the dsn option. You can prevent the VM reverting to different dump locations by using the -Xdump:nofailover option. filter=<filter> Some VM events occur thousands of times during the lifetime of an application. Dump agents can use filters and ranges to avoid producing an excessive number of dump files. The following syntax must be used: -Xdump:<agent>:filter=<filter> Wildcards You can use a wildcard in your exception event filter by placing an asterisk only at the beginning or end of the filter. The following command does not work because the second asterisk is not at the end: -Xdump:java:events=throw,filter=*InvalidArgumentException#*.myVirtualMethod To fix the problem, change this filter to the following string: -Xdump:java:events=throw,filter=*InvalidArgumentException#MyApplication.* Class loading and exception events You can filter class loading ( load ) and exception ( throw , catch , uncaught , systhrow ) events by the name of the class that is being loaded, thrown or caught. For example: -Xdump:java:events=load,filter=java/lang/String -Xdump:java:events=throw,filter=java/lang/ArrayStoreException -Xdump:java:events=catch,filter=java/lang/NullPointerException In addition, you can filter throw , uncaught , and systhrow exception events by the name of the method that throws the exception. The name of the parent class must include the full package name, using the forward slash (/) as a separator. Use a dot (.) to separate the method name from the class name. You can use an asterisk (*) as a wildcard character, to include all methods (optional portions are shown in brackets). For example: -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] For example, to trigger a Java dump when method MyApplication.myMethod() throws a NullPointerException exception, use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.myMethod The stack frame offset allows you to filter on the name of a method that calls the throwing method. This option is useful if the exception is being thrown from a general purpose or utility class. For example, to trigger a Java dump when a method called by MyApplication.main() throws a NullPointerException , use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.main#1 The default value of the stack frame offset is zero. You can filter the catch exception events by Java method name (optional portions are shown in brackets). For example: -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] You can filter throw , uncaught , and systhrowexception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] You can filter the catch exception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] Note: The filters apply to the stacktrace and fire every time the same exception is rethrown, which might result in multiple Java core files. vmstop event You can filter the VM shut down event ( vmstop ) by using one or more exit codes: -Xdump:java:events=vmstop,filter=#129..192#-42#255 slow event You can filter the slow event to change the time threshold from the default of 50 ms: -Xdump:java:events=slow,filter=#300ms allocation event You must filter the allocation event to specify the size of objects that cause a trigger. You can set the filter size from zero up to the maximum value of a 32-bit pointer on 32-bit platforms, or the maximum value of a 64-bit pointer on 64-bit platforms. Setting the lower filter value to zero triggers a dump on all allocations. For example, to trigger dumps on allocations greater than 5 Mb in size, use: -Xdump:stack:events=allocation,filter=#5m To trigger dumps on allocations between 256 Kb and 512 Kb in size, use: -Xdump:stack:events=allocation,filter=#256k..512k Other events If you apply a filter to an event that does not support filtering, the filter is ignored. msg_filter=<filter> You can use the msg_filter suboption to filter on text strings within an exception message, allowing you to reduce the number of dump files produced. This option is supported only for the following events: throw , catch , systhrow , and uncaught . Use the following syntax to include message filtering in your dump output: -Xdump:<agent>:events=<event>,msg_filter=<filter>` where <filter> is a text string from the exceptions that you want to include in the dump file. This suboption supports asterisks as wild cards. The following example filters java/lang/VerifyError exceptions that contain the text string class format : -Xdump:java:events=throw,filter=java/lang/VerifyError,msg_filter=*class format* opts=<options> The full syntax is -Xdump:<agent>:opts=<options> . The heap dump agent uses this suboption to specify the type of file to produce. On z/OS, the system dump agent uses this suboption to specify the type of dump to produce. Heap dumps You can specify a PHD heap dump file (PHD), a classic text heap dump file (CLASSIC), or both. The default is a PHD file. For example: -Xdump:heap:opts=PHD -Xdump:heap:opts=CLASSIC -Xdump:heap:opts=PHD+CLASSIC z/OS system dumps You can specify a system transaction dump (IEATDUMP), an LE dump (CEEDUMP), or both. The default is an IEADUMP file. For example: -Xdump:system:opts=IEATDUMP -Xdump:system:opts=CEEDUMP -Xdump:system:opts=IEATDUMP+CEEDUMP The ceedump agent is the preferred way to specify LE dumps, for example: -Xdump:ceedump:events=gpf Tool dumps The tool dump agent supports two suboptions that can be specified using the opts subption. You can run the external process asynchronously with opts=ASYNC. You can also specify a delay in milliseconds that produces a pause after starting the command. These two options can be used independently or together. The following examples show different options for starting a new process that runs myProgram : -Xdump:tool:events=vmstop,exec=myProgram Without the opts suboption, the tool dump agent starts the process, and waits for the process to end before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC When opts=ASYNC is specified, the tool dump agent starts the process, and continues without waiting for the new process to end. -Xdump:tool:events=vmstop,exec=myProgram,opts=WAIT1000 This option starts the process, waits for the process to end, and then waits a further 1 second (1000 milliseconds) before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC+WAIT10000 Finally, the last example starts the process and waits for 10 seconds before continuing, whether the process is still running or not. This last form is useful if you are starting a process that does not end, but requires time to initialize properly. priority=<0-999> One event can generate multiple dump files. The agents that produce each dump file run sequentially and their order is determined by the priority keyword set for each agent. The full syntax for this command is -Xdump:<agent>:priority=<0-999> . Examination of the output from -Xdump:what shows that a gpf event produces a snap trace, a Java dump file, and a system dump file. In this example, the system dump runs first, with priority 999. The snap dump runs second, with priority 500. The Java dump runs last, with priority 10: -Xdump:heap:events=vmstop,priority=123 The maximum value allowed for priority is 999. Higher priority dump agents are started first. If you do not specifically set a priority, default values are taken based on the dump type. The default priority and the other default values for a particular type of dump, can be displayed by using -Xdump:<type>:defaults . For example: java -Xdump:heap:defaults -version Default -Xdump:heap settings: events=gpf+user filter= file=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.phd range=1..0 priority=500 request=exclusive+compact+prepwalk opts=PHD range=<ranges> You can start and stop dump agents on a particular occurrence of a VM event by using the range suboption: -Xdump:<agent>:range=<ranges> For example: -Xdump:java:events=fullgc,range=100..200 Note: range=1..0 against an event means \"on every occurrence\". The VM default dump agents have the range suboption set to 1..0 for all events except systhrow. Most systhrow events with filter=java/lang/OutOfMemoryError have the range suboption set to 1..4, which limits the number of dump files produced on OutOfMemory conditions to a maximum of 4. For more information, see Default dump agents . If you add a new dump agent and do not specify the range, a default of 1..0 is used. request=<requests> Use the request suboption to ask the VM to prepare the state before starting the dump agent: -Xdump:<agent>:request=<requests> The available suboptions are listed in the following table: suboption value Description exclusive Request exclusive access to the VM. compact Run garbage collection. This option removes all unreachable objects from the heap before the dump file is generated. prepwalk Prepare the heap for walking. You must also specify exclusive when you use this option. serial Suspend other dumps until this dump is finished. preempt Applies to the Java dump agent and controls whether native threads in the process are forcibly pre-empted in order to collect stack traces. If this option is not specified, only Java stack traces are collected in the Java dump. You can specify more than one request option by using + . For example: -Xdump:heap:request=exclusive+compact+prepwalk The VM exclusive access mechanism allows a VM thread to halt the activity of other VM threads in a controlled way by using internal VM locks. When the request=exclusive option is specified for a dump agent, the VM thread that is producing the dump waits for threads that are running Java code to halt, and for garbage collection operations to complete, before the dump file is written. This process helps ensure that the dump has consistent data. When the dump is complete, the mechanism allows the other threads to resume. By default, only system dumps for OutOfMemoryError exceptions request exclusive access. Other system dump events typically result from a crash. In these cases, exclusive access is not requested because acquiring locks during a crash can be problematic. If system dumps are requested by using the com.ibm.jvm.Dump.SystemDump() API, the default system dump agent settings are used, and exclusive access is not requested. However, if you intend to use the system dump file for Java heap memory analysis, use the following option to request exclusive access when the dump is taken: -Xdump:system:defaults:request=exclusive+compact+prepwalk These settings avoid capturing a dump file with in-flight data during garbage collection. As an alternative, you can use the com.ibm.jvm.Dump.triggerDump() API and specify request=exclusive+compact+prepwalk on the API call. For more information about the com.ibm.jvm.Dump API , see the API reference information. The default setting of the request suboption for Java dump files is request=exclusive+preempt . To change the settings so that Java dump files are produced without pre-empting threads to collect native stack traces, use the following option: -Xdump:java:request=exclusive The Java dump agent ignores the request=exclusive setting if a user event occurs and another event already has exclusive access. In this scenario, the Java dump agent shares the access instead. This behavior is useful because it allows you to obtain a Java dump file during a deadlock situation, when exclusive access is not released. However, the resulting Java dump file, even in other situations, might omit thread stacks and contain inconsistent thread information, as indicated by the following line in the file: 1TIPREPINFO Exclusive VM access not taken: data may not be consistent across javacore sections On operating systems other than Windows, you can enforce exclusive access and obtain a complete dump file by specifying that the user2 event triggers the Java dump agent instead of the user event. For example: -Xdump:java:events=user2,request=exclusive+prepwalk When a user2 event occurs, for example, when you enter kill -USR2 <pid> on the command line, the Java dump agent accepts the request=exclusive setting and waits for exclusive access before creating the Java dump file. For more information about events, see Dump events . In general, the default request options are sufficient. Dump output Dump output is written to different files, depending on the type of dump and the platform. File names include a time stamp. Dump type File name (AIX, Linux, macOS, Windows) File name (z/OS) System dump core.%Y%m%d.%H%M%S.%pid.dmp %uid.JVM.TDUMP.%job.D%Y%m%d.T%H%M%S (31-bit), %uid.JVM.%job.D%y%m%d.T%H%M%S.X&DS (64-bit) See Note Java dump javacore.%Y%m%d.%H%M%S.%pid.%seq.txt javacore.%Y%m%d.%H%M%S.%pid.%seq.txt Heap dump heapdump.%Y%m%d.%H%M%S.%pid.phd heapdump.%Y%m%d.T%H%M%S.phd JIT dump jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp LE CEEDUMP - CEEDUMP.%Y%m%d.%H%M%S.%pid See Note The tokens used in this table, for example %Y , are described in Dump agent tokens . Note: On z/OS, the system dump file name can be set with the JAVA_DUMP_TDUMP_PATTERN environment variable. The CEEDUMP, which is not produced by default, is stored in the directory specified by _CEE_DMPTARG or the current directory if _CEE_DMPTARG is not specified. System dumps on Linux Linux does not provide an operating system API for generating a system dump from a running process. The VM produces system dumps on Linux by using the fork() API to start an identical process to the parent VM process. The VM then generates a SIGSEGV signal in the child process. The SIGSEGV signal causes Linux to create a system dump for the child process. The parent VM processes and renames the system dump, as required, by the -Xdump options, and might add additional data into the dump file. The system dump file for the child process contains an exact copy of the memory areas used in the parent. The dump viewer can obtain information about the Java threads, classes, and heap from the system dump. However, the dump viewer, and other system dump debuggers show only the single native thread that was running in the child process. You can use the Linux kernel.core_pattern setting to specify the name and path for system dumps. The VM dump agents override the Linux system dump name and path by renaming the dump as specified in the -Xdump options. If the kernel.core_pattern setting specifies a different file system to the -Xdump options, the VM dump agents might be unable to change the file path. In this case the VM renames the dump file, but leaves the file path unchanged. You can find the dump file name and location in the JVMDUMP010I message. Note: If you use the %t specifier in the kernel.core_pattern setting, the VM does not rename the dump. The VM cannot determine the exact time that Linux generated the core file, and therefore cannot be certain which Linux dump file is the correct one to rename. See also -Xtrace -Xdisablejavadump","title":"-Xdump"},{"location":"xdump/#-xdump","text":"OpenJ9 produces various types of diagnostic information for analysis when different events occur, such as a general protection fault. The dumps produced are controlled by dump agents, which are initialized when the OpenJ9 virtual machine (VM) starts. The default settings for the dump agents are sufficient for most cases. However, you can use the -Xdump option on the command line to fine tune the dump agent settings. For example, you can use the -Xdump option to add and remove dump agents for various VM events, update default dump settings, and limit the number of dumps that are produced. A large set of options and suboptions are available for controlling dumps, which provides a lot of flexibility.","title":"-Xdump"},{"location":"xdump/#xdump-option-builder","text":"Use the Xdump Option Builder tool to help you specify the correct options and avoid incompatibilities.","title":"Xdump Option Builder"},{"location":"xdump/#syntax","text":"-Xdump:<parameter> The following table lists the help options for -Xdump , which provide usage and configuration information: Command Result -Xdump:help Displays general dump help. -Xdump:events Lists available trigger events. -Xdump:request Lists additional VM requests. -Xdump:tokens Lists recognized label tokens. -Xdump:what Shows registered agents on startup. -Xdump:<agent>:help Displays dump agent usage information. The following options can be used to control the production of diagnostic data: Parameter Result -Xdump:none Removes all default dump agents and any preceding dump options. -Xdump:dynamic Enable support for pluggable agents -Xdump:nofailover Discards dumps when the default or specified dump location is full. -Xdump:directory=<path> Specifies a directory for all dump types to be written to. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents. -Xdump:suspendwith=<offset> Modifies the signal that is used to suspend VM threads while a dump file is being written. Use <offset> to change the default signal number. (Linux\u00ae only) -Xdump:<agent>:<suboptions> Provides detailed suboptions per dump agent that provide more granular control. Dump agents can be configured at a very granular level by specifying suboptions. The <events> suboption is the prime trigger mechanism. The full set of suboptions are listed in the following table: Dump agent suboptions Result -Xdump:<agent>:none Removes the dump agent. -Xdump:<agent>:defaults Prints the default options for the dump agent. -Xdump:<agent>:events=<events> Triggers a dump agent when a specific event occurs. -Xdump:<agent>:exec=<command> Starts an external application for the dump agent. -Xdump:<agent>:file=<filename> Specifies where to write the dump for the dump agent. -Xdump:<agent>:filter=<filter> Filters dumps by wildcards or events. -Xdump:<agent>:msg_filter=<filter> Filters on text strings within an exception message. -Xdump:<agent>:opts=<options> Used by specific dump agents to select the type of dump file to produce. -Xdump:<agent>:priority=<0-999> Specifies the priority that the dump agents run in. -Xdump:<agent>:range=<ranges> Starts and stops a dump agent on a particular occurrence of a VM. -Xdump:<agent>:request=<requests> Asks the VM to prepare the state before starting the dump agent. You can have multiple -Xdump options on the command line. You can also have multiple dump types triggered by multiple events. For example, the following command turns off the creation of heap dump files, and creates a dump agent that produces a heap dump file and a Java\u2122 dump file when either a vmstart or vmstop event occurs: java -Xdump:heap:none -Xdump:heap+java:events=vmstart+vmstop -mp . -m <class> [args...] Note: Multiple suboptions that follow an Xdump suboption must be split with a comma (,), for example: java -Xdump:java:events=vmstart,file=/STDERR/ -version For more detailed information on these parameters and suboptions, including examples, see Parameters .","title":"Syntax"},{"location":"xdump/#dump-agents","text":"A dump agent performs diagnostic tasks when triggered. Most dump agents save information on the state of the VM in some form of dump or trace file for later analysis. An exception is the \"tool\" agent, which can be used to trigger external processes when specific events occur. Dump agent Description stack Stack dumps are very basic dumps in which the status and Java stack of the thread is written to stderr. console Console dumps are very basic dumps, in which the status of every Java thread is written to stderr. system System dumps capture the raw process image or address space of an application. tool The tool option allows external processes to be started when an event occurs. java Java dumps are an internally generated and formatted analysis of the VM, giving information that includes the Java threads present, the classes loaded, and heap statistics. heap Heap dumps capture all object instances in the heap, including each object address, type or class name, size, and references to other objects. snap Take a snap of the trace buffers, which contain tracepoint data. ceedump LE CEEDUMP dumps are z/OS\u00ae formatted summary system dumps that show stack traces for each thread that is in the VM process, together with register information and a short dump of storage for each register. jit JIT compiler dumps contain diagnostic data in a binary format. exit Shut down the VM.","title":"Dump agents"},{"location":"xdump/#default-dump-agents","text":"During VM initialization a set of dump agents are added by default. You can override this set of dump agents using -Xdump on the command line. To show the registered dump agents, user the Xdump:what option on the command line. The following sample output shows the default dump agents that are in place on a Linux system: java -Xdump:what Registered dump agents ---------------------- -Xdump:system: events=gpf+abort+traceassert+corruptcache, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=999, request=serial ---------------------- -Xdump:system: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..1, priority=999, request=exclusive+compact+prepwalk ---------------------- -Xdump:heap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.%seq.phd, range=1..4, priority=500, request=exclusive+compact+prepwalk, opts=PHD ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- -Xdump:java: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..4, priority=400, request=exclusive+preempt ---------------------- -Xdump:snap: events=gpf+abort+traceassert+corruptcache, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..0, priority=300, request=serial ---------------------- -Xdump:snap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..4, priority=300, request=serial ---------------------- -Xdump:jit: events=gpf+abort, label=/home/user/jitdump.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=200, request=serial ----------------------","title":"Default dump agents"},{"location":"xdump/#dump-agent-tokens","text":"You can use tokens to add context to dump file names and directories, and to pass command-line arguments to the tool agent. The tokens available are listed in the following tables: Token Description %Y Year (4 digits) %y Year (2 digits) %m Month (2 digits) %d Day of the month (2 digits) %H Hour (2 digits) %M Minute (2 digits) %S Second (2 digits) %home Java home directory %last Last dump %pid Process ID %seq Dump counter %tick msec counter %uid User name The following tokens are applicable only to z/OS: Token Description %asid Address space ID %job Job name %jobid Job ID %sysname SYSNAME sysparm &DS Dump Section. An incrementing sequence number used for splitting TDUMP files to be less than 2 GB in size. (64-bit only)","title":"Dump agent tokens"},{"location":"xdump/#merging-dump-agents","text":"If you configure more than one dump agent, each responds to events according to its configuration. However, the internal structures representing the dump agent configuration might not match the command line because dump agents are merged for efficiency. Two sets of options can be merged as long as none of the agent settings conflict. This means that the list of installed dump agents and their parameters produced by -Xdump:what might not be grouped in the same way as the original -Xdump options that configured them. For example, you can use the following command to specify that a dump agent creates a Java dump file on class unload: java -Xdump:java:events=unload -Xdump:what This command does not create a new agent, as can be seen in the results from the -Xdump:what option. ... ---------------------- -Xdump:java: events=gpf+user+abort+unload+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- The configuration is merged with the existing Java dump agent for events gpf , user , abort , traceassert , and corruptcache , because none of the specified options for the new unload agent conflict with those for the existing agent. In the previous example, if one of the parameters for the unload agent is changed so that it conflicts with the existing agent, then it cannot be merged. For example, the following command specifies a different priority, forcing a separate agent to be created: java -Xdump:java:events=unload,priority=100 -Xdump:what The results of the -Xdump:what option in the command are as follows. ... ---------------------- -Xdump:java: events=unload, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=100, request=exclusive+preempt ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- To merge dump agents, the request , filter , opts , label , and range parameters must match exactly. If you specify multiple agents that filter on the same string, but keep all other parameters the same, the agents are merged. For example: java -Xdump:none -Xdump:java:events=uncaught,filter=java/lang/NullPointerException -Xdump:java:events=unload,filter=java/lang/NullPointerException -Xdump:what The results of this command are as follows: Registered dump agents ---------------------- -Xdump:java: events=unload+uncaught, filter=java/lang/NullPointerException, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ----------------------","title":"Merging dump agents"},{"location":"xdump/#dump-events","text":"Dump agents are triggered by events occurring during operation of the OpenJ9 VM. Some events can be filtered to improve the relevance of the output. The following table shows the events that are available as dump agent triggers: Event Triggered when.... Filters on.... gpf A General Protection Fault (GPF) occurs. Not applicable user The VM receives the SIGQUIT (Linux, macOS\u00ae, AIX\u00ae, z/OS) or SIGBREAK (Windows\u2122) signal from the operating system. Not applicable user2 The VM receives the SIGUSR2 (Linux, AIX, z/OS, and macOS) signal from the operating system. Not applicable abort The VM receives the SIGABRT signal from the operating system. Not applicable vmstart The virtual machine is started. Not applicable vmstop The virtual machine stops. Exit code; for example, filter=#129..#192#-42#255 load A class is loaded. Class name; for example, filter=java/lang/String unload A class is unloaded. Not applicable throw An exception is thrown explicitly in Java code. Use 'systhrow' for unexpected VM exceptions. Exception class name; for example, filter=java/lang/OutOfMem* catch An exception is caught. Exception class name; for example, filter=*Memory* uncaught A Java exception is not caught by the application. Exception class name; for example, filter=*MemoryError systhrow A Java exception is about to be thrown by the VM. This is different from the 'throw' event because it is only triggered for error conditions detected internally in the VM. Exception class name; for example, filter=java/lang/OutOfMem* . thrstart A new thread is started. Not applicable blocked A thread becomes blocked. Not applicable thrstop A thread stops. Not applicable fullgc A garbage collection cycle is started. Not applicable slow A thread takes longer than 50 ms to respond to an internal VM request. Time taken; for example, filter=#300ms will trigger when a thread takes longer than 300 ms to respond to an internal VM request. allocation A Java object is allocated with a size matching the given filter specification. Object size; a filter must be supplied. For example, filter=#5m will trigger on objects larger than 5 Mb. Ranges are also supported; for example, filter=#256k..512k will trigger on objects 256 - 512 Kb in size. traceassert An internal error occurs in the VM. Not applicable corruptcache The VM finds that the shared classes cache is corrupt. Not applicable excessivegc An excessive amount of time is being spent in the garbage collector. Not applicable Notes: The gpf , traceassert , and abort events cannot trigger a heap dump, prepare the heap (request=prepwalk), or compact the heap (request=compact). The Java dump agent behaves differently when triggered by the user and user2 events. For more information, see request=<requests> . The user2 event is commonly used for taking system dump files with exclusive access without overriding the user event, which is generally left for taking Java dump files for performance investigations. For example: -Xdump:system:events=user2,request=exclusive+prepwalk","title":"Dump events"},{"location":"xdump/#parameters","text":"-Xdump:<agent>:<suboptions> descriptions and examples.","title":"Parameters"},{"location":"xdump/#help","text":"To print usage information for a specific dump agent, use -Xdump:<agent>:help","title":"help"},{"location":"xdump/#noneoptions","text":"Use the -Xdump:none option to add and remove dump agents for various VM events, update default dump settings (such as the dump name), and limit the number of dumps that are produced. The option can be used to affect all agents by specifying -Xdump:none:<options> or specific agents by specifying -Xdump:<agent>:none:<suboptions> where <suboptions> is one of the following control types: events=<event> exec=<command> file=<filename> filter=<filter> opts=<options> priority=<0-999> range=<ranges> request=<requests> Explanations for these suboptions are provided elsewhere in this topic. To remove all default dump agents and any preceding dump options, use -Xdump:none . Use this option so that you can subsequently specify a completely new dump configuration. You can also remove dump agents of a particular type. Here are some examples: To turn off all heap dumps (including default agents) but leave Java dumps enabled, use the following option: -Xdump:java+heap:events=vmstop -Xdump:heap:none To turn off all dump agents for corruptcache events: -Xdump:none:events=corruptcache To turn off just system dumps for corruptcache events: -Xdump:system:none:events=corruptcache To turn off all dumps when a java/lang/OutOfMemory error is thrown: -Xdump:none:events=systhrow,filter=java/lang/OutOfMemoryError To turn off just system dumps when a java/lang/OutOfMemory error is thrown: -Xdump:system:none:events=systhrow,filter=java/lang/OutOfMemoryError If you remove all dump agents by using -Xdump:none with no further -Xdump options, the VM still provides these basic diagnostic outputs: If a user signal (kill -QUIT) is sent to the VM, a brief listing of the Java threads including their stacks, status, and monitor information is written to stderr. If a crash occurs, information about the location of the crash, VM options, and native and Java stack traces are written to stderr. A system dump file is also written to the user's home directory. Note: Removing dump agents and specifying a new dump configuration can require a long set of command-line options. To reuse command-line options, save the new dump configuration in a file and use the -Xoptionsfile option. For more information, see -Xoptionsfile .","title":"none:&lt;options&gt;"},{"location":"xdump/#defaults","text":"Each dump type has default options. To view the default options for a particular dump type, use -Xdump:<agent>:defaults . You can change the default options at run time. For example, you can direct Java dump files into a separate directory for each process, and guarantee unique files by adding a sequence number to the file name using: -Xdump:java:defaults:file=dumps/%pid/javacore-%seq.txt Or, for example, on z/OS, you can add the jobname to the Java dump file name using: -Xdump:java:defaults:file=javacore.%job.%H%M%S.txt This option does not add a Java dump agent; it updates the default settings for Java dump agents. Further Java dump agents will then create dump files using this specification for filenames, unless overridden. Note: Changing the defaults for a dump type will also affect the default agents for that dump type added by the VM during initialization. For example, if you change the default file name for Java dump files, that will change the file name used by the default Java dump agents. However, changing the default range option will not change the range used by the default Java dump agents, because those agents override the range option with specific values.","title":"defaults"},{"location":"xdump/#eventsevent","text":"To trigger a dump as a result of an event, use the -Xdump:<agent>:events=<event> suboption. For a list of possible events, see Dump events . For example, the following command instructs the VM to create a dump agent at startup that produces a Heap dump whenever the vmstop event happens: -Xdump:heap:events=vmstop","title":"events=&lt;event&gt;"},{"location":"xdump/#execcommand","text":"The exec suboption is used by the tool dump agent to specify an external application to start. You can set a specific command to run for a particular dump agent with the following command: -Xdump:<agent>:exec=<command>","title":"exec=&lt;command&gt;"},{"location":"xdump/#filefilename","text":"The file suboption specifies where the diagnostics information is written for the specified dump type. The syntax is -Xdump:<agent>:file=<filename> . For example, to create a Heap dump called my.dmp when a vmstop event is received, use: java -Xdump:heap:events=vmstop,file=my.dmp When producing system dump files on z/OS platforms, use the dsn option instead of the file option. For example: java -Xdump:system:events=vmstop,dsn=%uid.MYDUMP","title":"file=&lt;filename&gt;"},{"location":"xdump/#writing-to-stdoutstderr","text":"Add one of the following options to write a Java dump file to STDOUT or STDERR respectively: -Xdump:java:file=/STDOUT/ -Xdump:java:file=/STDERR/ The keywords /STDOUT/ and /STDERR/ are not case sensitive; /stdout/ and /stderr/ are equivalent. By common convention, you can use a dash ( - ) to refer to STDOUT: -Xdump:java:file=-","title":"Writing to STDOUT/STDERR"},{"location":"xdump/#tokens","text":"You can use tokens to add context to dump file names. For a list of tokens, see Dump agent tokens .","title":"Tokens"},{"location":"xdump/#file-location","text":"The location for the dump file is selected from the following options, in this order: The location specified by the -Xdump:<agent>:file suboption on the command line (if that location includes a path). This location applies to the specified dump agent type only. The location specified by the -Xdump:directory option on the command line. This location applies to all dump agent types. The location specified by the relevant environment variable: Dump agent type z/OS operating systems Other operating systems Java dumps _CEE_DMPTARG IBM_JAVACOREDIR Heap dumps _CEE_DMPTARG IBM_HEAPDUMPDIR System dumps JAVA_DUMP_TDUMP_PATTERN IBM_COREDIR JIT dumps _CEE_DMPTARG IBM_COREDIR Snap traces _CEE_DMPTARG IBM_COREDIR The current working directory of the OpenJ9 VM process. If the directory does not exist, it is created. If the dump file cannot be written to the selected location, the VM reverts to using the following locations, in this order: On Windows platforms only, the system default location is C:\\WINDOWS . The location specified by the TMPDIR environment variable. The C:\\Temp on Windows operating systems, or the /tmp directory on other operating systems. This VM action does not apply to system dumps on z/OS operating systems that use the dsn option. You can prevent the VM reverting to different dump locations by using the -Xdump:nofailover option.","title":"File location"},{"location":"xdump/#filterfilter","text":"Some VM events occur thousands of times during the lifetime of an application. Dump agents can use filters and ranges to avoid producing an excessive number of dump files. The following syntax must be used: -Xdump:<agent>:filter=<filter>","title":"filter=&lt;filter&gt;"},{"location":"xdump/#wildcards","text":"You can use a wildcard in your exception event filter by placing an asterisk only at the beginning or end of the filter. The following command does not work because the second asterisk is not at the end: -Xdump:java:events=throw,filter=*InvalidArgumentException#*.myVirtualMethod To fix the problem, change this filter to the following string: -Xdump:java:events=throw,filter=*InvalidArgumentException#MyApplication.*","title":"Wildcards"},{"location":"xdump/#class-loading-and-exception-events","text":"You can filter class loading ( load ) and exception ( throw , catch , uncaught , systhrow ) events by the name of the class that is being loaded, thrown or caught. For example: -Xdump:java:events=load,filter=java/lang/String -Xdump:java:events=throw,filter=java/lang/ArrayStoreException -Xdump:java:events=catch,filter=java/lang/NullPointerException In addition, you can filter throw , uncaught , and systhrow exception events by the name of the method that throws the exception. The name of the parent class must include the full package name, using the forward slash (/) as a separator. Use a dot (.) to separate the method name from the class name. You can use an asterisk (*) as a wildcard character, to include all methods (optional portions are shown in brackets). For example: -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] For example, to trigger a Java dump when method MyApplication.myMethod() throws a NullPointerException exception, use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.myMethod The stack frame offset allows you to filter on the name of a method that calls the throwing method. This option is useful if the exception is being thrown from a general purpose or utility class. For example, to trigger a Java dump when a method called by MyApplication.main() throws a NullPointerException , use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.main#1 The default value of the stack frame offset is zero. You can filter the catch exception events by Java method name (optional portions are shown in brackets). For example: -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] You can filter throw , uncaught , and systhrowexception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] You can filter the catch exception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] Note: The filters apply to the stacktrace and fire every time the same exception is rethrown, which might result in multiple Java core files.","title":"Class loading and exception events"},{"location":"xdump/#vmstop-event","text":"You can filter the VM shut down event ( vmstop ) by using one or more exit codes: -Xdump:java:events=vmstop,filter=#129..192#-42#255","title":"vmstop event"},{"location":"xdump/#slow-event","text":"You can filter the slow event to change the time threshold from the default of 50 ms: -Xdump:java:events=slow,filter=#300ms","title":"slow event"},{"location":"xdump/#allocation-event","text":"You must filter the allocation event to specify the size of objects that cause a trigger. You can set the filter size from zero up to the maximum value of a 32-bit pointer on 32-bit platforms, or the maximum value of a 64-bit pointer on 64-bit platforms. Setting the lower filter value to zero triggers a dump on all allocations. For example, to trigger dumps on allocations greater than 5 Mb in size, use: -Xdump:stack:events=allocation,filter=#5m To trigger dumps on allocations between 256 Kb and 512 Kb in size, use: -Xdump:stack:events=allocation,filter=#256k..512k","title":"allocation event"},{"location":"xdump/#other-events","text":"If you apply a filter to an event that does not support filtering, the filter is ignored.","title":"Other events"},{"location":"xdump/#msg_filterfilter","text":"You can use the msg_filter suboption to filter on text strings within an exception message, allowing you to reduce the number of dump files produced. This option is supported only for the following events: throw , catch , systhrow , and uncaught . Use the following syntax to include message filtering in your dump output: -Xdump:<agent>:events=<event>,msg_filter=<filter>` where <filter> is a text string from the exceptions that you want to include in the dump file. This suboption supports asterisks as wild cards. The following example filters java/lang/VerifyError exceptions that contain the text string class format : -Xdump:java:events=throw,filter=java/lang/VerifyError,msg_filter=*class format*","title":"msg_filter=&lt;filter&gt;"},{"location":"xdump/#optsoptions","text":"The full syntax is -Xdump:<agent>:opts=<options> . The heap dump agent uses this suboption to specify the type of file to produce. On z/OS, the system dump agent uses this suboption to specify the type of dump to produce.","title":"opts=&lt;options&gt;"},{"location":"xdump/#heap-dumps","text":"You can specify a PHD heap dump file (PHD), a classic text heap dump file (CLASSIC), or both. The default is a PHD file. For example: -Xdump:heap:opts=PHD -Xdump:heap:opts=CLASSIC -Xdump:heap:opts=PHD+CLASSIC","title":"Heap dumps"},{"location":"xdump/#zos-system-dumps","text":"You can specify a system transaction dump (IEATDUMP), an LE dump (CEEDUMP), or both. The default is an IEADUMP file. For example: -Xdump:system:opts=IEATDUMP -Xdump:system:opts=CEEDUMP -Xdump:system:opts=IEATDUMP+CEEDUMP The ceedump agent is the preferred way to specify LE dumps, for example: -Xdump:ceedump:events=gpf","title":"z/OS system dumps"},{"location":"xdump/#tool-dumps","text":"The tool dump agent supports two suboptions that can be specified using the opts subption. You can run the external process asynchronously with opts=ASYNC. You can also specify a delay in milliseconds that produces a pause after starting the command. These two options can be used independently or together. The following examples show different options for starting a new process that runs myProgram : -Xdump:tool:events=vmstop,exec=myProgram Without the opts suboption, the tool dump agent starts the process, and waits for the process to end before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC When opts=ASYNC is specified, the tool dump agent starts the process, and continues without waiting for the new process to end. -Xdump:tool:events=vmstop,exec=myProgram,opts=WAIT1000 This option starts the process, waits for the process to end, and then waits a further 1 second (1000 milliseconds) before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC+WAIT10000 Finally, the last example starts the process and waits for 10 seconds before continuing, whether the process is still running or not. This last form is useful if you are starting a process that does not end, but requires time to initialize properly.","title":"Tool dumps"},{"location":"xdump/#priority0-999","text":"One event can generate multiple dump files. The agents that produce each dump file run sequentially and their order is determined by the priority keyword set for each agent. The full syntax for this command is -Xdump:<agent>:priority=<0-999> . Examination of the output from -Xdump:what shows that a gpf event produces a snap trace, a Java dump file, and a system dump file. In this example, the system dump runs first, with priority 999. The snap dump runs second, with priority 500. The Java dump runs last, with priority 10: -Xdump:heap:events=vmstop,priority=123 The maximum value allowed for priority is 999. Higher priority dump agents are started first. If you do not specifically set a priority, default values are taken based on the dump type. The default priority and the other default values for a particular type of dump, can be displayed by using -Xdump:<type>:defaults . For example: java -Xdump:heap:defaults -version Default -Xdump:heap settings: events=gpf+user filter= file=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.phd range=1..0 priority=500 request=exclusive+compact+prepwalk opts=PHD","title":"priority=&lt;0-999&gt;"},{"location":"xdump/#rangeranges","text":"You can start and stop dump agents on a particular occurrence of a VM event by using the range suboption: -Xdump:<agent>:range=<ranges> For example: -Xdump:java:events=fullgc,range=100..200 Note: range=1..0 against an event means \"on every occurrence\". The VM default dump agents have the range suboption set to 1..0 for all events except systhrow. Most systhrow events with filter=java/lang/OutOfMemoryError have the range suboption set to 1..4, which limits the number of dump files produced on OutOfMemory conditions to a maximum of 4. For more information, see Default dump agents . If you add a new dump agent and do not specify the range, a default of 1..0 is used.","title":"range=&lt;ranges&gt;"},{"location":"xdump/#requestrequests","text":"Use the request suboption to ask the VM to prepare the state before starting the dump agent: -Xdump:<agent>:request=<requests> The available suboptions are listed in the following table: suboption value Description exclusive Request exclusive access to the VM. compact Run garbage collection. This option removes all unreachable objects from the heap before the dump file is generated. prepwalk Prepare the heap for walking. You must also specify exclusive when you use this option. serial Suspend other dumps until this dump is finished. preempt Applies to the Java dump agent and controls whether native threads in the process are forcibly pre-empted in order to collect stack traces. If this option is not specified, only Java stack traces are collected in the Java dump. You can specify more than one request option by using + . For example: -Xdump:heap:request=exclusive+compact+prepwalk The VM exclusive access mechanism allows a VM thread to halt the activity of other VM threads in a controlled way by using internal VM locks. When the request=exclusive option is specified for a dump agent, the VM thread that is producing the dump waits for threads that are running Java code to halt, and for garbage collection operations to complete, before the dump file is written. This process helps ensure that the dump has consistent data. When the dump is complete, the mechanism allows the other threads to resume. By default, only system dumps for OutOfMemoryError exceptions request exclusive access. Other system dump events typically result from a crash. In these cases, exclusive access is not requested because acquiring locks during a crash can be problematic. If system dumps are requested by using the com.ibm.jvm.Dump.SystemDump() API, the default system dump agent settings are used, and exclusive access is not requested. However, if you intend to use the system dump file for Java heap memory analysis, use the following option to request exclusive access when the dump is taken: -Xdump:system:defaults:request=exclusive+compact+prepwalk These settings avoid capturing a dump file with in-flight data during garbage collection. As an alternative, you can use the com.ibm.jvm.Dump.triggerDump() API and specify request=exclusive+compact+prepwalk on the API call. For more information about the com.ibm.jvm.Dump API , see the API reference information. The default setting of the request suboption for Java dump files is request=exclusive+preempt . To change the settings so that Java dump files are produced without pre-empting threads to collect native stack traces, use the following option: -Xdump:java:request=exclusive The Java dump agent ignores the request=exclusive setting if a user event occurs and another event already has exclusive access. In this scenario, the Java dump agent shares the access instead. This behavior is useful because it allows you to obtain a Java dump file during a deadlock situation, when exclusive access is not released. However, the resulting Java dump file, even in other situations, might omit thread stacks and contain inconsistent thread information, as indicated by the following line in the file: 1TIPREPINFO Exclusive VM access not taken: data may not be consistent across javacore sections On operating systems other than Windows, you can enforce exclusive access and obtain a complete dump file by specifying that the user2 event triggers the Java dump agent instead of the user event. For example: -Xdump:java:events=user2,request=exclusive+prepwalk When a user2 event occurs, for example, when you enter kill -USR2 <pid> on the command line, the Java dump agent accepts the request=exclusive setting and waits for exclusive access before creating the Java dump file. For more information about events, see Dump events . In general, the default request options are sufficient.","title":"request=&lt;requests&gt;"},{"location":"xdump/#dump-output","text":"Dump output is written to different files, depending on the type of dump and the platform. File names include a time stamp. Dump type File name (AIX, Linux, macOS, Windows) File name (z/OS) System dump core.%Y%m%d.%H%M%S.%pid.dmp %uid.JVM.TDUMP.%job.D%Y%m%d.T%H%M%S (31-bit), %uid.JVM.%job.D%y%m%d.T%H%M%S.X&DS (64-bit) See Note Java dump javacore.%Y%m%d.%H%M%S.%pid.%seq.txt javacore.%Y%m%d.%H%M%S.%pid.%seq.txt Heap dump heapdump.%Y%m%d.%H%M%S.%pid.phd heapdump.%Y%m%d.T%H%M%S.phd JIT dump jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp LE CEEDUMP - CEEDUMP.%Y%m%d.%H%M%S.%pid See Note The tokens used in this table, for example %Y , are described in Dump agent tokens . Note: On z/OS, the system dump file name can be set with the JAVA_DUMP_TDUMP_PATTERN environment variable. The CEEDUMP, which is not produced by default, is stored in the directory specified by _CEE_DMPTARG or the current directory if _CEE_DMPTARG is not specified.","title":"Dump output"},{"location":"xdump/#system-dumps-on-linux","text":"Linux does not provide an operating system API for generating a system dump from a running process. The VM produces system dumps on Linux by using the fork() API to start an identical process to the parent VM process. The VM then generates a SIGSEGV signal in the child process. The SIGSEGV signal causes Linux to create a system dump for the child process. The parent VM processes and renames the system dump, as required, by the -Xdump options, and might add additional data into the dump file. The system dump file for the child process contains an exact copy of the memory areas used in the parent. The dump viewer can obtain information about the Java threads, classes, and heap from the system dump. However, the dump viewer, and other system dump debuggers show only the single native thread that was running in the child process. You can use the Linux kernel.core_pattern setting to specify the name and path for system dumps. The VM dump agents override the Linux system dump name and path by renaming the dump as specified in the -Xdump options. If the kernel.core_pattern setting specifies a different file system to the -Xdump options, the VM dump agents might be unable to change the file path. In this case the VM renames the dump file, but leaves the file path unchanged. You can find the dump file name and location in the JVMDUMP010I message. Note: If you use the %t specifier in the kernel.core_pattern setting, the VM does not rename the dump. The VM cannot determine the exact time that Linux generated the core file, and therefore cannot be certain which Linux dump file is the correct one to rename.","title":"System dumps on Linux"},{"location":"xdump/#see-also","text":"-Xtrace -Xdisablejavadump","title":"See also"},{"location":"xenableexcessivegc/","text":"\u2011Xenableexcessivegc / \u2011Xdisableexcessivegc Enables or disables the throwing of an OutOfMemory exception if excessive time is spent in the GC. If excessive time is spent in the GC, the option returns null for an allocate request and thus causes an OutOfMemory exception to be thrown. Note: The OutOfMemory exception is thrown only when the heap has been fully expanded and the percentage of application run time that is spent in garbage collection is at least 95%. This percentage is the default value that triggers an excessive GC event. You can control this value with the -Xgc:excessiveGCratio option. Syntax Setting Effect Default -Xenableexcessivegc Enable exception yes -Xdisableexcessivegc Disable exception These options can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"-Xenableexcessivegc"},{"location":"xenableexcessivegc/#xenableexcessivegc-xdisableexcessivegc","text":"Enables or disables the throwing of an OutOfMemory exception if excessive time is spent in the GC. If excessive time is spent in the GC, the option returns null for an allocate request and thus causes an OutOfMemory exception to be thrown. Note: The OutOfMemory exception is thrown only when the heap has been fully expanded and the percentage of application run time that is spent in garbage collection is at least 95%. This percentage is the default value that triggers an excessive GC event. You can control this value with the -Xgc:excessiveGCratio option.","title":"\u2011Xenableexcessivegc / \u2011Xdisableexcessivegc"},{"location":"xenableexcessivegc/#syntax","text":"Setting Effect Default -Xenableexcessivegc Enable exception yes -Xdisableexcessivegc Disable exception These options can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"Syntax"},{"location":"xenableexplicitgc/","text":"\u2011Xenableexplicitgc / \u2011Xdisableexplicitgc Enables and disables garbage collection (GC) when calls are made to System.gc() . Syntax Setting Effect Default -Xenableexplicitgc Enable explicit GC calls yes -Xdisableexplicitgc Disable explicit GC calls Explanation Although it is possible to programmatically trigger a global GC by calling System.gc() , performance can be adversely affected by halting the application before it is really necessary. Use this option to prevent the VM responding to application requests for a GC cycle. The default for all Eclipse OpenJ9\u2122 GC policies is -Xenableexplicitgc except for -Xgcpolicy:nogc , where the default is -Xdisableexplicitgc . These options can be used with all OpenJ9 GC policies.","title":"-Xenableexplicitgc"},{"location":"xenableexplicitgc/#xenableexplicitgc-xdisableexplicitgc","text":"Enables and disables garbage collection (GC) when calls are made to System.gc() .","title":"\u2011Xenableexplicitgc / \u2011Xdisableexplicitgc"},{"location":"xenableexplicitgc/#syntax","text":"Setting Effect Default -Xenableexplicitgc Enable explicit GC calls yes -Xdisableexplicitgc Disable explicit GC calls","title":"Syntax"},{"location":"xenableexplicitgc/#explanation","text":"Although it is possible to programmatically trigger a global GC by calling System.gc() , performance can be adversely affected by halting the application before it is really necessary. Use this option to prevent the VM responding to application requests for a GC cycle. The default for all Eclipse OpenJ9\u2122 GC policies is -Xenableexplicitgc except for -Xgcpolicy:nogc , where the default is -Xdisableexplicitgc . These options can be used with all OpenJ9 GC policies.","title":"Explanation"},{"location":"xenablestringconstantgc/","text":"\u2011Xenablestringconstantgc / \u2011Xdisablestringconstantgc Enables or disables the collection of strings from the string intern table. Syntax Setting Effect Default -Xenablestringconstantgc Enable collection yes -Xdisablestringconstantgc Disable collection This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ).","title":"-Xenablestringconstantgc"},{"location":"xenablestringconstantgc/#xenablestringconstantgc-xdisablestringconstantgc","text":"Enables or disables the collection of strings from the string intern table.","title":"\u2011Xenablestringconstantgc / \u2011Xdisablestringconstantgc"},{"location":"xenablestringconstantgc/#syntax","text":"Setting Effect Default -Xenablestringconstantgc Enable collection yes -Xdisablestringconstantgc Disable collection This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ).","title":"Syntax"},{"location":"xfastresolve/","text":"-Xfastresolve Tune performance by improving the resolution time for classes when the field count exceeds the specified threshold. If profiling tools show significant costs in field resolution, change the threshold until the costs are reduced. If you enable this option, additional memory is used when the threshold is exceeded. Note: The use of this option is deprecated. Syntax -Xfastresolve<n> where <n> is the required threshold.","title":"-Xfastresolve"},{"location":"xfastresolve/#-xfastresolve","text":"Tune performance by improving the resolution time for classes when the field count exceeds the specified threshold. If profiling tools show significant costs in field resolution, change the threshold until the costs are reduced. If you enable this option, additional memory is used when the threshold is exceeded. Note: The use of this option is deprecated.","title":"-Xfastresolve"},{"location":"xfastresolve/#syntax","text":"-Xfastresolve<n> where <n> is the required threshold.","title":"Syntax"},{"location":"xfuture/","text":"-Xfuture As described in the Oracle \"Non-Standard Options\" documentation , this HotSpot option turns on strict class-file format checks. For compatibility, this option is also supported by the Eclipse OpenJ9\u2122 VM. Syntax -Xfuture Explanation Oracle recommend that you use this flag when you are developing new code because stricter checks will become the default in future releases. Note: You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier . Default behavior By default, strict format checks are disabled.","title":"-Xfuture"},{"location":"xfuture/#-xfuture","text":"As described in the Oracle \"Non-Standard Options\" documentation , this HotSpot option turns on strict class-file format checks. For compatibility, this option is also supported by the Eclipse OpenJ9\u2122 VM.","title":"-Xfuture"},{"location":"xfuture/#syntax","text":"-Xfuture","title":"Syntax"},{"location":"xfuture/#explanation","text":"Oracle recommend that you use this flag when you are developing new code because stricter checks will become the default in future releases. Note: You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier .","title":"Explanation"},{"location":"xfuture/#default-behavior","text":"By default, strict format checks are disabled.","title":"Default behavior"},{"location":"xgc/","text":"-Xgc Options that change the behavior of the garbage collector. Syntax -Xgc:<parameter> Parameters Parameter Effect breadthFirstScanOrdering Sets the scan mode to breadth first. classUnloadingKickoffThreshold Sets a threshold to start an early concurrent global garbage collection (GC) cycle due to recent, heavy class loading activity classUnloadingThreshold Sets a threshold to trigger a class unloading operation in a global GC cycle concurrentScavenge Enables a GC mode with less pause times. dnssExpectedTimeRatioMaximum Sets the maximum percentage of time to spend on local GC pauses dnssExpectedTimeRatioMinimum Sets the minimum percentage of time to spend on local GC pauses dynamicBreadthFirstScanOrdering Sets scan mode to dynamic breadth first. excessiveGCratio Sets a boundary value beyond which GC is deemed to be excessive. hierarchicalScanOrdering Sets scan mode to hierarchical. minContractPercent Sets the minimum percentage of the heap that can be contracted at any given time. maxContractPercent Sets the maximum percentage of the heap that can be contracted at any given time. noConcurrentScavenge Disables concurrent scavenge. noSynchronousGCOnOOM Prevents an application stopping to allow GC activity. overrideHiresTimerCheck Overrides GC operating system checks for timer resolution. preferredHeapBase Sets a memory range for the Java\u2122 heap. (AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) scvNoAdaptiveTenure Turns off the adaptive tenure age in the generational concurrent GC policy. scvTenureAge Sets the initial scavenger tenure age in the generational concurrent GC policy. stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required. synchronousGCOnOOM Stops an application to allow GC activity. targetPausetime Sets the target GC pause time for the metronome and balanced GC policies. targetUtilization Sets application utilization for the metronome GC policy. tlhIncrementSize Sets the size of the thread local heap (TLH) increment. tlhInitialSize Sets the initial size of the thread local heap. tlhMaximumSize Sets the maximum size of the thread local heap. verboseFormat Sets the verbose GC format. verbosegcCycleTime Sets the criteria for verbose GC logging. breadthFirstScanOrdering -Xgc:breadthFirstScanOrdering This option sets the scan mode for GC operations that evacuate objects in the heap (scavenge operations ( gencon ) and copy forward operations ( balanced )) to breadth first mode. The scan mode reflects the method for traversing the object graph and is also known as Cheney's algorithm . classUnloadingKickoffThreshold -Xgc:classUnloadingKickoffThreshold=<value> Where <value> is equal to the number of class loaders plus the number of anonymous classes that are loaded since the previous class unloading operation. This option sets a threshold that is used to start an early concurrent global GC cycle due to recent class loading activity. The default value is 80000. This option is applicable to the following GC policies: gencon and optavgpause . classUnloadingThreshold -Xgc:classUnloadingThreshold=<value> Where <value> is equal to the number of class loaders plus the number of anonymous classes that are loaded since the previous class unloading operation. This option sets a threshold that is used to trigger an optional GC class unloading operation in a global GC cycle, irrespective of how the global GC cycle is triggered. The default value is 6. This option is applicable to the following GC policies: gencon , optavgpause , and optthruput . concurrentScavenge (64-bit only) -Xgc:concurrentScavenge This option supports pause-less garbage collection mode when you use the Generational Concurrent ( gencon ) garbage collection policy (the default policy). This option cannot be used with any other GC policies. If you set this option, the VM attempts to reduce GC pause times for response-time sensitive, large-heap applications. This mode can be enabled with hardware-based support (Linux on IBM Z\u00ae and z/OS\u00ae) and software-based support (64-bit: Linux on (x86-64, POWER\u00ae, IBM Z\u00ae) AIX\u00ae, macOS\u00ae, and z/OS). Note: Linux on IBM Z and z/OS This option is supported by all generations of IBM Z hardware to enable pause-less GC with two modes of operation: hardware-based and software-based operations. IBM z13\u2122 and earlier hardware operates in software-based pause-less GC mode; IBM z14\u2122 and later hardware (with supported software) operates in hardware-based mode. Hardware-based pause-less GC is supported on IBM z14 and later hardware running the following software: Operating systems: z/OS V2R3 z/OS V2R2 and APAR OA51643 . RHEL 7.5 (minimum kernel level 4.14) Ubuntu 18.04 (minimum kernel level 4.15) Hypervisors: IBM z/VM 6.4 with APAR VM65987 IBM z/VM 7.1 KVM solutions with QEMU 2.10 or later and minimum host kernel level 4.12 (for example, RHEL 7.5 with kernel level 4.14) If these requirements are not met, the option is ignored. Note: On z/OS, the virtual storage used might exceed the Java maximum heap size. Set the z/OS memory limit, specified by ulimit -M , to a larger value than the maximum heap size. dnssExpectedTimeRatioMaximum -Xgc:dnssExpectedTimeRatioMaximum=<value> Setting Value Default <value> [percentage] 5 for gencon, 5 for balanced The maximum percentage of time spent in local garbage collection pauses. For the gencon policy, this refers to the amount of time spent on the nursery area of the heap (scavenge operation). For the balanced policy, this refers to the amount of time spent on the eden regions of the heap (PGC operation). This option applies only to the gencon and balanced GC policies. dnssExpectedTimeRatioMinimum -Xgc:dnssExpectedTimeRatioMinimum=<value> Setting Value Default <value> [percentage] 1 for gencon, 2 for balanced The minimum percentage of time spent in local garbage collection pauses. For the gencon policy, this refers to the amount of time spent in Scavenge operation (on the nursery area of the heap). For the balanced policy, this refers to the amount of time spent in PGC operations (mostly on the eden and young regions, but also some other regions for de-fragmentation purposes). This option applies only to the gencon and balanced GC policies. dynamicBreadthFirstScanOrdering -Xgc:dynamicBreadthFirstScanOrdering This option sets the scan mode for GC operations that evacuate objects in the heap (scavenge operations ( gencon ) and copy forward operations ( balanced )) to dynamic breadth first mode. This scan mode reflects the method for traversing the object graph and is a variant that adds partial depth first traversal on top of the breadth first scan mode. The aim of dynamic breadth first mode is driven by object field hotness. This mode is the default for the balanced GC policy. excessiveGCratio -Xgc:excessiveGCratio=<value> Setting Value Default <value> [percentage] 95 where <value> is a percentage of total application run time that is spent in GC. The default value is 95, which means that anything over 95% of total application run time spent on GC is deemed excessive. This option can be used only when -Xenableexcessivegc is set (enabled by default). This option can be used with all Eclipse OpenJ9\u2122 GC policies. hierarchicalScanOrdering -Xgc:hierarchicalScanOrdering This option sets the scan mode for the scavenge operation ( gencon GC policy) to hierarchical mode. This mode reflects the method for traversing the object graph and adds partial depth first traversal on top of breadth first scan mode. The aim of hierarchical mode is to minimize object distances. This option is the default for the gencon GC policy. minContractPercent -Xgc:minContractPercent=<n> Setting Value Default <n> [percentage] - The minimum percentage of the heap that can be contracted at any given time. This option can be used with all OpenJ9 GC policies. maxContractPercent -Xgc:maxContractPercent=<n> Setting Value Default <n> [percentage] - The maximum percentage of the heap that can be contracted at any given time. For example, -Xgc:maxContractPercent=20 causes the heap to contract by as much as 20%. This option can be used with all OpenJ9 GC policies. noConcurrentScavenge (64-bit only) -Xgc:noConcurrentScavenge This option disables pause-less garbage collection that you might have enabled with the -Xgc:concurrentScavenge option when using the default gencon GC policy. This option applies only to the gencon GC policy. Note: No concurrent scavenge is the default state, but the noConcurrentScavenge option is useful as it will disable concurrent scavenge even if it has been enabled by a previous option; the right-most option always takes precedence. nosynchronousGCOnOOM -Xgc:nosynchronousGCOnOOM Setting -Xgc:nosynchronousGCOnOOM implies that when heap memory is full your application stops and issues an out-of-memory message. The default is -Xgc:synchronousGCOnOOM . This option applies only to the metronome GC policy. overrideHiresTimerCheck -Xgc:overrideHiresTimerCheck When the VM starts, the GC checks that the operating system can meet the timer resolution requirements for the requested target pause time. Typically, this check correctly identifies operating systems that can deliver adequate time resolution. However, in some cases the operating system provides a more conservative answer than strictly necessary for GC pause time management, which prevents startup. Specifying this parameter causes the GC to ignore the answer returned by the operating system. The VM starts, but GC pause time management remains subject to operating system performance, which might not provide adequate timer resolution. Note: Use this option with caution, and only when you are unable to use a supported operating system. This option applies only to the metronome GC policy. preferredHeapBase (AIX, Linux, macOS, and Windows only) -Xgc:preferredHeapBase=<address> Setting Value Default <value> [hexadecimal] - where, <address> is the base memory address for the heap. Use this option with the -Xcompressedrefs option to allocate the heap you specify with the -Xmx option, in a memory range of your choice. If -Xcompressedrefs is not specified, this option has no effect. In the following example, the heap is located at the 4 GB mark, leaving the lowest 4 GB of address space for use by other processes. -Xgc:preferredHeapBase=0x100000000 If the heap cannot be allocated in a contiguous block at the preferredHeapBase address you specified, an error occurs detailing a Garbage Collection (GC) allocation failure startup. When the preferredHeapBase option is used with the -Xlp option, the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size. This option can be used with all OpenJ9 GC policies. scvNoAdaptiveTenure -Xgc:scvNoAdaptiveTenure Turns off the adaptive tenure age in the gencon GC policy. The initial age that is set is maintained throughout the run time of the VM. See scvTenureAge . This option applies only to the gencon GC policy. scvTenureAge -Xgc:scvTenureAge=<n> Setting Value Default <n> [1 - 14] 10 Sets the initial scavenger tenure age in the gencon GC policy. For more information, see gencon policy (default) . This option applies only to the gencon GC policy. stdGlobalCompactToSatisfyAllocate -Xgc:stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required to satisfy the current allocation failure by removing the dynamic compaction triggers that look at heap occupancy. This option works only with the following GC policies: gencon optthruput optavgpause This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ). synchronousGCOnOOM -Xgc:synchronousGCOnOOM GC cycles can occur when the Java heap runs out of memory. If there is no more free space in the heap, using -Xgc:synchronousGCOnOOM stops your application while GC operations remove unused objects. If free space runs out again, consider decreasing the target utilization to allow GC operations more time to complete. Setting -Xgc:nosynchronousGCOnOOM implies that when heap memory is full your application stops and issues an out-of-memory message. The default is -Xgc:synchronousGCOnOOM . This option applies only to the metronome GC policy. targetPausetime -Xgc:targetPausetime=N Sets the target GC pause time, where N is the time in milliseconds. When this option is specified with the metronome policy, the garbage collector operates with pauses that do not exceed the value specified. If this option is not specified when using the metronome policy, the default pause time target is set to 3 milliseconds. For example, running with -Xgc:targetPausetime=20 causes the garbage collector to pause for no longer than 20 milliseconds during GC operations. When this option is specified with the balanced policy, the GC will use the specified pause time as a soft pause time target. If this option is not specified when using the balanced policy, the default pause time target is set to 200 milliseconds. If the GC pauses are longer than the specified target, then the GC may shrink the amount of eden regions in order to satisfy the target pause time. If the percentage of time spent in PGC pauses is higher than dnssExpectedTimeRatioMaximum and the GC pauses are longer than the specified pause time target, then the target pause time may not be satisfied, in order to balance reaching the target pause time goal and percentage of time in GC pause goal. Note: Specifying an ultra low targetPausetime with the Balanced GC policy may cause the percentage of time spent in GC pauses to noticeably increase. This option applies only to the metronome and balanced GC policies. targetUtilization -Xgc:targetUtilization=N Sets the application utilization to N% ; the garbage collector attempts to use at most (100-N)% of each time interval. Reasonable values are in the range of 50-80%. Applications with low allocation rates might be able to run at 90%. The default is 70%. In the following example, the maximum size of the heap is set to 30 MB. The garbage collector attempts to use 25% of each time interval because the target utilization for the application is set to 75%. java -Xgcpolicy:metronome -Xmx30m -Xgc:targetUtilization=75 Test This option applies only to the metronome GC policy. tlhIncrementSize -Xgc:tlhIncrementSize=<bytes> Sets the increment size of the thread local heap (TLH), which plays a key role in cache allocation. Threads start creating TLHs with a predefined initial size (default 2 KB). On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). Use this option to control the increment size. This option can be used with all OpenJ9 GC policies. tlhInitialSize -Xgc:tlhInitialSize=<bytes> Sets the initial size of the TLH. The default size is 2 KB. This option can be used with all OpenJ9 GC policies. tlhMaximumSize -Xgc:tlhMaximumSize=<bytes> Sets the maximum size of the TLH. The size of the TLH varies from 512 bytes (768 on 64-bit JVMs) to 128 KB, depending on the allocation rate of the thread. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilisation and increase heap fragmentation. Typically, when the maximum TLH size is increased, you should also increase the increment size ( -XtlhIncrementSize ) proportionally, so that active threads can reach the maximum requested TLH size more quickly. This option can be used with all OpenJ9 GC policies. verboseFormat -Xgc:verboseFormat=<format> Setting Value Default <format> default yes deprecated default : The default verbose garbage collection format for OpenJ9. For more information, see Verbose garbage collection logs . deprecated : The verbose garbage collection format available in the IBM J9 VM V2.4 and earlier. This option does not apply to the metronome GC policy. The verbose log format for the metronome GC policy is equivalent to -Xgc:verboseFormat=deprecated . verbosegcCycleTime -Xgc:verbosegcCycleTime=N N is the time in milliseconds that the summary information should be logged. Note: The cycle time does not mean that the summary information is logged precisely at that time, but when the last GC event that meets this time criterion passes. This option applies only to the metronome GC policy.","title":"-Xgc"},{"location":"xgc/#-xgc","text":"Options that change the behavior of the garbage collector.","title":"-Xgc"},{"location":"xgc/#syntax","text":"-Xgc:<parameter>","title":"Syntax"},{"location":"xgc/#parameters","text":"Parameter Effect breadthFirstScanOrdering Sets the scan mode to breadth first. classUnloadingKickoffThreshold Sets a threshold to start an early concurrent global garbage collection (GC) cycle due to recent, heavy class loading activity classUnloadingThreshold Sets a threshold to trigger a class unloading operation in a global GC cycle concurrentScavenge Enables a GC mode with less pause times. dnssExpectedTimeRatioMaximum Sets the maximum percentage of time to spend on local GC pauses dnssExpectedTimeRatioMinimum Sets the minimum percentage of time to spend on local GC pauses dynamicBreadthFirstScanOrdering Sets scan mode to dynamic breadth first. excessiveGCratio Sets a boundary value beyond which GC is deemed to be excessive. hierarchicalScanOrdering Sets scan mode to hierarchical. minContractPercent Sets the minimum percentage of the heap that can be contracted at any given time. maxContractPercent Sets the maximum percentage of the heap that can be contracted at any given time. noConcurrentScavenge Disables concurrent scavenge. noSynchronousGCOnOOM Prevents an application stopping to allow GC activity. overrideHiresTimerCheck Overrides GC operating system checks for timer resolution. preferredHeapBase Sets a memory range for the Java\u2122 heap. (AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) scvNoAdaptiveTenure Turns off the adaptive tenure age in the generational concurrent GC policy. scvTenureAge Sets the initial scavenger tenure age in the generational concurrent GC policy. stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required. synchronousGCOnOOM Stops an application to allow GC activity. targetPausetime Sets the target GC pause time for the metronome and balanced GC policies. targetUtilization Sets application utilization for the metronome GC policy. tlhIncrementSize Sets the size of the thread local heap (TLH) increment. tlhInitialSize Sets the initial size of the thread local heap. tlhMaximumSize Sets the maximum size of the thread local heap. verboseFormat Sets the verbose GC format. verbosegcCycleTime Sets the criteria for verbose GC logging.","title":"Parameters"},{"location":"xgc/#breadthfirstscanordering","text":"-Xgc:breadthFirstScanOrdering This option sets the scan mode for GC operations that evacuate objects in the heap (scavenge operations ( gencon ) and copy forward operations ( balanced )) to breadth first mode. The scan mode reflects the method for traversing the object graph and is also known as Cheney's algorithm .","title":"breadthFirstScanOrdering"},{"location":"xgc/#classunloadingkickoffthreshold","text":"-Xgc:classUnloadingKickoffThreshold=<value> Where <value> is equal to the number of class loaders plus the number of anonymous classes that are loaded since the previous class unloading operation. This option sets a threshold that is used to start an early concurrent global GC cycle due to recent class loading activity. The default value is 80000. This option is applicable to the following GC policies: gencon and optavgpause .","title":"classUnloadingKickoffThreshold"},{"location":"xgc/#classunloadingthreshold","text":"-Xgc:classUnloadingThreshold=<value> Where <value> is equal to the number of class loaders plus the number of anonymous classes that are loaded since the previous class unloading operation. This option sets a threshold that is used to trigger an optional GC class unloading operation in a global GC cycle, irrespective of how the global GC cycle is triggered. The default value is 6. This option is applicable to the following GC policies: gencon , optavgpause , and optthruput .","title":"classUnloadingThreshold"},{"location":"xgc/#concurrentscavenge","text":"(64-bit only) -Xgc:concurrentScavenge This option supports pause-less garbage collection mode when you use the Generational Concurrent ( gencon ) garbage collection policy (the default policy). This option cannot be used with any other GC policies. If you set this option, the VM attempts to reduce GC pause times for response-time sensitive, large-heap applications. This mode can be enabled with hardware-based support (Linux on IBM Z\u00ae and z/OS\u00ae) and software-based support (64-bit: Linux on (x86-64, POWER\u00ae, IBM Z\u00ae) AIX\u00ae, macOS\u00ae, and z/OS). Note: Linux on IBM Z and z/OS This option is supported by all generations of IBM Z hardware to enable pause-less GC with two modes of operation: hardware-based and software-based operations. IBM z13\u2122 and earlier hardware operates in software-based pause-less GC mode; IBM z14\u2122 and later hardware (with supported software) operates in hardware-based mode. Hardware-based pause-less GC is supported on IBM z14 and later hardware running the following software: Operating systems: z/OS V2R3 z/OS V2R2 and APAR OA51643 . RHEL 7.5 (minimum kernel level 4.14) Ubuntu 18.04 (minimum kernel level 4.15) Hypervisors: IBM z/VM 6.4 with APAR VM65987 IBM z/VM 7.1 KVM solutions with QEMU 2.10 or later and minimum host kernel level 4.12 (for example, RHEL 7.5 with kernel level 4.14) If these requirements are not met, the option is ignored. Note: On z/OS, the virtual storage used might exceed the Java maximum heap size. Set the z/OS memory limit, specified by ulimit -M , to a larger value than the maximum heap size.","title":"concurrentScavenge"},{"location":"xgc/#dnssexpectedtimeratiomaximum","text":"-Xgc:dnssExpectedTimeRatioMaximum=<value> Setting Value Default <value> [percentage] 5 for gencon, 5 for balanced The maximum percentage of time spent in local garbage collection pauses. For the gencon policy, this refers to the amount of time spent on the nursery area of the heap (scavenge operation). For the balanced policy, this refers to the amount of time spent on the eden regions of the heap (PGC operation). This option applies only to the gencon and balanced GC policies.","title":"dnssExpectedTimeRatioMaximum"},{"location":"xgc/#dnssexpectedtimeratiominimum","text":"-Xgc:dnssExpectedTimeRatioMinimum=<value> Setting Value Default <value> [percentage] 1 for gencon, 2 for balanced The minimum percentage of time spent in local garbage collection pauses. For the gencon policy, this refers to the amount of time spent in Scavenge operation (on the nursery area of the heap). For the balanced policy, this refers to the amount of time spent in PGC operations (mostly on the eden and young regions, but also some other regions for de-fragmentation purposes). This option applies only to the gencon and balanced GC policies.","title":"dnssExpectedTimeRatioMinimum"},{"location":"xgc/#dynamicbreadthfirstscanordering","text":"-Xgc:dynamicBreadthFirstScanOrdering This option sets the scan mode for GC operations that evacuate objects in the heap (scavenge operations ( gencon ) and copy forward operations ( balanced )) to dynamic breadth first mode. This scan mode reflects the method for traversing the object graph and is a variant that adds partial depth first traversal on top of the breadth first scan mode. The aim of dynamic breadth first mode is driven by object field hotness. This mode is the default for the balanced GC policy.","title":"dynamicBreadthFirstScanOrdering"},{"location":"xgc/#excessivegcratio","text":"-Xgc:excessiveGCratio=<value> Setting Value Default <value> [percentage] 95 where <value> is a percentage of total application run time that is spent in GC. The default value is 95, which means that anything over 95% of total application run time spent on GC is deemed excessive. This option can be used only when -Xenableexcessivegc is set (enabled by default). This option can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"excessiveGCratio"},{"location":"xgc/#hierarchicalscanordering","text":"-Xgc:hierarchicalScanOrdering This option sets the scan mode for the scavenge operation ( gencon GC policy) to hierarchical mode. This mode reflects the method for traversing the object graph and adds partial depth first traversal on top of breadth first scan mode. The aim of hierarchical mode is to minimize object distances. This option is the default for the gencon GC policy.","title":"hierarchicalScanOrdering"},{"location":"xgc/#mincontractpercent","text":"-Xgc:minContractPercent=<n> Setting Value Default <n> [percentage] - The minimum percentage of the heap that can be contracted at any given time. This option can be used with all OpenJ9 GC policies.","title":"minContractPercent"},{"location":"xgc/#maxcontractpercent","text":"-Xgc:maxContractPercent=<n> Setting Value Default <n> [percentage] - The maximum percentage of the heap that can be contracted at any given time. For example, -Xgc:maxContractPercent=20 causes the heap to contract by as much as 20%. This option can be used with all OpenJ9 GC policies.","title":"maxContractPercent"},{"location":"xgc/#noconcurrentscavenge","text":"(64-bit only) -Xgc:noConcurrentScavenge This option disables pause-less garbage collection that you might have enabled with the -Xgc:concurrentScavenge option when using the default gencon GC policy. This option applies only to the gencon GC policy. Note: No concurrent scavenge is the default state, but the noConcurrentScavenge option is useful as it will disable concurrent scavenge even if it has been enabled by a previous option; the right-most option always takes precedence.","title":"noConcurrentScavenge"},{"location":"xgc/#nosynchronousgconoom","text":"-Xgc:nosynchronousGCOnOOM Setting -Xgc:nosynchronousGCOnOOM implies that when heap memory is full your application stops and issues an out-of-memory message. The default is -Xgc:synchronousGCOnOOM . This option applies only to the metronome GC policy.","title":"nosynchronousGCOnOOM"},{"location":"xgc/#overridehirestimercheck","text":"-Xgc:overrideHiresTimerCheck When the VM starts, the GC checks that the operating system can meet the timer resolution requirements for the requested target pause time. Typically, this check correctly identifies operating systems that can deliver adequate time resolution. However, in some cases the operating system provides a more conservative answer than strictly necessary for GC pause time management, which prevents startup. Specifying this parameter causes the GC to ignore the answer returned by the operating system. The VM starts, but GC pause time management remains subject to operating system performance, which might not provide adequate timer resolution. Note: Use this option with caution, and only when you are unable to use a supported operating system. This option applies only to the metronome GC policy.","title":"overrideHiresTimerCheck"},{"location":"xgc/#preferredheapbase","text":"(AIX, Linux, macOS, and Windows only) -Xgc:preferredHeapBase=<address> Setting Value Default <value> [hexadecimal] - where, <address> is the base memory address for the heap. Use this option with the -Xcompressedrefs option to allocate the heap you specify with the -Xmx option, in a memory range of your choice. If -Xcompressedrefs is not specified, this option has no effect. In the following example, the heap is located at the 4 GB mark, leaving the lowest 4 GB of address space for use by other processes. -Xgc:preferredHeapBase=0x100000000 If the heap cannot be allocated in a contiguous block at the preferredHeapBase address you specified, an error occurs detailing a Garbage Collection (GC) allocation failure startup. When the preferredHeapBase option is used with the -Xlp option, the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size. This option can be used with all OpenJ9 GC policies.","title":"preferredHeapBase"},{"location":"xgc/#scvnoadaptivetenure","text":"-Xgc:scvNoAdaptiveTenure Turns off the adaptive tenure age in the gencon GC policy. The initial age that is set is maintained throughout the run time of the VM. See scvTenureAge . This option applies only to the gencon GC policy.","title":"scvNoAdaptiveTenure"},{"location":"xgc/#scvtenureage","text":"-Xgc:scvTenureAge=<n> Setting Value Default <n> [1 - 14] 10 Sets the initial scavenger tenure age in the gencon GC policy. For more information, see gencon policy (default) . This option applies only to the gencon GC policy.","title":"scvTenureAge"},{"location":"xgc/#stdglobalcompacttosatisfyallocate","text":"-Xgc:stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required to satisfy the current allocation failure by removing the dynamic compaction triggers that look at heap occupancy. This option works only with the following GC policies: gencon optthruput optavgpause This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ).","title":"stdGlobalCompactToSatisfyAllocate"},{"location":"xgc/#synchronousgconoom","text":"-Xgc:synchronousGCOnOOM GC cycles can occur when the Java heap runs out of memory. If there is no more free space in the heap, using -Xgc:synchronousGCOnOOM stops your application while GC operations remove unused objects. If free space runs out again, consider decreasing the target utilization to allow GC operations more time to complete. Setting -Xgc:nosynchronousGCOnOOM implies that when heap memory is full your application stops and issues an out-of-memory message. The default is -Xgc:synchronousGCOnOOM . This option applies only to the metronome GC policy.","title":"synchronousGCOnOOM"},{"location":"xgc/#targetpausetime","text":"-Xgc:targetPausetime=N Sets the target GC pause time, where N is the time in milliseconds. When this option is specified with the metronome policy, the garbage collector operates with pauses that do not exceed the value specified. If this option is not specified when using the metronome policy, the default pause time target is set to 3 milliseconds. For example, running with -Xgc:targetPausetime=20 causes the garbage collector to pause for no longer than 20 milliseconds during GC operations. When this option is specified with the balanced policy, the GC will use the specified pause time as a soft pause time target. If this option is not specified when using the balanced policy, the default pause time target is set to 200 milliseconds. If the GC pauses are longer than the specified target, then the GC may shrink the amount of eden regions in order to satisfy the target pause time. If the percentage of time spent in PGC pauses is higher than dnssExpectedTimeRatioMaximum and the GC pauses are longer than the specified pause time target, then the target pause time may not be satisfied, in order to balance reaching the target pause time goal and percentage of time in GC pause goal. Note: Specifying an ultra low targetPausetime with the Balanced GC policy may cause the percentage of time spent in GC pauses to noticeably increase. This option applies only to the metronome and balanced GC policies.","title":"targetPausetime"},{"location":"xgc/#targetutilization","text":"-Xgc:targetUtilization=N Sets the application utilization to N% ; the garbage collector attempts to use at most (100-N)% of each time interval. Reasonable values are in the range of 50-80%. Applications with low allocation rates might be able to run at 90%. The default is 70%. In the following example, the maximum size of the heap is set to 30 MB. The garbage collector attempts to use 25% of each time interval because the target utilization for the application is set to 75%. java -Xgcpolicy:metronome -Xmx30m -Xgc:targetUtilization=75 Test This option applies only to the metronome GC policy.","title":"targetUtilization"},{"location":"xgc/#tlhincrementsize","text":"-Xgc:tlhIncrementSize=<bytes> Sets the increment size of the thread local heap (TLH), which plays a key role in cache allocation. Threads start creating TLHs with a predefined initial size (default 2 KB). On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). Use this option to control the increment size. This option can be used with all OpenJ9 GC policies.","title":"tlhIncrementSize"},{"location":"xgc/#tlhinitialsize","text":"-Xgc:tlhInitialSize=<bytes> Sets the initial size of the TLH. The default size is 2 KB. This option can be used with all OpenJ9 GC policies.","title":"tlhInitialSize"},{"location":"xgc/#tlhmaximumsize","text":"-Xgc:tlhMaximumSize=<bytes> Sets the maximum size of the TLH. The size of the TLH varies from 512 bytes (768 on 64-bit JVMs) to 128 KB, depending on the allocation rate of the thread. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilisation and increase heap fragmentation. Typically, when the maximum TLH size is increased, you should also increase the increment size ( -XtlhIncrementSize ) proportionally, so that active threads can reach the maximum requested TLH size more quickly. This option can be used with all OpenJ9 GC policies.","title":"tlhMaximumSize"},{"location":"xgc/#verboseformat","text":"-Xgc:verboseFormat=<format> Setting Value Default <format> default yes deprecated default : The default verbose garbage collection format for OpenJ9. For more information, see Verbose garbage collection logs . deprecated : The verbose garbage collection format available in the IBM J9 VM V2.4 and earlier. This option does not apply to the metronome GC policy. The verbose log format for the metronome GC policy is equivalent to -Xgc:verboseFormat=deprecated .","title":"verboseFormat"},{"location":"xgc/#verbosegccycletime","text":"-Xgc:verbosegcCycleTime=N N is the time in milliseconds that the summary information should be logged. Note: The cycle time does not mean that the summary information is logged precisely at that time, but when the last GC event that meets this time criterion passes. This option applies only to the metronome GC policy.","title":"verbosegcCycleTime"},{"location":"xgcmaxthreads/","text":"-Xgcmaxthreads Specifies the maximum number of threads that the garbage collector can use for parallel operations. This option behaves in the same way as -Xgcthreads but does not enforce a fixed thread count, which allows the garbage collector to adjust the thread count when used with the -XX:+AdaptiveGCThreading option. Syntax -Xgcmaxthreads<number> Where <number> is the maximum number of threads that can be used for parallel operations.","title":"-Xgcmaxthreads"},{"location":"xgcmaxthreads/#-xgcmaxthreads","text":"Specifies the maximum number of threads that the garbage collector can use for parallel operations. This option behaves in the same way as -Xgcthreads but does not enforce a fixed thread count, which allows the garbage collector to adjust the thread count when used with the -XX:+AdaptiveGCThreading option.","title":"-Xgcmaxthreads"},{"location":"xgcmaxthreads/#syntax","text":"-Xgcmaxthreads<number> Where <number> is the maximum number of threads that can be used for parallel operations.","title":"Syntax"},{"location":"xgcpolicy/","text":"-Xgcpolicy Controls which garbage collection (GC) policy is used for your Java\u2122 application. Syntax -Xgcpolicy:<parameter> Parameters Parameter Default gencon yes balanced (64-bit only) metronome (AIX\u00ae, Linux\u00ae x86 only) optavgpause optthruput nogc For a detailed description of the policies, when to use them, and how they work, see Garbage Collection policies . The following GC policies are available: gencon -Xgcpolicy:gencon The generational concurrent policy (default) requires a heap that is divided into two main areas ( nursery and tenure ) to manage two generation groups ( new and older ). The policy uses a global GC cycle of concurrent mark-sweep operations, optionally followed by compact operations. The policy also uses a partial GC cycle to run scavenge operations on the nursery area. The partial cycle helps reduce the frequency and duration of the global GC cycle. Note that scavenge is a stop-the-world operation, unless -Xgcpolicy:gencon is specified with the -Xgc:concurrentScavenge option. To learn more about this policy, when to use it, and how it works, see Garbage collection: gencon policy . balanced (64-bit only) -Xgcpolicy:balanced The Balanced policy requires a multi-region heap to manage multiple generations of objects. The policy uses a global GC cycle that involves an incremental concurrent mark operation (global mark phase), followed by stop-the-world (STW) sweep operation. The policy also uses a partial GC cycle to run copy forward or mark-compact operations. Regions are individually managed to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The policy tries to avoid global collections by matching object allocation and survival rates. With the balanced policy, the global mark and partial GC cycles interleave. The global STW sweep operation runs within the same GC increment as the first partial GC cycle that follows the global mark phase. The balanced policy also exploits large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER\u2122 platforms only), which might further improve application throughput. Note: If you are using this GC policy in a Docker container that uses the default seccomp Docker profile, you must start the container with --security-opt seccomp=unconfined to exploit NUMA characteristics. These options are not required if you are running in Kubernetes because unconfined is set by default (see Seccomp ). To learn more about this policy, how it works, and when to use it, see Garbage collection: balanced policy . balanced defaults and options The initial heap size is Xmx/1024 , rounded down to the nearest power of 2, where Xmx is the maximum heap size available. You can override this value by specifying the -Xms option on the command line. The following options can also be specified on the command line with -Xgcpolicy:balanced : -Xdisableexcessivegc -Xdisableexplicitgc -Xenableexcessivegc -Xgcthreads<number> -Xgcworkpackets<number> -Xmaxe<size> -Xmaxf<percentage> -Xmaxt<percentage> -Xmca<size> -Xmco<size> -Xmine<size> -Xminf<percentage> -Xmint<percentage> -Xmn<size> -Xmns<size> -Xmnx<size> -Xms<size> -Xmx<size> -Xnuma:none -Xsoftmx<size> -Xsoftrefthreshold<number> -Xverbosegclog[:<file> [, <X>,<Y>]] The behavior of the following options is different when specified with -Xgcpolicy:balanced : -Xcompactgc (default) Forces compaction in each Global GC cycle. -Xnocompactgc Disables internal compaction heuristics in Global GC cycles. -Xcompactexplicitgc (default) Forces compaction in explicit Global GC cycles, such as those invoked by System.gc() . Compaction in implicit Global GC remains optional, triggered by internal heuristics. -Xnocompactexplicitgc Disables compaction in explicit Global GC cycles. Compaction in implicit Global GC remains optional, triggered by internal heuristics. -Xgc:targetPausetime Uses the specified GC pause time as a soft GC pause time target. The following options are ignored when specified with -Xgcpolicy:balanced : -Xconcurrentbackground<number> -Xconcurrentlevel<number> -Xconcurrentslack<size> -Xconmeter:<soa | loa | dynamic> -Xdisablestringconstantgc -Xenablestringconstantgc -Xloa -Xloainitial<percentage> -Xloamaximum<percentage> -Xloaminimum<percentage> -Xmo<size> -Xmoi<size> -Xmos<size> -Xmr<size> -Xmrx<size> -Xnoloa optavgpause -Xgcpolicy:optavgpause The optimize for pause time policy requires a flat heap and uses a global GC cycle to run concurrent mark-sweep operations, optionally followed by compact operations. Pause times are shorter than with optthruput , but application throughput is reduced. The impact on throughput occurs because some garbage collection work is taking place in the context of mutator (application) threads, and because GC frequency is increased. To learn more about this policy and when to use it, see Garbage collection: optavgpause policy . optthruput -Xgcpolicy:optthruput The optimize for throughput policy requires a flat heap and uses a global GC cycle to run mark-sweep operations, optionally followed by compact operations. Because the application stops during a global GC cycle, long pauses can occur. To learn more about this policy, how it works, and when to use it, see Garbage collection: optthruput policy . metronome (AIX, Linux x86 only) -Xgcpolicy:metronome The metronome policy is an incremental, deterministic garbage collector with short pause times. Applications that are dependent on precise response times can take advantage of this technology by avoiding potentially long delays from GC activity. The metronome policy is supported on specific hardware and operating system configurations. To learn more about this policy, how it works, and when to use it, see Garbage collection: metronome policy . metronome options The following options are specific to the metronome GC policy: -Xgc:nosynchronousGCOnOOM -Xgc:overrideHiresTimerCheck -Xgc:synchronousGCOnOOM -Xgc:targetUtilization -Xgc:verbosegcCycleTime -Xgc:targetPausetime option also applies to the metronome GC policy. This option applies only to the metronome and balanced GC policies. nogc -Xgcpolicy:nogc This policy handles only memory allocation and heap expansion, but doesn't reclaim any memory. If the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops. You should be especially careful when using any of the following techniques with nogc because memory is never released under this policy: - Finalization - Direct memory access - Weak, soft, and phantom references To learn when to use this policy, see Garbage collection: nogc policy . This policy can also be enabled with the -XX:+UseNoGC option. Further details are available at JEP 318: Epsilon: A No-Op Garbage Collector .","title":"-Xgcpolicy"},{"location":"xgcpolicy/#-xgcpolicy","text":"Controls which garbage collection (GC) policy is used for your Java\u2122 application.","title":"-Xgcpolicy"},{"location":"xgcpolicy/#syntax","text":"-Xgcpolicy:<parameter>","title":"Syntax"},{"location":"xgcpolicy/#parameters","text":"Parameter Default gencon yes balanced (64-bit only) metronome (AIX\u00ae, Linux\u00ae x86 only) optavgpause optthruput nogc For a detailed description of the policies, when to use them, and how they work, see Garbage Collection policies . The following GC policies are available:","title":"Parameters"},{"location":"xgcpolicy/#gencon","text":"-Xgcpolicy:gencon The generational concurrent policy (default) requires a heap that is divided into two main areas ( nursery and tenure ) to manage two generation groups ( new and older ). The policy uses a global GC cycle of concurrent mark-sweep operations, optionally followed by compact operations. The policy also uses a partial GC cycle to run scavenge operations on the nursery area. The partial cycle helps reduce the frequency and duration of the global GC cycle. Note that scavenge is a stop-the-world operation, unless -Xgcpolicy:gencon is specified with the -Xgc:concurrentScavenge option. To learn more about this policy, when to use it, and how it works, see Garbage collection: gencon policy .","title":"gencon"},{"location":"xgcpolicy/#balanced-64-bit-only","text":"-Xgcpolicy:balanced The Balanced policy requires a multi-region heap to manage multiple generations of objects. The policy uses a global GC cycle that involves an incremental concurrent mark operation (global mark phase), followed by stop-the-world (STW) sweep operation. The policy also uses a partial GC cycle to run copy forward or mark-compact operations. Regions are individually managed to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The policy tries to avoid global collections by matching object allocation and survival rates. With the balanced policy, the global mark and partial GC cycles interleave. The global STW sweep operation runs within the same GC increment as the first partial GC cycle that follows the global mark phase. The balanced policy also exploits large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER\u2122 platforms only), which might further improve application throughput. Note: If you are using this GC policy in a Docker container that uses the default seccomp Docker profile, you must start the container with --security-opt seccomp=unconfined to exploit NUMA characteristics. These options are not required if you are running in Kubernetes because unconfined is set by default (see Seccomp ). To learn more about this policy, how it works, and when to use it, see Garbage collection: balanced policy .","title":"balanced (64-bit only)"},{"location":"xgcpolicy/#balanced-defaults-and-options","text":"The initial heap size is Xmx/1024 , rounded down to the nearest power of 2, where Xmx is the maximum heap size available. You can override this value by specifying the -Xms option on the command line. The following options can also be specified on the command line with -Xgcpolicy:balanced : -Xdisableexcessivegc -Xdisableexplicitgc -Xenableexcessivegc -Xgcthreads<number> -Xgcworkpackets<number> -Xmaxe<size> -Xmaxf<percentage> -Xmaxt<percentage> -Xmca<size> -Xmco<size> -Xmine<size> -Xminf<percentage> -Xmint<percentage> -Xmn<size> -Xmns<size> -Xmnx<size> -Xms<size> -Xmx<size> -Xnuma:none -Xsoftmx<size> -Xsoftrefthreshold<number> -Xverbosegclog[:<file> [, <X>,<Y>]] The behavior of the following options is different when specified with -Xgcpolicy:balanced : -Xcompactgc (default) Forces compaction in each Global GC cycle. -Xnocompactgc Disables internal compaction heuristics in Global GC cycles. -Xcompactexplicitgc (default) Forces compaction in explicit Global GC cycles, such as those invoked by System.gc() . Compaction in implicit Global GC remains optional, triggered by internal heuristics. -Xnocompactexplicitgc Disables compaction in explicit Global GC cycles. Compaction in implicit Global GC remains optional, triggered by internal heuristics. -Xgc:targetPausetime Uses the specified GC pause time as a soft GC pause time target. The following options are ignored when specified with -Xgcpolicy:balanced : -Xconcurrentbackground<number> -Xconcurrentlevel<number> -Xconcurrentslack<size> -Xconmeter:<soa | loa | dynamic> -Xdisablestringconstantgc -Xenablestringconstantgc -Xloa -Xloainitial<percentage> -Xloamaximum<percentage> -Xloaminimum<percentage> -Xmo<size> -Xmoi<size> -Xmos<size> -Xmr<size> -Xmrx<size> -Xnoloa","title":"balanced defaults and options"},{"location":"xgcpolicy/#optavgpause","text":"-Xgcpolicy:optavgpause The optimize for pause time policy requires a flat heap and uses a global GC cycle to run concurrent mark-sweep operations, optionally followed by compact operations. Pause times are shorter than with optthruput , but application throughput is reduced. The impact on throughput occurs because some garbage collection work is taking place in the context of mutator (application) threads, and because GC frequency is increased. To learn more about this policy and when to use it, see Garbage collection: optavgpause policy .","title":"optavgpause"},{"location":"xgcpolicy/#optthruput","text":"-Xgcpolicy:optthruput The optimize for throughput policy requires a flat heap and uses a global GC cycle to run mark-sweep operations, optionally followed by compact operations. Because the application stops during a global GC cycle, long pauses can occur. To learn more about this policy, how it works, and when to use it, see Garbage collection: optthruput policy .","title":"optthruput"},{"location":"xgcpolicy/#metronome-aix-linux-x86-only","text":"-Xgcpolicy:metronome The metronome policy is an incremental, deterministic garbage collector with short pause times. Applications that are dependent on precise response times can take advantage of this technology by avoiding potentially long delays from GC activity. The metronome policy is supported on specific hardware and operating system configurations. To learn more about this policy, how it works, and when to use it, see Garbage collection: metronome policy .","title":"metronome (AIX, Linux x86 only)"},{"location":"xgcpolicy/#metronome-options","text":"The following options are specific to the metronome GC policy: -Xgc:nosynchronousGCOnOOM -Xgc:overrideHiresTimerCheck -Xgc:synchronousGCOnOOM -Xgc:targetUtilization -Xgc:verbosegcCycleTime -Xgc:targetPausetime option also applies to the metronome GC policy. This option applies only to the metronome and balanced GC policies.","title":"metronome options"},{"location":"xgcpolicy/#nogc","text":"-Xgcpolicy:nogc This policy handles only memory allocation and heap expansion, but doesn't reclaim any memory. If the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops. You should be especially careful when using any of the following techniques with nogc because memory is never released under this policy: - Finalization - Direct memory access - Weak, soft, and phantom references To learn when to use this policy, see Garbage collection: nogc policy . This policy can also be enabled with the -XX:+UseNoGC option. Further details are available at JEP 318: Epsilon: A No-Op Garbage Collector .","title":"nogc"},{"location":"xgcsplitheap/","text":"-Xgc:splitheap (Windows\u2122 32-bit only) By default, the VM uses a contiguous Java\u2122 heap to store Java objects. However, on Windows 32-bit systems, there are restrictions in the 32-bit memory space that prevents a process accessing more than 2GB of memory, even if there is more memory available. To increase the maximum allocatable heap size, Eclipse OpenJ9\u2122 can split the heap, allowing memory use up to the 4GB limit. Restrictions: A split heap forces the garbage collector to use the gencon policy and allocates the new and old areas of the generational Java heap in separate areas of memory. Resizing of the new and old memory areas is disabled. This option can be used only with Java SE version 8 runtime environments. This option is deprecated in Version 8 and will be removed from future versions. Syntax -Xgc:splitheap Explanation Use -Xgc:splitheap for applications that must run on the 32-bit VM because of 32-bit JNI libraries, a 32-bit operating system, or 32-bit hardware, but need large Java heaps. By using a larger heap, you can allocate more objects before incurring a garbage collection (GC) and you can increase the number of live objects that you can use before an OutOfMemoryError exception occurs. With a split heap, the old area is committed to its maximum size (set with -Xmox ) in a lower region of memory and the new area is committed to its maximum size (set with -Xmnx ) in a higher region of memory. This option is not recommended if your application works in the any of the following ways: Performs poorly under the gencon GC policy. Loads a very large number of classes. Uses large amounts of native system memory in JNI libraries; the increased size Java heap might reserve too much of the application's address space.","title":"-Xgc:splitheap"},{"location":"xgcsplitheap/#-xgcsplitheap","text":"(Windows\u2122 32-bit only) By default, the VM uses a contiguous Java\u2122 heap to store Java objects. However, on Windows 32-bit systems, there are restrictions in the 32-bit memory space that prevents a process accessing more than 2GB of memory, even if there is more memory available. To increase the maximum allocatable heap size, Eclipse OpenJ9\u2122 can split the heap, allowing memory use up to the 4GB limit. Restrictions: A split heap forces the garbage collector to use the gencon policy and allocates the new and old areas of the generational Java heap in separate areas of memory. Resizing of the new and old memory areas is disabled. This option can be used only with Java SE version 8 runtime environments. This option is deprecated in Version 8 and will be removed from future versions.","title":"-Xgc:splitheap"},{"location":"xgcsplitheap/#syntax","text":"-Xgc:splitheap","title":"Syntax"},{"location":"xgcsplitheap/#explanation","text":"Use -Xgc:splitheap for applications that must run on the 32-bit VM because of 32-bit JNI libraries, a 32-bit operating system, or 32-bit hardware, but need large Java heaps. By using a larger heap, you can allocate more objects before incurring a garbage collection (GC) and you can increase the number of live objects that you can use before an OutOfMemoryError exception occurs. With a split heap, the old area is committed to its maximum size (set with -Xmox ) in a lower region of memory and the new area is committed to its maximum size (set with -Xmnx ) in a higher region of memory. This option is not recommended if your application works in the any of the following ways: Performs poorly under the gencon GC policy. Loads a very large number of classes. Uses large amounts of native system memory in JNI libraries; the increased size Java heap might reserve too much of the application's address space.","title":"Explanation"},{"location":"xgcthreads/","text":"-Xgcthreads Sets the number of threads that the garbage collector uses for parallel operations. Notes: This option enforces a fixed thread count and cannot be used with the -XX:+AdaptiveGCThreading option, which enables the garbage collector to adjust the number of parallel threads based on heuristics. If you want to use -XX:+AdaptiveGCThreading , use -Xgcmaxthreads instead of -Xgcthreads . Syntax -Xgcthreads<number> Explanation The total number of GC threads is composed of one application thread with the remainder being dedicated GC threads. By default, the number is set to n-1 , where n is the number of reported CPUs, up to a maximum of 64. Where SMT or hyperthreading is in place, the number of reported CPUs is larger than the number of physical CPUs. Likewise, where virtualization is in place, the number of reported CPUs is the number of virtual CPUs assigned to the operating system. To set it to a different number, for example 4, use -Xgcthreads4 . The minimum valid value is 1, which disables parallel operations, at the cost of performance. No advantage is gained if you increase the number of threads to more than the default setting. On systems running multiple VMs or in LPAR environments where multiple VMs can share the same physical CPUs, you might want to restrict the number of GC threads used by each VM. The restriction helps prevent the total number of parallel operation GC threads for all VMs exceeding the number of physical CPUs present, when multiple VMs perform garbage collection at the same time. This option is directly mapped to the HotSpot option -XX:ParallelGCThreads and can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"-Xgcthreads"},{"location":"xgcthreads/#-xgcthreads","text":"Sets the number of threads that the garbage collector uses for parallel operations. Notes: This option enforces a fixed thread count and cannot be used with the -XX:+AdaptiveGCThreading option, which enables the garbage collector to adjust the number of parallel threads based on heuristics. If you want to use -XX:+AdaptiveGCThreading , use -Xgcmaxthreads instead of -Xgcthreads .","title":"-Xgcthreads"},{"location":"xgcthreads/#syntax","text":"-Xgcthreads<number>","title":"Syntax"},{"location":"xgcthreads/#explanation","text":"The total number of GC threads is composed of one application thread with the remainder being dedicated GC threads. By default, the number is set to n-1 , where n is the number of reported CPUs, up to a maximum of 64. Where SMT or hyperthreading is in place, the number of reported CPUs is larger than the number of physical CPUs. Likewise, where virtualization is in place, the number of reported CPUs is the number of virtual CPUs assigned to the operating system. To set it to a different number, for example 4, use -Xgcthreads4 . The minimum valid value is 1, which disables parallel operations, at the cost of performance. No advantage is gained if you increase the number of threads to more than the default setting. On systems running multiple VMs or in LPAR environments where multiple VMs can share the same physical CPUs, you might want to restrict the number of GC threads used by each VM. The restriction helps prevent the total number of parallel operation GC threads for all VMs exceeding the number of physical CPUs present, when multiple VMs perform garbage collection at the same time. This option is directly mapped to the HotSpot option -XX:ParallelGCThreads and can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"Explanation"},{"location":"xgcworkpackets/","text":"-Xgcworkpackets Specifies the total number of work packets available in the global collector. Syntax -Xgcworkpackets<number> Explanation If you do not specify a value, the collector allocates a number of packets based on the maximum heap size. This option can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"-Xgcworkpackets"},{"location":"xgcworkpackets/#-xgcworkpackets","text":"Specifies the total number of work packets available in the global collector.","title":"-Xgcworkpackets"},{"location":"xgcworkpackets/#syntax","text":"-Xgcworkpackets<number>","title":"Syntax"},{"location":"xgcworkpackets/#explanation","text":"If you do not specify a value, the collector allocates a number of packets based on the maximum heap size. This option can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"Explanation"},{"location":"xint/","text":"-Xint As described in the Oracle \"Non-Standard Options\" documentation , this VM option runs an application in interpreted-only mode. For compatibility, this option is also supported by the Eclipse OpenJ9\u2122 VM. Syntax -Xint Explanation If you use this option, the OpenJ9 VM uses only the interpreter, disabling the OpenJ9 just-in-time (JIT) and ahead-of-time (AOT) compilers. By default, both these compilers are enabled, although the AOT compiler is not used by the VM unless shared classes are also enabled.","title":"-Xint"},{"location":"xint/#-xint","text":"As described in the Oracle \"Non-Standard Options\" documentation , this VM option runs an application in interpreted-only mode. For compatibility, this option is also supported by the Eclipse OpenJ9\u2122 VM.","title":"-Xint"},{"location":"xint/#syntax","text":"-Xint","title":"Syntax"},{"location":"xint/#explanation","text":"If you use this option, the OpenJ9 VM uses only the interpreter, disabling the OpenJ9 just-in-time (JIT) and ahead-of-time (AOT) compilers. By default, both these compilers are enabled, although the AOT compiler is not used by the VM unless shared classes are also enabled.","title":"Explanation"},{"location":"xjit/","text":"-Xjit / -Xnojit Use this option to control the behavior of the JIT compiler. Specifying -Xjit with no parameters has no effect because the JIT compiler is enabled by default. Specifying -Xnojit turns off the JIT compiler but does not affect the AOT compiler. Specify the -Xjit option only once. If you specify this option multiple times, only the last option takes effect. You can specify multiple parameters for the -Xjit option by using commas to separate the parameters. For example: -Xjit:enableGPU,exclude={ilog/rules/engine/sequential/generated/*} Parameters such as exclude are additive so you can specify them multiple times within the same -Xjit option. Syntax Setting Action Default -Xjit Enable JIT yes -Xjit[:<parameter>=<value>{,<parameter>=<value>}] Enable JIT with options -Xnojit Disable JIT Parameters These parameters can be used to modify the behavior of -Xjit : Parameter Effect count Specifies the number of times a method is called before it is compiled. disableRMODE64 Allows the JIT to allocate executable code caches above the 2 GB memory bar. enableGPU Allows the JIT to offload certain processing tasks to a graphics processing unit (GPU) exclude Excludes the specified method from compilation. limit Includes the specified method in compilation. limitFile Compile methods that are listed in the limit file. optlevel Forces the JIT compiler to compile all methods at a specific optimization level. verbose Reports information about the JIT and AOT compiler configuration and method compilation. vlog Sends verbose output to a file. perfTool Facilitates JIT-compiled code symbol resolution when profiling the VM on Linux. count -Xjit:count=<n> Specifies the number of times, <n> , a method is called before it is compiled. For example, setting count=0 forces the JIT compiler to compile everything on first execution, which is useful for problem determination. disableRMODE64 (z/OS\u00ae only) -Xjit:disableRMODE64 From z/OS V2R3, residency mode for 64-bit applications (RMODE64) is enabled by default. This feature allows the JIT to allocate executable code caches above the 2 GB memory bar, which is the default behavior. Use this option to turn off this JIT behavior. enableGPU (Windows (x86-64) or Linux (x86-64 and IBM POWER LE)) -Xjit:enableGPU Enables the JIT compiler to offload certain processing tasks to a graphics processing unit (GPU). The JIT determines which functions to offload based on performance heuristics. Systems must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0. To troubleshoot operations between the JIT compiler and the GPU, use -Xjit:enableGPU={verbose} , which provides output showing the processing tasks that are offloaded and their status. To send this output to a file ( output.txt ), run -Xjit:enableGPU={verbose},vlog=output.txt when you start your application. exclude -Xjit:exclude={<method>} Excludes the specified method from compilation. <method_name> is the method or methods that are to be excluded; the wildcard * may be used. Specify as much of the full package, class and method as necessary. For example, -Xjit:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xjit:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xjit:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:exclude , AOT compilation is also prevented and the methods specified are always interpreted. limit -Xjit:limit={<method_name>} Only the Java\u2122 methods specified are included when code is compiled or loaded from the shared classes cache. <method_name> is the method or methods that are to be included (the wildcard * can be used, see -Xjit:exclude for details). Note: limit has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limit , AOT compilation is also restricted to those methods specified; other methods are always interpreted. limitFile -Xjit:limitFile=(<vlog_filename>, <m>, <n>) Compile only the methods that are listed on lines <m> to <n> in the specified limit file, where the limit file is a verbose log that you generated with the -Xjit:verbose,vlog=<vlog_filename> option. Methods that are not listed in the limit file and methods that are listed on lines outside the range are not compiled. Note: limitFile has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limitFile , AOT compilation is also restricted to those methods specified; other methods are always interpreted. optlevel -Xjit:optlevel=[noOpt|cold|warm|hot|veryHot|scorching] Forces the JIT compiler to compile all methods at a specific optimization level. Specifying optlevel might have an unexpected effect on performance, including reduced overall performance. verbose -Xjit:verbose Generates a JIT verbose log. The log provides a summary of which methods were compiled by the JIT and some of the compilation heuristic decisions that were taken while the JIT operates inside the Eclipse OpenJ9\u2122 VM. -Xjit:verbose={compileStart} Prints a line when the JIT is about to start compiling a method. -Xjit:verbose={compileEnd} Prints a line when the JIT stops compiling a method. -Xjit:verbose={compilePerformance} Adds the values time (time taken to do the compilation) and mem (the amount of memory that was allocated during the compilation) into each line. This option includes the compileStart and compileEnd suboptions by default. -Xjit:verbose={disableInlining} Turns off inlining operations. -Xjit:verbose={inlining} Shows the methods that are inlined. Note: Suboptions can be chained together by using a pipe ( | ) symbol. When used, you must enclose the full option name in single quotation marks ( ' ) to avoid the shell misinterpreting these characters as pipe commands. For example: java '-Xjit:verbose={compileStart|compileEnd|inlining}' -version vlog -Xjit:vlog=<vlog_filename> Sends verbose output to a file, of the format <vlog_filename>.<date>.<time>.<JVM_process_ID> , which is created in your current directory. Running the command multiple times produces multiple distinct versions of this file. If you do not specify this parameter, the output is sent to the standard error output stream (STDERR). This type of log file can be used with the limitFile suboption to target the compilation of specific methods. perfTool -Xjit:perfTool generates a /tmp/perf-<pid>.map file for the JIT-compiled code. This file is used by the Linux\u00ae system profiler, perf , to map the samples in the JIT-compiled code to the corresponding Java method names for profiling the VM. For more information, see -XX:[+|-]PerfTool . Examples Generating a JIT verbose log The following example requests a JIT verbose log of the java -version command: java -Xjit:verbose,vlog=vlogfile -version Analyzing JIT performance The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the following information to compilation entry: the amount of time taken to do the compilation. the amount of memory that was allocated during the compilation. Analyzing inlining operations The following example generates output that contains performance data and inlining operations. The suboptions count and -XcompilationThreads1 are used only to simplify the output. These options are not recommended for production because performance will be affected. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version See also Diagnosing a JIT or AOT problem -Xaot","title":"-Xnojit"},{"location":"xjit/#-xjit-xnojit","text":"Use this option to control the behavior of the JIT compiler. Specifying -Xjit with no parameters has no effect because the JIT compiler is enabled by default. Specifying -Xnojit turns off the JIT compiler but does not affect the AOT compiler. Specify the -Xjit option only once. If you specify this option multiple times, only the last option takes effect. You can specify multiple parameters for the -Xjit option by using commas to separate the parameters. For example: -Xjit:enableGPU,exclude={ilog/rules/engine/sequential/generated/*} Parameters such as exclude are additive so you can specify them multiple times within the same -Xjit option.","title":"-Xjit / -Xnojit"},{"location":"xjit/#syntax","text":"Setting Action Default -Xjit Enable JIT yes -Xjit[:<parameter>=<value>{,<parameter>=<value>}] Enable JIT with options -Xnojit Disable JIT","title":"Syntax"},{"location":"xjit/#parameters","text":"These parameters can be used to modify the behavior of -Xjit : Parameter Effect count Specifies the number of times a method is called before it is compiled. disableRMODE64 Allows the JIT to allocate executable code caches above the 2 GB memory bar. enableGPU Allows the JIT to offload certain processing tasks to a graphics processing unit (GPU) exclude Excludes the specified method from compilation. limit Includes the specified method in compilation. limitFile Compile methods that are listed in the limit file. optlevel Forces the JIT compiler to compile all methods at a specific optimization level. verbose Reports information about the JIT and AOT compiler configuration and method compilation. vlog Sends verbose output to a file. perfTool Facilitates JIT-compiled code symbol resolution when profiling the VM on Linux.","title":"Parameters"},{"location":"xjit/#count","text":"-Xjit:count=<n> Specifies the number of times, <n> , a method is called before it is compiled. For example, setting count=0 forces the JIT compiler to compile everything on first execution, which is useful for problem determination.","title":"count"},{"location":"xjit/#disablermode64","text":"(z/OS\u00ae only) -Xjit:disableRMODE64 From z/OS V2R3, residency mode for 64-bit applications (RMODE64) is enabled by default. This feature allows the JIT to allocate executable code caches above the 2 GB memory bar, which is the default behavior. Use this option to turn off this JIT behavior.","title":"disableRMODE64"},{"location":"xjit/#enablegpu","text":"(Windows (x86-64) or Linux (x86-64 and IBM POWER LE)) -Xjit:enableGPU Enables the JIT compiler to offload certain processing tasks to a graphics processing unit (GPU). The JIT determines which functions to offload based on performance heuristics. Systems must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0. To troubleshoot operations between the JIT compiler and the GPU, use -Xjit:enableGPU={verbose} , which provides output showing the processing tasks that are offloaded and their status. To send this output to a file ( output.txt ), run -Xjit:enableGPU={verbose},vlog=output.txt when you start your application.","title":"enableGPU"},{"location":"xjit/#exclude","text":"-Xjit:exclude={<method>} Excludes the specified method from compilation. <method_name> is the method or methods that are to be excluded; the wildcard * may be used. Specify as much of the full package, class and method as necessary. For example, -Xjit:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xjit:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xjit:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:exclude , AOT compilation is also prevented and the methods specified are always interpreted.","title":"exclude"},{"location":"xjit/#limit","text":"-Xjit:limit={<method_name>} Only the Java\u2122 methods specified are included when code is compiled or loaded from the shared classes cache. <method_name> is the method or methods that are to be included (the wildcard * can be used, see -Xjit:exclude for details). Note: limit has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limit , AOT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limit"},{"location":"xjit/#limitfile","text":"-Xjit:limitFile=(<vlog_filename>, <m>, <n>) Compile only the methods that are listed on lines <m> to <n> in the specified limit file, where the limit file is a verbose log that you generated with the -Xjit:verbose,vlog=<vlog_filename> option. Methods that are not listed in the limit file and methods that are listed on lines outside the range are not compiled. Note: limitFile has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limitFile , AOT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limitFile"},{"location":"xjit/#optlevel","text":"-Xjit:optlevel=[noOpt|cold|warm|hot|veryHot|scorching] Forces the JIT compiler to compile all methods at a specific optimization level. Specifying optlevel might have an unexpected effect on performance, including reduced overall performance.","title":"optlevel"},{"location":"xjit/#verbose","text":"-Xjit:verbose Generates a JIT verbose log. The log provides a summary of which methods were compiled by the JIT and some of the compilation heuristic decisions that were taken while the JIT operates inside the Eclipse OpenJ9\u2122 VM. -Xjit:verbose={compileStart} Prints a line when the JIT is about to start compiling a method. -Xjit:verbose={compileEnd} Prints a line when the JIT stops compiling a method. -Xjit:verbose={compilePerformance} Adds the values time (time taken to do the compilation) and mem (the amount of memory that was allocated during the compilation) into each line. This option includes the compileStart and compileEnd suboptions by default. -Xjit:verbose={disableInlining} Turns off inlining operations. -Xjit:verbose={inlining} Shows the methods that are inlined. Note: Suboptions can be chained together by using a pipe ( | ) symbol. When used, you must enclose the full option name in single quotation marks ( ' ) to avoid the shell misinterpreting these characters as pipe commands. For example: java '-Xjit:verbose={compileStart|compileEnd|inlining}' -version","title":"verbose"},{"location":"xjit/#vlog","text":"-Xjit:vlog=<vlog_filename> Sends verbose output to a file, of the format <vlog_filename>.<date>.<time>.<JVM_process_ID> , which is created in your current directory. Running the command multiple times produces multiple distinct versions of this file. If you do not specify this parameter, the output is sent to the standard error output stream (STDERR). This type of log file can be used with the limitFile suboption to target the compilation of specific methods.","title":"vlog"},{"location":"xjit/#perftool","text":"-Xjit:perfTool generates a /tmp/perf-<pid>.map file for the JIT-compiled code. This file is used by the Linux\u00ae system profiler, perf , to map the samples in the JIT-compiled code to the corresponding Java method names for profiling the VM. For more information, see -XX:[+|-]PerfTool .","title":"perfTool"},{"location":"xjit/#examples","text":"","title":"Examples"},{"location":"xjit/#generating-a-jit-verbose-log","text":"The following example requests a JIT verbose log of the java -version command: java -Xjit:verbose,vlog=vlogfile -version","title":"Generating a JIT verbose log"},{"location":"xjit/#analyzing-jit-performance","text":"The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the following information to compilation entry: the amount of time taken to do the compilation. the amount of memory that was allocated during the compilation.","title":"Analyzing JIT performance"},{"location":"xjit/#analyzing-inlining-operations","text":"The following example generates output that contains performance data and inlining operations. The suboptions count and -XcompilationThreads1 are used only to simplify the output. These options are not recommended for production because performance will be affected. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version","title":"Analyzing inlining operations"},{"location":"xjit/#see-also","text":"Diagnosing a JIT or AOT problem -Xaot","title":"See also"},{"location":"xjni/","text":"-Xjni Sets JNI options. Syntax -Xjni:<parameter> Parameters arrayCacheMax -Xjni:arrayCacheMax=<size in bytes> -Xjni:arrayCacheMax=unlimited Sets the maximum size of the array cache. The default size is 128 KB ( -Xjni:arrayCacheMax=131072 ).","title":"-Xjni"},{"location":"xjni/#-xjni","text":"Sets JNI options.","title":"-Xjni"},{"location":"xjni/#syntax","text":"-Xjni:<parameter>","title":"Syntax"},{"location":"xjni/#parameters","text":"","title":"Parameters"},{"location":"xjni/#arraycachemax","text":"-Xjni:arrayCacheMax=<size in bytes> -Xjni:arrayCacheMax=unlimited Sets the maximum size of the array cache. The default size is 128 KB ( -Xjni:arrayCacheMax=131072 ).","title":"arrayCacheMax"},{"location":"xlinenumbers/","text":"-Xlinenumbers / -Xnolinenumbers Enables or disables line numbers in stack traces for debugging. Syntax Setting Effect Default -Xlinenumbers Enable yes -Xnolinenumbers Disable Explanation If you start the Eclipse OpenJ9\u2122 VM with -Xnolinenumbers when creating a new shared classes cache, the Class Debug Area is not created. The option -Xnolinenumbers advises the VM not to load any class debug information, so there is no need for this region. If -Xscdmx is also used on the command line to specify a non zero debug area size, then a debug area is created despite the use of -Xnolinenumbers .","title":"-Xnolinenumbers"},{"location":"xlinenumbers/#-xlinenumbers-xnolinenumbers","text":"Enables or disables line numbers in stack traces for debugging.","title":"-Xlinenumbers / -Xnolinenumbers"},{"location":"xlinenumbers/#syntax","text":"Setting Effect Default -Xlinenumbers Enable yes -Xnolinenumbers Disable","title":"Syntax"},{"location":"xlinenumbers/#explanation","text":"If you start the Eclipse OpenJ9\u2122 VM with -Xnolinenumbers when creating a new shared classes cache, the Class Debug Area is not created. The option -Xnolinenumbers advises the VM not to load any class debug information, so there is no need for this region. If -Xscdmx is also used on the command line to specify a non zero debug area size, then a debug area is created despite the use of -Xnolinenumbers .","title":"Explanation"},{"location":"xloa/","text":"-Xloa / -Xnoloa This option enables or prevents the allocation of a large object area (LOA) during garbage collection (GC). Syntax Setting Effect Default -Xloa Enable LOA yes (see Default behavior) -Xnoloa Disable LOA Default behavior By default, allocations are made in the small object area (SOA). If there is no room in the SOA, and an object is larger than 64KB, the object is allocated in the LOA. If the LOA is not used, it is shrunk to zero after a few collections. You can disable it explicitly by specifying the -Xnoloa option. Explanation The LOA is an area of the tenure area of the heap set used solely to satisfy allocations for large objects. The LOA is used when the allocation request cannot be satisfied in the main area (the SOA of the tenure heap. As objects are allocated and freed, the heap can become fragmented in such a way that allocation can be met only by time-consuming compactions. This problem is more pronounced if an application allocates large objects. In an attempt to alleviate this problem, the LOA is allocated. A large object in this context is considered to be any object 64 KB or greater in size. Allocations for new TLH objects are not considered to be large objects. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ), which do not use an LOA. Any LOA options passed on the command line are ignored. These policies address the issues that are solved by an LOA by reorganizing object layout with the VM to reduce heap fragmentation and compaction requirements. See also -Xloainitial / -Xloaminimum / -Xloamaximum","title":"-Xnoloa"},{"location":"xloa/#-xloa-xnoloa","text":"This option enables or prevents the allocation of a large object area (LOA) during garbage collection (GC).","title":"-Xloa / -Xnoloa"},{"location":"xloa/#syntax","text":"Setting Effect Default -Xloa Enable LOA yes (see Default behavior) -Xnoloa Disable LOA","title":"Syntax"},{"location":"xloa/#default-behavior","text":"By default, allocations are made in the small object area (SOA). If there is no room in the SOA, and an object is larger than 64KB, the object is allocated in the LOA. If the LOA is not used, it is shrunk to zero after a few collections. You can disable it explicitly by specifying the -Xnoloa option.","title":"Default behavior"},{"location":"xloa/#explanation","text":"The LOA is an area of the tenure area of the heap set used solely to satisfy allocations for large objects. The LOA is used when the allocation request cannot be satisfied in the main area (the SOA of the tenure heap. As objects are allocated and freed, the heap can become fragmented in such a way that allocation can be met only by time-consuming compactions. This problem is more pronounced if an application allocates large objects. In an attempt to alleviate this problem, the LOA is allocated. A large object in this context is considered to be any object 64 KB or greater in size. Allocations for new TLH objects are not considered to be large objects. This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ), which do not use an LOA. Any LOA options passed on the command line are ignored. These policies address the issues that are solved by an LOA by reorganizing object layout with the VM to reduce heap fragmentation and compaction requirements.","title":"Explanation"},{"location":"xloa/#see-also","text":"-Xloainitial / -Xloaminimum / -Xloamaximum","title":"See also"},{"location":"xloaminimum/","text":"-Xloainitial / -Xloaminimum / -Xloamaximum Specifies the initial, minimum, and maximum proportion of the current tenure space allocated to the large object area (LOA). The LOA does not shrink to less than the minimum value. Syntax Setting Effect Default -Xloainitial<value> Set initial space 0.05 -Xloaminimum<value> Set minimum space 0.01 -Xloamaximum<value> Set minimum space 0.5 See also -Xloa / Xnoloa This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ), which do not use an LOA.","title":"-Xloaminimum"},{"location":"xloaminimum/#-xloainitial-xloaminimum-xloamaximum","text":"Specifies the initial, minimum, and maximum proportion of the current tenure space allocated to the large object area (LOA). The LOA does not shrink to less than the minimum value.","title":"-Xloainitial / -Xloaminimum / -Xloamaximum"},{"location":"xloaminimum/#syntax","text":"Setting Effect Default -Xloainitial<value> Set initial space 0.05 -Xloaminimum<value> Set minimum space 0.01 -Xloamaximum<value> Set minimum space 0.5","title":"Syntax"},{"location":"xloaminimum/#see-also","text":"-Xloa / Xnoloa This option is not supported with the balanced GC policy ( -Xgcpolicy:balanced ) or metronome GC policy ( -Xgcpolicy:metronome ), which do not use an LOA.","title":"See also"},{"location":"xlockreservation/","text":"-XlockReservation Enables an optimization that presumes a monitor is owned by the thread that last acquired it. This optimization minimizes the runtime cost of acquiring and releasing a monitor for a single thread if the monitor is rarely acquired by multiple threads. Syntax -XlockReservation","title":"-XlockReservation"},{"location":"xlockreservation/#-xlockreservation","text":"Enables an optimization that presumes a monitor is owned by the thread that last acquired it. This optimization minimizes the runtime cost of acquiring and releasing a monitor for a single thread if the monitor is rarely acquired by multiple threads.","title":"-XlockReservation"},{"location":"xlockreservation/#syntax","text":"-XlockReservation","title":"Syntax"},{"location":"xlockword/","text":"-Xlockword Test whether performance optimizations are negatively impacting an application. Syntax -Xlockword:<parameters> Parameters mode -Xlockword:mode=all -Xlockword:mode=default Locking optimizations typically reduce memory usage and improve performance. However, there might be some situations where a smaller heap size is achieved for an application, but overall application performance decreases. For example, if your application synchronizes on objects that are not typically synchronized on, such as Java.lang.String , run the following test: Use the following command-line option to revert to behavior that is closer to earlier versions and monitor application performance: -Xlockword:mode=all If performance does not improve, remove the previous command-line options or use the following command-line option to reestablish the new behavior: -Xlockword:mode=default nolockword -Xlockword:nolockword=<class_name> Removes the lockword from object instances of the class <class_name> , reducing the space required for these objects. However, this action might have an adverse effect on synchronization for those objects. You should only use this option for troubleshooting. what -Xlockword:what Shows the current lockword configuration.","title":"-Xlockword"},{"location":"xlockword/#-xlockword","text":"Test whether performance optimizations are negatively impacting an application.","title":"-Xlockword"},{"location":"xlockword/#syntax","text":"-Xlockword:<parameters>","title":"Syntax"},{"location":"xlockword/#parameters","text":"","title":"Parameters"},{"location":"xlockword/#mode","text":"-Xlockword:mode=all -Xlockword:mode=default Locking optimizations typically reduce memory usage and improve performance. However, there might be some situations where a smaller heap size is achieved for an application, but overall application performance decreases. For example, if your application synchronizes on objects that are not typically synchronized on, such as Java.lang.String , run the following test: Use the following command-line option to revert to behavior that is closer to earlier versions and monitor application performance: -Xlockword:mode=all If performance does not improve, remove the previous command-line options or use the following command-line option to reestablish the new behavior: -Xlockword:mode=default","title":"mode"},{"location":"xlockword/#nolockword","text":"-Xlockword:nolockword=<class_name> Removes the lockword from object instances of the class <class_name> , reducing the space required for these objects. However, this action might have an adverse effect on synchronization for those objects. You should only use this option for troubleshooting.","title":"nolockword"},{"location":"xlockword/#what","text":"-Xlockword:what Shows the current lockword configuration.","title":"what"},{"location":"xlog/","text":"-Xlog This option is supported for better compatibility with the reference implementation. However, only forms of -Xlog that enable garbage collection (GC) logging are recognized. Note that the behavior of this option changed in Eclipse OpenJ9\u2122 0.24.0. Syntax -Xlog[:<parameters>] Note: In Eclipse OpenJ9 version 0.24.0, the -Xsyslog option replaced the existing OpenJ9 -Xlog option for message logging to avoid conflicts with the reference implementation. For backward compatibility, you can control the behavior of the -Xlog option with the -XX:[+|-]LegacyXlogOption option. Explanation Use of the -Xlog option is supported for GC logging only. The following table describes the behavior of the option depending on what you specify on the command line. -Xlog option type Behavior An option that returns GC data. For example -Xlog:gc An equivalent OpenJ9 GC logging option is enabled. See the next table for more details. An option that, in the reference implementation, returns GC data and also other data. For example: -Xlog , -Xlog:all , -Xlog:gc+<other_tag> , or -Xlog:gc:stdout An equivalent OpenJ9 GC logging option is enabled as before but because non-GC data is not supported, the following error message is also produced: JVMJ9VM007W Command-line option unrecognised: <option> An option that, in the reference implementation, returns only non-GC data Non-GC data is not supported, so the following error message is produced: JVMJ9VM007W Command-line option unrecognised: <option> The following table shows some examples of the mapping between -Xlog parameters and the equivalent OpenJ9 GC parameters: -Xlog parameter OpenJ9 GC equivalent -Xlog:gc -Xlog:gc:stderr -verbose:gc -Xlog:gc:<filename> -Xlog:gc:file=<filename> -Xverbosegclog:<updated_filename> In the table, the value of <filename> can contain the following tokens, which are processed and passed to the -Xverbosegclog option as <updated_filename> : %p is replaced with the process ID (equivalent to dump agent token %pid ) %t is replaced with the dump agent tokens %Y-%m-%d_%H-%M-%S . See also -Xsyslog -Xverbosegclog -XX:[+|-]LegacyXlogOption","title":"-Xlog"},{"location":"xlog/#-xlog","text":"This option is supported for better compatibility with the reference implementation. However, only forms of -Xlog that enable garbage collection (GC) logging are recognized. Note that the behavior of this option changed in Eclipse OpenJ9\u2122 0.24.0.","title":"-Xlog"},{"location":"xlog/#syntax","text":"-Xlog[:<parameters>] Note: In Eclipse OpenJ9 version 0.24.0, the -Xsyslog option replaced the existing OpenJ9 -Xlog option for message logging to avoid conflicts with the reference implementation. For backward compatibility, you can control the behavior of the -Xlog option with the -XX:[+|-]LegacyXlogOption option.","title":"Syntax"},{"location":"xlog/#explanation","text":"Use of the -Xlog option is supported for GC logging only. The following table describes the behavior of the option depending on what you specify on the command line. -Xlog option type Behavior An option that returns GC data. For example -Xlog:gc An equivalent OpenJ9 GC logging option is enabled. See the next table for more details. An option that, in the reference implementation, returns GC data and also other data. For example: -Xlog , -Xlog:all , -Xlog:gc+<other_tag> , or -Xlog:gc:stdout An equivalent OpenJ9 GC logging option is enabled as before but because non-GC data is not supported, the following error message is also produced: JVMJ9VM007W Command-line option unrecognised: <option> An option that, in the reference implementation, returns only non-GC data Non-GC data is not supported, so the following error message is produced: JVMJ9VM007W Command-line option unrecognised: <option> The following table shows some examples of the mapping between -Xlog parameters and the equivalent OpenJ9 GC parameters: -Xlog parameter OpenJ9 GC equivalent -Xlog:gc -Xlog:gc:stderr -verbose:gc -Xlog:gc:<filename> -Xlog:gc:file=<filename> -Xverbosegclog:<updated_filename> In the table, the value of <filename> can contain the following tokens, which are processed and passed to the -Xverbosegclog option as <updated_filename> : %p is replaced with the process ID (equivalent to dump agent token %pid ) %t is replaced with the dump agent tokens %Y-%m-%d_%H-%M-%S .","title":"Explanation"},{"location":"xlog/#see-also","text":"-Xsyslog -Xverbosegclog -XX:[+|-]LegacyXlogOption","title":"See also"},{"location":"xlp/","text":"-Xlp Requests the Eclipse OpenJ9\u2122 VM to allocate the Java\u2122 object heap and JIT code cache memory with large pages. Note: This option is deprecated in all versions later than Java 8. Use the -Xlp:codecache and -Xlp:objectheap options instead. Restriction: This option does not work on macOS\u00ae. If you use the -Xgc:preferredHeapBase option with -Xlp , the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output. Syntax -Xlp[<size>] See Using -X command-line options for more information about the <size> parameter. Explanation AIX\u00ae If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If a size is not specified, this option requests the VM to allocate the Java object heap (the heap from which Java objects are allocated) with large (16 MB) pages. If large pages are not available, the Java object heap is allocated with the next smaller page size that is supported by the system. AIX requires special configuration to enable large pages. The VM supports the use of large pages only to back the Java object heap shared memory segments. The VM uses shmget() with the SHM_LGPG and SHM_PIN flags to allocate large pages. The -Xlp option replaces the environment variable IBM_JAVA_LARGE_PAGE_SIZE , which is now ignored if set. For more information about configuring AIX support for large pages, see Large pages in the AIX product documentation. Linux\u00ae If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If large pages are not available, the VM does not start and produces an error message. The VM uses shmget() to allocate large pages for the heap. Large pages are supported by systems that have Linux kernels v2.6 or higher. Note: Linux for IBM Z\u00ae supports only a large page size of 1 M. Depending on the architecture, 1 MB or 2 MB large pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap . Windows\u2122 If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. z/OS\u00ae If <size> is specified but unsuccessful, or if executable pages of that size are not supported, 1 M pageable is attempted. If 1 M pageable is not available, the JIT code cache memory is allocated by using the default or smallest available executable page size. If <size> is not specified, the 1 M nonpageable size is used. If large pages are not supported by the hardware, or enabled in RACF\u00ae, the VM does not start and produces an error message. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 31-bit VM. The -Xlp[<size>] option supports only a large page size of 2 G and 1 M (nonpageable). 1 M pageable pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap . Specifying -Xlp1M uses a 1 M pageable size for the code cache, when available. Specifying -Xlp2G sets the object heap size, but generates a warning that 2 G nonpageable pages cannot be used for the code cache. Use the -Xlp:objectheap:pagesize=2G,nonpageable option to avoid the warning. Limitation and workaround The VM ends if insufficient operating system resources are available to satisfy the request. However, an error message is not issued. There are a number of reasons why the VM cannot honor a large page request. For example, there might be insufficient large pages available on the system at the time of the request. To check whether the -Xlp request was honored, you can review the output from -verbose:gc . Look for the attributes requestedPageSize and pageSize in the -verbose:gc log file. The attribute requestedPageSize contains the value specified by -Xlp . The attribute pageSize is the actual page size used by the VM. See also Configuring large page memory allocation .","title":"-Xlp"},{"location":"xlp/#-xlp","text":"Requests the Eclipse OpenJ9\u2122 VM to allocate the Java\u2122 object heap and JIT code cache memory with large pages. Note: This option is deprecated in all versions later than Java 8. Use the -Xlp:codecache and -Xlp:objectheap options instead. Restriction: This option does not work on macOS\u00ae. If you use the -Xgc:preferredHeapBase option with -Xlp , the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output.","title":"-Xlp"},{"location":"xlp/#syntax","text":"-Xlp[<size>] See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xlp/#explanation","text":"","title":"Explanation"},{"location":"xlp/#aix","text":"If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If a size is not specified, this option requests the VM to allocate the Java object heap (the heap from which Java objects are allocated) with large (16 MB) pages. If large pages are not available, the Java object heap is allocated with the next smaller page size that is supported by the system. AIX requires special configuration to enable large pages. The VM supports the use of large pages only to back the Java object heap shared memory segments. The VM uses shmget() with the SHM_LGPG and SHM_PIN flags to allocate large pages. The -Xlp option replaces the environment variable IBM_JAVA_LARGE_PAGE_SIZE , which is now ignored if set. For more information about configuring AIX support for large pages, see Large pages in the AIX product documentation.","title":"AIX&reg;"},{"location":"xlp/#linux","text":"If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If large pages are not available, the VM does not start and produces an error message. The VM uses shmget() to allocate large pages for the heap. Large pages are supported by systems that have Linux kernels v2.6 or higher. Note: Linux for IBM Z\u00ae supports only a large page size of 1 M. Depending on the architecture, 1 MB or 2 MB large pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap .","title":"Linux&reg;"},{"location":"xlp/#windows","text":"If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM.","title":"Windows&trade;"},{"location":"xlp/#zos","text":"If <size> is specified but unsuccessful, or if executable pages of that size are not supported, 1 M pageable is attempted. If 1 M pageable is not available, the JIT code cache memory is allocated by using the default or smallest available executable page size. If <size> is not specified, the 1 M nonpageable size is used. If large pages are not supported by the hardware, or enabled in RACF\u00ae, the VM does not start and produces an error message. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 31-bit VM. The -Xlp[<size>] option supports only a large page size of 2 G and 1 M (nonpageable). 1 M pageable pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap . Specifying -Xlp1M uses a 1 M pageable size for the code cache, when available. Specifying -Xlp2G sets the object heap size, but generates a warning that 2 G nonpageable pages cannot be used for the code cache. Use the -Xlp:objectheap:pagesize=2G,nonpageable option to avoid the warning.","title":"z/OS&reg;"},{"location":"xlp/#limitation-and-workaround","text":"The VM ends if insufficient operating system resources are available to satisfy the request. However, an error message is not issued. There are a number of reasons why the VM cannot honor a large page request. For example, there might be insufficient large pages available on the system at the time of the request. To check whether the -Xlp request was honored, you can review the output from -verbose:gc . Look for the attributes requestedPageSize and pageSize in the -verbose:gc log file. The attribute requestedPageSize contains the value specified by -Xlp . The attribute pageSize is the actual page size used by the VM.","title":"Limitation and workaround"},{"location":"xlp/#see-also","text":"Configuring large page memory allocation .","title":"See also"},{"location":"xlpcodecache/","text":"-Xlp:codecache Requests the Eclipse OpenJ9\u2122 VM to allocate the JIT code cache by using large page sizes. If the requested large page size is not available, the VM starts, but the JIT code cache is allocated by using a platform-defined size. A warning is displayed when the requested page size is not available. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output. Syntax AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:codecache:pagesize=<size> z/OS\u00ae: -Xlp:codecache:pagesize=<size>,pageable See Using -X command-line options for more information about the <size> parameter. Default values AIX The code cache page size is controlled by the DATAPSIZE setting of the LDR_CNTRL environment variable. The page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. For more information about the LDR_CNTRL environment variable, see Configuring large page memory allocation: AIX systems . Linux The default size for the code cache depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages Linux on Power Systems\u2122: The code cache page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. On other architectures, the VM uses the default operating system page size. macOS The default size for the code cache is 4 KB large pages. z/OS 1 MB pageable pages, when available, are the default size for the code cache. The -Xlp:codecache:pagesize=<size>,pageable option supports only a large page size of 1 MB pageable large pages. The use of 1 MB pageable large pages for the JIT code cache can improve the runtime performance of some Java\u2122 applications. A page size of 4 KB can also be used. See also Configuring large page memory allocation .","title":"-Xlp:codecache"},{"location":"xlpcodecache/#-xlpcodecache","text":"Requests the Eclipse OpenJ9\u2122 VM to allocate the JIT code cache by using large page sizes. If the requested large page size is not available, the VM starts, but the JIT code cache is allocated by using a platform-defined size. A warning is displayed when the requested page size is not available. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output.","title":"-Xlp:codecache"},{"location":"xlpcodecache/#syntax","text":"AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:codecache:pagesize=<size> z/OS\u00ae: -Xlp:codecache:pagesize=<size>,pageable See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xlpcodecache/#default-values","text":"","title":"Default values"},{"location":"xlpcodecache/#aix","text":"The code cache page size is controlled by the DATAPSIZE setting of the LDR_CNTRL environment variable. The page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. For more information about the LDR_CNTRL environment variable, see Configuring large page memory allocation: AIX systems .","title":"AIX"},{"location":"xlpcodecache/#linux","text":"The default size for the code cache depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages Linux on Power Systems\u2122: The code cache page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. On other architectures, the VM uses the default operating system page size.","title":"Linux"},{"location":"xlpcodecache/#macos","text":"The default size for the code cache is 4 KB large pages.","title":"macOS"},{"location":"xlpcodecache/#zos","text":"1 MB pageable pages, when available, are the default size for the code cache. The -Xlp:codecache:pagesize=<size>,pageable option supports only a large page size of 1 MB pageable large pages. The use of 1 MB pageable large pages for the JIT code cache can improve the runtime performance of some Java\u2122 applications. A page size of 4 KB can also be used.","title":"z/OS"},{"location":"xlpcodecache/#see-also","text":"Configuring large page memory allocation .","title":"See also"},{"location":"xlpobjectheap/","text":"-Xlp:objectheap Requests the Eclipse OpenJ9\u2122 VM to allocate the Java\u2122 object heap by using large page sizes. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output. Syntax AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:objectheap:pagesize=<size>[,strict|warn] z/OS\u00ae: -Xlp:objectheap:pagesize=<size>[,strict|warn][,pageable|nonpageable] See Using -X command-line options for more information about the <size> parameter. Parameters pagesize -Xlp:objectheap:pagesize=<size> The large page size that you require. If the operating system does not have sufficient resources to satisfy the request, the page size you requested might not be available when the VM starts up. By default, the VM starts and the Java object heap is allocated by using a different platform-defined page size. Alternatively, you can use the strict or warn suboptions to customize behavior. Default page sizes On Linux systems, the default size for the object heap depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages On other architectures, the VM uses the default operating system page size. On macOS, the default page size is 4 KB. strict | warn -Xlp:objectheap:strict -Xlp:objectheap:warn strict causes an error message to be generated if large pages are requested but cannot be obtained. This option causes the VM to end. warn causes a warning message to be generated if large pages are requested but cannot be obtained. This option allows the VM to continue. Note: If both strict and warn are specified, strict takes precedence. pageable | nonpageable -Xlp:objectheap:pageable -Xlp:objectheap:nonpageable On z/OS systems, defines the type of memory to allocate for the Java object heap. 1 MB pageable large pages, when available, are the default size for the object heap. 64-bit VMs support large page sizes of 1 MB nonpageable and 2 GB nonpageable with the following requirements: 2 GB nonpageable sizes are supported only on IBM zEnterprise EC12 processors or later. A system programmer must configure z/OS for nonpageable large pages. Users who require large pages must be authorized to the IARRSM.LRGPAGES resource in the RACF FACILITY class with read authority. 31-bit VMs support a large page size of only 1 MB pageable. A page size of 4 KB can also be used. Examples z/OS: To allocate 1 GB of real memory by using 1 MB nonpageable pages when the VM starts, set the following options: -Xmx1023m -Xms512m -Xlp:objectheap:pagesize=1M,nonpageable z/OS: To allocate 1 GB of real memory by using 2 GB nonpageable pages, set the following options: -Xmx1023m -Xms512m -Xlp:objectheap:pagesize=2G,nonpageable In this example the heap is allocated on a 2 GB large page. Even though the object heap is only 1 GB, 2 GB of memory are consumed and the large page is never paged out while the VM is running. See also Configuring large page memory allocation .","title":"-Xlp:objectheap"},{"location":"xlpobjectheap/#-xlpobjectheap","text":"Requests the Eclipse OpenJ9\u2122 VM to allocate the Java\u2122 object heap by using large page sizes. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output.","title":"-Xlp:objectheap"},{"location":"xlpobjectheap/#syntax","text":"AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:objectheap:pagesize=<size>[,strict|warn] z/OS\u00ae: -Xlp:objectheap:pagesize=<size>[,strict|warn][,pageable|nonpageable] See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xlpobjectheap/#parameters","text":"","title":"Parameters"},{"location":"xlpobjectheap/#pagesize","text":"-Xlp:objectheap:pagesize=<size> The large page size that you require. If the operating system does not have sufficient resources to satisfy the request, the page size you requested might not be available when the VM starts up. By default, the VM starts and the Java object heap is allocated by using a different platform-defined page size. Alternatively, you can use the strict or warn suboptions to customize behavior.","title":"pagesize"},{"location":"xlpobjectheap/#default-page-sizes","text":"On Linux systems, the default size for the object heap depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages On other architectures, the VM uses the default operating system page size. On macOS, the default page size is 4 KB.","title":"Default page sizes"},{"location":"xlpobjectheap/#strict-warn","text":"-Xlp:objectheap:strict -Xlp:objectheap:warn strict causes an error message to be generated if large pages are requested but cannot be obtained. This option causes the VM to end. warn causes a warning message to be generated if large pages are requested but cannot be obtained. This option allows the VM to continue. Note: If both strict and warn are specified, strict takes precedence.","title":"strict | warn"},{"location":"xlpobjectheap/#pageablenonpageable","text":"-Xlp:objectheap:pageable -Xlp:objectheap:nonpageable On z/OS systems, defines the type of memory to allocate for the Java object heap. 1 MB pageable large pages, when available, are the default size for the object heap. 64-bit VMs support large page sizes of 1 MB nonpageable and 2 GB nonpageable with the following requirements: 2 GB nonpageable sizes are supported only on IBM zEnterprise EC12 processors or later. A system programmer must configure z/OS for nonpageable large pages. Users who require large pages must be authorized to the IARRSM.LRGPAGES resource in the RACF FACILITY class with read authority. 31-bit VMs support a large page size of only 1 MB pageable. A page size of 4 KB can also be used.","title":"pageable|nonpageable"},{"location":"xlpobjectheap/#examples","text":"z/OS: To allocate 1 GB of real memory by using 1 MB nonpageable pages when the VM starts, set the following options: -Xmx1023m -Xms512m -Xlp:objectheap:pagesize=1M,nonpageable z/OS: To allocate 1 GB of real memory by using 2 GB nonpageable pages, set the following options: -Xmx1023m -Xms512m -Xlp:objectheap:pagesize=2G,nonpageable In this example the heap is allocated on a 2 GB large page. Even though the object heap is only 1 GB, 2 GB of memory are consumed and the large page is never paged out while the VM is running.","title":"Examples"},{"location":"xlpobjectheap/#see-also","text":"Configuring large page memory allocation .","title":"See also"},{"location":"xmca/","text":"-Xmca / -Xmco Sets the expansion step for the memory allocated to store the RAM ( -Xmca ) and ROM ( -Xmco ) portions of loaded classes. Each time more memory is required to store classes in RAM or ROM, the allocated memory is increased by the amount set. If the expansion step size you choose is too large, OutOfMemoryError is reported. The exact value of a \"too large\" expansion step size varies according to the platform and the specific machine configuration. You can use the -verbose:sizes option to find out the value that is being used by the VM. Syntax Setting Effect Default -Xmca<size> Set expansion step for RAM 32 KB -Xmco<size> Set expansion step for ROM 128 KB See Using -X command-line options for more information about the <size> parameter. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded. See also Heap expansion and contraction","title":"-Xmco"},{"location":"xmca/#-xmca-xmco","text":"Sets the expansion step for the memory allocated to store the RAM ( -Xmca ) and ROM ( -Xmco ) portions of loaded classes. Each time more memory is required to store classes in RAM or ROM, the allocated memory is increased by the amount set. If the expansion step size you choose is too large, OutOfMemoryError is reported. The exact value of a \"too large\" expansion step size varies according to the platform and the specific machine configuration. You can use the -verbose:sizes option to find out the value that is being used by the VM.","title":"-Xmca / -Xmco"},{"location":"xmca/#syntax","text":"Setting Effect Default -Xmca<size> Set expansion step for RAM 32 KB -Xmco<size> Set expansion step for ROM 128 KB See Using -X command-line options for more information about the <size> parameter. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded.","title":"Syntax"},{"location":"xmca/#see-also","text":"Heap expansion and contraction","title":"See also"},{"location":"xmcrs/","text":"-Xmcrs Sets an initial size for an area in memory that is reserved for any native classes, monitors, and threads that are used by compressed references within the lowest 4 GB memory area. You can use the -verbose:sizes option to find out the value that is being used by the VM. Notes: Native memory OutOfMemoryError exceptions might occur when using compressed references if the lowest 4 GB of address space becomes full, particularly when loading classes, starting threads, or using monitors. If you are not using compressed references and this option is set, the option is ignored and the output of -verbose:sizes shows -Xmcrs0 . Syntax -Xmcrs<size> See Using -X command-line options for more information about the <size> parameter.","title":"-Xmcrs"},{"location":"xmcrs/#-xmcrs","text":"Sets an initial size for an area in memory that is reserved for any native classes, monitors, and threads that are used by compressed references within the lowest 4 GB memory area. You can use the -verbose:sizes option to find out the value that is being used by the VM. Notes: Native memory OutOfMemoryError exceptions might occur when using compressed references if the lowest 4 GB of address space becomes full, particularly when loading classes, starting threads, or using monitors. If you are not using compressed references and this option is set, the option is ignored and the output of -verbose:sizes shows -Xmcrs0 .","title":"-Xmcrs"},{"location":"xmcrs/#syntax","text":"-Xmcrs<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmine/","text":"-Xmine / -Xmaxe Set the minimum and maximum amounts by which the garbage collector expands the heap. Syntax Setting Default -Xmine<size> 1 MB -Xmaxe<size> 0 (unlimited expansion) See Using -X command-line options for more information about the <size> parameter. Explanation Typically, the garbage collector expands the heap by the amount required to restore the free space to 30% (or the amount specified by -Xminf ). If heap expansion is required: -Xmine forces the expansion to be at least the specified value. For example, -Xmine10M sets the expansion size to a minimum of 10 MB. -Xmaxe limits the expansion to the specified value. For example -Xmaxe50M prevents expansion by more than 50 MB. ( -Xmaxe0 allows unlimited expansion.) For the gencon GC policy, the values apply only to the tenure part of the heap. For the balanced , optthruput , and optavgpause GC policies, these values apply to the whole heap. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded. See also Heap expansion and contraction","title":"-Xmine"},{"location":"xmine/#-xmine-xmaxe","text":"Set the minimum and maximum amounts by which the garbage collector expands the heap.","title":"-Xmine / -Xmaxe"},{"location":"xmine/#syntax","text":"Setting Default -Xmine<size> 1 MB -Xmaxe<size> 0 (unlimited expansion) See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmine/#explanation","text":"Typically, the garbage collector expands the heap by the amount required to restore the free space to 30% (or the amount specified by -Xminf ). If heap expansion is required: -Xmine forces the expansion to be at least the specified value. For example, -Xmine10M sets the expansion size to a minimum of 10 MB. -Xmaxe limits the expansion to the specified value. For example -Xmaxe50M prevents expansion by more than 50 MB. ( -Xmaxe0 allows unlimited expansion.) For the gencon GC policy, the values apply only to the tenure part of the heap. For the balanced , optthruput , and optavgpause GC policies, these values apply to the whole heap. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded.","title":"Explanation"},{"location":"xmine/#see-also","text":"Heap expansion and contraction","title":"See also"},{"location":"xminf/","text":"-Xminf / -Xmaxf Specifies the minimum and maximum proportion of the heap that must remain free after a global garbage collection (GC) cycle. If the free space is above or below these limits, the Eclipse OpenJ9\u2122 VM attempts to adjust the heap size so that: -Xminf \u2264 free space \u2264 -Xmaxf . Syntax Setting Effect Default -Xminf<value> Set minimum free space 0.3 -Xmaxf<value> Set maximum free space 0.6 The value range is 0.0 - 1.0. For the balanced GC policy, these values apply only to the non-eden space part of the heap. The non-eden heap resizing decision is made by observing both -Xmint / -Xmaxt and -Xminf / -Xmaxf . Free memory in eden space is not considered for -Xminf / -Xmaxf purposes. For the gencon GC policy, the values apply only to the tenure part of the heap and only at global GC points. For the optthruput and optavgpause GC policies, these values apply to the whole heap at every GC point. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded. See also Heap expansion and contraction Garbage collection policies","title":"-Xminf"},{"location":"xminf/#-xminf-xmaxf","text":"Specifies the minimum and maximum proportion of the heap that must remain free after a global garbage collection (GC) cycle. If the free space is above or below these limits, the Eclipse OpenJ9\u2122 VM attempts to adjust the heap size so that: -Xminf \u2264 free space \u2264 -Xmaxf .","title":"-Xminf / -Xmaxf"},{"location":"xminf/#syntax","text":"Setting Effect Default -Xminf<value> Set minimum free space 0.3 -Xmaxf<value> Set maximum free space 0.6 The value range is 0.0 - 1.0. For the balanced GC policy, these values apply only to the non-eden space part of the heap. The non-eden heap resizing decision is made by observing both -Xmint / -Xmaxt and -Xminf / -Xmaxf . Free memory in eden space is not considered for -Xminf / -Xmaxf purposes. For the gencon GC policy, the values apply only to the tenure part of the heap and only at global GC points. For the optthruput and optavgpause GC policies, these values apply to the whole heap at every GC point. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded.","title":"Syntax"},{"location":"xminf/#see-also","text":"Heap expansion and contraction Garbage collection policies","title":"See also"},{"location":"xmint/","text":"-Xmint / -Xmaxt Sets the minimum and maximum proportion of time to spend in the garbage collection (GC) process as a percentage of the overall running time that included the last three GC runs. Therefore, the time spent in the GC process includes time spent in global mark phase and global GC operations but excludes partial garbage collection pauses because the latter apply only to the eden space. If the percentage of time drops to less than the minimum, the Eclipse OpenJ9\u2122 VM tries to shrink the heap. If the percentage of time exceeds the maximum, the VM tries to expand the heap. Restrictions: This option applies only to GC policies that include stop-the-world (STW) operations, such as -Xgcpolicy:optthruput . Syntax Setting Effect Default for balanced policy Default for other policies -Xmint<value> Set minimum time in GC 0.02 0.05 -Xmaxt<value> Set maximum time in GC 0.05 0.13 For the balanced GC policy, the values apply only to the non-eden space part of the heap. The non-eden heap resizing decision is made by observing both -Xmint / -Xmaxt and -Xminf / -Xmaxf . For the gencon GC policy, the values apply only to the tenure part of the heap. For the optthruput , and optavgpause GC policies, these values apply to the whole heap. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded. See also Heap expansion and contraction Garbage collection policies","title":"-Xmint"},{"location":"xmint/#-xmint-xmaxt","text":"Sets the minimum and maximum proportion of time to spend in the garbage collection (GC) process as a percentage of the overall running time that included the last three GC runs. Therefore, the time spent in the GC process includes time spent in global mark phase and global GC operations but excludes partial garbage collection pauses because the latter apply only to the eden space. If the percentage of time drops to less than the minimum, the Eclipse OpenJ9\u2122 VM tries to shrink the heap. If the percentage of time exceeds the maximum, the VM tries to expand the heap. Restrictions: This option applies only to GC policies that include stop-the-world (STW) operations, such as -Xgcpolicy:optthruput .","title":"-Xmint / -Xmaxt"},{"location":"xmint/#syntax","text":"Setting Effect Default for balanced policy Default for other policies -Xmint<value> Set minimum time in GC 0.02 0.05 -Xmaxt<value> Set maximum time in GC 0.05 0.13 For the balanced GC policy, the values apply only to the non-eden space part of the heap. The non-eden heap resizing decision is made by observing both -Xmint / -Xmaxt and -Xminf / -Xmaxf . For the gencon GC policy, the values apply only to the tenure part of the heap. For the optthruput , and optavgpause GC policies, these values apply to the whole heap. This option cannot be used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded.","title":"Syntax"},{"location":"xmint/#see-also","text":"Heap expansion and contraction Garbage collection policies","title":"See also"},{"location":"xmn/","text":"-Xmn / -Xmns / -Xmnx Sets the initial and maximum size of the nursery area when using the gencon garbage collection (GC) policy ( -Xgcpolicy:gencon ), and sets the size of eden when using the balanced garbage collection (GC) policy ( -Xgcpolicy:balanced ). These options are ignored if they are used with any other GC policy. You can use the -verbose:sizes option to find out the value that is being used by the VM. Syntax Setting Effect Default -Xmn<size> Equivalent to setting both -Xmns and -Xmnx Not set -Xmns<size> Set initial size 25% of -Xms when using gencon and balanced policies -Xmnx<size> Set maximum size 25% of -Xmx when using gencon , and 75% of -Xmx when using balanced See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmn with either -Xmns or -Xmnx , the VM does not start, returning an error. Notes: When using the balanced GC policy without specifying -Xmn or -Xmns , the GC may decide to shrink eden size below its initial size (25% of -Xms ) if it determines that doing so will improve GC performance. When using the balanced GC policy, specifying -Xmn / -Xmns / -Xmnx may affect balanced GC's ability to satisfy -Xgc:targetPausetime Specifying -Xmn / -Xmns / -Xmnx may affect both gencon and balanced GC's ability to satisfy -Xgc:dnssexpectedtimeratiomaximum and -Xgc:dnssexpectedtimeratiominimum To set the size of the tenure area of the heap when using gencon GC policy, see -Xmo/-Xmos/-Xmox . See also gencon GC policy (default) balanced GC policy -Xmo/-Xmos/-Xmox -Xms / -Xmx","title":"-Xmnx"},{"location":"xmn/#-xmn-xmns-xmnx","text":"Sets the initial and maximum size of the nursery area when using the gencon garbage collection (GC) policy ( -Xgcpolicy:gencon ), and sets the size of eden when using the balanced garbage collection (GC) policy ( -Xgcpolicy:balanced ). These options are ignored if they are used with any other GC policy. You can use the -verbose:sizes option to find out the value that is being used by the VM.","title":"-Xmn / -Xmns / -Xmnx"},{"location":"xmn/#syntax","text":"Setting Effect Default -Xmn<size> Equivalent to setting both -Xmns and -Xmnx Not set -Xmns<size> Set initial size 25% of -Xms when using gencon and balanced policies -Xmnx<size> Set maximum size 25% of -Xmx when using gencon , and 75% of -Xmx when using balanced See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmn with either -Xmns or -Xmnx , the VM does not start, returning an error. Notes: When using the balanced GC policy without specifying -Xmn or -Xmns , the GC may decide to shrink eden size below its initial size (25% of -Xms ) if it determines that doing so will improve GC performance. When using the balanced GC policy, specifying -Xmn / -Xmns / -Xmnx may affect balanced GC's ability to satisfy -Xgc:targetPausetime Specifying -Xmn / -Xmns / -Xmnx may affect both gencon and balanced GC's ability to satisfy -Xgc:dnssexpectedtimeratiomaximum and -Xgc:dnssexpectedtimeratiominimum To set the size of the tenure area of the heap when using gencon GC policy, see -Xmo/-Xmos/-Xmox .","title":"Syntax"},{"location":"xmn/#see-also","text":"gencon GC policy (default) balanced GC policy -Xmo/-Xmos/-Xmox -Xms / -Xmx","title":"See also"},{"location":"xmo/","text":"-Xmo / -Xmos / -Xmox Sets the size of the tenure area of the heap for the gencon garbage collection (GC) policy. You can use the -verbose:sizes option to find out the values that the VM is currently using. Syntax Setting Effect Default -Xmo<size> Equivalent to setting both -Xmos and -Xmox not set -Xmos<size> Set initial size of the tenure area of the heap 75% of -Xms -Xmox<size> Set maximum size of the tenure area of the heap Same as -Xmx See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmo with either -Xmos or -Xmox , the VM does not start, returning an error. To set the size of the nursery area of the heap, see -Xmn/-Xmns/-Xmnx . See also gencon policy (default) -Xmn/-Xmns/-Xmnx -Xms / -Xmx","title":"-Xmox"},{"location":"xmo/#-xmo-xmos-xmox","text":"Sets the size of the tenure area of the heap for the gencon garbage collection (GC) policy. You can use the -verbose:sizes option to find out the values that the VM is currently using.","title":"-Xmo / -Xmos / -Xmox"},{"location":"xmo/#syntax","text":"Setting Effect Default -Xmo<size> Equivalent to setting both -Xmos and -Xmox not set -Xmos<size> Set initial size of the tenure area of the heap 75% of -Xms -Xmox<size> Set maximum size of the tenure area of the heap Same as -Xmx See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmo with either -Xmos or -Xmox , the VM does not start, returning an error. To set the size of the nursery area of the heap, see -Xmn/-Xmns/-Xmnx .","title":"Syntax"},{"location":"xmo/#see-also","text":"gencon policy (default) -Xmn/-Xmns/-Xmnx -Xms / -Xmx","title":"See also"},{"location":"xmoi/","text":"-Xmoi Sets the heap expansion allocation increment. You can use the -verbose:sizes option to find out the values that the VM is currently using. Syntax Setting Effect Default -Xmoi<size> Sets the heap expansion allocation increment See Notes Notes: By default, the increment size ( -Xmoi ) is calculated on the expansion size, set by -Xmine and -Xminf . If you set -Xmoi to zero, no expansion is allowed. For the gencon GC policy, the expansion increment applies to the tenure area of the heap. This option is not supported for the metronome GC policy, because the heap is always fully expanded. See Using -X command-line options for more information about the <size> parameter. See also Heap expansion and contraction","title":"-Xmoi"},{"location":"xmoi/#-xmoi","text":"Sets the heap expansion allocation increment. You can use the -verbose:sizes option to find out the values that the VM is currently using.","title":"-Xmoi"},{"location":"xmoi/#syntax","text":"Setting Effect Default -Xmoi<size> Sets the heap expansion allocation increment See Notes Notes: By default, the increment size ( -Xmoi ) is calculated on the expansion size, set by -Xmine and -Xminf . If you set -Xmoi to zero, no expansion is allowed. For the gencon GC policy, the expansion increment applies to the tenure area of the heap. This option is not supported for the metronome GC policy, because the heap is always fully expanded. See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmoi/#see-also","text":"Heap expansion and contraction","title":"See also"},{"location":"xmr/","text":"-Xmr / -Xmrx Sets the initial and maximum size of the the garbage collection (GC) remembered set in the gencon GC policy. The remembered set is a list of objects in the tenure area of the heap that have references to objects in the new area. Syntax Setting Effect Default -Xmr<size> Set initial size 16 K -Xmrx<size> Set maximium size See Using -X command-line options for more information about the <size> parameter. This option applies only to the gencon GC policy.","title":"-Xmrx"},{"location":"xmr/#-xmr-xmrx","text":"Sets the initial and maximum size of the the garbage collection (GC) remembered set in the gencon GC policy. The remembered set is a list of objects in the tenure area of the heap that have references to objects in the new area.","title":"-Xmr / &nbsp; -Xmrx"},{"location":"xmr/#syntax","text":"Setting Effect Default -Xmr<size> Set initial size 16 K -Xmrx<size> Set maximium size See Using -X command-line options for more information about the <size> parameter. This option applies only to the gencon GC policy.","title":"Syntax"},{"location":"xms/","text":"-Xms / -Xmx These Oracle\u00ae HotSpot\u2122 options set the initial/minimum Java\u2122 heap size, and the maximum heap size respectively. These options are recognized by the Eclipse OpenJ9\u2122 VM. Notes: If you set -Xms > -Xmx , the VM fails with the message -Xms too large for -Xmx . If you exceed the limit set by the -Xmx option, the VM generates an OutofMemoryError . If you set a value for -Xms , the -XX:InitialRAMPercentage option is ignored. If you set a value for -Xmx , the -XX:MaxRAMPercentage option is ignored. For the gencon GC policy, you can also use the -Xmo option: If the scavenger is enabled, -Xms \u2265 -Xmn + -Xmo If the scavenger is disabled, -Xms \u2265 -Xmo Syntax Setting Effect Default -Xms<size> Set initial heap size 8 MB -Xmx<size> Set maximum heap size 25% of available memory (25 GB maximum) See Using -X command-line options for more information about the <size> parameter. See Default settings for the OpenJ9 VM for more about default values. The -Xmx option can be used with all OpenJ9 GC policies. However, the -Xms option can be used with all GC policies except for the metronome GC policy because the heap is always fully expanded. Examples -Xms2m -Xmx64m Heap starts at 2 MB and grows to a maximum of 64 MB. -Xms100m -Xmx100m Heap starts at 100 MB and never grows. -Xms50m Heap starts at 50 MB and grows to the default maximum. -Xmx256m Heap starts at default initial value and grows to a maximum of 256 MB. See also -Xsoftmx (Set \"soft\" maximum Java heap size)","title":"-Xmx"},{"location":"xms/#-xms-xmx","text":"These Oracle\u00ae HotSpot\u2122 options set the initial/minimum Java\u2122 heap size, and the maximum heap size respectively. These options are recognized by the Eclipse OpenJ9\u2122 VM. Notes: If you set -Xms > -Xmx , the VM fails with the message -Xms too large for -Xmx . If you exceed the limit set by the -Xmx option, the VM generates an OutofMemoryError . If you set a value for -Xms , the -XX:InitialRAMPercentage option is ignored. If you set a value for -Xmx , the -XX:MaxRAMPercentage option is ignored. For the gencon GC policy, you can also use the -Xmo option: If the scavenger is enabled, -Xms \u2265 -Xmn + -Xmo If the scavenger is disabled, -Xms \u2265 -Xmo","title":"-Xms / -Xmx"},{"location":"xms/#syntax","text":"Setting Effect Default -Xms<size> Set initial heap size 8 MB -Xmx<size> Set maximum heap size 25% of available memory (25 GB maximum) See Using -X command-line options for more information about the <size> parameter. See Default settings for the OpenJ9 VM for more about default values. The -Xmx option can be used with all OpenJ9 GC policies. However, the -Xms option can be used with all GC policies except for the metronome GC policy because the heap is always fully expanded.","title":"Syntax"},{"location":"xms/#examples","text":"-Xms2m -Xmx64m Heap starts at 2 MB and grows to a maximum of 64 MB. -Xms100m -Xmx100m Heap starts at 100 MB and never grows. -Xms50m Heap starts at 50 MB and grows to the default maximum. -Xmx256m Heap starts at default initial value and grows to a maximum of 256 MB.","title":"Examples"},{"location":"xms/#see-also","text":"-Xsoftmx (Set \"soft\" maximum Java heap size)","title":"See also"},{"location":"xmso/","text":"-Xmso Sets the native stack size for operating system threads. You can use the -verbose:sizes option to find out the values that the VM is currently using. When a native method makes a call into the VM, the VM calculates whether the memory required for the call will exceed the -Xmso value. If so, a java/lang/StackOverflowError error is thrown. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; this option applies to the native stack only. For the Java stack option, see the link in the See also section. Syntax -Xmso<size> See Using -X command-line options for more information about the <size> parameter. Default setting Default values vary by platform. See Default settings for the Eclipse OpenJ9\u2122 VM . Note: On 64-bit z/OS, the default size is the minimum that can be allocated by the operating system. So if you set a value that is smaller, that value is ignored by the VM. See also -Xiss/-Xss/-Xssi (stack size and increment for Java\u2122 threads)","title":"-Xmso"},{"location":"xmso/#-xmso","text":"Sets the native stack size for operating system threads. You can use the -verbose:sizes option to find out the values that the VM is currently using. When a native method makes a call into the VM, the VM calculates whether the memory required for the call will exceed the -Xmso value. If so, a java/lang/StackOverflowError error is thrown. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; this option applies to the native stack only. For the Java stack option, see the link in the See also section.","title":"-Xmso"},{"location":"xmso/#syntax","text":"-Xmso<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmso/#default-setting","text":"Default values vary by platform. See Default settings for the Eclipse OpenJ9\u2122 VM . Note: On 64-bit z/OS, the default size is the minimum that can be allocated by the operating system. So if you set a value that is smaller, that value is ignored by the VM.","title":"Default setting"},{"location":"xmso/#see-also","text":"-Xiss/-Xss/-Xssi (stack size and increment for Java\u2122 threads)","title":"See also"},{"location":"xnumanone/","text":"-Xnuma:none (AIX\u00ae, Linux\u00ae, and Windows\u2122 only) Use this option to turn off non-uniform memory architecture (NUMA) awareness when using the balanced garbage collection policy. For workloads that do most of their work in one thread, or workloads that maintain a full heap, turning off NUMA awareness can improve performance. Syntax -Xnuma:none Default behavior NUMA awareness is enabled by default.","title":"-Xnuma:none"},{"location":"xnumanone/#-xnumanone","text":"(AIX\u00ae, Linux\u00ae, and Windows\u2122 only) Use this option to turn off non-uniform memory architecture (NUMA) awareness when using the balanced garbage collection policy. For workloads that do most of their work in one thread, or workloads that maintain a full heap, turning off NUMA awareness can improve performance.","title":"-Xnuma:none"},{"location":"xnumanone/#syntax","text":"-Xnuma:none","title":"Syntax"},{"location":"xnumanone/#default-behavior","text":"NUMA awareness is enabled by default.","title":"Default behavior"},{"location":"xoptionsfile/","text":"-Xoptionsfile Specifies a file that contains VM options and definitions. The contents of the options file are recorded in the ENVINFO section of a Java\u2122 dump. Syntax -Xoptionsfile=<file_name> where <file_name> specifies a file that contains options that are processed as if they had been entered directly as command-line options. Explanation At startup, the VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. <path> is the VM directory, as shown in Directory conventions . <path> is the <java_home>/lib directory, where <java_home> is the directory for your runtime environment. The file options.default can be updated with any options that you want to specify at run time. The options file does not support these options: -assert -fullversion -help -showversion -version -Xcompressedrefs -Xcheck:memory -Xoptionsfile -XshowSettings Although you cannot use -Xoptionsfile recursively within an options file, you can use -Xoptionsfile multiple times on the same command line to load more than one options files. Some options use quoted strings as parameters. Do not split quoted strings over multiple lines using the forward slash line continuation character (\\). The Yen symbol (\u00a5) is not supported as a line continuation character. For example, the following example is not valid in an options file: -Xevents=vmstop,exec=\"cmd /c \\ echo %pid has finished.\" The following example is valid in an options file: -Xevents=vmstop, \\ exec=\"cmd /c echo %pid has finished.\" Example Here is an example of an options file: #My options file -X<option1> -X<option2>=\\ <value1>,\\ <value2> -D<sysprop1>=<value1> See also Specifying command-line options Javadump: TITLE, GPINFO, and ENVINFO sections","title":"-Xoptionsfile"},{"location":"xoptionsfile/#-xoptionsfile","text":"Specifies a file that contains VM options and definitions. The contents of the options file are recorded in the ENVINFO section of a Java\u2122 dump.","title":"-Xoptionsfile"},{"location":"xoptionsfile/#syntax","text":"-Xoptionsfile=<file_name> where <file_name> specifies a file that contains options that are processed as if they had been entered directly as command-line options.","title":"Syntax"},{"location":"xoptionsfile/#explanation","text":"At startup, the VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. <path> is the VM directory, as shown in Directory conventions . <path> is the <java_home>/lib directory, where <java_home> is the directory for your runtime environment. The file options.default can be updated with any options that you want to specify at run time. The options file does not support these options: -assert -fullversion -help -showversion -version -Xcompressedrefs -Xcheck:memory -Xoptionsfile -XshowSettings Although you cannot use -Xoptionsfile recursively within an options file, you can use -Xoptionsfile multiple times on the same command line to load more than one options files. Some options use quoted strings as parameters. Do not split quoted strings over multiple lines using the forward slash line continuation character (\\). The Yen symbol (\u00a5) is not supported as a line continuation character. For example, the following example is not valid in an options file: -Xevents=vmstop,exec=\"cmd /c \\ echo %pid has finished.\" The following example is valid in an options file: -Xevents=vmstop, \\ exec=\"cmd /c echo %pid has finished.\"","title":"Explanation"},{"location":"xoptionsfile/#example","text":"Here is an example of an options file: #My options file -X<option1> -X<option2>=\\ <value1>,\\ <value2> -D<sysprop1>=<value1>","title":"Example"},{"location":"xoptionsfile/#see-also","text":"Specifying command-line options Javadump: TITLE, GPINFO, and ENVINFO sections","title":"See also"},{"location":"xquickstart/","text":"-Xquickstart This option causes the JIT compiler to run with a subset of optimizations, which can improve the performance of short-running applications. Note: For compatibility with other Java\u2122 virtual machines, you can also specify the -client option, which results in identical behavior to -Xquickstart . Syntax -Xquickstart Default behavior By default, -Xquickstart is disabled. Explanation The JIT compiler is tuned for long-running applications typically used on a server. When you specify this option, the compiler uses a subset of optimizations, which results in faster compilation times that improve startup time. However, longer running applications might run more slowly, especially applications that contain hot methods and other methods using a large amount of processing resource. When the AOT compiler is active (both shared classes and AOT compilation enabled), -Xquickstart causes all methods to be AOT compiled. The AOT compilation improves the startup time of subsequent runs, but might reduce performance for longer running applications, especially those that contain hot methods. Note: The implementation of -Xquickstart is subject to change in future releases.","title":"-Xquickstart"},{"location":"xquickstart/#-xquickstart","text":"This option causes the JIT compiler to run with a subset of optimizations, which can improve the performance of short-running applications. Note: For compatibility with other Java\u2122 virtual machines, you can also specify the -client option, which results in identical behavior to -Xquickstart .","title":"-Xquickstart"},{"location":"xquickstart/#syntax","text":"-Xquickstart","title":"Syntax"},{"location":"xquickstart/#default-behavior","text":"By default, -Xquickstart is disabled.","title":"Default behavior"},{"location":"xquickstart/#explanation","text":"The JIT compiler is tuned for long-running applications typically used on a server. When you specify this option, the compiler uses a subset of optimizations, which results in faster compilation times that improve startup time. However, longer running applications might run more slowly, especially applications that contain hot methods and other methods using a large amount of processing resource. When the AOT compiler is active (both shared classes and AOT compilation enabled), -Xquickstart causes all methods to be AOT compiled. The AOT compilation improves the startup time of subsequent runs, but might reduce performance for longer running applications, especially those that contain hot methods. Note: The implementation of -Xquickstart is subject to change in future releases.","title":"Explanation"},{"location":"xrs/","text":"-Xrs Prevents the Eclipse OpenJ9\u2122 runtime environment from handling any internally or externally generated signals such as SIGSEGV and SIGABRT . Any signals that are raised are handled by the default operating system handlers, which you might want if you are using a debugger such as GDB or WinDbg to diagnose problems in JNI code. Disabling signal handling in the OpenJ9 VM reduces performance by approximately 2-4%, depending on the application. Note: Setting this option prevents dumps being generated by the OpenJ9 VM for signals such as SIGSEGV and SIGABRT , because the VM is no longer intercepting these signals. Do not use the -Xrs and -XX:+HandleSIGABRT options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled. Syntax -Xrs -Xrs:sync Parameters If you specify the sync parameter: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: Disables signal handling in the VM for SIGSEGV , SIGFPE , SIGBUS , SIGILL , SIGTRAP , and SIGABRT signals. However, the VM still handles the SIGQUIT and SIGTERM signals, among others. On Windows\u2122 systems: Hardware exceptions are not handled by the OpenJ9 VM when this option is specified. However, the Windows CTRL_BREAK_EVENT signal, triggered by the Ctrl-Break key combination, is still handled by the VM. Linux and macOS systems always use the SIGUSR1 signal. See also Signal handling","title":"-Xrs"},{"location":"xrs/#-xrs","text":"Prevents the Eclipse OpenJ9\u2122 runtime environment from handling any internally or externally generated signals such as SIGSEGV and SIGABRT . Any signals that are raised are handled by the default operating system handlers, which you might want if you are using a debugger such as GDB or WinDbg to diagnose problems in JNI code. Disabling signal handling in the OpenJ9 VM reduces performance by approximately 2-4%, depending on the application. Note: Setting this option prevents dumps being generated by the OpenJ9 VM for signals such as SIGSEGV and SIGABRT , because the VM is no longer intercepting these signals. Do not use the -Xrs and -XX:+HandleSIGABRT options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled.","title":"-Xrs"},{"location":"xrs/#syntax","text":"-Xrs -Xrs:sync","title":"Syntax"},{"location":"xrs/#parameters","text":"If you specify the sync parameter: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: Disables signal handling in the VM for SIGSEGV , SIGFPE , SIGBUS , SIGILL , SIGTRAP , and SIGABRT signals. However, the VM still handles the SIGQUIT and SIGTERM signals, among others. On Windows\u2122 systems: Hardware exceptions are not handled by the OpenJ9 VM when this option is specified. However, the Windows CTRL_BREAK_EVENT signal, triggered by the Ctrl-Break key combination, is still handled by the VM. Linux and macOS systems always use the SIGUSR1 signal.","title":"Parameters"},{"location":"xrs/#see-also","text":"Signal handling","title":"See also"},{"location":"xsamplingexpirationtime/","text":"-XsamplingExpirationTime Disables JIT sampling after a specified amount of time. When the JIT sampling thread is disabled, no processor cycles are used by an idle Eclipse OpenJ9\u2122 VM. Use this option with care; after the sampling thread is disabled, you cannot reactivate it. However, because the profiling frequency is automatically reduced, you should not have to use this option. Allow the sampling thread to run for long enough to identify important optimizations. Syntax -XsamplingExpirationTime<time> where <time> is specified in seconds. Explanation The JIT sampling thread profiles the running Java\u2122 application to discover commonly used methods. The memory and processor usage of the sampling thread is negligible, and the frequency of profiling is automatically reduced when the OpenJ9 VM is idle, to once per second instead of once every 10ms, or once every 100 seconds if the idle state lasts more than 50 seconds.","title":"-XsamplingExpirationTime"},{"location":"xsamplingexpirationtime/#-xsamplingexpirationtime","text":"Disables JIT sampling after a specified amount of time. When the JIT sampling thread is disabled, no processor cycles are used by an idle Eclipse OpenJ9\u2122 VM. Use this option with care; after the sampling thread is disabled, you cannot reactivate it. However, because the profiling frequency is automatically reduced, you should not have to use this option. Allow the sampling thread to run for long enough to identify important optimizations.","title":"-XsamplingExpirationTime"},{"location":"xsamplingexpirationtime/#syntax","text":"-XsamplingExpirationTime<time> where <time> is specified in seconds.","title":"Syntax"},{"location":"xsamplingexpirationtime/#explanation","text":"The JIT sampling thread profiles the running Java\u2122 application to discover commonly used methods. The memory and processor usage of the sampling thread is negligible, and the frequency of profiling is automatically reduced when the OpenJ9 VM is idle, to once per second instead of once every 10ms, or once every 100 seconds if the idle state lasts more than 50 seconds.","title":"Explanation"},{"location":"xscdmx/","text":"-Xscdmx Use the -Xscdmx option to control the size of the class debug area when you create a shared classes cache. Syntax -Xscdmx<size> See Using -X command-line options for more information about the <size> parameter. Explanation The -Xscdmx option works in a similar way to the -Xscmx option, which is used to control the overall size of the shared classes cache. The size of -Xscdmx must be smaller than the size of -Xscmx . By default, the size of the class debug area is a percentage of the free class data bytes in a newly created or empty cache. A class debug area is still created if you use the -Xnolinenumbers option with the -Xscdmx option on the command line.","title":"-Xscdmx"},{"location":"xscdmx/#-xscdmx","text":"Use the -Xscdmx option to control the size of the class debug area when you create a shared classes cache.","title":"-Xscdmx"},{"location":"xscdmx/#syntax","text":"-Xscdmx<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscdmx/#explanation","text":"The -Xscdmx option works in a similar way to the -Xscmx option, which is used to control the overall size of the shared classes cache. The size of -Xscdmx must be smaller than the size of -Xscmx . By default, the size of the class debug area is a percentage of the free class data bytes in a newly created or empty cache. A class debug area is still created if you use the -Xnolinenumbers option with the -Xscdmx option on the command line.","title":"Explanation"},{"location":"xscminaot/","text":"-Xscminaot / -Xscmaxaot When you create a shared classes cache, you can use these options to set the minimum and maximum number of bytes in the class cache to reserve for AOT data. Setting -Xscmaxaot is useful if you want a certain amount of cache space guaranteed for non-AOT data. Syntax Setting Effect Default -Xscminaot<size> Set minimum size for AOT class cache 0 -Xscmaxaot<size> Set maximum size for AOT class cache The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter. -Xscminaot If -Xscminaot is not specified, no space is reserved for AOT data. However, AOT data is still written to the cache until the cache is full or the -Xscmaxaot limit is reached. The value of -Xscminaot must not exceed the value of -Xscmx or -Xscmaxaot and should be considerably less than the total cache size, because AOT data can be created only for cached classes. If the value of -Xscminaot equals the value of -Xscmx , no class data or AOT data can be stored. You can also adjust the -Xscminaot value by using: -Xshareclasses:adjustminaot=<size> option MemoryMXBean.setSharedClassCacheMinAotBytes() method in the com.ibm.lang.management API You can also adjust the -Xscmaxaot value by using: -Xshareclasses:adjustmaxaot=<size> option MemoryMXBean.setSharedClassCacheMaxAotBytes() method in the com.ibm.lang.management API. -Xscmaxaot The value of this option must not be smaller than the value of -Xscminaot and must not be larger than the value of -Xscmx . When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of AOT data that is not stored due to the current setting of the maximum AOT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxAotUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum AOT data space size accordingly if you want to add the unstored AOT data to the shared cache. See also -Xshareclasses","title":"-Xscminaot"},{"location":"xscminaot/#-xscminaot-xscmaxaot","text":"When you create a shared classes cache, you can use these options to set the minimum and maximum number of bytes in the class cache to reserve for AOT data. Setting -Xscmaxaot is useful if you want a certain amount of cache space guaranteed for non-AOT data.","title":"-Xscminaot / -Xscmaxaot"},{"location":"xscminaot/#syntax","text":"Setting Effect Default -Xscminaot<size> Set minimum size for AOT class cache 0 -Xscmaxaot<size> Set maximum size for AOT class cache The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscminaot/#-xscminaot","text":"If -Xscminaot is not specified, no space is reserved for AOT data. However, AOT data is still written to the cache until the cache is full or the -Xscmaxaot limit is reached. The value of -Xscminaot must not exceed the value of -Xscmx or -Xscmaxaot and should be considerably less than the total cache size, because AOT data can be created only for cached classes. If the value of -Xscminaot equals the value of -Xscmx , no class data or AOT data can be stored. You can also adjust the -Xscminaot value by using: -Xshareclasses:adjustminaot=<size> option MemoryMXBean.setSharedClassCacheMinAotBytes() method in the com.ibm.lang.management API You can also adjust the -Xscmaxaot value by using: -Xshareclasses:adjustmaxaot=<size> option MemoryMXBean.setSharedClassCacheMaxAotBytes() method in the com.ibm.lang.management API.","title":"-Xscminaot"},{"location":"xscminaot/#-xscmaxaot","text":"The value of this option must not be smaller than the value of -Xscminaot and must not be larger than the value of -Xscmx . When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of AOT data that is not stored due to the current setting of the maximum AOT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxAotUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum AOT data space size accordingly if you want to add the unstored AOT data to the shared cache.","title":"-Xscmaxaot"},{"location":"xscminaot/#see-also","text":"-Xshareclasses","title":"See also"},{"location":"xscminjitdata/","text":"-Xscminjitdata / -Xscmaxjitdata When you create a shared classes cache, you can use these options to set a minimum and maximum number of bytes in the class cache that can be used for JIT data. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of JIT data that is not stored due to the current setting of the the maximum JIT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxJitDataUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum JIT data space size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store the JIT data. Subsequent VMs can store JIT data in the shared cache. Syntax Setting Effect Default -Xscminjitdata<size> Set minimum size for JIT data 0 (See Default behavior ) -Xscmaxjitdata<size> Set maximum size for JIT data The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter. Default behavior If -Xscminjitdata is not specified, no space is reserved for JIT data, although JIT data is still written to the cache until the cache is full or the -Xscmaxjitdata limit is reached. Explanation -Xscminjitdata The value of -Xscminjitdata must not exceed the value of -Xscmx or -Xscmaxjitdata . The value of -Xscminjitdata must always be considerably less than the total cache size, because JIT data can be created only for cached classes. If the value of -Xscminjitdata equals the value of -Xscmx , no class data or JIT data can be stored. You can also adjust the -Xscminjitdata value by using: -Xshareclasses:adjustminjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API. -Xscmaxjitdata Setting -Xscmaxjitdata is useful if you want a certain amount of cache space guaranteed for non-JIT data. If this option is not specified, the maximum limit for JIT data is the amount of free space in the cache. The value of this option must not be smaller than the value of -Xscminjitdata , and must not be larger than the value of -Xscmx . You can also adjust the -Xscmaxjitdata value by using: -Xshareclasses:adjustmaxjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API. See also -Xscmx","title":"-Xscminjitdata"},{"location":"xscminjitdata/#-xscminjitdata-xscmaxjitdata","text":"When you create a shared classes cache, you can use these options to set a minimum and maximum number of bytes in the class cache that can be used for JIT data. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of JIT data that is not stored due to the current setting of the the maximum JIT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxJitDataUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum JIT data space size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store the JIT data. Subsequent VMs can store JIT data in the shared cache.","title":"-Xscminjitdata / -Xscmaxjitdata"},{"location":"xscminjitdata/#syntax","text":"Setting Effect Default -Xscminjitdata<size> Set minimum size for JIT data 0 (See Default behavior ) -Xscmaxjitdata<size> Set maximum size for JIT data The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscminjitdata/#default-behavior","text":"If -Xscminjitdata is not specified, no space is reserved for JIT data, although JIT data is still written to the cache until the cache is full or the -Xscmaxjitdata limit is reached.","title":"Default behavior"},{"location":"xscminjitdata/#explanation","text":"","title":"Explanation"},{"location":"xscminjitdata/#-xscminjitdata","text":"The value of -Xscminjitdata must not exceed the value of -Xscmx or -Xscmaxjitdata . The value of -Xscminjitdata must always be considerably less than the total cache size, because JIT data can be created only for cached classes. If the value of -Xscminjitdata equals the value of -Xscmx , no class data or JIT data can be stored. You can also adjust the -Xscminjitdata value by using: -Xshareclasses:adjustminjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API.","title":"-Xscminjitdata"},{"location":"xscminjitdata/#-xscmaxjitdata","text":"Setting -Xscmaxjitdata is useful if you want a certain amount of cache space guaranteed for non-JIT data. If this option is not specified, the maximum limit for JIT data is the amount of free space in the cache. The value of this option must not be smaller than the value of -Xscminjitdata , and must not be larger than the value of -Xscmx . You can also adjust the -Xscmaxjitdata value by using: -Xshareclasses:adjustmaxjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API.","title":"-Xscmaxjitdata"},{"location":"xscminjitdata/#see-also","text":"-Xscmx","title":"See also"},{"location":"xscmx/","text":"-Xscmx For a new shared classes cache, specifies either: the actual size of the cache, if the -XX:SharedCacheHardLimit option is not present the soft maximum size of the cache, if used with the -XX:SharedCacheHardLimit option (See -XX:SharedCacheHardLimit ) This option applies only if a cache is being created and no cache of the same name exists. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. You can also get this information by using the MemoryMXBean.getSharedClassCacheSoftmxUnstoredBytes() method in the com.ibm.lang.management API. You can increase the soft maximum size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store that data. Therefore, increasing the soft maximum size does not necessarily cause any more data to be stored in the shared cache by the current VM, but subsequent VMs can add data to the shared cache. Syntax -Xscmx<size> See Using -X command-line options for more information about the <size> parameter. Explanation Setting a soft maximum size If you specify the -Xscmx option with the -XX:SharedCacheHardLimit option, the -Xscmx option sets the soft maximum size of a new shared classes cache, and the -XX:SharedCacheHardLimit option sets the actual maximum size. The value of the -Xscmx option must therefore not exceed the value of -XX:SharedCacheHardLimit . When the soft maximum limit is reached, no more data can be added into the shared cache, unless there is reserved AOT or JIT data space. If such reserved space exists, AOT or JIT data can still be added into the reserved space. The reserved AOT and JIT data spaces are counted as used space within the soft maximum size, so the soft maximum size should not be less than the minimum reserved space for AOT and JIT data if you specify the -Xscminaot or -Xscminjitdata options. You can change the soft maximum size by using the -Xshareclasses:adjustsoftmx=<size> option or the MemoryMXBean.setSharedClassCacheSoftmxBytes() method in the com.ibm.lang.management API. By using this API, Java\u2122 applications can dynamically monitor and adjust the cache soft maximum size as required. This function can be useful in virtualized or cloud environments, for example, where the shared cache size might change dynamically to meet business needs. For example, you might create a 64 MB shared cache and set a smaller value, such as 16 MB, for the -Xscmx option, to limit the data stored in the cache: -XX:SharedCacheHardLimit=64m -Xscmx16m You can then use the com.ibm.lang.management API from within a Java application to increase the soft maximum value during run time, as load increases. This change allows the application to use more shared cache space than you specified initially. You can increase the soft maximum size if it is currently less than the actual cache size. If you attempt to reduce the soft maximum size to a value that is less than the number of bytes already used in the cache, the number of used bytes is set as the new soft maximum size. Cache size limits The theoretical cache size limit is 2 GB. The size of the cache that you can specify is limited by the following factors: AIX\u00ae, Linux\u00ae, and macOS\u00ae: The amount of physical memory and paging space available to the system. Windows\u00ae: The amount of available disk space and available virtual address space. z/OS\u00ae: The amount of swap space available to the system. Non-persistent caches are stored in shared memory and are removed when a system is rebooted. On systems other than Windows, non-persistent caches are allocated by using the System V IPC shared memory mechanism. To ensure that sufficient shared memory is available for class data sharing, see Setting shared memory values . Note: By default, a cache is persistent on all platforms, except z/OS. See also -Xscdmx (control the size of the class debug area)","title":"-Xscmx"},{"location":"xscmx/#-xscmx","text":"For a new shared classes cache, specifies either: the actual size of the cache, if the -XX:SharedCacheHardLimit option is not present the soft maximum size of the cache, if used with the -XX:SharedCacheHardLimit option (See -XX:SharedCacheHardLimit ) This option applies only if a cache is being created and no cache of the same name exists. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. You can also get this information by using the MemoryMXBean.getSharedClassCacheSoftmxUnstoredBytes() method in the com.ibm.lang.management API. You can increase the soft maximum size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store that data. Therefore, increasing the soft maximum size does not necessarily cause any more data to be stored in the shared cache by the current VM, but subsequent VMs can add data to the shared cache.","title":"-Xscmx"},{"location":"xscmx/#syntax","text":"-Xscmx<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscmx/#explanation","text":"","title":"Explanation"},{"location":"xscmx/#setting-a-soft-maximum-size","text":"If you specify the -Xscmx option with the -XX:SharedCacheHardLimit option, the -Xscmx option sets the soft maximum size of a new shared classes cache, and the -XX:SharedCacheHardLimit option sets the actual maximum size. The value of the -Xscmx option must therefore not exceed the value of -XX:SharedCacheHardLimit . When the soft maximum limit is reached, no more data can be added into the shared cache, unless there is reserved AOT or JIT data space. If such reserved space exists, AOT or JIT data can still be added into the reserved space. The reserved AOT and JIT data spaces are counted as used space within the soft maximum size, so the soft maximum size should not be less than the minimum reserved space for AOT and JIT data if you specify the -Xscminaot or -Xscminjitdata options. You can change the soft maximum size by using the -Xshareclasses:adjustsoftmx=<size> option or the MemoryMXBean.setSharedClassCacheSoftmxBytes() method in the com.ibm.lang.management API. By using this API, Java\u2122 applications can dynamically monitor and adjust the cache soft maximum size as required. This function can be useful in virtualized or cloud environments, for example, where the shared cache size might change dynamically to meet business needs. For example, you might create a 64 MB shared cache and set a smaller value, such as 16 MB, for the -Xscmx option, to limit the data stored in the cache: -XX:SharedCacheHardLimit=64m -Xscmx16m You can then use the com.ibm.lang.management API from within a Java application to increase the soft maximum value during run time, as load increases. This change allows the application to use more shared cache space than you specified initially. You can increase the soft maximum size if it is currently less than the actual cache size. If you attempt to reduce the soft maximum size to a value that is less than the number of bytes already used in the cache, the number of used bytes is set as the new soft maximum size.","title":"Setting a soft maximum size"},{"location":"xscmx/#cache-size-limits","text":"The theoretical cache size limit is 2 GB. The size of the cache that you can specify is limited by the following factors: AIX\u00ae, Linux\u00ae, and macOS\u00ae: The amount of physical memory and paging space available to the system. Windows\u00ae: The amount of available disk space and available virtual address space. z/OS\u00ae: The amount of swap space available to the system. Non-persistent caches are stored in shared memory and are removed when a system is rebooted. On systems other than Windows, non-persistent caches are allocated by using the System V IPC shared memory mechanism. To ensure that sufficient shared memory is available for class data sharing, see Setting shared memory values . Note: By default, a cache is persistent on all platforms, except z/OS.","title":"Cache size limits"},{"location":"xscmx/#see-also","text":"-Xscdmx (control the size of the class debug area)","title":"See also"},{"location":"xshareclasses/","text":"-Xshareclasses Use the -Xshareclasses option to enable, disable, or modify class sharing behavior. Class data sharing is enabled by default for bootstrap classes only (the equivalent of specifying -Xshareclasses:bootClassesOnly,nonFatal,silent ), unless your application is running in a container. This option can take a number of parameters, some of which are cache utilities . Cache utilities carry out specific operations on a specified cache without starting the Java virtual machine (VM). Although you can combine multiple suboptions, which are separated by commas, the cache utilities are mutually exclusive. Some cache utilities can work with caches from previous Java\u2122 versions or caches that are created by VMs with different bit-widths. These caches are referred to as \"incompatible\" caches. See also the Class data sharing topic, which includes some best practices for using -Xshareclasses . Syntax -Xshareclasses:<parameter> When you specify -Xshareclasses without any parameters and without specifying either the -Xscmx or -XX:SharedCacheHardLimit options, a shared classes cache is created with a default size, as follows: For 64-bit platforms, the default size is 300 MB, with a \"soft\" maximum limit for the initial size of the cache ( -Xscmx ) of 64MB, with the following exceptions: For a persistent cache, if the free disk space is less than 6 GB, the default size is set to 64 MB and an -Xscmx size is not set. For a non-persistent cache on Linux\u00ae or macOS\u00ae systems, the cache size is limited by the maximum amount of memory that can be reserved by a process ( SHMMAX ). If SHMMAX is less than 300MB, the default shared cache size is set to equal SHMMAX . If SHMMAX is greater than 80 MB, -Xscmx is set to 64 MB. If SHMMAX is less than 80MB an -Xscmx size is not set. For other platforms, the default size is 16MB. Parameters adjustmaxaot (Cache utility) -Xshareclasses:adjustmaxaot=<size> Adjusts the maximum shared classes cache space that is allowed for AOT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxaot option. adjustminaot (Cache utility) -Xshareclasses:adjustminaot=<size> Adjusts the minimum shared classes cache space that is reserved for AOT data. Use the -Xscminaot option to set the initial minimum size. adjustmaxjitdata (Cache utility) -Xshareclasses:adjustmaxjitdata=<size> Adjusts the maximum shared classes cache space that is allowed for JIT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxjitdata option. adjustminjitdata (Cache utility) -Xshareclasses:adjustminjitdata=<size> Adjusts the minimum shared classes cache space that is reserved for JIT data. Use the -Xscminjitdata option to set the initial minimum size. adjustsoftmx (Cache utility) -Xshareclasses:adjustsoftmx=<size> Adjusts the soft maximum size of the cache. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. For more information about the soft maximum size, see -Xscmx . allowClasspaths -Xshareclasses:allowClasspaths Allows a VM to store classpaths into an existing shared cache that was created by using the restrictClasspaths option. bootClassesOnly -Xshareclasses:bootClassesOnly Disables caching of classes that are loaded by class loaders other than the bootstrap class loader. If you use this suboption, the nonfatal suboption is also set, so this suboption is the equivalent of specifying -Xshareclasses:bootClassesOnly,nonfatal . cacheDir -Xshareclasses:cacheDir=<directory> Sets the directory in which cache data is read and written. Please do not set the cache directory on a NFS mount or a shared mount across systems or LPARs. The following defaults apply: On Windows\u2122 systems, <directory> is the user's C:\\Users\\<username>\\AppData\\Local\\javasharedresources directory. On z/OS\u00ae systems, <directory> is the /tmp/javasharedresources directory. On other operating systems, <directory> is javasharedresources in the user's home directory, unless the groupAccess parameter is specified, in which case it is /tmp/javasharedresources , because some members of the group might not have access to the user's home directory. You must have sufficient permissions in <directory> . Do not set user's home directory on a NFS or shared mount. On AIX\u00ae, Linux, macOS, and Windows systems, the VM writes persistent cache files directly into the directory specified. Persistent cache files can be safely moved and deleted from the file system. Non-persistent caches are stored in shared memory and have control files that describe the location of the memory. Control files are stored in a javasharedresources subdirectory of the cacheDir specified. Do not move or delete control files in this directory. The listAllCaches utility, the destroyAll utility, and the expire suboption work only in the scope of a given cacheDir . On AIX, Linux, and macOS systems, if you specify the cacheDir=<directory> option, persistent caches are created with the following permissions ( -rw-r--r-- ): User: read/write Group: read (read/write if you also specify -Xshareclasses:groupAccess ) Other: read only Otherwise, persistent caches are created with the same permissions as non-persistent caches. The permissions for non-persistent caches are -rw-r----- , or -rw-rw---- if you also specify -Xshareclasses:groupAccess . Note: It is good practice to set an application-specific cache directory to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory, and means that your application is therefore unaffected by a user running java -Xshareclasses:destroyAll . See Class data sharing: Best practices for using -Xshareclasses . cacheDirPerm (Not Windows) -Xshareclasses:cacheDirPerm=<permission> Sets Unix-style permissions when you are creating a cache directory. <permission> must be an octal number in the ranges 0700 - 0777 or 1700 - 1777. If <permission> is not valid, the VM ends with an appropriate error message. The permissions that are specified by this suboption are used only when you are creating a new cache directory. If the cache directory already exists, this suboption is ignored and the cache directory permissions are not changed. If you set this suboption to 0000, the default directory permissions are used. If you set this suboption to 1000, the machine default directory permissions are used, but the sticky bit is enabled. If the cache directory is the platform default directory, /tmp/javasharedresources , this suboption is ignored and the cache directory permissions are set to 0777. If you do not set this suboption, the default permissions are used according to the following conditions: Condition Permissions The cache directory is /tmp/javasharedresources . If this directory already exists with different permissions, the permissions are changed when the cache is opened.\u2020 0777 The cache directory is a new directory and you also specify the groupAcess suboption 0770 The cache directory is a new directory and you do not specify the groupAccess suboption 0700 The cache directory already exists and is not /tmp/javasharedresources Unchanged \u2020On z/OS\u00ae systems, permissions for existing cache directories are unchanged, to avoid generating RACF\u00ae errors, which generate log messages. Note: It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. See Class data sharing: Best practices for using -Xshareclasses . cacheRetransformed -Xshareclasses:cacheRetransformed Enables caching of classes that are transformed by using the JVMTI RetransformClasses function. For more information, see Redefined and retransformed classes . The option enableBCI is enabled by default. However, if you use the cacheRetransformed option, this option forces cache creation into -Xshareclasses:disableBCI mode. checkURLTimestamps -Xshareclasses:checkURLTimestamps Causes timestamps of jar or zip files to be checked every time a class is loaded. If a timestamp has changed, the class is loaded from the jar or zip file and not from the shared cache. This suboption is not enabled by default and reflects the legacy behavior of the shared classes cache. Note: The timestamp of a bootstrap jar or zip file is checked once when it is used for the first time to load a class. createLayer (64-bit only) -Xshareclasses:createLayer Creates layered caches. If there are multiple VMs in a race condition while creating a layered cache, more than one new layered cache can be created. To avoid this situation, use the -Xshareclasses:layer=<number> suboption to create a new layered cache with a specific layer number. See layer for more information about layered caches. destroy (Cache utility) -Xshareclasses:destroy Destroys a cache that is specified by the name , cacheDir , and nonpersistent suboptions. A cache can be destroyed only if all VMs that are using it have ended and the user has sufficient permissions. destroyAll (Cache utility) -Xshareclasses:destroyAll Tries to destroy all the caches that are specified by the cacheDir and nonpersistent suboptions. On Windows and z/OS systems, a cache can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Note: On z/OS, when the destroyAll option is invoked from a 31-bit VM, 64-bit caches are not destroyed. Similarly, when the destroyAll option is invoked from a 64-bit VM, 31-bit caches are not destroyed. The following message is displayed: JVMSHRC735I: Use a nn-bit VM to perform the requested operation on the nn-bit shared cache \"cachename\" as the nn-bit VM cannot verify that the shared memory was created by the VM. On AIX, Linux, and macOS systems: Non-persistent caches can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Persistent caches that are still in use continue to exist even when you use this option, but they are unlinked from the file system so they are not visible to new VM invocations. If you update the VM then restart an application for which a persistent shared cache already exists, the VM unlinks the existing cache and creates a new cache. Because the unlinked caches are not visible to new VMs, you cannot find them by using the -Xshareclasses:listAllCaches option, and you cannot use the -Xshareclasses:printStats option on them. You can therefore have multiple unlinked caches that consume file system space until they are no longer in use. destroyAllLayers (Cache utility) (64-bit only) -Xshareclasses:destroyAllLayers Destroys all shared cache layers that are specified by the name suboption. For example, -Xshareclasses:name=Cache1,destroyAllLayers destroys all layers of the cache called Cache1 . If you use the destroy suboption on a layered cache, for example -Xshareclasses:name=Cache1,destroy , only the top layer of the cache is destroyed. For more information about layered caches, see Creating layer caches . destroyAllSnapshots (Cache utility) (Not Windows) -Xshareclasses:destroyAllSnapshots Destroys all shared cache snapshots that are available as a result of the specified cacheDir suboption. destroySnapshot (Cache utility) (Not Windows) -Xshareclasses:destroySnapshot Destroys a snapshot that is specified by the name and cacheDir suboptions. disableBCI -Xshareclasses:disableBCI Turns off BCI support. This option can be used to override -XXShareClassesEnableBCI . enableBCI -Xshareclasses:enableBCI This option is enabled by default. Allows a JVMTI ClassFileLoadHook event to be triggered every time, for classes that are loaded from the cache. This mode also prevents caching of classes that are modified by JVMTI agents. For more information about bytecode modification, see Support for bytecode instrumentation . This option is incompatible with the cacheRetransformed option. Using the two options together causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created without the enableBCI suboption cannot be reused with the enableBCI suboption. Attempting to do so causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created with the enableBCI suboption can be reused without specifying this suboption. In this case, the VM detects that the cache was created with the enableBCI suboption and uses the cache in this mode. expire (Cache utility) -Xshareclasses:expire=<time_in_minutes> Destroys all caches that are unused for the time that is specified before loading shared classes. This option is not a utility option because it does not cause the VM to exit. On Windows systems, which have NTFS file systems, the expire option is accurate to the nearest hour. fatal -Xshareclasses:fatal The VM does not start if class data sharing fails, for example because there was an error when accessing the cache directory. An error message is generated. This suboption is specified by default unless you use the bootClassesOnly suboption, which is equivalent to -Xshareclasses:bootClassesOnly,nonfatal . You can override this behavior by specifying -Xshareclasses:bootClassesOnly,fatal . See also nonfatal . findAotMethods (Cache utility) -Xshareclasses:findAotMethods=<method_specification> -Xshareclasses:findAotMethods=help Print the AOT methods in the shared classes cache that match the method specifications. Methods that are already invalidated are indicated in the output. Use this suboption to check which AOT methods in the shared classes cache would be invalidated by using the same method specifications with the invalidateAotMethods suboption. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax . groupAccess (Not Windows) -Xshareclasses:groupAccess Sets operating system permissions on a new cache to allow group access to the cache. Group access can be set only when permitted by the operating system umask setting. The default is user access only. On AIX, Linux, and macOS systems, if a user creates a cache by specifying the groupAccess suboption, other users in the same group must also specify this suboption to be granted access to the same cache. When groupAccess is specified, the default directory for a cache is /tmp/javasharedresources . Some systems might clear the content of the /tmp directory on a reboot, removing the shared cache. To avoid that problem, you are therefore recommended to use cacheDir to set a different location for the cache. If necessary, use cacheDirPerm to ensure that the cache directory permissions are set appropriately. In certain situations, warning messages might be generated when the groupAccess suboption is used. This message can occur when persistent caches are used: JVMSHRC756W Failed to set group access permission on the shared cache file as requested by the 'groupAccess' sub-option These messages can occur when non-persistent caches are used: JVMSHRC759W Failed to set group access permission as requested by the 'groupAccess' sub-option on the semaphore control file associated with shared classes cache. JVMSHRC760W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared memory control file associated with shared classes cache. This message can occur in combination with the snapshotCache suboption: JVMSHRC761W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared cache snapshot file. All of these warning messages mean that the user's umask setting does not allow either, or both, of the group read and write permission to be set on the file. The typical umask setting restricts only the write permission. To resolve the warning, either change the umask setting or remove the groupAccess suboption. help -Xshareclasses:help Lists all the command-line options. invalidateAotMethods (Cache utility) -Xshareclasses:invalidateAotMethods=<method_specification> -Xshareclasses:invalidateAotMethods=help Modify the existing shared cache to invalidate the AOT methods that match the method specifications. Use this suboption to invalidate AOT methods that cause a failure in the application, without having to destroy the shared cache. Invalidated AOT methods remain in the shared cache, but are then excluded from being loaded. VMs that have not processed the methods, or new VMs that use the cache are not affected by the invalidated methods. The AOT methods are invalidated for the lifetime of the cache, but do not prevent the AOT methods from being compiled again if a new shared cache is created. To prevent AOT method compilation into a new shared cache, use the -Xaot:exclude option. For more information, see -Xaot . To identify AOT problems, see Diagnosing a JIT or AOT problem . To revalidate an AOT method, see the revalidateAotMethods suboption. Use the findAotMethod suboption to determine which AOT methods match the method specifications. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax . layer (64-bit only) -Xshareclasses:layer=<number> Creates layered caches. This suboption has the same effect as the createLayer suboption, but with the added ability to specify the layer number. For more information about creating a shared classes cache with layers, see Creating layer caches . listAllCaches (Cache utility) -Xshareclasses:listAllCaches Lists all the compatible and incompatible caches, and snapshots that exist in the specified cache directory. If you do not specify cacheDir , the default directory is used. Summary information, such as Java version and current usage, is displayed for each cache. Output includes cache-type (persistent or non-persistent) and feature (compressed references ( cr ) or non-compressed references ( non-cr )). mprotect AIX, z/OS 31-bit: -Xshareclasses:mprotect=[default|all|none] Linux, Windows, macOS: -Xshareclasses:mprotect=[default|all|partialpagesonstartup|onfind|nopartialpages|none] where: default : By default, the memory pages that contain the cache are always protected, unless a specific page is being updated. This protection helps prevent accidental or deliberate corruption to the cache. The cache header is not protected by default because this protection has a performance cost. On Linux, macOS, and Windows systems, after the startup phase, the Java virtual machine (VM) protects partially filled pages whenever new data is added to the shared classes cache in the following sequence: The VM changes the memory protection of any partially filled pages to read/write. The VM adds the data to the cache. The VM changes the memory protection of any partially filled pages to read only. all : This value ensures that all the cache pages are protected, including the header. See Note. partialpagesonstartup : This value causes the VM to protect partially filled pages during startup as well as after the startup phase. This value is available only on Linux, macOS, and Windows systems. onfind : When this option is specified, the VM protects partially filled pages when it reads new data in the cache that is added by another VM. This option is available only on Linux, macOS, and Windows systems. nopartialpages : Use this value to turn off the protection of partially filled pages. This value is available only on Linux, macOS, and Windows systems. none : Specifying this value disables the page protection. Note: Specifying all has a negative impact on performance. You should specify all only for problem diagnosis and not for production. Specifying values partialpagesonstartup or onfind can also have a negative impact on performance when the cache is being populated. There is no further impact when the cache is full or no longer being modified. modified -Xshareclasses:modified=<modified_context> Used when a JVMTI agent is installed that might modify bytecode at run time. If you do not specify this suboption and a bytecode modification agent is installed, classes are safely shared with an extra performance cost. The <modified context> is a descriptor that is chosen by the user; for example, myModification1 . This option partitions the cache so that only VMs that are using context myModification1 can share the same classes. So if, for example, you run an application with a modification context and then run it again with a different modification context, all classes are stored twice in the cache. For more information, see Sharing modified bytecode . If you are migrating from IBM\u00ae SDK, Java Technology Edition, Version 7, or earlier releases, you must set -Xshareclasses:disableBCI when you use this option to retain the same behavior. name -Xshareclasses:name=<name> Connects to a cache of a given name, creating the cache if it does not exist. This option is also used to indicate the cache that is to be modified by cache utilities; for example, destroy . Use the listAllCaches utility to show which named caches are currently available. If you do not specify a name, the default name \"sharedcc_%u\" is used. \"%u\" in the cache name inserts the current user name. On operating systems other than Windows, you can specify \"%g\" in the cache name to insert the current group name. Note: It is good practice to explicitly specify a cache for your application. This avoids the application sharing a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note that you cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. See Class data sharing: Best practices for using -Xshareclasses . noaot -Xshareclasses:noaot Disables caching and loading of AOT code. AOT code already in the shared data cache can be loaded. noBootclasspath -Xshareclasses:noBootclasspath Disables the storage of classes that are loaded by the bootstrap class loader in the shared classes cache. Often used with the SharedClassURLFilter API to control exactly which classes are cached. For more information about shared class filtering, see The Java shared classes Helper API . noTimestampChecks -Xshareclasses:noTimestampChecks Turns off timestamp checking when finding classes in the shared cache. Use this option only when you know there are no updates to the classes from the class paths or module paths in your application. Otherwise, obsolete classes might be loaded from the shared cache. If this happens, remove the noTimestampChecks option. nocheckURLTimestamps -Xshareclasses:nocheckURLTimestamps Timestamps of jar or zip files are checked only when they are added to a class loader and used for the first time to look up a class. This is the default behavior, which can improve the performance of class loading from the shared classes cache, especially on Windows systems. To revert to the behavior of the shared classes cache in earlier releases, use the CheckURLTimeStamps suboption. Restriction: When the nocheckURLTimestamps suboption is used (default), if jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. If this scenario occurs, use the checkURLTimestamps option. nojitdata -Xshareclasses:nojitdata Disables caching of JIT data. JIT data already in the shared data cache can be loaded. none -Xshareclasses:none Added to the end of a command line, disables class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption disables the shared class utility APIs. To disable class data sharing without disabling the utility APIs, use the utilities suboption. For more information about the shared class utility APIs, see The Java shared classes utility API . nonfatal -Xshareclasses:nonfatal Allows the VM to start, in most cases, even if class data sharing fails. Normal behavior for the VM is to refuse to start if class data sharing fails. If you select nonfatal and the shared classes cache fails to initialize, the VM attempts to connect to the cache in read-only mode. If this attempt fails, the VM starts without class data sharing. See also fatal . Note: Unless it is important that your application runs with class data sharing, it is good practice to set this parameter. See Creating a shared classes cache . However, cache corruption as a result of a bug in the operating system, VM, or user code might not be detected when opening the cache. In this situation, the cache is used and the application might crash. nonpersistent -Xshareclasses:nonpersistent Uses a non-persistent cache. The cache is lost when the operating system shuts down. Non-persistent and persistent caches can have the same name. On Linux, macOS, and Windows systems, you must always use the nonpersistent suboption when you run utilities such as destroy on a non-persistent cache. z/OS supports only non-persistent caches. Note: On macOS systems, you must set kern.sysv.shmmax and kern.sysv.shmall when using a non-persistent cache. noPersistentDiskSpaceCheck -Xshareclasses:noPersistentDiskSpaceCheck Instructs the VM not to check for available storage on the file system before creating a persistent shared classes cache. This option prevents an error on file systems that do not support the checking of free space, where a value of 0 is returned and a shared cache cannot be created. Regardless of whether you choose to set this option, if there isn't enough disk space available when the VM writes to the shared cache memory, a SIGBUS or SIGSEGV signal occurs and the VM ends. If you are using the readonly suboption, the VM does not check the available disk space, so you do not need to set the noPersistentDiskSpaceCheck suboption. persistent -Xshareclasses:persistent Uses a persistent cache. The cache is created on disk, which persists beyond operating system restarts. Non-persistent and persistent caches can have the same name. On AIX, you must always use the persistent suboption when you run utilities such as destroy on a persistent cache. Note: Persisent caches are not supported on z/OS systems. z/OS supports only non-persistent caches. printAllStats (Cache utility) -Xshareclasses:printAllStats Displays detailed information about the contents of the cache that is specified in the name suboption. If the name is not specified, statistics are displayed about the default cache. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats=all ). Every class is listed in chronological order with a reference to the location from which it was loaded. For more information, see Shared classes cache diagnostic utilities . printStats (Cache utility) -Xshareclasses:printStats=<data_type>[+<data_type>] Displays summary information for the cache that is specified by the name , cacheDir , and nonpersistent suboptions. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats ). The most useful information that is displayed is how full the cache is and how many classes it contains. Stale classes are classes that are updated on the file system and which the cache has therefore marked as \"stale\". Stale classes are not purged from the cache and can be reused. Use the printStats=stale option to list all the stale entries and stale bytes. Specify one or more data types, which are separated by a plus symbol (+), to see more detailed information about the cache content. Data types include AOT data, class paths, and ROMMethods. For more information and for a full list of data types, see Shared classes cache diagnostic utilities . printTopLayerStats (Cache utility) -Xshareclasses:printTopLayerStats=<data_type>[+<data_type>] Equivalent to printStats but for the top layer cache only. For more information about layered caches, see Creating a layer cache . readonly -Xshareclasses:readonly By default, a shared classes cache is created with read/write access. Use the readonly suboption to open an existing cache with read-only permissions. Opening a cache read-only prevents the VM from making any updates to the cache. If you specify this suboption, the VM can connect to caches that were created by other users or groups without requiring write access. On AIX, Linux, and macOS systems, this access is permitted only if the cache was created by using the -Xshareclasses:cacheDir option to specify a directory with appropriate permissions. If you do not use the -Xshareclasses:cacheDir option, the cache is created with default permissions, which do not permit access by other users or groups. By default, this suboption is not specified. reset -Xshareclasses:reset Causes a cache to be destroyed and then re-created when the VM starts up. This option can be added to the end of a command line as -Xshareclasses:reset . restoreFromSnapshot (Cache utility) (Not Windows) -Xshareclasses:restoreFromSnapshot Restores a new non-persistent shared cache from a snapshot file. The snapshot and shared cache have the same name and location, as specified by the name and cacheDir suboptions. The non-persistent cache cannot already exist when the snapshot is restored. Restoring a snapshot does not remove the snapshot file; it can be restored multiple times. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to restore a snapshot. restrictClasspaths -Xshareclasses:restrictClasspaths Allows only the first VM that is initializing a shared cache to store classpaths in the cache. Subsequent VMs are not allowed to store classpaths in the cache unless the allowClasspaths option is specified. Use the restrictClasspaths option only if the application is designed to create class loaders of type java.net.URLClassloader or its subclass, such that their classpaths are unique to the instance of the application, but the classes that are loaded from these classpaths are the same. In such cases application classpaths that are stored by one VM cannot be used by another VM. For example, consider two VMs, VM1 and VM2, that are using class paths CP1 and CP2 respectively, where: CP1: url1;url2;url3;tempurl1;url4;url5 CP2: url1;url2;url3;tempurl2;url4;url5 These class paths differ only by one entry, which is the tempurl . The url1 , url2 , url3 , url4 , and url5 entries never change from run to run, whereas the tempurl entry is always different. This difference means that a class that is loaded from url4 or url5 , and stored into the shared cache by VM1, cannot be located by VM2. Therefore, an attempt by VM2 to load a class from url4 or url5 would cause it to store its own classpath CP2 into the shared cache, and also add new metadata for classes that are loaded from url4 or url5 . Addition of such unique class paths into the shared cache is not useful. Moreover, the additional metadata might adversely affect the performance of other VMs that connect to the shared cache. Because classes loaded from url4 or url5 are not loaded from the shared cache when the tempurl differs from the original, it is good practice to put the tempurl as the last entry in the class path. In situations such as that described in the example, the restrictClasspaths option can be used to restrict the addition of classpaths by ensuring that the first VM initializes the shared cache, and then prevents the addition of unique classpaths by subsequent VMs that attach to the shared cache. Note that use of the restrictClasspaths option in any other scenario is likely to negatively impact a VM's performance when it is using an existing cache. revalidateAotMethods (Cache utility) -Xshareclasses:revalidateAotMethods=<method_specification> -Xshareclasses:revalidateAotMethods=help Modify the shared cache to revalidate the AOT methods that match the method specifications. Use this suboption to revalidate AOT methods that were invalidated by using the invalidateAotMethods suboption. Revalidated AOT methods are then eligible for loading into a VM, but do not affect VMs where the methods have already been processed. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax . silent -Xshareclasses:silent Disables all shared class messages, including error messages. Unrecoverable error messages, which prevent the VM from initializing, are displayed. snapshotCache (Cache utility) (Not Windows) -Xshareclasses:snapshotCache Creates a snapshot file of an existing non-persistent shared cache. The snapshot has the same name and location as the shared cache, as specified by the name and cacheDir suboptions. The shared cache can be in use when the snapshot is taken, but VMs are blocked when they try to write to the shared cache, while the cache data is copied to the file. Typically, after a system is reinitialized, the snapshot file is used to restore the copy of the non-persistent cache into shared memory, via the restoreFromSnapshot suboption. Since this process removes all non-persistent caches from shared memory, restoring the cache from the snapshot file can result in better VM startup performance, because the contents of the shared cache, including classes and AOT code, do not have to be re-created. A snapshot can be created only if the user has sufficient permissions to create the destination snapshot file. If a snapshot of the same name exists already, it is overwritten. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to create a snapshot. For information about removing snapshot files, see the destroySnapshot and destroyAllSnapshots suboptions. utilities -Xshareclasses:utilities Can be added to the end of a command line to disable class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption is like none , but does not disable the shared class utility APIs. For more information, see The Java shared classes utility API . verbose -Xshareclasses:verbose Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders ask their parents for a class if they can't find it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy. The standard option -verbose:class also enables class sharing verbose output if class sharing is enabled. verboseAOT -Xshareclasses:verboseAOT Enables verbose output when compiled AOT code is being found or stored in the cache. AOT code is generated heuristically. You might not see any AOT code that is generated at all for a small application. You can disable AOT caching by using the noaot suboption. See the VM Messages Guide for a list of the messages produced. verboseHelper -Xshareclasses:verboseHelper Enables verbose output for the Java Helper API. This output shows you how the Helper API is used by your class loader. verboseIO -Xshareclasses:verboseIO Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders must ask their parents for a class before they can load it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy. Method specification syntax The following examples show how to specify more than one method specification when you are using the findAotMethods , invalidateAotMethods , or revalidateAotMethods suboptions. Each method specification is defined as follows: <packagename>/<classname>[.<methodname>[(<parameters>)]] If you want to include more than one method specification in a single option, separate the specifications with a comma and enclose all the specifications in {braces}. For example: {<packagename/classname>}[.{<methodname>}[({<parameters>})]] You can use an asterisk (*) in most places as a wildcard. You can use an exclamation point (!) before the specification to mean \"everything except this\". Parameters are optional, but if specified, should be enclosed in parentheses and the following native signature formats must be used: B for byte C for char D for double F for float I for int J for long S for short Z for Boolean L<classname>; for objects [ before the signature means array If you want to specify parameters to distinguish between methods, you can use -Xshareclasses:findAotMethods=* (with a wildcard) to list all the parameter variations. Copy the signature for the method that you want from the output. For example, the signature for the parameters (byte[] bytes, int offset, int length, Charset charset) is ([BIILjava/nio/charset/Charset;) Here are some examples: Method signature Matches... * All AOT methods. java/lang/Object All AOT methods in the java.lang.Object class java/util/* All AOT classes and methods in the java.util package java/util/HashMap.putVal All putVal methods in the java.util.HashMap class java/util/HashMap.hash(Ljava/lang/Object;) The private java.util.HashMap.hash(java.lang.Object) method *.equals All equals methods in all classes {java/lang/Object,!java/lang/Object.clone} All methods in java.lang.Object except clone {java/util/*.*(),java/lang/Object.*(*)} All classes or methods with no input parameter in the java.util package, and all methods in java.lang.Object {java/util/*.*(),!java/util/*.*()} Nothing. Introduction to class data sharing -Xscmx -XX:SharedCacheHardLimit","title":"-Xshareclasses"},{"location":"xshareclasses/#-xshareclasses","text":"Use the -Xshareclasses option to enable, disable, or modify class sharing behavior. Class data sharing is enabled by default for bootstrap classes only (the equivalent of specifying -Xshareclasses:bootClassesOnly,nonFatal,silent ), unless your application is running in a container. This option can take a number of parameters, some of which are cache utilities . Cache utilities carry out specific operations on a specified cache without starting the Java virtual machine (VM). Although you can combine multiple suboptions, which are separated by commas, the cache utilities are mutually exclusive. Some cache utilities can work with caches from previous Java\u2122 versions or caches that are created by VMs with different bit-widths. These caches are referred to as \"incompatible\" caches. See also the Class data sharing topic, which includes some best practices for using -Xshareclasses .","title":"-Xshareclasses"},{"location":"xshareclasses/#syntax","text":"-Xshareclasses:<parameter> When you specify -Xshareclasses without any parameters and without specifying either the -Xscmx or -XX:SharedCacheHardLimit options, a shared classes cache is created with a default size, as follows: For 64-bit platforms, the default size is 300 MB, with a \"soft\" maximum limit for the initial size of the cache ( -Xscmx ) of 64MB, with the following exceptions: For a persistent cache, if the free disk space is less than 6 GB, the default size is set to 64 MB and an -Xscmx size is not set. For a non-persistent cache on Linux\u00ae or macOS\u00ae systems, the cache size is limited by the maximum amount of memory that can be reserved by a process ( SHMMAX ). If SHMMAX is less than 300MB, the default shared cache size is set to equal SHMMAX . If SHMMAX is greater than 80 MB, -Xscmx is set to 64 MB. If SHMMAX is less than 80MB an -Xscmx size is not set. For other platforms, the default size is 16MB.","title":"Syntax"},{"location":"xshareclasses/#parameters","text":"","title":"Parameters"},{"location":"xshareclasses/#adjustmaxaot-cache-utility","text":"-Xshareclasses:adjustmaxaot=<size> Adjusts the maximum shared classes cache space that is allowed for AOT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxaot option.","title":"adjustmaxaot (Cache utility)"},{"location":"xshareclasses/#adjustminaot-cache-utility","text":"-Xshareclasses:adjustminaot=<size> Adjusts the minimum shared classes cache space that is reserved for AOT data. Use the -Xscminaot option to set the initial minimum size.","title":"adjustminaot (Cache utility)"},{"location":"xshareclasses/#adjustmaxjitdata-cache-utility","text":"-Xshareclasses:adjustmaxjitdata=<size> Adjusts the maximum shared classes cache space that is allowed for JIT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxjitdata option.","title":"adjustmaxjitdata (Cache utility)"},{"location":"xshareclasses/#adjustminjitdata-cache-utility","text":"-Xshareclasses:adjustminjitdata=<size> Adjusts the minimum shared classes cache space that is reserved for JIT data. Use the -Xscminjitdata option to set the initial minimum size.","title":"adjustminjitdata (Cache utility)"},{"location":"xshareclasses/#adjustsoftmx-cache-utility","text":"-Xshareclasses:adjustsoftmx=<size> Adjusts the soft maximum size of the cache. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. For more information about the soft maximum size, see -Xscmx .","title":"adjustsoftmx (Cache utility)"},{"location":"xshareclasses/#allowclasspaths","text":"-Xshareclasses:allowClasspaths Allows a VM to store classpaths into an existing shared cache that was created by using the restrictClasspaths option.","title":"allowClasspaths"},{"location":"xshareclasses/#bootclassesonly","text":"-Xshareclasses:bootClassesOnly Disables caching of classes that are loaded by class loaders other than the bootstrap class loader. If you use this suboption, the nonfatal suboption is also set, so this suboption is the equivalent of specifying -Xshareclasses:bootClassesOnly,nonfatal .","title":"bootClassesOnly"},{"location":"xshareclasses/#cachedir","text":"-Xshareclasses:cacheDir=<directory> Sets the directory in which cache data is read and written. Please do not set the cache directory on a NFS mount or a shared mount across systems or LPARs. The following defaults apply: On Windows\u2122 systems, <directory> is the user's C:\\Users\\<username>\\AppData\\Local\\javasharedresources directory. On z/OS\u00ae systems, <directory> is the /tmp/javasharedresources directory. On other operating systems, <directory> is javasharedresources in the user's home directory, unless the groupAccess parameter is specified, in which case it is /tmp/javasharedresources , because some members of the group might not have access to the user's home directory. You must have sufficient permissions in <directory> . Do not set user's home directory on a NFS or shared mount. On AIX\u00ae, Linux, macOS, and Windows systems, the VM writes persistent cache files directly into the directory specified. Persistent cache files can be safely moved and deleted from the file system. Non-persistent caches are stored in shared memory and have control files that describe the location of the memory. Control files are stored in a javasharedresources subdirectory of the cacheDir specified. Do not move or delete control files in this directory. The listAllCaches utility, the destroyAll utility, and the expire suboption work only in the scope of a given cacheDir . On AIX, Linux, and macOS systems, if you specify the cacheDir=<directory> option, persistent caches are created with the following permissions ( -rw-r--r-- ): User: read/write Group: read (read/write if you also specify -Xshareclasses:groupAccess ) Other: read only Otherwise, persistent caches are created with the same permissions as non-persistent caches. The permissions for non-persistent caches are -rw-r----- , or -rw-rw---- if you also specify -Xshareclasses:groupAccess . Note: It is good practice to set an application-specific cache directory to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory, and means that your application is therefore unaffected by a user running java -Xshareclasses:destroyAll . See Class data sharing: Best practices for using -Xshareclasses .","title":"cacheDir"},{"location":"xshareclasses/#cachedirperm","text":"(Not Windows) -Xshareclasses:cacheDirPerm=<permission> Sets Unix-style permissions when you are creating a cache directory. <permission> must be an octal number in the ranges 0700 - 0777 or 1700 - 1777. If <permission> is not valid, the VM ends with an appropriate error message. The permissions that are specified by this suboption are used only when you are creating a new cache directory. If the cache directory already exists, this suboption is ignored and the cache directory permissions are not changed. If you set this suboption to 0000, the default directory permissions are used. If you set this suboption to 1000, the machine default directory permissions are used, but the sticky bit is enabled. If the cache directory is the platform default directory, /tmp/javasharedresources , this suboption is ignored and the cache directory permissions are set to 0777. If you do not set this suboption, the default permissions are used according to the following conditions: Condition Permissions The cache directory is /tmp/javasharedresources . If this directory already exists with different permissions, the permissions are changed when the cache is opened.\u2020 0777 The cache directory is a new directory and you also specify the groupAcess suboption 0770 The cache directory is a new directory and you do not specify the groupAccess suboption 0700 The cache directory already exists and is not /tmp/javasharedresources Unchanged \u2020On z/OS\u00ae systems, permissions for existing cache directories are unchanged, to avoid generating RACF\u00ae errors, which generate log messages. Note: It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. See Class data sharing: Best practices for using -Xshareclasses .","title":"cacheDirPerm"},{"location":"xshareclasses/#cacheretransformed","text":"-Xshareclasses:cacheRetransformed Enables caching of classes that are transformed by using the JVMTI RetransformClasses function. For more information, see Redefined and retransformed classes . The option enableBCI is enabled by default. However, if you use the cacheRetransformed option, this option forces cache creation into -Xshareclasses:disableBCI mode.","title":"cacheRetransformed"},{"location":"xshareclasses/#checkurltimestamps","text":"-Xshareclasses:checkURLTimestamps Causes timestamps of jar or zip files to be checked every time a class is loaded. If a timestamp has changed, the class is loaded from the jar or zip file and not from the shared cache. This suboption is not enabled by default and reflects the legacy behavior of the shared classes cache. Note: The timestamp of a bootstrap jar or zip file is checked once when it is used for the first time to load a class.","title":"checkURLTimestamps"},{"location":"xshareclasses/#createlayer","text":"(64-bit only) -Xshareclasses:createLayer Creates layered caches. If there are multiple VMs in a race condition while creating a layered cache, more than one new layered cache can be created. To avoid this situation, use the -Xshareclasses:layer=<number> suboption to create a new layered cache with a specific layer number. See layer for more information about layered caches.","title":"createLayer"},{"location":"xshareclasses/#destroy-cache-utility","text":"-Xshareclasses:destroy Destroys a cache that is specified by the name , cacheDir , and nonpersistent suboptions. A cache can be destroyed only if all VMs that are using it have ended and the user has sufficient permissions.","title":"destroy (Cache utility)"},{"location":"xshareclasses/#destroyall-cache-utility","text":"-Xshareclasses:destroyAll Tries to destroy all the caches that are specified by the cacheDir and nonpersistent suboptions. On Windows and z/OS systems, a cache can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Note: On z/OS, when the destroyAll option is invoked from a 31-bit VM, 64-bit caches are not destroyed. Similarly, when the destroyAll option is invoked from a 64-bit VM, 31-bit caches are not destroyed. The following message is displayed: JVMSHRC735I: Use a nn-bit VM to perform the requested operation on the nn-bit shared cache \"cachename\" as the nn-bit VM cannot verify that the shared memory was created by the VM. On AIX, Linux, and macOS systems: Non-persistent caches can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Persistent caches that are still in use continue to exist even when you use this option, but they are unlinked from the file system so they are not visible to new VM invocations. If you update the VM then restart an application for which a persistent shared cache already exists, the VM unlinks the existing cache and creates a new cache. Because the unlinked caches are not visible to new VMs, you cannot find them by using the -Xshareclasses:listAllCaches option, and you cannot use the -Xshareclasses:printStats option on them. You can therefore have multiple unlinked caches that consume file system space until they are no longer in use.","title":"destroyAll (Cache utility)"},{"location":"xshareclasses/#destroyalllayers-cache-utility","text":"(64-bit only) -Xshareclasses:destroyAllLayers Destroys all shared cache layers that are specified by the name suboption. For example, -Xshareclasses:name=Cache1,destroyAllLayers destroys all layers of the cache called Cache1 . If you use the destroy suboption on a layered cache, for example -Xshareclasses:name=Cache1,destroy , only the top layer of the cache is destroyed. For more information about layered caches, see Creating layer caches .","title":"destroyAllLayers (Cache utility)"},{"location":"xshareclasses/#destroyallsnapshots-cache-utility","text":"(Not Windows) -Xshareclasses:destroyAllSnapshots Destroys all shared cache snapshots that are available as a result of the specified cacheDir suboption.","title":"destroyAllSnapshots (Cache utility)"},{"location":"xshareclasses/#destroysnapshot-cache-utility","text":"(Not Windows) -Xshareclasses:destroySnapshot Destroys a snapshot that is specified by the name and cacheDir suboptions.","title":"destroySnapshot (Cache utility)"},{"location":"xshareclasses/#disablebci","text":"-Xshareclasses:disableBCI Turns off BCI support. This option can be used to override -XXShareClassesEnableBCI .","title":"disableBCI"},{"location":"xshareclasses/#enablebci","text":"-Xshareclasses:enableBCI This option is enabled by default. Allows a JVMTI ClassFileLoadHook event to be triggered every time, for classes that are loaded from the cache. This mode also prevents caching of classes that are modified by JVMTI agents. For more information about bytecode modification, see Support for bytecode instrumentation . This option is incompatible with the cacheRetransformed option. Using the two options together causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created without the enableBCI suboption cannot be reused with the enableBCI suboption. Attempting to do so causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created with the enableBCI suboption can be reused without specifying this suboption. In this case, the VM detects that the cache was created with the enableBCI suboption and uses the cache in this mode.","title":"enableBCI"},{"location":"xshareclasses/#expire-cache-utility","text":"-Xshareclasses:expire=<time_in_minutes> Destroys all caches that are unused for the time that is specified before loading shared classes. This option is not a utility option because it does not cause the VM to exit. On Windows systems, which have NTFS file systems, the expire option is accurate to the nearest hour.","title":"expire (Cache utility)"},{"location":"xshareclasses/#fatal","text":"-Xshareclasses:fatal The VM does not start if class data sharing fails, for example because there was an error when accessing the cache directory. An error message is generated. This suboption is specified by default unless you use the bootClassesOnly suboption, which is equivalent to -Xshareclasses:bootClassesOnly,nonfatal . You can override this behavior by specifying -Xshareclasses:bootClassesOnly,fatal . See also nonfatal .","title":"fatal"},{"location":"xshareclasses/#findaotmethods-cache-utility","text":"-Xshareclasses:findAotMethods=<method_specification> -Xshareclasses:findAotMethods=help Print the AOT methods in the shared classes cache that match the method specifications. Methods that are already invalidated are indicated in the output. Use this suboption to check which AOT methods in the shared classes cache would be invalidated by using the same method specifications with the invalidateAotMethods suboption. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax .","title":"findAotMethods (Cache utility)"},{"location":"xshareclasses/#groupaccess","text":"(Not Windows) -Xshareclasses:groupAccess Sets operating system permissions on a new cache to allow group access to the cache. Group access can be set only when permitted by the operating system umask setting. The default is user access only. On AIX, Linux, and macOS systems, if a user creates a cache by specifying the groupAccess suboption, other users in the same group must also specify this suboption to be granted access to the same cache. When groupAccess is specified, the default directory for a cache is /tmp/javasharedresources . Some systems might clear the content of the /tmp directory on a reboot, removing the shared cache. To avoid that problem, you are therefore recommended to use cacheDir to set a different location for the cache. If necessary, use cacheDirPerm to ensure that the cache directory permissions are set appropriately. In certain situations, warning messages might be generated when the groupAccess suboption is used. This message can occur when persistent caches are used: JVMSHRC756W Failed to set group access permission on the shared cache file as requested by the 'groupAccess' sub-option These messages can occur when non-persistent caches are used: JVMSHRC759W Failed to set group access permission as requested by the 'groupAccess' sub-option on the semaphore control file associated with shared classes cache. JVMSHRC760W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared memory control file associated with shared classes cache. This message can occur in combination with the snapshotCache suboption: JVMSHRC761W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared cache snapshot file. All of these warning messages mean that the user's umask setting does not allow either, or both, of the group read and write permission to be set on the file. The typical umask setting restricts only the write permission. To resolve the warning, either change the umask setting or remove the groupAccess suboption.","title":"groupAccess"},{"location":"xshareclasses/#help","text":"-Xshareclasses:help Lists all the command-line options.","title":"help"},{"location":"xshareclasses/#invalidateaotmethods-cache-utility","text":"-Xshareclasses:invalidateAotMethods=<method_specification> -Xshareclasses:invalidateAotMethods=help Modify the existing shared cache to invalidate the AOT methods that match the method specifications. Use this suboption to invalidate AOT methods that cause a failure in the application, without having to destroy the shared cache. Invalidated AOT methods remain in the shared cache, but are then excluded from being loaded. VMs that have not processed the methods, or new VMs that use the cache are not affected by the invalidated methods. The AOT methods are invalidated for the lifetime of the cache, but do not prevent the AOT methods from being compiled again if a new shared cache is created. To prevent AOT method compilation into a new shared cache, use the -Xaot:exclude option. For more information, see -Xaot . To identify AOT problems, see Diagnosing a JIT or AOT problem . To revalidate an AOT method, see the revalidateAotMethods suboption. Use the findAotMethod suboption to determine which AOT methods match the method specifications. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax .","title":"invalidateAotMethods (Cache utility)"},{"location":"xshareclasses/#layer","text":"(64-bit only) -Xshareclasses:layer=<number> Creates layered caches. This suboption has the same effect as the createLayer suboption, but with the added ability to specify the layer number. For more information about creating a shared classes cache with layers, see Creating layer caches .","title":"layer"},{"location":"xshareclasses/#listallcaches-cache-utility","text":"-Xshareclasses:listAllCaches Lists all the compatible and incompatible caches, and snapshots that exist in the specified cache directory. If you do not specify cacheDir , the default directory is used. Summary information, such as Java version and current usage, is displayed for each cache. Output includes cache-type (persistent or non-persistent) and feature (compressed references ( cr ) or non-compressed references ( non-cr )).","title":"listAllCaches (Cache utility)"},{"location":"xshareclasses/#mprotect","text":"AIX, z/OS 31-bit: -Xshareclasses:mprotect=[default|all|none] Linux, Windows, macOS: -Xshareclasses:mprotect=[default|all|partialpagesonstartup|onfind|nopartialpages|none] where: default : By default, the memory pages that contain the cache are always protected, unless a specific page is being updated. This protection helps prevent accidental or deliberate corruption to the cache. The cache header is not protected by default because this protection has a performance cost. On Linux, macOS, and Windows systems, after the startup phase, the Java virtual machine (VM) protects partially filled pages whenever new data is added to the shared classes cache in the following sequence: The VM changes the memory protection of any partially filled pages to read/write. The VM adds the data to the cache. The VM changes the memory protection of any partially filled pages to read only. all : This value ensures that all the cache pages are protected, including the header. See Note. partialpagesonstartup : This value causes the VM to protect partially filled pages during startup as well as after the startup phase. This value is available only on Linux, macOS, and Windows systems. onfind : When this option is specified, the VM protects partially filled pages when it reads new data in the cache that is added by another VM. This option is available only on Linux, macOS, and Windows systems. nopartialpages : Use this value to turn off the protection of partially filled pages. This value is available only on Linux, macOS, and Windows systems. none : Specifying this value disables the page protection. Note: Specifying all has a negative impact on performance. You should specify all only for problem diagnosis and not for production. Specifying values partialpagesonstartup or onfind can also have a negative impact on performance when the cache is being populated. There is no further impact when the cache is full or no longer being modified.","title":"mprotect"},{"location":"xshareclasses/#modified","text":"-Xshareclasses:modified=<modified_context> Used when a JVMTI agent is installed that might modify bytecode at run time. If you do not specify this suboption and a bytecode modification agent is installed, classes are safely shared with an extra performance cost. The <modified context> is a descriptor that is chosen by the user; for example, myModification1 . This option partitions the cache so that only VMs that are using context myModification1 can share the same classes. So if, for example, you run an application with a modification context and then run it again with a different modification context, all classes are stored twice in the cache. For more information, see Sharing modified bytecode . If you are migrating from IBM\u00ae SDK, Java Technology Edition, Version 7, or earlier releases, you must set -Xshareclasses:disableBCI when you use this option to retain the same behavior.","title":"modified"},{"location":"xshareclasses/#name","text":"-Xshareclasses:name=<name> Connects to a cache of a given name, creating the cache if it does not exist. This option is also used to indicate the cache that is to be modified by cache utilities; for example, destroy . Use the listAllCaches utility to show which named caches are currently available. If you do not specify a name, the default name \"sharedcc_%u\" is used. \"%u\" in the cache name inserts the current user name. On operating systems other than Windows, you can specify \"%g\" in the cache name to insert the current group name. Note: It is good practice to explicitly specify a cache for your application. This avoids the application sharing a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note that you cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. See Class data sharing: Best practices for using -Xshareclasses .","title":"name"},{"location":"xshareclasses/#noaot","text":"-Xshareclasses:noaot Disables caching and loading of AOT code. AOT code already in the shared data cache can be loaded.","title":"noaot"},{"location":"xshareclasses/#nobootclasspath","text":"-Xshareclasses:noBootclasspath Disables the storage of classes that are loaded by the bootstrap class loader in the shared classes cache. Often used with the SharedClassURLFilter API to control exactly which classes are cached. For more information about shared class filtering, see The Java shared classes Helper API .","title":"noBootclasspath"},{"location":"xshareclasses/#notimestampchecks","text":"-Xshareclasses:noTimestampChecks Turns off timestamp checking when finding classes in the shared cache. Use this option only when you know there are no updates to the classes from the class paths or module paths in your application. Otherwise, obsolete classes might be loaded from the shared cache. If this happens, remove the noTimestampChecks option.","title":"noTimestampChecks"},{"location":"xshareclasses/#nocheckurltimestamps","text":"-Xshareclasses:nocheckURLTimestamps Timestamps of jar or zip files are checked only when they are added to a class loader and used for the first time to look up a class. This is the default behavior, which can improve the performance of class loading from the shared classes cache, especially on Windows systems. To revert to the behavior of the shared classes cache in earlier releases, use the CheckURLTimeStamps suboption. Restriction: When the nocheckURLTimestamps suboption is used (default), if jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. If this scenario occurs, use the checkURLTimestamps option.","title":"nocheckURLTimestamps"},{"location":"xshareclasses/#nojitdata","text":"-Xshareclasses:nojitdata Disables caching of JIT data. JIT data already in the shared data cache can be loaded.","title":"nojitdata"},{"location":"xshareclasses/#none","text":"-Xshareclasses:none Added to the end of a command line, disables class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption disables the shared class utility APIs. To disable class data sharing without disabling the utility APIs, use the utilities suboption. For more information about the shared class utility APIs, see The Java shared classes utility API .","title":"none"},{"location":"xshareclasses/#nonfatal","text":"-Xshareclasses:nonfatal Allows the VM to start, in most cases, even if class data sharing fails. Normal behavior for the VM is to refuse to start if class data sharing fails. If you select nonfatal and the shared classes cache fails to initialize, the VM attempts to connect to the cache in read-only mode. If this attempt fails, the VM starts without class data sharing. See also fatal . Note: Unless it is important that your application runs with class data sharing, it is good practice to set this parameter. See Creating a shared classes cache . However, cache corruption as a result of a bug in the operating system, VM, or user code might not be detected when opening the cache. In this situation, the cache is used and the application might crash.","title":"nonfatal"},{"location":"xshareclasses/#nonpersistent","text":"-Xshareclasses:nonpersistent Uses a non-persistent cache. The cache is lost when the operating system shuts down. Non-persistent and persistent caches can have the same name. On Linux, macOS, and Windows systems, you must always use the nonpersistent suboption when you run utilities such as destroy on a non-persistent cache. z/OS supports only non-persistent caches. Note: On macOS systems, you must set kern.sysv.shmmax and kern.sysv.shmall when using a non-persistent cache.","title":"nonpersistent"},{"location":"xshareclasses/#nopersistentdiskspacecheck","text":"-Xshareclasses:noPersistentDiskSpaceCheck Instructs the VM not to check for available storage on the file system before creating a persistent shared classes cache. This option prevents an error on file systems that do not support the checking of free space, where a value of 0 is returned and a shared cache cannot be created. Regardless of whether you choose to set this option, if there isn't enough disk space available when the VM writes to the shared cache memory, a SIGBUS or SIGSEGV signal occurs and the VM ends. If you are using the readonly suboption, the VM does not check the available disk space, so you do not need to set the noPersistentDiskSpaceCheck suboption.","title":"noPersistentDiskSpaceCheck"},{"location":"xshareclasses/#persistent","text":"-Xshareclasses:persistent Uses a persistent cache. The cache is created on disk, which persists beyond operating system restarts. Non-persistent and persistent caches can have the same name. On AIX, you must always use the persistent suboption when you run utilities such as destroy on a persistent cache. Note: Persisent caches are not supported on z/OS systems. z/OS supports only non-persistent caches.","title":"persistent"},{"location":"xshareclasses/#printallstats-cache-utility","text":"-Xshareclasses:printAllStats Displays detailed information about the contents of the cache that is specified in the name suboption. If the name is not specified, statistics are displayed about the default cache. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats=all ). Every class is listed in chronological order with a reference to the location from which it was loaded. For more information, see Shared classes cache diagnostic utilities .","title":"printAllStats (Cache utility)"},{"location":"xshareclasses/#printstats-cache-utility","text":"-Xshareclasses:printStats=<data_type>[+<data_type>] Displays summary information for the cache that is specified by the name , cacheDir , and nonpersistent suboptions. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats ). The most useful information that is displayed is how full the cache is and how many classes it contains. Stale classes are classes that are updated on the file system and which the cache has therefore marked as \"stale\". Stale classes are not purged from the cache and can be reused. Use the printStats=stale option to list all the stale entries and stale bytes. Specify one or more data types, which are separated by a plus symbol (+), to see more detailed information about the cache content. Data types include AOT data, class paths, and ROMMethods. For more information and for a full list of data types, see Shared classes cache diagnostic utilities .","title":"printStats (Cache utility)"},{"location":"xshareclasses/#printtoplayerstats-cache-utility","text":"-Xshareclasses:printTopLayerStats=<data_type>[+<data_type>] Equivalent to printStats but for the top layer cache only. For more information about layered caches, see Creating a layer cache .","title":"printTopLayerStats (Cache utility)"},{"location":"xshareclasses/#readonly","text":"-Xshareclasses:readonly By default, a shared classes cache is created with read/write access. Use the readonly suboption to open an existing cache with read-only permissions. Opening a cache read-only prevents the VM from making any updates to the cache. If you specify this suboption, the VM can connect to caches that were created by other users or groups without requiring write access. On AIX, Linux, and macOS systems, this access is permitted only if the cache was created by using the -Xshareclasses:cacheDir option to specify a directory with appropriate permissions. If you do not use the -Xshareclasses:cacheDir option, the cache is created with default permissions, which do not permit access by other users or groups. By default, this suboption is not specified.","title":"readonly"},{"location":"xshareclasses/#reset","text":"-Xshareclasses:reset Causes a cache to be destroyed and then re-created when the VM starts up. This option can be added to the end of a command line as -Xshareclasses:reset .","title":"reset"},{"location":"xshareclasses/#restorefromsnapshot-cache-utility","text":"(Not Windows) -Xshareclasses:restoreFromSnapshot Restores a new non-persistent shared cache from a snapshot file. The snapshot and shared cache have the same name and location, as specified by the name and cacheDir suboptions. The non-persistent cache cannot already exist when the snapshot is restored. Restoring a snapshot does not remove the snapshot file; it can be restored multiple times. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to restore a snapshot.","title":"restoreFromSnapshot (Cache utility)"},{"location":"xshareclasses/#restrictclasspaths","text":"-Xshareclasses:restrictClasspaths Allows only the first VM that is initializing a shared cache to store classpaths in the cache. Subsequent VMs are not allowed to store classpaths in the cache unless the allowClasspaths option is specified. Use the restrictClasspaths option only if the application is designed to create class loaders of type java.net.URLClassloader or its subclass, such that their classpaths are unique to the instance of the application, but the classes that are loaded from these classpaths are the same. In such cases application classpaths that are stored by one VM cannot be used by another VM. For example, consider two VMs, VM1 and VM2, that are using class paths CP1 and CP2 respectively, where: CP1: url1;url2;url3;tempurl1;url4;url5 CP2: url1;url2;url3;tempurl2;url4;url5 These class paths differ only by one entry, which is the tempurl . The url1 , url2 , url3 , url4 , and url5 entries never change from run to run, whereas the tempurl entry is always different. This difference means that a class that is loaded from url4 or url5 , and stored into the shared cache by VM1, cannot be located by VM2. Therefore, an attempt by VM2 to load a class from url4 or url5 would cause it to store its own classpath CP2 into the shared cache, and also add new metadata for classes that are loaded from url4 or url5 . Addition of such unique class paths into the shared cache is not useful. Moreover, the additional metadata might adversely affect the performance of other VMs that connect to the shared cache. Because classes loaded from url4 or url5 are not loaded from the shared cache when the tempurl differs from the original, it is good practice to put the tempurl as the last entry in the class path. In situations such as that described in the example, the restrictClasspaths option can be used to restrict the addition of classpaths by ensuring that the first VM initializes the shared cache, and then prevents the addition of unique classpaths by subsequent VMs that attach to the shared cache. Note that use of the restrictClasspaths option in any other scenario is likely to negatively impact a VM's performance when it is using an existing cache.","title":"restrictClasspaths"},{"location":"xshareclasses/#revalidateaotmethods-cache-utility","text":"-Xshareclasses:revalidateAotMethods=<method_specification> -Xshareclasses:revalidateAotMethods=help Modify the shared cache to revalidate the AOT methods that match the method specifications. Use this suboption to revalidate AOT methods that were invalidated by using the invalidateAotMethods suboption. Revalidated AOT methods are then eligible for loading into a VM, but do not affect VMs where the methods have already been processed. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax .","title":"revalidateAotMethods (Cache utility)"},{"location":"xshareclasses/#silent","text":"-Xshareclasses:silent Disables all shared class messages, including error messages. Unrecoverable error messages, which prevent the VM from initializing, are displayed.","title":"silent"},{"location":"xshareclasses/#snapshotcache-cache-utility","text":"(Not Windows) -Xshareclasses:snapshotCache Creates a snapshot file of an existing non-persistent shared cache. The snapshot has the same name and location as the shared cache, as specified by the name and cacheDir suboptions. The shared cache can be in use when the snapshot is taken, but VMs are blocked when they try to write to the shared cache, while the cache data is copied to the file. Typically, after a system is reinitialized, the snapshot file is used to restore the copy of the non-persistent cache into shared memory, via the restoreFromSnapshot suboption. Since this process removes all non-persistent caches from shared memory, restoring the cache from the snapshot file can result in better VM startup performance, because the contents of the shared cache, including classes and AOT code, do not have to be re-created. A snapshot can be created only if the user has sufficient permissions to create the destination snapshot file. If a snapshot of the same name exists already, it is overwritten. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to create a snapshot. For information about removing snapshot files, see the destroySnapshot and destroyAllSnapshots suboptions.","title":"snapshotCache (Cache utility)"},{"location":"xshareclasses/#utilities","text":"-Xshareclasses:utilities Can be added to the end of a command line to disable class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption is like none , but does not disable the shared class utility APIs. For more information, see The Java shared classes utility API .","title":"utilities"},{"location":"xshareclasses/#verbose","text":"-Xshareclasses:verbose Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders ask their parents for a class if they can't find it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy. The standard option -verbose:class also enables class sharing verbose output if class sharing is enabled.","title":"verbose"},{"location":"xshareclasses/#verboseaot","text":"-Xshareclasses:verboseAOT Enables verbose output when compiled AOT code is being found or stored in the cache. AOT code is generated heuristically. You might not see any AOT code that is generated at all for a small application. You can disable AOT caching by using the noaot suboption. See the VM Messages Guide for a list of the messages produced.","title":"verboseAOT"},{"location":"xshareclasses/#verbosehelper","text":"-Xshareclasses:verboseHelper Enables verbose output for the Java Helper API. This output shows you how the Helper API is used by your class loader.","title":"verboseHelper"},{"location":"xshareclasses/#verboseio","text":"-Xshareclasses:verboseIO Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders must ask their parents for a class before they can load it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy.","title":"verboseIO"},{"location":"xshareclasses/#method-specification-syntax","text":"The following examples show how to specify more than one method specification when you are using the findAotMethods , invalidateAotMethods , or revalidateAotMethods suboptions. Each method specification is defined as follows: <packagename>/<classname>[.<methodname>[(<parameters>)]] If you want to include more than one method specification in a single option, separate the specifications with a comma and enclose all the specifications in {braces}. For example: {<packagename/classname>}[.{<methodname>}[({<parameters>})]] You can use an asterisk (*) in most places as a wildcard. You can use an exclamation point (!) before the specification to mean \"everything except this\". Parameters are optional, but if specified, should be enclosed in parentheses and the following native signature formats must be used: B for byte C for char D for double F for float I for int J for long S for short Z for Boolean L<classname>; for objects [ before the signature means array If you want to specify parameters to distinguish between methods, you can use -Xshareclasses:findAotMethods=* (with a wildcard) to list all the parameter variations. Copy the signature for the method that you want from the output. For example, the signature for the parameters (byte[] bytes, int offset, int length, Charset charset) is ([BIILjava/nio/charset/Charset;) Here are some examples: Method signature Matches... * All AOT methods. java/lang/Object All AOT methods in the java.lang.Object class java/util/* All AOT classes and methods in the java.util package java/util/HashMap.putVal All putVal methods in the java.util.HashMap class java/util/HashMap.hash(Ljava/lang/Object;) The private java.util.HashMap.hash(java.lang.Object) method *.equals All equals methods in all classes {java/lang/Object,!java/lang/Object.clone} All methods in java.lang.Object except clone {java/util/*.*(),java/lang/Object.*(*)} All classes or methods with no input parameter in the java.util package, and all methods in java.lang.Object {java/util/*.*(),!java/util/*.*()} Nothing. Introduction to class data sharing -Xscmx -XX:SharedCacheHardLimit","title":"Method specification syntax"},{"location":"xsigcatch/","text":"-Xsigcatch / -Xnosigcatch Enables and disables VM signal handling code. Syntax Setting Effect Default -Xsigcatch Enable yes -Xnosigcatch Disable See also Signal handling","title":"-Xsigcatch"},{"location":"xsigcatch/#-xsigcatch-xnosigcatch","text":"Enables and disables VM signal handling code.","title":"-Xsigcatch / -Xnosigcatch"},{"location":"xsigcatch/#syntax","text":"Setting Effect Default -Xsigcatch Enable yes -Xnosigcatch Disable","title":"Syntax"},{"location":"xsigcatch/#see-also","text":"Signal handling","title":"See also"},{"location":"xsigchain/","text":"-Xsigchain / -Xnosigchain Enables and disables signal handler chaining. Syntax Setting Effect Default -Xsigchain Enable yes (except on z/OS\u00ae) -Xnosigchain Disable See also Signal handling","title":"-Xsigchain"},{"location":"xsigchain/#-xsigchain-xnosigchain","text":"Enables and disables signal handler chaining.","title":"-Xsigchain / -Xnosigchain"},{"location":"xsigchain/#syntax","text":"Setting Effect Default -Xsigchain Enable yes (except on z/OS\u00ae) -Xnosigchain Disable","title":"Syntax"},{"location":"xsigchain/#see-also","text":"Signal handling","title":"See also"},{"location":"xsignal/","text":"-Xsignal (z/OS\u00ae only) This option controls the behavior of Eclipse OpenJ9\u2122 VM signal handlers. Syntax -Xsignal:<parameter>=<value> Parameters Restriction: You cannot use these parameters together. posixSignalHandler -Xsignal:posixSignalHandler=cooperativeShutdown When the VM signal handlers for SIGSEGV, SIGILL, SIGBUS, SIGFPE, SIGTRAP, and SIGABRT end a process, they call exit() , by default. In this case, the z/OS\u2122 Language Environment\u00ae is not aware that the VM ended abnormally. With -Xsignal:posixSignalHandler=cooperativeShutdown , the VM no longer uses exit() to end the process from the signal handlers. Instead, the VM behaves in one of the following ways: In response to a z/OS hardware exception, the VM uses return() . In response to signals raised or injected by software, the VM ends the enclave with abend 3565 . Language Environment detects that the VM is ending abnormally and initiates Resource Recovery Services. userConditionHandler (31-bit z/OS only) -Xsignal:userConditionHandler=percolate This option results in similar behavior to the -XCEEHDLR option: the VM registers user condition handlers to handle the z/OS exceptions that would otherwise be handled by the VM POSIX signal handlers for the SIGBUS, SIGFPE, SIGILL, SIGSEGV, and SIGTRAP signals. As with the -XCEEHDLR option, the VM does not install POSIX signal handlers for these signals. This option differs from the -XCEEHDLR option in that the VM percolates all Language Environment\u00ae conditions that were not triggered and expected by the VM during normal running, including conditions that are severity 2 or greater. The VM generates its own diagnostic information before percolating severity 2 or greater conditions. The VM is in an undefined state after percolating a severity 2 or greater condition. Applications cannot resume running then call back into, or return to, the VM. See also -XCEEHDLR Signal handling","title":"-Xsignal"},{"location":"xsignal/#-xsignal","text":"(z/OS\u00ae only) This option controls the behavior of Eclipse OpenJ9\u2122 VM signal handlers.","title":"-Xsignal"},{"location":"xsignal/#syntax","text":"-Xsignal:<parameter>=<value>","title":"Syntax"},{"location":"xsignal/#parameters","text":"Restriction: You cannot use these parameters together.","title":"Parameters"},{"location":"xsignal/#posixsignalhandler","text":"-Xsignal:posixSignalHandler=cooperativeShutdown When the VM signal handlers for SIGSEGV, SIGILL, SIGBUS, SIGFPE, SIGTRAP, and SIGABRT end a process, they call exit() , by default. In this case, the z/OS\u2122 Language Environment\u00ae is not aware that the VM ended abnormally. With -Xsignal:posixSignalHandler=cooperativeShutdown , the VM no longer uses exit() to end the process from the signal handlers. Instead, the VM behaves in one of the following ways: In response to a z/OS hardware exception, the VM uses return() . In response to signals raised or injected by software, the VM ends the enclave with abend 3565 . Language Environment detects that the VM is ending abnormally and initiates Resource Recovery Services.","title":"posixSignalHandler"},{"location":"xsignal/#userconditionhandler","text":"(31-bit z/OS only) -Xsignal:userConditionHandler=percolate This option results in similar behavior to the -XCEEHDLR option: the VM registers user condition handlers to handle the z/OS exceptions that would otherwise be handled by the VM POSIX signal handlers for the SIGBUS, SIGFPE, SIGILL, SIGSEGV, and SIGTRAP signals. As with the -XCEEHDLR option, the VM does not install POSIX signal handlers for these signals. This option differs from the -XCEEHDLR option in that the VM percolates all Language Environment\u00ae conditions that were not triggered and expected by the VM during normal running, including conditions that are severity 2 or greater. The VM generates its own diagnostic information before percolating severity 2 or greater conditions. The VM is in an undefined state after percolating a severity 2 or greater condition. Applications cannot resume running then call back into, or return to, the VM.","title":"userConditionHandler"},{"location":"xsignal/#see-also","text":"-XCEEHDLR Signal handling","title":"See also"},{"location":"xsoftmx/","text":"-Xsoftmx This option sets a \"soft\" maximum limit for the Java\u2122 heap. Syntax -Xsoftmx<size> Explanation Use the -Xmx option to set a \"hard\" limit for the maximum size of the heap. By default, -Xsoftmx is set to the same value as -Xmx . The value of -Xms must be less than, or equal to, the value of -Xsoftmx . See Using -X command-line options for more information about the <size> parameter. You can set this option on the command line, then modify it at run time by using the MemoryMXBean.setMaxHeapSize() method in the com.ibm.lang.management API. By using this API, Java applications can dynamically monitor and adjust the heap size as required. This function can be useful in virtualized or cloud environments, for example, where the available memory might change dynamically to meet business needs. When you use the API, you must specify the value in bytes, such as 2147483648 instead of 2g . For example, you might set the initial heap size to 1 GB and the maximum heap size to 8 GB. You might set a smaller value, such as 2 GB, for -Xsoftmx , to limit the heap size that is used initially: -Xms1g -Xsoftmx2g -Xmx8g You can then use the com.ibm.lang.management API from within a Java application to increase the -Xsoftmx value during run time, as load increases. This change allows the application to use more memory than you specified initially. If you reduce the -Xsoftmx value, the garbage collector attempts to respect the new limit. However, the ability to shrink the heap depends on a number of factors. There is no guarantee that a decrease in the heap size will occur. If or when the heap shrinks to less than the new limit, the heap will not grow beyond that limit. When the heap shrinks, the garbage collector might release memory. The ability of the operating system to reclaim and use this memory varies based on the capabilities of the operating system. Notes: When using -Xgcpolicy:gencon with -Xsoftmx , the proportion of heap space used for nursery within the -Xsoftmx limit is proportional to the maximum amount of nursery space specified (see Xmn/Xmnx ) relative to the -Xmx value. For example, if the following is specified on the command line -Xsoftmx2g -Xmnx4g -Xmx8g , nursery space is allowed to use 50%(4G/8G) of the specified -Xsoftmx value, which in this example is 1G. When using -Xgcpolicy:balanced with -Xsoftmx and -Xmn / -Xmnx / -Xmns options, the maximum and minimum size for eden are absolute (rather than the proportional nursery behaviour for gencon), and do not depend on the -Xsoftmx value specified. For example, if -Xmnx1G is specified, then eden will be able to grow up to 1G in size, regardless of the -Xsoftmx value specified. This option is ignored if used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded. There might be little benefit in reducing the -Xsoftmx value when the Java heap is using large pages. Large pages are pinned in memory and are not reclaimed by the operating system, with the exception of 1M pageable pages on z/OS\u00ae. On certain platforms and processors the VM starts with large pages enabled by default for the Java heap when the operating system is configured to provide large pages. For more information, see Configuring large page memory allocation . A future version of the Java virtual machine might provide a hint to the operating system when large pages are no longer in use.","title":"-Xsoftmx"},{"location":"xsoftmx/#-xsoftmx","text":"This option sets a \"soft\" maximum limit for the Java\u2122 heap.","title":"-Xsoftmx"},{"location":"xsoftmx/#syntax","text":"-Xsoftmx<size>","title":"Syntax"},{"location":"xsoftmx/#explanation","text":"Use the -Xmx option to set a \"hard\" limit for the maximum size of the heap. By default, -Xsoftmx is set to the same value as -Xmx . The value of -Xms must be less than, or equal to, the value of -Xsoftmx . See Using -X command-line options for more information about the <size> parameter. You can set this option on the command line, then modify it at run time by using the MemoryMXBean.setMaxHeapSize() method in the com.ibm.lang.management API. By using this API, Java applications can dynamically monitor and adjust the heap size as required. This function can be useful in virtualized or cloud environments, for example, where the available memory might change dynamically to meet business needs. When you use the API, you must specify the value in bytes, such as 2147483648 instead of 2g . For example, you might set the initial heap size to 1 GB and the maximum heap size to 8 GB. You might set a smaller value, such as 2 GB, for -Xsoftmx , to limit the heap size that is used initially: -Xms1g -Xsoftmx2g -Xmx8g You can then use the com.ibm.lang.management API from within a Java application to increase the -Xsoftmx value during run time, as load increases. This change allows the application to use more memory than you specified initially. If you reduce the -Xsoftmx value, the garbage collector attempts to respect the new limit. However, the ability to shrink the heap depends on a number of factors. There is no guarantee that a decrease in the heap size will occur. If or when the heap shrinks to less than the new limit, the heap will not grow beyond that limit. When the heap shrinks, the garbage collector might release memory. The ability of the operating system to reclaim and use this memory varies based on the capabilities of the operating system. Notes: When using -Xgcpolicy:gencon with -Xsoftmx , the proportion of heap space used for nursery within the -Xsoftmx limit is proportional to the maximum amount of nursery space specified (see Xmn/Xmnx ) relative to the -Xmx value. For example, if the following is specified on the command line -Xsoftmx2g -Xmnx4g -Xmx8g , nursery space is allowed to use 50%(4G/8G) of the specified -Xsoftmx value, which in this example is 1G. When using -Xgcpolicy:balanced with -Xsoftmx and -Xmn / -Xmnx / -Xmns options, the maximum and minimum size for eden are absolute (rather than the proportional nursery behaviour for gencon), and do not depend on the -Xsoftmx value specified. For example, if -Xmnx1G is specified, then eden will be able to grow up to 1G in size, regardless of the -Xsoftmx value specified. This option is ignored if used with the metronome GC policy ( -Xgcpolicy:metronome ) because the heap is always fully expanded. There might be little benefit in reducing the -Xsoftmx value when the Java heap is using large pages. Large pages are pinned in memory and are not reclaimed by the operating system, with the exception of 1M pageable pages on z/OS\u00ae. On certain platforms and processors the VM starts with large pages enabled by default for the Java heap when the operating system is configured to provide large pages. For more information, see Configuring large page memory allocation . A future version of the Java virtual machine might provide a hint to the operating system when large pages are no longer in use.","title":"Explanation"},{"location":"xsoftrefthreshold/","text":"-Xsoftrefthreshold Sets the value used by the garbage collector to determine the number of garbage collection (GC) cycles after which a soft reference is cleared if its referent has not been marked. Syntax -Xsoftrefthreshold<value> Default behavior The default value is 32. This option can be used with all Eclipse OpenJ9\u2122 GC policies. Explanation A soft reference (where its referent is not marked) is cleared after a number of GC cycles, which is calculated as: <value> * (proportion of free heap space) For example, if -Xsoftrefthreshold is set to 32, and the heap is 25% free, soft references are cleared after 8 GC cycles.","title":"-Xsoftrefthreshold"},{"location":"xsoftrefthreshold/#-xsoftrefthreshold","text":"Sets the value used by the garbage collector to determine the number of garbage collection (GC) cycles after which a soft reference is cleared if its referent has not been marked.","title":"-Xsoftrefthreshold"},{"location":"xsoftrefthreshold/#syntax","text":"-Xsoftrefthreshold<value>","title":"Syntax"},{"location":"xsoftrefthreshold/#default-behavior","text":"The default value is 32. This option can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"Default behavior"},{"location":"xsoftrefthreshold/#explanation","text":"A soft reference (where its referent is not marked) is cleared after a number of GC cycles, which is calculated as: <value> * (proportion of free heap space) For example, if -Xsoftrefthreshold is set to 32, and the heap is 25% free, soft references are cleared after 8 GC cycles.","title":"Explanation"},{"location":"xss/","text":"-Xiss / -Xss / -Xssi Sets the stack size and increment for Java\u2122 threads. If you exceed the maximum Java thread stack size, a java/lang/OutOfMemoryError message is reported. You can use the -verbose:sizes option to find out the values that the VM is currently using. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; these options apply to the Java stack only. For the native stack option, see the link in the See also section. Syntax Setting Effect Default -Xiss<size> Set initial Java thread stack size 2 KB -Xss<size> Set maximum Java thread stack size 320 KB (31/32-bit); 1024 KB (64-bit) -Xssi<size> Set Java thread stack size increment 16 KB See Using -X command-line options for more information about the <size> parameter. See Default settings for the Eclipse OpenJ9\u2122 VM for more about default values. See also -Xmso (Native stack size for operating system threads)","title":"-Xssi"},{"location":"xss/#-xiss-xss-xssi","text":"Sets the stack size and increment for Java\u2122 threads. If you exceed the maximum Java thread stack size, a java/lang/OutOfMemoryError message is reported. You can use the -verbose:sizes option to find out the values that the VM is currently using. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; these options apply to the Java stack only. For the native stack option, see the link in the See also section.","title":"-Xiss / -Xss / -Xssi"},{"location":"xss/#syntax","text":"Setting Effect Default -Xiss<size> Set initial Java thread stack size 2 KB -Xss<size> Set maximum Java thread stack size 320 KB (31/32-bit); 1024 KB (64-bit) -Xssi<size> Set Java thread stack size increment 16 KB See Using -X command-line options for more information about the <size> parameter. See Default settings for the Eclipse OpenJ9\u2122 VM for more about default values.","title":"Syntax"},{"location":"xss/#see-also","text":"-Xmso (Native stack size for operating system threads)","title":"See also"},{"location":"xsyslog/","text":"-Xsyslog Enables operating system message logging. Notes: Changes made to message logging by using the -Xsyslog option do not affect messages written to the standard error stream ( stderr ). This option replaces the Eclipse OpenJ9\u2122 -Xlog option in Eclipse OpenJ9 version 0.24.0. If the -XX:+LegacyXlogOption is set, -Xlog behaves in the same way as -Xsyslog and with the same parameters. Syntax -Xsyslog:<parameter>{,<parameter>} Parameters Restriction: The parameters all , none and help must be used on their own and cannot be combined. However, the other parameters can be grouped. For example, to include error, vital and warning messages use -Xsyslog:error,vital,warn . For message details see OpenJ9 VM messages . help -Xsyslog:help Gives details the available parameters. (This parameter cannot be combined with others.) error -Xsyslog:error Turns on logging for all OpenJ9 VM error messages (default). vital -Xsyslog:vital Turns on logging for selected information messages JVMDUMP006I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the OpenJ9 VM (default). info -Xsyslog:info Turns on logging for all OpenJ9 VM information messages. warn -Xsyslog:warn Turns on logging for all OpenJ9 VM warning messages. config -Xsyslog:config Turns on logging for all OpenJ9 VM configuration messages. all -Xsyslog:all Turns on logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.) none -Xsyslog:none Turns off logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.)","title":"-Xsyslog"},{"location":"xsyslog/#-xsyslog","text":"Enables operating system message logging. Notes: Changes made to message logging by using the -Xsyslog option do not affect messages written to the standard error stream ( stderr ). This option replaces the Eclipse OpenJ9\u2122 -Xlog option in Eclipse OpenJ9 version 0.24.0. If the -XX:+LegacyXlogOption is set, -Xlog behaves in the same way as -Xsyslog and with the same parameters.","title":"-Xsyslog"},{"location":"xsyslog/#syntax","text":"-Xsyslog:<parameter>{,<parameter>}","title":"Syntax"},{"location":"xsyslog/#parameters","text":"Restriction: The parameters all , none and help must be used on their own and cannot be combined. However, the other parameters can be grouped. For example, to include error, vital and warning messages use -Xsyslog:error,vital,warn . For message details see OpenJ9 VM messages .","title":"Parameters"},{"location":"xsyslog/#help","text":"-Xsyslog:help Gives details the available parameters. (This parameter cannot be combined with others.)","title":"help"},{"location":"xsyslog/#error","text":"-Xsyslog:error Turns on logging for all OpenJ9 VM error messages (default).","title":"error"},{"location":"xsyslog/#vital","text":"-Xsyslog:vital Turns on logging for selected information messages JVMDUMP006I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the OpenJ9 VM (default).","title":"vital"},{"location":"xsyslog/#info","text":"-Xsyslog:info Turns on logging for all OpenJ9 VM information messages.","title":"info"},{"location":"xsyslog/#warn","text":"-Xsyslog:warn Turns on logging for all OpenJ9 VM warning messages.","title":"warn"},{"location":"xsyslog/#config","text":"-Xsyslog:config Turns on logging for all OpenJ9 VM configuration messages.","title":"config"},{"location":"xsyslog/#all","text":"-Xsyslog:all Turns on logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.)","title":"all"},{"location":"xsyslog/#none","text":"-Xsyslog:none Turns off logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.)","title":"none"},{"location":"xtgc/","text":"-Xtgc Provides garbage collection tracing options. Syntax -Xtgc:<parameter>{,<parameter>} Parameters Specify one one or more of the following parameters in a comma-separated list: backtrace -Xtgc:backtrace Before a garbage collection, a single line is printed containing the name of the main thread for garbage collection, as well as the value of the osThread slot in the J9VMThread structure. compaction -Xtgc:compaction Prints extra information showing the relative time spent by threads in the \"move\" and \"fixup\" phases of compaction concurrent -Xtgc:concurrent Prints extra information showing the activity of the concurrent mark background thread dump -Xtgc:dump Prints a line of output for every free chunk of memory in the system, including \"dark matter\" (free chunks that are not on the free list for some reason, typically because they are too small). Each line contains the base address and the size in bytes of the chunk. If the chunk is followed in the heap by an object, the size and class name of the object is also printed. This argument has a similar effect to the terse argument. file -Xtgc:file=<filename> Directs the logs to a file. Otherwise they are directed to stderr. freeList -Xtgc:freeList Before a garbage collection, prints information about the free list and allocation statistics since the last garbage collection. Prints the number of items on the free list, including \"deferred\" entries (with the scavenger, the unused space is a deferred free list entry). For TLH and non-TLH allocations, prints the total number of allocations, the average allocation size, and the total number of bytes discarded during allocation. For non-TLH allocations, also included is the average number of entries that were searched before a sufficiently large entry was found. parallel -Xtgc:parallel Produces statistics on the activity of the parallel threads during each operation (mark, sweep, scavenge etc.) of a GC cycle. rootscantime -Xtgc:rootscantime Prints duration of strong and weak roots scanning of a GC cycle. scavenger -Xtgc:scavenger Prints extra information after each scavenger collection. A histogram is produced showing the number of instances of each class, and their relative ages, present in the survivor space. The information is obtained by performing a linear walk-through of the space. terse -Xtgc:terse Dumps the contents of the entire heap before and after a garbage collection. For each object or free chunk in the heap, a line of trace output is produced. Each line contains the base address, \"a\" if it is an allocated object, and \"f\" if it is a free chunk, the size of the chunk in bytes, and, if it is an object, its class name.","title":"-Xtgc"},{"location":"xtgc/#-xtgc","text":"Provides garbage collection tracing options.","title":"-Xtgc"},{"location":"xtgc/#syntax","text":"-Xtgc:<parameter>{,<parameter>}","title":"Syntax"},{"location":"xtgc/#parameters","text":"Specify one one or more of the following parameters in a comma-separated list:","title":"Parameters"},{"location":"xtgc/#backtrace","text":"-Xtgc:backtrace Before a garbage collection, a single line is printed containing the name of the main thread for garbage collection, as well as the value of the osThread slot in the J9VMThread structure.","title":"backtrace"},{"location":"xtgc/#compaction","text":"-Xtgc:compaction Prints extra information showing the relative time spent by threads in the \"move\" and \"fixup\" phases of compaction","title":"compaction"},{"location":"xtgc/#concurrent","text":"-Xtgc:concurrent Prints extra information showing the activity of the concurrent mark background thread","title":"concurrent"},{"location":"xtgc/#dump","text":"-Xtgc:dump Prints a line of output for every free chunk of memory in the system, including \"dark matter\" (free chunks that are not on the free list for some reason, typically because they are too small). Each line contains the base address and the size in bytes of the chunk. If the chunk is followed in the heap by an object, the size and class name of the object is also printed. This argument has a similar effect to the terse argument.","title":"dump"},{"location":"xtgc/#file","text":"-Xtgc:file=<filename> Directs the logs to a file. Otherwise they are directed to stderr.","title":"file"},{"location":"xtgc/#freelist","text":"-Xtgc:freeList Before a garbage collection, prints information about the free list and allocation statistics since the last garbage collection. Prints the number of items on the free list, including \"deferred\" entries (with the scavenger, the unused space is a deferred free list entry). For TLH and non-TLH allocations, prints the total number of allocations, the average allocation size, and the total number of bytes discarded during allocation. For non-TLH allocations, also included is the average number of entries that were searched before a sufficiently large entry was found.","title":"freeList"},{"location":"xtgc/#parallel","text":"-Xtgc:parallel Produces statistics on the activity of the parallel threads during each operation (mark, sweep, scavenge etc.) of a GC cycle.","title":"parallel"},{"location":"xtgc/#rootscantime","text":"-Xtgc:rootscantime Prints duration of strong and weak roots scanning of a GC cycle.","title":"rootscantime"},{"location":"xtgc/#scavenger","text":"-Xtgc:scavenger Prints extra information after each scavenger collection. A histogram is produced showing the number of instances of each class, and their relative ages, present in the survivor space. The information is obtained by performing a linear walk-through of the space.","title":"scavenger"},{"location":"xtgc/#terse","text":"-Xtgc:terse Dumps the contents of the entire heap before and after a garbage collection. For each object or free chunk in the heap, a line of trace output is produced. Each line contains the base address, \"a\" if it is an allocated object, and \"f\" if it is a free chunk, the size of the chunk in bytes, and, if it is an object, its class name.","title":"terse"},{"location":"xthr/","text":"-Xthr Syntax -Xthr:<parameter> Parameters AdaptSpin | noAdaptSpin -Xthr:AdaptSpin -Xthr:noAdaptSpin This tuning option is available to test whether performance optimizations are negatively impacting an application. fastNotify | noFastNotify -Xthr:fastNotify -Xthr:noFastNotify When a large number of threads try to acquire a Java\u2122 monitor, throughput of an application can be reduced. This issue is known as high contention. If high contention occurs when the Java wait and notify features are regularly used, you can use -Xthr:fastNotify to increase throughput. However, -Xthr:noFastNotify is the default setting, because it is faster in all other scenarios. cfsYield | noCfsYield (Linux\u00ae only) -Xthr:cfsYield -Xthr:noCfsYield The default value, cfsYield , enables threading optimizations for running on Linux with the Completely Fair Scheduler (CFS) in the default mode ( sched_compat_yield=0 ). The noCfsYield value disables these threading optimizations. You might want to use the noCfsYield value if your application uses the Thread.yield() method extensively, because otherwise you might see a performance decrease in cases where yielding is not beneficial. minimizeUserCPU -Xthr:minimizeUserCPU Minimizes user-mode CPU usage in thread synchronization where possible. The reduction in CPU usage might be a trade-off in exchange for decreased performance. secondarySpinForObjectMonitors | noSecondarySpinForObjectMonitors -Xthr:secondarySpinForObjectMonitors -Xthr:noSecondarySpinForObjectMonitors This tuning option is available to test whether performance optimizations are negatively impacting an application.","title":"-Xthr"},{"location":"xthr/#-xthr","text":"","title":"-Xthr"},{"location":"xthr/#syntax","text":"-Xthr:<parameter>","title":"Syntax"},{"location":"xthr/#parameters","text":"","title":"Parameters"},{"location":"xthr/#adaptspin-noadaptspin","text":"-Xthr:AdaptSpin -Xthr:noAdaptSpin This tuning option is available to test whether performance optimizations are negatively impacting an application.","title":"AdaptSpin | noAdaptSpin"},{"location":"xthr/#fastnotify-nofastnotify","text":"-Xthr:fastNotify -Xthr:noFastNotify When a large number of threads try to acquire a Java\u2122 monitor, throughput of an application can be reduced. This issue is known as high contention. If high contention occurs when the Java wait and notify features are regularly used, you can use -Xthr:fastNotify to increase throughput. However, -Xthr:noFastNotify is the default setting, because it is faster in all other scenarios.","title":"fastNotify | noFastNotify"},{"location":"xthr/#cfsyield-nocfsyield-linux-only","text":"-Xthr:cfsYield -Xthr:noCfsYield The default value, cfsYield , enables threading optimizations for running on Linux with the Completely Fair Scheduler (CFS) in the default mode ( sched_compat_yield=0 ). The noCfsYield value disables these threading optimizations. You might want to use the noCfsYield value if your application uses the Thread.yield() method extensively, because otherwise you might see a performance decrease in cases where yielding is not beneficial.","title":"cfsYield | noCfsYield (Linux&reg; only)"},{"location":"xthr/#minimizeusercpu","text":"-Xthr:minimizeUserCPU Minimizes user-mode CPU usage in thread synchronization where possible. The reduction in CPU usage might be a trade-off in exchange for decreased performance.","title":"minimizeUserCPU"},{"location":"xthr/#secondaryspinforobjectmonitors-nosecondaryspinforobjectmonitors","text":"-Xthr:secondarySpinForObjectMonitors -Xthr:noSecondarySpinForObjectMonitors This tuning option is available to test whether performance optimizations are negatively impacting an application.","title":"secondarySpinForObjectMonitors | noSecondarySpinForObjectMonitors"},{"location":"xtlhprefetch/","text":"-XtlhPrefetch (AIX\u00ae, Windows\u2122 only) Speculatively prefetches bytes in the thread local heap (TLH) ahead of the current allocation pointer during object allocation. This option helps reduce the performance cost of subsequent allocations. Syntax -XtlhPrefetch This option can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"-XtlhPrefetch"},{"location":"xtlhprefetch/#-xtlhprefetch","text":"(AIX\u00ae, Windows\u2122 only) Speculatively prefetches bytes in the thread local heap (TLH) ahead of the current allocation pointer during object allocation. This option helps reduce the performance cost of subsequent allocations.","title":"-XtlhPrefetch"},{"location":"xtlhprefetch/#syntax","text":"-XtlhPrefetch This option can be used with all Eclipse OpenJ9\u2122 GC policies.","title":"Syntax"},{"location":"xtrace/","text":"-Xtrace Eclipse OpenJ9\u2122 VM tracing is a powerful feature to help you diagnose problems with minimal effect on performance. Tracing is enabled by default, together with a small set of trace points going to memory buffers. You can enable tracepoints at run time by using levels, components, group names, or individual tracepoint identifiers to trace VM internal operations and instrumented Java\u2122 applications. You can also trace Java methods. See the About trace section that follows for more detail. Trace data can be output in human-readable or in compressed binary formats. The VM provides a tool to process and convert the compressed binary data into a readable format. See Trace formatter . Note: You can also control trace by using the com.ibm.jvm.Trace API or by using JVMTI from an external agent. Xtrace Option Builder Use the Xtrace Option Builder tool to help you specify the correct options and avoid incompatibilities. Syntax -Xtrace:<parameter> You can get help with -Xtrace by using the following options: -Xtrace:help Displays general trace help -Xtrace:what Shows the current trace settings Configuring trace The following parameters can be used to configure trace. (Follow links for more information about individual options.) Command Result -Xtrace:properties[=<filename>] Configures trace options based on a file -Xtrace:buffers=<size>[dynamic\\|nodynamic] Modifies the size of buffers that are used to store trace data -Xtrace:exception.output=<filename>[,<size>] Redirects exceptions trace data to a file. -Xtrace:methods=<method_specification> Traces methods -Xtrace:output=<filename>[,<size>[,<generations>]] Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:resume Resumes tracing globally. -Xtrace:resumecount=<count> Enables tracing at a thread level after a specified count. -Xtrace:sleeptime=<time> Pauses trace operations for a specified length of time. -Xtrace:stackdepth=<n> Limits the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:suspend Suspends tracing globally. -Xtrace:suspendcount=<count> Suspends tracing at a thread level after a specified count. -Xtrace:trigger=<clause> Determines when various triggered trace actions occur, including turning trace on or off. Note: If an option value contains commas, it must be enclosed in braces. For example: methods={java/lang/*,com/ibm/*} Controlling tracepoint activation The following parameters can be used to control tracepoint activation. (Follow links for more information about individual options.) Command Result -Xtrace:maximal=<tracepoint_specification> Records all associated data. -Xtrace:minimal=<tracepoint_specification> Records only the time stamp and tracepoint identifier. -Xtrace:count=<tracepoint_specification> Counts the tracepoints that are used in a trace configuration. -Xtrace:print=<tracepoint_specification> Prints the specified tracepoints to stderr in real time. -Xtrace:iprint=<tracepoint_specification> Prints the specified tracepoints to stderr in real time with indentation. -Xtrace:exception=<tracepoint_specification> Enables exception tracing. -Xtrace:external<tracepoint_specification> Routes trace data to trace listeners, which are registered by using the JVMTI APIs. -Xtrace:none[=<tracepoint_specification>] Prevents the trace engine from loading if it is the only trace option specified. Note: These options control which individual tracepoints are activated at run time and the implicit destination of the trace data. All these properties are independent of each other and can be mixed and matched in any way that you choose. For more information, see Tracepoint activation . About trace With the OpenJ9 trace feature, you can trace VM internal operations, Java applications, and Java methods, or any combination of these. VM internal operations The OpenJ9 virtual machine (VM) is extensively instrumented with tracepoints for tracing operations. Interpreting this trace data requires detailed knowledge of the VM, and is intended to diagnose VM problems. No guarantee is given that tracepoints will not vary from release to release and from platform to platform. Applications VM trace contains an application trace facility that allows tracepoints to be placed in Java code, enabling you to combine trace data with the other forms of trace. This capability is supported by the com.ibm.jvm.Trace API. Note that an instrumented Java application runs only on an OpenJ9 VM. For more information, see Application trace . Java methods Use method trace to debug and trace application code and the system classes provided with the VM. You can trace entry to and exit from Java methods run by the VM. You can select method trace by classname, method name, or both. You can also use wildcards to create complex method selections. For more information about command syntax, see methods . Trace can produce large amounts of data in a very short time. Before running trace, think carefully about what information you need in order to solve the problem. Here are some considerations: If you need only the trace information that is produced shortly before the problem occurs, consider wrapping the file by using the output option. In many cases, just use internal trace with an increased buffer size and snap the trace when the problem occurs. If the problem results in a thread stack dump or operating system signal or exception, trace buffers are snapped automatically to a file that is in the current directory. The file is called: Snapnnnn. yyyymmdd.hhmmssth.process.trc . You must also think carefully about which components need to be traced and what level of tracing is required. For example, if you are tracing a suspected shared classes problem, it might be enough to trace all components at level 1, and j9shr at level 9, while maximal can be used to show parameters and other information for the failing component. Tracepoint components and trace levels are described in the following sections: Tracepoint specification and Trace levels . There are two types of tracepoints inside the VM: Regular tracepoints include method tracepoints, application tracepoints, data tracepoints inside the VM and data tracepoints inside class libraries. You can display regular tracepoint data on the screen or save the data to a file. You can also use command line options to trigger specific actions when regular tracepoints fire. Auxiliary tracepoints are a special type of tracepoint that can be fired only when another tracepoint is being processed. For example, the stack frame information produced by the jstacktrace -Xtrace:trigger command. You cannot control where auxiliary tracepoint data is sent and you cannot set triggers on auxiliary tracepoints. Auxiliary tracepoint data is sent to the same destination as the tracepoint that caused them to be generated. Trace data can be written to one of the following locations: Memory buffers that can be dumped or snapped when a problem occurs. Use the -Xtrace:buffers=<size> option to control the size of the buffer allocated to each thread. Buffers allocated to a thread are discarded when that thread terminates. To examine the trace data captured in these memory buffers, you must snap or dump the data. Use the -Xdump:snap option to vary the events that cause a snap trace file to be produced. When produced, format the buffers by using the trace formatter . One or more files that are using buffered I/O. Use the -Xtrace:output option. An external agent in real time, using the -Xtrace:external option. stderr in real time. Any combination of the other items in this list. Default tracing By default, the equivalent of the following trace command line is always available in the VM: -Xtrace:maximal=all{level1},exception=j9mm{gclogger} When startup is complete, the equivalent of the following command line is added to enable level 2 trace points: -Xtrace:maximal=all{level2} Level 2 is used for default tracing that would produce too much data during the startup of the VM. If you set other trace options on the command line, or before the VM finishes startup (through use of JVMTI or the com.ibm.jvm.Trace API), the level 2 trace points are enabled just before your trace options are processed. This behavior ensures that the default level 2 trace points do not override any changes that you specify. The data generated by the tracepoints is continuously captured in wrapping memory buffers for each thread. You can find tracepoint information in the following diagnostics data: System memory dumps, extracted by using jdmpview. Snap traces, generated when the VM encounters a problem or an output file is specified. Using dump agents describes more ways to create a snap trace. For exception trace only, in Javadumps. Default memory management tracing The default trace options are designed to ensure that Javadumps always contain a record of the most recent memory management history, regardless of how much work the VM has performed since the garbage collection cycle was last called. The exception=j9mm{gclogger} clause of the default trace set specifies that a history of garbage collection cycles that have occurred in the VM is continuously recorded. The gclogger group of tracepoints in the j9mm component constitutes a set of tracepoints that record a snapshot of each garbage collection cycle. These tracepoints are recorded in their own separate buffer, called the exception buffer. The effect is that the tracepoints are not overwritten by the higher frequency tracepoints of the VM. The GC History section of the Javadump is based on the information in the exception buffer. If a garbage collection cycle has occurred in a traced VM, the Java dump probably contains a GC History section. Default assertion tracing The VM includes assertions, implemented as special trace points. By default, internal assertions are detected and diagnostics logs are produced to help assess the error. Assertion failures often indicate a serious problem, and the VM usually stops immediately. In these circumstances, raise an issue, including the standard error output and any diagnostic files that are produced. When an assertion trace point is reached, a message like the following output is produced on the standard error stream: 16:43:48.671 0x10a4800 j9vm.209 * ** ASSERTION FAILED ** at jniinv.c:251: ((javaVM == ((void *)0))) This error stream is followed with information about the diagnostic logs produced: JVMDUMP007I JVM Requesting System Dump using 'core.20060426.124348.976.dmp' JVMDUMP010I System Dump written to core.20060426.124348.976.dmp JVMDUMP007I JVM Requesting Snap Dump using 'Snap0001.20060426.124648.976.trc' JVMDUMP010I Snap Dump written to Snap0001.20060426.124648.976.trc Assertions are special trace points. They can be enabled or disabled by using the standard trace command-line options. Assertion failures might occur early during VM startup, before trace is enabled. In this case, the assert message has a different format, and is not prefixed by a timestamp or thread ID. For example: ** ASSERTION FAILED ** j9vmutil.15 at thrinfo.c:371 Assert_VMUtil_true(( publicFlags & 0x200)) Assertion failures that occur early during startup cannot be disabled. These failures do not produce diagnostic dumps, and do not cause the VM to stop. Tracepoint activation The options that control which individual tracepoints are activated at run time and the implicit destination of the trace data are listed under Syntax: Controlling tracepoint activation In some cases, you must use them with other options. For example, if you specify maximal or minimal tracepoints, the trace data is put into memory buffers. If you are going to send the data to a file, you must use an output option to specify the destination file name. With the exception of none , all options require at least one <tracepoint_specification> , which is described in the following section. Multiple statements of each type of trace are allowed and their effect is cumulative. If you want to use multiple trace options of the same name, use a properties file. (See properties .) Tracepoint specification Tracepoints are enabled by specifying component and tracepoint . If no qualifier parameters are entered, all tracepoints are enabled, except for <exception.output> trace, where the default is all {exception}. The <tracepoint_specification> syntax can be further broken down as follows: [!]<component>[{<group>}] or [!]<component>[{<type>}] or [!]<tracepoint_id>[,<tracepoint_id>] Where: The ! symbol is a logical not . That is, the tracepoints that are in a specification starting with ! are turned off. <component> is a Java component. <group> is a tracepoint group, which is a set of tracepoints that are defined within a component. <type> is the tracepoint type: entry , exit , event , exception , and eem . <tracepoint_id> is the tracepoint identifier. The tracepoint identifier constitutes the component name of the tracepoint, followed by its integer number inside that component. For example, j9mm.49 , j9shr.20-29 , j9vm.15 . To understand these numbers, see Determining the tracepoint ID of a tracepoint. Some tracepoints can be both an exit and an exception ; that is, the function ended with an error. If you specify either exit or exception , these tracepoints are included. Lists of Java components and tracepoint groups can be found in the tables that follow. The following table lists the possible Java components ( <component> ). To include all Java components, specify all . Component name Description avl VM AVL tree support io Class library java.io native code j9bcu VM byte code utilities j9bcverify VM byte code verification j9codertvm VM byte code run time j9dmp VM dump j9jcl VM class libraries j9jit VM JIT interface j9jni VM JNI support j9jvmti VM JVMTI support j9mm VM memory management j9prt VM port library j9scar VM class library interface j9shr VM shared classes j9trc VM trace j9util VM utilities j9vm VM general j9vmutil VM utilities j9vrb VM verbose stack walker map VM mapped memory support mt Java methods (see Note ) net Class library TCP/IP networking native code pool VM storage pool support rpc VM RPC support simplepool VM storage pool support sunvmi VM class library interface Note: When specifying the mt component you must also specify the methods option. The following table lists all the tracepoint groups ( <group> ). Each group is associated with one or more Java components: Component name or names Group name Description j9mm gclogger A set of tracepoints that record each garbage collection cycle. Equivalent to -verbose:gc output j9prt nlsmessage A set of tracepoints that record each NLS message that is issued by the VM. j9jcl , j9vm verboseclass A set of tracepoints that record each class as it is loaded. Equivalent to -verbose:class output. j9jni , j9vm checkjni A set of tracepoints that record JNI function checks. Equivalent to -Xcheck:jni output. j9vm checkmemory A set of tracepoints that record memory checks. Equivalent to -Xcheck:memory output. j9vm checkvm A set of tracepoints that record VM checks. Equivalent to -Xcheck:vm output. j9jit verbose A set of tracepoints that record JIT compiler configuration and method compilation. Equivalent to -Xjit:verbose output. mt compiledMethods A set of tracepoints that record compiled Java methods. mt nativeMethods A set of tracepoints that record Java native methods. mt staticMethods A set of tracepoints that record Java static methods. Here are some examples: To trace all tracepoints, specify the following command: -Xtrace:maximal=all To trace all tracepoints except **j9vrb** and **j9trc**, specify the following command: -Xtrace:minimal={all},minimal={!j9vrb,j9trc} To trace all entry and exit tracepoints in j9bcu , specify the following command: -Xtrace:maximal={j9bcu{entry},j9bcu{exit}} To trace all tracepoints in **j9mm** except tracepoints 20-30, specify the following command: -Xtrace:maximal=j9mm,maximal=!j9mm.20-30 To trace tracepoints j9prt.5 through j9prt.15 , specify the following command: -Xtrace:print=j9prt.5-15 To trace all **j9trc** tracepoints, specify the following command: -Xtrace:count=j9trc To trace all entry and exit tracepoints, specify the following command: -Xtrace:external={all{entry},all{exit}} Trace levels Tracepoints have been assigned levels 0 through 9 that are based on the importance of the tracepoint. A level 0 tracepoint is the most important. It is reserved for extraordinary events and errors. A level 9 tracepoint is in-depth component detail. To specify a given level of tracing, the level0 through level9 keywords are used. You can abbreviate these keywords to l0 through l9. For example, if level5 is selected, all tracepoints that have levels 0 through 5 are included. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. The level is provided as a modifier to a component specification, for example: -Xtrace:maximal={all{level5}} or -Xtrace:maximal={j9mm{L2},j9trc,j9bcu{level9},all{level1}} In the first example, tracepoints that have a level of 5 or less are enabled for all components. In the second example, all level 1 tracepoints are enabled. All level 2 tracepoints in j9mm are enabled. All tracepoints up to level 9 are enabled in j9bcu . Note: The level applies only to the current component. If multiple trace selection components are found in a trace properties file, the level is reset to the default for each new component. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. When the not operator is specified, the level is inverted; that is, !j9mm{level5} disables all tracepoints of level 6 or greater for the j9mm component. The following example enables trace for all components at level 9 (the default), but disables level 6 and higher for the locking component, and level 7 and higher for the storage component: -Xtrace:print={all},print={!j9trc{l5},j9mm{l6}} Here are some examples: To count the level zero and level one tracepoints matched, specify the following command: -Xtrace:count=all{L1} To produce maximal trace of all components at level 5 and j9mm at level 9, specify the following command: -Xtrace:maximal={all{level5},j9mm{L9}} To trace all components at level 6, but do not trace j9vrb at all, and do not trace the entry and exit tracepoints in the j9trc component, specify the following command: -Xtrace:minimal={all{l6}},minimal={!j9vrb,j9trc{entry},j9trc{exit}} Parameters Parameters to use with the -Xtrace option: buffers You can modify the size of the buffers to change how much diagnostic output is provided in a snap dump. This buffer is allocated for each thread that makes trace entries. The following table shows how this parameter can be set: Command Effect -Xtrace:buffers=<size> Creates buffers of the specified <size> in k (KB) or m (MB), allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>dynamic Creates buffers of the specified <size> , allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>nodynamic Creates buffers of the specified <size> , with a maximum allocation of two buffers per thread. If external trace is enabled, the number of buffers is doubled; that is, each thread allocates two or more buffers. The same buffer size is used for state and exception tracing, but, in this case, buffers are allocated globally. The default is 8 KB per thread. The dynamic and nodynamic suboptions have meaning only when tracing to an output file. Note: If nodynamic is specified, you might lose trace data if the volume of trace data exceeds the bandwidth of the trace output file. Message UTE115 is issued when the first trace entry is lost, and message UTE018 is issued when the VM ends. Here are some command line examples: To set a buffer size of 2 MB per thread, with dynamic buffering, use: -Xtrace:buffers=2m To limit each thread to 2 trace buffers, each of 128 KB: -Xtrace:buffers={128k,nodynamic} count (tracepoint) -Xtrace:count=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The count option requests that only a count of the selected tracepoints is kept. When the VM ends, all nonzero totals of tracepoints (sorted by tracepoint id) are written to a file, called utTrcCounters , in the current directory. This information is useful if you want to determine the overhead of particular tracepoints, but do not want to produce a large amount (GB) of trace data. For example, to count the tracepoints that are used in the default trace configuration, use the following command: -Xtrace:count=all{level1},count=j9mm{gclogger} exception (tracepoint) -Xtrace:exception=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When exception trace is enabled, the trace data is collected in internal buffers that are separate from the normal buffers. These internal buffers can then be written to a snap file or written to the file that is specified in an exception.output option. The exception option allows low-volume tracing in buffers and files that are distinct from the higher-volume information that minimal and maximal tracing have provided. In most cases, this information is exception-type data, but you can use this option to capture any trace data that you want. This form of tracing is channeled through a single set of buffers, as opposed to the buffer-per-thread approach for normal trace. Buffer contention might occur if high volumes of trace data are collected. A difference exists in the <tracepoint_specification> defaults for exception tracing; see Tracepoint specification . Notes: The exception trace buffers are intended for low-volume tracing. By default, the exception trace buffers log garbage collection (GC) event tracepoints, see Default tracing. You can send additional tracepoints to the exception buffers or turn off the GC tracepoints. Changing the exception trace buffers alters the contents of the GC History section in any Javadumps. When exception trace is entered for an active tracepoint, the current thread ID is checked against the previous caller's thread ID. If it is a different thread, or this is the first call to exception trace, a context tracepoint is put into the trace buffer first. This context tracepoint consists only of the current thread ID, which is necessary because of the single set of buffers for exception trace. (The formatter identifies all trace entries as coming from the Exception trace pseudo thread when it formats exception trace files.) exception.output Use exception output to redirect exceptions trace data to a file. -Xtrace:exception.output=<filename>[,<size>] Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d (today's date in \" yyyymmdd\" format), %p (process ID number of the process generating the trace), or %t (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps nondestructively to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Here are some examples: Exception trace output goes to file /u/traces/exception.trc with no size limit: -Xtrace:exception.output=/u/traces/exception.trc,maximal Exception trace output goes to file except and wraps at 2 MB: -Xtrace:exception.output={except,2m},maximal Exception trace output goes to a file whose filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:exception.output=traceout.%d.trc,maximal Exception trace output goes to a file whose filename contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:exception.output=tracefrompid%p.trc,maximal Exception trace output goes to a file whose filename contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:exception.output=traceout.%t.trc,maximal external (tracepoint) -Xtrace:external<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The external option routes trace data to trace listeners, which are registered by using the JVMTI RegisterTracePointSubscriber() and DeregisterTracePointSubscriber() APIs. help -Xtrace:help Displays general trace help iprint (tracepoint) -Xtrace:iprint=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The iprint option is the same as the print option, but uses indenting to format the trace. maximal (tracepoint) -Xtrace:maximal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. All associated data is traced. minimal and maximal traces are independent from any types that follow them. For example, if the maximal option is specified, it does not affect a later option such as print . methods Using method trace provides a complete and potentially large diagnosis of code paths inside your application and the system classes. Use wild cards and filtering to control method trace so that you can focus on the sections of code that interest you. Note that method trace is powerful but it also has a cost. Application throughput is affected by method trace. To specify one or more method specifications, use the following syntax: -Xtrace:methods=<method_specification>[,<method_specification>] The syntax for <method_specification> can be further broken down to the following suboptions: -Xtrace:methods={[!][*][<package>/]<class>[*],[[*]<method>[*]|[()]]} Where: The delimiter between parts of the package name is a forward slash, \"/\". The ! in the methods parameter is a NOT operator that allows you to tell the VM not to trace the specified method or methods. The parentheses, (), define whether or not to include method parameters in the trace. If a method specification includes any commas, the whole specification must be enclosed in braces, for example: -Xtrace:methods={java/lang/*,java/util/*},print=mt It might be necessary to enclose your command line in quotation marks to prevent the shell intercepting and fragmenting comma-separated command lines, for example: \"-Xtrace:methods={java/lang/*,java/util/*},print=mt\" To output all method trace information to stderr, use either the print or iprint suboptions: -Xtrace:print=mt,methods=*.* -Xtrace:iprint=mt,methods=*.* The iprint suboption prints to stderr with indentation. To output method trace information in binary format, see the output option Internal Native Library (INL) native methods inside the VM cannot be traced because they are not implemented by using JNI. The list of methods that are not traceable is subject to change without notice. Here are some examples: Tracing entry and exit of all methods in a given class: To trace all method entry and exit of the ReaderMain class in the default package and the java.lang.String class, specify the following command: -Xtrace:methods={ReaderMain.*,java/lang/String.*},print=mt Tracing entry, exit and input parameters of all methods in a class: To trace all method entry, exit, and input of the ReaderMain class in the default package, specify the following command: -Xtrace:methods=ReaderMain.*(),print=mt Tracing all methods in a given package: To trace all method entry, exit, and input of all classes in the package com.ibm.socket , specify the following command: -Xtrace:methods=com/ibm/socket/*.*(),print=mt Multiple method trace: To trace all method entry, exit, and input in the Widget class in the default package and all method entry and exit in the common package, specify the following command: -Xtrace:methods={Widget.*(),common/*},print=mt Using the ! operator: To trace all methods in the ArticleUI class in the default package except those beginning with \"get\", specify the following command: -Xtrace:methods={ArticleUI.*,!ArticleUI.get*},print=mt Tracing a specific method in a class: This example traces entry and exit of the substring method of the java.lang.String class . If there is more than one method with the same name, they are all traced. You cannot filter method trace by the signature of the method. -Xtrace:print=mt,methods={java/lang/String.substring} Tracing the constructor of a class: This example traces entry and exit of the constructors of the java.lang.String class. -Xtrace:print=mt,methods={java/lang/String.<init>} Here is some example output: java \"-Xtrace:methods={java/lang*.*},iprint=mt\" HW 10:02:42.281*0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/String.<clinit>()V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method The output lines comprise of: 0x9e900 , the current execenv (execution environment). Because every VM thread has its own execenv , you can regard execenv as a thread-id . All trace with the same execenv relates to a single thread. The individual tracepoint ID in the mt component that collects and emits the data. The remaining fields show whether a method is being entered (>) or exited (<), followed by details of the method. minimal (tracepoint) -Xtrace:minimal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. Only the time stamp and tracepoint identifier are recorded. When the trace is formatted, missing trace data is replaced with the characters \"???\" in the output file. minimal and maximal traces are independent from any types that follow them. For example, if the minimal option is specified, it does not affect a later option such as print . none (tracepoint) -Xtrace:none[=<tracepoint_specification>] For further information about <tracepoint_specification> syntax, see Tracepoint specification . -Xtrace:none prevents the trace engine from loading if it is the only trace option specified. However, if other -Xtrace options are on the command line, it is treated as the equivalent of -Xtrace:none=all and the trace engine still loads. If you specify other tracepoints without specifying -Xtrace:none , the tracepoints are added to the default set. output Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:output=<filename>[,<size>[,<generations>]]` Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d% (today's date in \" yyyymmdd\" format), %p% (process ID number of the process generating the trace), or %t% (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Optionally, <generations> is a value 2 through 36. These values cause up to 36 files to be used sequentially as each file reaches its <size> threshold. When a file needs to be reused, it is overwritten. If <generations> is specified, the filename must contain a # (hash, pound symbol), which will be substituted with its generation identifier, the sequence of which is 0 through 9 followed by A through Z. Note: When tracing to a file, buffers for each thread are written when the buffer is full or when the VM ends. If a thread has been inactive for a period of time before the VM ends, what seems to be 'old' trace data is written to the file. When formatted, it then seems that trace data is missing from the other threads, but this is an unavoidable side-effect of the buffer-per-thread design. This effect becomes especially noticeable when you use the generation facility, and format individual earlier generations. Here are some examples: Trace output goes to file /u/traces/gc.problem with no size limit: -Xtrace:output=/u/traces/gc.problem,maximal=j9gc Trace output goes to file trace , which will wrap at 2 MB: -Xtrace:output={trace,2m},maximal=j9gc Trace output goes to files gc0.trc , gc1.trc , and gc2.trc , each 10 MB in size: -Xtrace:output={gc#.trc,10m,3},maximal=j9gc Trace output goes to a file, where the filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:output=traceout.%d.trc,maximal=j9gc Trace output goes to a file whose name contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:output=tracefrompid%p.trc,maximal=j9gc Trace output goes to a file whose name contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:output=traceout.%t.trc,maximal=j9gc print (tracepoint) -Xtrace:print=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The print option causes the specified tracepoints to be routed to stderr in real time. The VM tracepoints are formatted by using J9TraceFormat.dat . The class library tracepoints are formatted by J9TraceFormat.dat and TraceFormat.dat . properties You can use properties files to control trace. A properties file saves typing and allows you to create a library of files that are tailored to solving problems in a particular area. -Xtrace:properties[=<filename>] If <filename> is not specified, the VM searches for a default name of IBMTRACE.properties in the current directory. All the options that are in the file are processed in the sequence in which they are stored in the file, before the next option that is obtained through the normal mechanism is processed. Therefore, a command-line property always overrides a property that is in the file. Here is an example of a properties file: minimal=all // maximal=j9mm maximal=j9shr buffers=128k,nodynamic output=c:\\traces\\classloader.trc print=tpnid(j9vm.23-25) The following restrictions apply to the file: The file must be a flat ASCII file. Nesting is not supported; that is, the file cannot contain a properties option. You cannot leave properties that have the form <name>=<value> to default if they are specified in the property file; that is, you must specify a value, for example maximal=all . Do not add white space before, after, or within the trace options. If any error is found when the file is accessed, VM initialization fails with an explanatory error message and return code. To use a file trace.props stored in the c:\\trc\\gc directory, specify the following command: -Xtrace:properties=c:\\trc\\gc\\trace.props resume The resume option resumes tracing globally. -Xtrace:resume The suspend and resume options are not recursive. That is, two suspends that are followed by a single resume cause trace to be resumed. resumecount This trace option determines whether tracing is enabled for each thread. -Xtrace:resumecount=<count> If <count> is greater than zero, each thread initially has its tracing disabled and must receive <count> resumethis actions before it starts tracing. This option is used with the trigger option. Note: You cannot use resumecount and suspendcount together because they use the same internal counter. The following example starts with all tracing turned off. Each thread starts tracing when it has had three resumethis actions performed on it: -Xtrace:resumecount=3 sleeptime You can specify how long the sleep lasts when using the sleep trigger action. -Xtrace:sleeptime=nnn|aaams|bbbs Where: nnn sleeps for nnn milliseconds. aaams sleeps for aaa milliseconds. bbbs sleeps for bbb seconds. The default length of time is 30 seconds. If no units are specified, the default time unit is milliseconds. stackdepth Use this option to limit the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:stackdepth=<n> Where <n> is the maximum number of stack frames reported. suspend -Xtrace:suspend Suspends tracing globally for all threads and all forms of tracing but leaves tracepoints activated. suspendcount This trace option determines whether tracing is enabled for each thread. -Xtrace:suspendcount=<count> If <count> is greater than zero, each thread initially has its tracing enabled and must receive <count> suspendthis actions before it stops tracing. You cannot use resumecount and suspendcount together because they both set the same internal counter. This trace option is for use with the trigger option. The following example starts with tracing turned on. Each thread stops tracing when it has had three suspendthis actions performed on it: -Xtrace:suspendcount=3 trigger The trigger parameter determines when various triggered trace actions occur. Supported actions include turning tracing on and off for all threads, turning tracing on or off for the current thread, or producing various dumps. -Xtrace:trigger=<clause>[,<clause>] This trace option does not control what is traced. It controls only whether the information that has been selected by the other trace options is produced as normal or is blocked. Types Each clause of the trigger parameter can be one of the following types: a method ( -Xtrace:trigger=method{...} ) a tracepoint ID ( -Xtrace:trigger=tpnid{...} ) a group ( -Xtrace:trigger=group{...} ) You can specify multiple clauses of the same type if required, but you do not need to specify all types. method -Xtrace:trigger=method{<methodspec>[,<entryAction>[,<exitAction>[,<delayCount>[,<matchcount>]]]]} On entering a method that matches <methodspec> , the specified <entryAction> is run. On leaving a method that matches <methodspec> , the specified <exitAction> is run. If you specify a <delayCount> , the actions are performed only after a matching <methodspec> has been entered that many times. If you specify a <matchCount> , <entryAction> and <exitAction> are performed at most that many times. <methodspec> is the specification of a Java method, consisting of a class and a method name separated by a dot. For example, specify HelloWorld.main . If the class is in a package, the package name must be included, separated by slashes. For example, specify java/lang/String.getBytes . A wildcard \"*\" can be used at the start or end of the class and method names, or both. For example, you can specify */String.get* . To specify a constructor method, use <init> as the method name. Method signatures cannot be specified, so a method specification applies to all overloaded methods. tracepoint ID -Xtrace:trigger=tpnid{<tpnid>|<tpnidRange>,<action>[,<delayCount>[,<matchcount>]]} On finding the specified active tracepoint ID ( <tpnid> ) or a tracepoint ID) that falls inside the specified <tpnidRange> , the specified action is run . If you specify a <delayCount> , the action is performed only after the VM finds such an active <tpnid> that many times. If you specify a <matchCount> , <action> is performed at most that many times. group -Xtrace:trigger=group{<groupname>,<action>[,<delayCount>[,<matchcount>]]} On finding any active tracepoint that is defined as being in trace group <groupname> , for example Entry or Exit , the specified action is run . If you specify a <delayCount> , the action is performed only after that many active tracepoints from group <groupname> have been found. If you specify a <matchCount> , <action> is performed at most that many times. Actions Wherever an action ( <action> , <entryAction> , or <exitAction> ) must be specified in one of the trigger parameter clauses, you must select from these options: <action> Effect abort Halt the VM. ceedump This action is applicable to z/OS\u00ae only. For more information, see z/OS LE CEEDUMPs . coredump Produce a system dump. See Dump agents ( -Xdump:system ) heapdump Produce a heap dump. See Heap dump . javadump Produce a Java dump. See Java dump . jstacktrace Examine the Java stack of the current thread and generate auxiliary tracepoints for each stack frame. The auxiliary tracepoints are written to the same destination as the tracepoint or method trace that triggered the action. You can control the number of stack frames examined with the stackdepth=n option. See the stackdepth option. resume Resume all tracing (except for threads that are suspended by the action of the resumecount property and Trace.suspendThis() calls). resumethis Decrement the suspend count for this thread. If the suspend count is zero or less, resume tracing for this thread. segv Cause a segmentation violation. (Intended for use in debugging.) sleep Delay the current thread for a length of time controlled by the sleeptime option. The default is 30 seconds. See sleeptime option. snap Snap all active trace buffers to a file in the current working directory. The file name has the format: Snapnnnn.yyyymmdd.hhmmssth.ppppp.trc , where nnnn is the sequence number of the snap file since VM startup, yyyymmdd is the date, hhmmssth is the time, and ppppp is the process ID in decimal with leading zeros removed. suspend Suspend all tracing (except for special trace points). suspendthis Increment the suspend count for this thread. If the suspend-count is greater than zero, prevent all tracing for this thread. sysdump (or coredump ) Produce a system dump. See Dump agents( -Xdump:system ) . Here are some examples of using the trigger option: To produce a Java dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump} To produce a system dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,sysdump} To produce a Java dump when a class constructor is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<init>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a class static initializer is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<clinit>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a method is entered 1000 times and 1001 times, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump,,1000,2} To start tracing this thread when it enters any method in java/lang/String , and to stop tracing the thread after exiting the method, specify the following command: -Xtrace:resumecount=1 -Xtrace:trigger=method{java/lang/String.*,resumethis,suspendthis} To resume all tracing when any thread enters a method in any class that starts with error , specify the following command: -Xtrace:trigger=method{*.error*,resume} To trace (all threads) while the application is active; that is, not starting or shut down. (The application name is HelloWorld ), specify the following command: -Xtrace:suspend,trigger=method{HelloWorld.main,resume,suspend} To print a Java stack trace to the console when the mycomponent.1 tracepoint is reached, specify the following command: -Xtrace:print=mycomponent.1,trigger=tpnid{mycomponent.1,jstacktrace} To write a Java stack trace to the trace output file when the Sample.code() method is called, specify the following command: -Xtrace:maximal=mt,output=trc.out,methods={mycompany/mypackage/Sample.code},trigger=method{mycompany/mypackage/Sample.code,jstacktrace} what -Xtrace:what Shows the current trace settings See also Application trace Heap dump Java dump Dump viewer","title":"-Xtrace"},{"location":"xtrace/#-xtrace","text":"Eclipse OpenJ9\u2122 VM tracing is a powerful feature to help you diagnose problems with minimal effect on performance. Tracing is enabled by default, together with a small set of trace points going to memory buffers. You can enable tracepoints at run time by using levels, components, group names, or individual tracepoint identifiers to trace VM internal operations and instrumented Java\u2122 applications. You can also trace Java methods. See the About trace section that follows for more detail. Trace data can be output in human-readable or in compressed binary formats. The VM provides a tool to process and convert the compressed binary data into a readable format. See Trace formatter . Note: You can also control trace by using the com.ibm.jvm.Trace API or by using JVMTI from an external agent.","title":"-Xtrace"},{"location":"xtrace/#xtrace-option-builder","text":"Use the Xtrace Option Builder tool to help you specify the correct options and avoid incompatibilities.","title":"Xtrace Option Builder"},{"location":"xtrace/#syntax","text":"-Xtrace:<parameter> You can get help with -Xtrace by using the following options: -Xtrace:help Displays general trace help -Xtrace:what Shows the current trace settings","title":"Syntax"},{"location":"xtrace/#configuring-trace","text":"The following parameters can be used to configure trace. (Follow links for more information about individual options.) Command Result -Xtrace:properties[=<filename>] Configures trace options based on a file -Xtrace:buffers=<size>[dynamic\\|nodynamic] Modifies the size of buffers that are used to store trace data -Xtrace:exception.output=<filename>[,<size>] Redirects exceptions trace data to a file. -Xtrace:methods=<method_specification> Traces methods -Xtrace:output=<filename>[,<size>[,<generations>]] Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:resume Resumes tracing globally. -Xtrace:resumecount=<count> Enables tracing at a thread level after a specified count. -Xtrace:sleeptime=<time> Pauses trace operations for a specified length of time. -Xtrace:stackdepth=<n> Limits the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:suspend Suspends tracing globally. -Xtrace:suspendcount=<count> Suspends tracing at a thread level after a specified count. -Xtrace:trigger=<clause> Determines when various triggered trace actions occur, including turning trace on or off. Note: If an option value contains commas, it must be enclosed in braces. For example: methods={java/lang/*,com/ibm/*}","title":"Configuring trace"},{"location":"xtrace/#controlling-tracepoint-activation","text":"The following parameters can be used to control tracepoint activation. (Follow links for more information about individual options.) Command Result -Xtrace:maximal=<tracepoint_specification> Records all associated data. -Xtrace:minimal=<tracepoint_specification> Records only the time stamp and tracepoint identifier. -Xtrace:count=<tracepoint_specification> Counts the tracepoints that are used in a trace configuration. -Xtrace:print=<tracepoint_specification> Prints the specified tracepoints to stderr in real time. -Xtrace:iprint=<tracepoint_specification> Prints the specified tracepoints to stderr in real time with indentation. -Xtrace:exception=<tracepoint_specification> Enables exception tracing. -Xtrace:external<tracepoint_specification> Routes trace data to trace listeners, which are registered by using the JVMTI APIs. -Xtrace:none[=<tracepoint_specification>] Prevents the trace engine from loading if it is the only trace option specified. Note: These options control which individual tracepoints are activated at run time and the implicit destination of the trace data. All these properties are independent of each other and can be mixed and matched in any way that you choose. For more information, see Tracepoint activation .","title":"Controlling tracepoint activation"},{"location":"xtrace/#about-trace","text":"With the OpenJ9 trace feature, you can trace VM internal operations, Java applications, and Java methods, or any combination of these. VM internal operations The OpenJ9 virtual machine (VM) is extensively instrumented with tracepoints for tracing operations. Interpreting this trace data requires detailed knowledge of the VM, and is intended to diagnose VM problems. No guarantee is given that tracepoints will not vary from release to release and from platform to platform. Applications VM trace contains an application trace facility that allows tracepoints to be placed in Java code, enabling you to combine trace data with the other forms of trace. This capability is supported by the com.ibm.jvm.Trace API. Note that an instrumented Java application runs only on an OpenJ9 VM. For more information, see Application trace . Java methods Use method trace to debug and trace application code and the system classes provided with the VM. You can trace entry to and exit from Java methods run by the VM. You can select method trace by classname, method name, or both. You can also use wildcards to create complex method selections. For more information about command syntax, see methods . Trace can produce large amounts of data in a very short time. Before running trace, think carefully about what information you need in order to solve the problem. Here are some considerations: If you need only the trace information that is produced shortly before the problem occurs, consider wrapping the file by using the output option. In many cases, just use internal trace with an increased buffer size and snap the trace when the problem occurs. If the problem results in a thread stack dump or operating system signal or exception, trace buffers are snapped automatically to a file that is in the current directory. The file is called: Snapnnnn. yyyymmdd.hhmmssth.process.trc . You must also think carefully about which components need to be traced and what level of tracing is required. For example, if you are tracing a suspected shared classes problem, it might be enough to trace all components at level 1, and j9shr at level 9, while maximal can be used to show parameters and other information for the failing component. Tracepoint components and trace levels are described in the following sections: Tracepoint specification and Trace levels . There are two types of tracepoints inside the VM: Regular tracepoints include method tracepoints, application tracepoints, data tracepoints inside the VM and data tracepoints inside class libraries. You can display regular tracepoint data on the screen or save the data to a file. You can also use command line options to trigger specific actions when regular tracepoints fire. Auxiliary tracepoints are a special type of tracepoint that can be fired only when another tracepoint is being processed. For example, the stack frame information produced by the jstacktrace -Xtrace:trigger command. You cannot control where auxiliary tracepoint data is sent and you cannot set triggers on auxiliary tracepoints. Auxiliary tracepoint data is sent to the same destination as the tracepoint that caused them to be generated. Trace data can be written to one of the following locations: Memory buffers that can be dumped or snapped when a problem occurs. Use the -Xtrace:buffers=<size> option to control the size of the buffer allocated to each thread. Buffers allocated to a thread are discarded when that thread terminates. To examine the trace data captured in these memory buffers, you must snap or dump the data. Use the -Xdump:snap option to vary the events that cause a snap trace file to be produced. When produced, format the buffers by using the trace formatter . One or more files that are using buffered I/O. Use the -Xtrace:output option. An external agent in real time, using the -Xtrace:external option. stderr in real time. Any combination of the other items in this list.","title":"About trace"},{"location":"xtrace/#default-tracing","text":"By default, the equivalent of the following trace command line is always available in the VM: -Xtrace:maximal=all{level1},exception=j9mm{gclogger} When startup is complete, the equivalent of the following command line is added to enable level 2 trace points: -Xtrace:maximal=all{level2} Level 2 is used for default tracing that would produce too much data during the startup of the VM. If you set other trace options on the command line, or before the VM finishes startup (through use of JVMTI or the com.ibm.jvm.Trace API), the level 2 trace points are enabled just before your trace options are processed. This behavior ensures that the default level 2 trace points do not override any changes that you specify. The data generated by the tracepoints is continuously captured in wrapping memory buffers for each thread. You can find tracepoint information in the following diagnostics data: System memory dumps, extracted by using jdmpview. Snap traces, generated when the VM encounters a problem or an output file is specified. Using dump agents describes more ways to create a snap trace. For exception trace only, in Javadumps.","title":"Default tracing"},{"location":"xtrace/#default-memory-management-tracing","text":"The default trace options are designed to ensure that Javadumps always contain a record of the most recent memory management history, regardless of how much work the VM has performed since the garbage collection cycle was last called. The exception=j9mm{gclogger} clause of the default trace set specifies that a history of garbage collection cycles that have occurred in the VM is continuously recorded. The gclogger group of tracepoints in the j9mm component constitutes a set of tracepoints that record a snapshot of each garbage collection cycle. These tracepoints are recorded in their own separate buffer, called the exception buffer. The effect is that the tracepoints are not overwritten by the higher frequency tracepoints of the VM. The GC History section of the Javadump is based on the information in the exception buffer. If a garbage collection cycle has occurred in a traced VM, the Java dump probably contains a GC History section.","title":"Default memory management tracing"},{"location":"xtrace/#default-assertion-tracing","text":"The VM includes assertions, implemented as special trace points. By default, internal assertions are detected and diagnostics logs are produced to help assess the error. Assertion failures often indicate a serious problem, and the VM usually stops immediately. In these circumstances, raise an issue, including the standard error output and any diagnostic files that are produced. When an assertion trace point is reached, a message like the following output is produced on the standard error stream: 16:43:48.671 0x10a4800 j9vm.209 * ** ASSERTION FAILED ** at jniinv.c:251: ((javaVM == ((void *)0))) This error stream is followed with information about the diagnostic logs produced: JVMDUMP007I JVM Requesting System Dump using 'core.20060426.124348.976.dmp' JVMDUMP010I System Dump written to core.20060426.124348.976.dmp JVMDUMP007I JVM Requesting Snap Dump using 'Snap0001.20060426.124648.976.trc' JVMDUMP010I Snap Dump written to Snap0001.20060426.124648.976.trc Assertions are special trace points. They can be enabled or disabled by using the standard trace command-line options. Assertion failures might occur early during VM startup, before trace is enabled. In this case, the assert message has a different format, and is not prefixed by a timestamp or thread ID. For example: ** ASSERTION FAILED ** j9vmutil.15 at thrinfo.c:371 Assert_VMUtil_true(( publicFlags & 0x200)) Assertion failures that occur early during startup cannot be disabled. These failures do not produce diagnostic dumps, and do not cause the VM to stop.","title":"Default assertion tracing"},{"location":"xtrace/#tracepoint-activation","text":"The options that control which individual tracepoints are activated at run time and the implicit destination of the trace data are listed under Syntax: Controlling tracepoint activation In some cases, you must use them with other options. For example, if you specify maximal or minimal tracepoints, the trace data is put into memory buffers. If you are going to send the data to a file, you must use an output option to specify the destination file name. With the exception of none , all options require at least one <tracepoint_specification> , which is described in the following section. Multiple statements of each type of trace are allowed and their effect is cumulative. If you want to use multiple trace options of the same name, use a properties file. (See properties .)","title":"Tracepoint activation"},{"location":"xtrace/#tracepoint-specification","text":"Tracepoints are enabled by specifying component and tracepoint . If no qualifier parameters are entered, all tracepoints are enabled, except for <exception.output> trace, where the default is all {exception}. The <tracepoint_specification> syntax can be further broken down as follows: [!]<component>[{<group>}] or [!]<component>[{<type>}] or [!]<tracepoint_id>[,<tracepoint_id>] Where: The ! symbol is a logical not . That is, the tracepoints that are in a specification starting with ! are turned off. <component> is a Java component. <group> is a tracepoint group, which is a set of tracepoints that are defined within a component. <type> is the tracepoint type: entry , exit , event , exception , and eem . <tracepoint_id> is the tracepoint identifier. The tracepoint identifier constitutes the component name of the tracepoint, followed by its integer number inside that component. For example, j9mm.49 , j9shr.20-29 , j9vm.15 . To understand these numbers, see Determining the tracepoint ID of a tracepoint. Some tracepoints can be both an exit and an exception ; that is, the function ended with an error. If you specify either exit or exception , these tracepoints are included. Lists of Java components and tracepoint groups can be found in the tables that follow. The following table lists the possible Java components ( <component> ). To include all Java components, specify all . Component name Description avl VM AVL tree support io Class library java.io native code j9bcu VM byte code utilities j9bcverify VM byte code verification j9codertvm VM byte code run time j9dmp VM dump j9jcl VM class libraries j9jit VM JIT interface j9jni VM JNI support j9jvmti VM JVMTI support j9mm VM memory management j9prt VM port library j9scar VM class library interface j9shr VM shared classes j9trc VM trace j9util VM utilities j9vm VM general j9vmutil VM utilities j9vrb VM verbose stack walker map VM mapped memory support mt Java methods (see Note ) net Class library TCP/IP networking native code pool VM storage pool support rpc VM RPC support simplepool VM storage pool support sunvmi VM class library interface Note: When specifying the mt component you must also specify the methods option. The following table lists all the tracepoint groups ( <group> ). Each group is associated with one or more Java components: Component name or names Group name Description j9mm gclogger A set of tracepoints that record each garbage collection cycle. Equivalent to -verbose:gc output j9prt nlsmessage A set of tracepoints that record each NLS message that is issued by the VM. j9jcl , j9vm verboseclass A set of tracepoints that record each class as it is loaded. Equivalent to -verbose:class output. j9jni , j9vm checkjni A set of tracepoints that record JNI function checks. Equivalent to -Xcheck:jni output. j9vm checkmemory A set of tracepoints that record memory checks. Equivalent to -Xcheck:memory output. j9vm checkvm A set of tracepoints that record VM checks. Equivalent to -Xcheck:vm output. j9jit verbose A set of tracepoints that record JIT compiler configuration and method compilation. Equivalent to -Xjit:verbose output. mt compiledMethods A set of tracepoints that record compiled Java methods. mt nativeMethods A set of tracepoints that record Java native methods. mt staticMethods A set of tracepoints that record Java static methods. Here are some examples: To trace all tracepoints, specify the following command: -Xtrace:maximal=all To trace all tracepoints except **j9vrb** and **j9trc**, specify the following command: -Xtrace:minimal={all},minimal={!j9vrb,j9trc} To trace all entry and exit tracepoints in j9bcu , specify the following command: -Xtrace:maximal={j9bcu{entry},j9bcu{exit}} To trace all tracepoints in **j9mm** except tracepoints 20-30, specify the following command: -Xtrace:maximal=j9mm,maximal=!j9mm.20-30 To trace tracepoints j9prt.5 through j9prt.15 , specify the following command: -Xtrace:print=j9prt.5-15 To trace all **j9trc** tracepoints, specify the following command: -Xtrace:count=j9trc To trace all entry and exit tracepoints, specify the following command: -Xtrace:external={all{entry},all{exit}}","title":"Tracepoint specification"},{"location":"xtrace/#trace-levels","text":"Tracepoints have been assigned levels 0 through 9 that are based on the importance of the tracepoint. A level 0 tracepoint is the most important. It is reserved for extraordinary events and errors. A level 9 tracepoint is in-depth component detail. To specify a given level of tracing, the level0 through level9 keywords are used. You can abbreviate these keywords to l0 through l9. For example, if level5 is selected, all tracepoints that have levels 0 through 5 are included. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. The level is provided as a modifier to a component specification, for example: -Xtrace:maximal={all{level5}} or -Xtrace:maximal={j9mm{L2},j9trc,j9bcu{level9},all{level1}} In the first example, tracepoints that have a level of 5 or less are enabled for all components. In the second example, all level 1 tracepoints are enabled. All level 2 tracepoints in j9mm are enabled. All tracepoints up to level 9 are enabled in j9bcu . Note: The level applies only to the current component. If multiple trace selection components are found in a trace properties file, the level is reset to the default for each new component. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. When the not operator is specified, the level is inverted; that is, !j9mm{level5} disables all tracepoints of level 6 or greater for the j9mm component. The following example enables trace for all components at level 9 (the default), but disables level 6 and higher for the locking component, and level 7 and higher for the storage component: -Xtrace:print={all},print={!j9trc{l5},j9mm{l6}} Here are some examples: To count the level zero and level one tracepoints matched, specify the following command: -Xtrace:count=all{L1} To produce maximal trace of all components at level 5 and j9mm at level 9, specify the following command: -Xtrace:maximal={all{level5},j9mm{L9}} To trace all components at level 6, but do not trace j9vrb at all, and do not trace the entry and exit tracepoints in the j9trc component, specify the following command: -Xtrace:minimal={all{l6}},minimal={!j9vrb,j9trc{entry},j9trc{exit}}","title":"Trace levels"},{"location":"xtrace/#parameters","text":"Parameters to use with the -Xtrace option:","title":"Parameters"},{"location":"xtrace/#buffers","text":"You can modify the size of the buffers to change how much diagnostic output is provided in a snap dump. This buffer is allocated for each thread that makes trace entries. The following table shows how this parameter can be set: Command Effect -Xtrace:buffers=<size> Creates buffers of the specified <size> in k (KB) or m (MB), allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>dynamic Creates buffers of the specified <size> , allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>nodynamic Creates buffers of the specified <size> , with a maximum allocation of two buffers per thread. If external trace is enabled, the number of buffers is doubled; that is, each thread allocates two or more buffers. The same buffer size is used for state and exception tracing, but, in this case, buffers are allocated globally. The default is 8 KB per thread. The dynamic and nodynamic suboptions have meaning only when tracing to an output file. Note: If nodynamic is specified, you might lose trace data if the volume of trace data exceeds the bandwidth of the trace output file. Message UTE115 is issued when the first trace entry is lost, and message UTE018 is issued when the VM ends. Here are some command line examples: To set a buffer size of 2 MB per thread, with dynamic buffering, use: -Xtrace:buffers=2m To limit each thread to 2 trace buffers, each of 128 KB: -Xtrace:buffers={128k,nodynamic}","title":"buffers"},{"location":"xtrace/#count-tracepoint","text":"-Xtrace:count=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The count option requests that only a count of the selected tracepoints is kept. When the VM ends, all nonzero totals of tracepoints (sorted by tracepoint id) are written to a file, called utTrcCounters , in the current directory. This information is useful if you want to determine the overhead of particular tracepoints, but do not want to produce a large amount (GB) of trace data. For example, to count the tracepoints that are used in the default trace configuration, use the following command: -Xtrace:count=all{level1},count=j9mm{gclogger}","title":"count (tracepoint)"},{"location":"xtrace/#exception-tracepoint","text":"-Xtrace:exception=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When exception trace is enabled, the trace data is collected in internal buffers that are separate from the normal buffers. These internal buffers can then be written to a snap file or written to the file that is specified in an exception.output option. The exception option allows low-volume tracing in buffers and files that are distinct from the higher-volume information that minimal and maximal tracing have provided. In most cases, this information is exception-type data, but you can use this option to capture any trace data that you want. This form of tracing is channeled through a single set of buffers, as opposed to the buffer-per-thread approach for normal trace. Buffer contention might occur if high volumes of trace data are collected. A difference exists in the <tracepoint_specification> defaults for exception tracing; see Tracepoint specification . Notes: The exception trace buffers are intended for low-volume tracing. By default, the exception trace buffers log garbage collection (GC) event tracepoints, see Default tracing. You can send additional tracepoints to the exception buffers or turn off the GC tracepoints. Changing the exception trace buffers alters the contents of the GC History section in any Javadumps. When exception trace is entered for an active tracepoint, the current thread ID is checked against the previous caller's thread ID. If it is a different thread, or this is the first call to exception trace, a context tracepoint is put into the trace buffer first. This context tracepoint consists only of the current thread ID, which is necessary because of the single set of buffers for exception trace. (The formatter identifies all trace entries as coming from the Exception trace pseudo thread when it formats exception trace files.)","title":"exception (tracepoint)"},{"location":"xtrace/#exceptionoutput","text":"Use exception output to redirect exceptions trace data to a file. -Xtrace:exception.output=<filename>[,<size>] Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d (today's date in \" yyyymmdd\" format), %p (process ID number of the process generating the trace), or %t (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps nondestructively to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Here are some examples: Exception trace output goes to file /u/traces/exception.trc with no size limit: -Xtrace:exception.output=/u/traces/exception.trc,maximal Exception trace output goes to file except and wraps at 2 MB: -Xtrace:exception.output={except,2m},maximal Exception trace output goes to a file whose filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:exception.output=traceout.%d.trc,maximal Exception trace output goes to a file whose filename contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:exception.output=tracefrompid%p.trc,maximal Exception trace output goes to a file whose filename contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:exception.output=traceout.%t.trc,maximal","title":"exception.output"},{"location":"xtrace/#external-tracepoint","text":"-Xtrace:external<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The external option routes trace data to trace listeners, which are registered by using the JVMTI RegisterTracePointSubscriber() and DeregisterTracePointSubscriber() APIs.","title":"external (tracepoint)"},{"location":"xtrace/#help","text":"-Xtrace:help Displays general trace help","title":"help"},{"location":"xtrace/#iprint-tracepoint","text":"-Xtrace:iprint=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The iprint option is the same as the print option, but uses indenting to format the trace.","title":"iprint (tracepoint)"},{"location":"xtrace/#maximal-tracepoint","text":"-Xtrace:maximal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. All associated data is traced. minimal and maximal traces are independent from any types that follow them. For example, if the maximal option is specified, it does not affect a later option such as print .","title":"maximal (tracepoint)"},{"location":"xtrace/#methods","text":"Using method trace provides a complete and potentially large diagnosis of code paths inside your application and the system classes. Use wild cards and filtering to control method trace so that you can focus on the sections of code that interest you. Note that method trace is powerful but it also has a cost. Application throughput is affected by method trace. To specify one or more method specifications, use the following syntax: -Xtrace:methods=<method_specification>[,<method_specification>] The syntax for <method_specification> can be further broken down to the following suboptions: -Xtrace:methods={[!][*][<package>/]<class>[*],[[*]<method>[*]|[()]]} Where: The delimiter between parts of the package name is a forward slash, \"/\". The ! in the methods parameter is a NOT operator that allows you to tell the VM not to trace the specified method or methods. The parentheses, (), define whether or not to include method parameters in the trace. If a method specification includes any commas, the whole specification must be enclosed in braces, for example: -Xtrace:methods={java/lang/*,java/util/*},print=mt It might be necessary to enclose your command line in quotation marks to prevent the shell intercepting and fragmenting comma-separated command lines, for example: \"-Xtrace:methods={java/lang/*,java/util/*},print=mt\" To output all method trace information to stderr, use either the print or iprint suboptions: -Xtrace:print=mt,methods=*.* -Xtrace:iprint=mt,methods=*.* The iprint suboption prints to stderr with indentation. To output method trace information in binary format, see the output option Internal Native Library (INL) native methods inside the VM cannot be traced because they are not implemented by using JNI. The list of methods that are not traceable is subject to change without notice. Here are some examples: Tracing entry and exit of all methods in a given class: To trace all method entry and exit of the ReaderMain class in the default package and the java.lang.String class, specify the following command: -Xtrace:methods={ReaderMain.*,java/lang/String.*},print=mt Tracing entry, exit and input parameters of all methods in a class: To trace all method entry, exit, and input of the ReaderMain class in the default package, specify the following command: -Xtrace:methods=ReaderMain.*(),print=mt Tracing all methods in a given package: To trace all method entry, exit, and input of all classes in the package com.ibm.socket , specify the following command: -Xtrace:methods=com/ibm/socket/*.*(),print=mt Multiple method trace: To trace all method entry, exit, and input in the Widget class in the default package and all method entry and exit in the common package, specify the following command: -Xtrace:methods={Widget.*(),common/*},print=mt Using the ! operator: To trace all methods in the ArticleUI class in the default package except those beginning with \"get\", specify the following command: -Xtrace:methods={ArticleUI.*,!ArticleUI.get*},print=mt Tracing a specific method in a class: This example traces entry and exit of the substring method of the java.lang.String class . If there is more than one method with the same name, they are all traced. You cannot filter method trace by the signature of the method. -Xtrace:print=mt,methods={java/lang/String.substring} Tracing the constructor of a class: This example traces entry and exit of the constructors of the java.lang.String class. -Xtrace:print=mt,methods={java/lang/String.<init>} Here is some example output: java \"-Xtrace:methods={java/lang*.*},iprint=mt\" HW 10:02:42.281*0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/String.<clinit>()V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method The output lines comprise of: 0x9e900 , the current execenv (execution environment). Because every VM thread has its own execenv , you can regard execenv as a thread-id . All trace with the same execenv relates to a single thread. The individual tracepoint ID in the mt component that collects and emits the data. The remaining fields show whether a method is being entered (>) or exited (<), followed by details of the method.","title":"methods"},{"location":"xtrace/#minimal-tracepoint","text":"-Xtrace:minimal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. Only the time stamp and tracepoint identifier are recorded. When the trace is formatted, missing trace data is replaced with the characters \"???\" in the output file. minimal and maximal traces are independent from any types that follow them. For example, if the minimal option is specified, it does not affect a later option such as print .","title":"minimal (tracepoint)"},{"location":"xtrace/#none-tracepoint","text":"-Xtrace:none[=<tracepoint_specification>] For further information about <tracepoint_specification> syntax, see Tracepoint specification . -Xtrace:none prevents the trace engine from loading if it is the only trace option specified. However, if other -Xtrace options are on the command line, it is treated as the equivalent of -Xtrace:none=all and the trace engine still loads. If you specify other tracepoints without specifying -Xtrace:none , the tracepoints are added to the default set.","title":"none (tracepoint)"},{"location":"xtrace/#output","text":"Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:output=<filename>[,<size>[,<generations>]]` Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d% (today's date in \" yyyymmdd\" format), %p% (process ID number of the process generating the trace), or %t% (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Optionally, <generations> is a value 2 through 36. These values cause up to 36 files to be used sequentially as each file reaches its <size> threshold. When a file needs to be reused, it is overwritten. If <generations> is specified, the filename must contain a # (hash, pound symbol), which will be substituted with its generation identifier, the sequence of which is 0 through 9 followed by A through Z. Note: When tracing to a file, buffers for each thread are written when the buffer is full or when the VM ends. If a thread has been inactive for a period of time before the VM ends, what seems to be 'old' trace data is written to the file. When formatted, it then seems that trace data is missing from the other threads, but this is an unavoidable side-effect of the buffer-per-thread design. This effect becomes especially noticeable when you use the generation facility, and format individual earlier generations. Here are some examples: Trace output goes to file /u/traces/gc.problem with no size limit: -Xtrace:output=/u/traces/gc.problem,maximal=j9gc Trace output goes to file trace , which will wrap at 2 MB: -Xtrace:output={trace,2m},maximal=j9gc Trace output goes to files gc0.trc , gc1.trc , and gc2.trc , each 10 MB in size: -Xtrace:output={gc#.trc,10m,3},maximal=j9gc Trace output goes to a file, where the filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:output=traceout.%d.trc,maximal=j9gc Trace output goes to a file whose name contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:output=tracefrompid%p.trc,maximal=j9gc Trace output goes to a file whose name contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:output=traceout.%t.trc,maximal=j9gc","title":"output"},{"location":"xtrace/#print-tracepoint","text":"-Xtrace:print=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The print option causes the specified tracepoints to be routed to stderr in real time. The VM tracepoints are formatted by using J9TraceFormat.dat . The class library tracepoints are formatted by J9TraceFormat.dat and TraceFormat.dat .","title":"print (tracepoint)"},{"location":"xtrace/#properties","text":"You can use properties files to control trace. A properties file saves typing and allows you to create a library of files that are tailored to solving problems in a particular area. -Xtrace:properties[=<filename>] If <filename> is not specified, the VM searches for a default name of IBMTRACE.properties in the current directory. All the options that are in the file are processed in the sequence in which they are stored in the file, before the next option that is obtained through the normal mechanism is processed. Therefore, a command-line property always overrides a property that is in the file. Here is an example of a properties file: minimal=all // maximal=j9mm maximal=j9shr buffers=128k,nodynamic output=c:\\traces\\classloader.trc print=tpnid(j9vm.23-25) The following restrictions apply to the file: The file must be a flat ASCII file. Nesting is not supported; that is, the file cannot contain a properties option. You cannot leave properties that have the form <name>=<value> to default if they are specified in the property file; that is, you must specify a value, for example maximal=all . Do not add white space before, after, or within the trace options. If any error is found when the file is accessed, VM initialization fails with an explanatory error message and return code. To use a file trace.props stored in the c:\\trc\\gc directory, specify the following command: -Xtrace:properties=c:\\trc\\gc\\trace.props","title":"properties"},{"location":"xtrace/#resume","text":"The resume option resumes tracing globally. -Xtrace:resume The suspend and resume options are not recursive. That is, two suspends that are followed by a single resume cause trace to be resumed.","title":"resume"},{"location":"xtrace/#resumecount","text":"This trace option determines whether tracing is enabled for each thread. -Xtrace:resumecount=<count> If <count> is greater than zero, each thread initially has its tracing disabled and must receive <count> resumethis actions before it starts tracing. This option is used with the trigger option. Note: You cannot use resumecount and suspendcount together because they use the same internal counter. The following example starts with all tracing turned off. Each thread starts tracing when it has had three resumethis actions performed on it: -Xtrace:resumecount=3","title":"resumecount"},{"location":"xtrace/#sleeptime","text":"You can specify how long the sleep lasts when using the sleep trigger action. -Xtrace:sleeptime=nnn|aaams|bbbs Where: nnn sleeps for nnn milliseconds. aaams sleeps for aaa milliseconds. bbbs sleeps for bbb seconds. The default length of time is 30 seconds. If no units are specified, the default time unit is milliseconds.","title":"sleeptime"},{"location":"xtrace/#stackdepth","text":"Use this option to limit the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:stackdepth=<n> Where <n> is the maximum number of stack frames reported.","title":"stackdepth"},{"location":"xtrace/#suspend","text":"-Xtrace:suspend Suspends tracing globally for all threads and all forms of tracing but leaves tracepoints activated.","title":"suspend"},{"location":"xtrace/#suspendcount","text":"This trace option determines whether tracing is enabled for each thread. -Xtrace:suspendcount=<count> If <count> is greater than zero, each thread initially has its tracing enabled and must receive <count> suspendthis actions before it stops tracing. You cannot use resumecount and suspendcount together because they both set the same internal counter. This trace option is for use with the trigger option. The following example starts with tracing turned on. Each thread stops tracing when it has had three suspendthis actions performed on it: -Xtrace:suspendcount=3","title":"suspendcount"},{"location":"xtrace/#trigger","text":"The trigger parameter determines when various triggered trace actions occur. Supported actions include turning tracing on and off for all threads, turning tracing on or off for the current thread, or producing various dumps. -Xtrace:trigger=<clause>[,<clause>] This trace option does not control what is traced. It controls only whether the information that has been selected by the other trace options is produced as normal or is blocked.","title":"trigger"},{"location":"xtrace/#types","text":"Each clause of the trigger parameter can be one of the following types: a method ( -Xtrace:trigger=method{...} ) a tracepoint ID ( -Xtrace:trigger=tpnid{...} ) a group ( -Xtrace:trigger=group{...} ) You can specify multiple clauses of the same type if required, but you do not need to specify all types. method -Xtrace:trigger=method{<methodspec>[,<entryAction>[,<exitAction>[,<delayCount>[,<matchcount>]]]]} On entering a method that matches <methodspec> , the specified <entryAction> is run. On leaving a method that matches <methodspec> , the specified <exitAction> is run. If you specify a <delayCount> , the actions are performed only after a matching <methodspec> has been entered that many times. If you specify a <matchCount> , <entryAction> and <exitAction> are performed at most that many times. <methodspec> is the specification of a Java method, consisting of a class and a method name separated by a dot. For example, specify HelloWorld.main . If the class is in a package, the package name must be included, separated by slashes. For example, specify java/lang/String.getBytes . A wildcard \"*\" can be used at the start or end of the class and method names, or both. For example, you can specify */String.get* . To specify a constructor method, use <init> as the method name. Method signatures cannot be specified, so a method specification applies to all overloaded methods. tracepoint ID -Xtrace:trigger=tpnid{<tpnid>|<tpnidRange>,<action>[,<delayCount>[,<matchcount>]]} On finding the specified active tracepoint ID ( <tpnid> ) or a tracepoint ID) that falls inside the specified <tpnidRange> , the specified action is run . If you specify a <delayCount> , the action is performed only after the VM finds such an active <tpnid> that many times. If you specify a <matchCount> , <action> is performed at most that many times. group -Xtrace:trigger=group{<groupname>,<action>[,<delayCount>[,<matchcount>]]} On finding any active tracepoint that is defined as being in trace group <groupname> , for example Entry or Exit , the specified action is run . If you specify a <delayCount> , the action is performed only after that many active tracepoints from group <groupname> have been found. If you specify a <matchCount> , <action> is performed at most that many times.","title":"Types"},{"location":"xtrace/#actions","text":"Wherever an action ( <action> , <entryAction> , or <exitAction> ) must be specified in one of the trigger parameter clauses, you must select from these options: <action> Effect abort Halt the VM. ceedump This action is applicable to z/OS\u00ae only. For more information, see z/OS LE CEEDUMPs . coredump Produce a system dump. See Dump agents ( -Xdump:system ) heapdump Produce a heap dump. See Heap dump . javadump Produce a Java dump. See Java dump . jstacktrace Examine the Java stack of the current thread and generate auxiliary tracepoints for each stack frame. The auxiliary tracepoints are written to the same destination as the tracepoint or method trace that triggered the action. You can control the number of stack frames examined with the stackdepth=n option. See the stackdepth option. resume Resume all tracing (except for threads that are suspended by the action of the resumecount property and Trace.suspendThis() calls). resumethis Decrement the suspend count for this thread. If the suspend count is zero or less, resume tracing for this thread. segv Cause a segmentation violation. (Intended for use in debugging.) sleep Delay the current thread for a length of time controlled by the sleeptime option. The default is 30 seconds. See sleeptime option. snap Snap all active trace buffers to a file in the current working directory. The file name has the format: Snapnnnn.yyyymmdd.hhmmssth.ppppp.trc , where nnnn is the sequence number of the snap file since VM startup, yyyymmdd is the date, hhmmssth is the time, and ppppp is the process ID in decimal with leading zeros removed. suspend Suspend all tracing (except for special trace points). suspendthis Increment the suspend count for this thread. If the suspend-count is greater than zero, prevent all tracing for this thread. sysdump (or coredump ) Produce a system dump. See Dump agents( -Xdump:system ) . Here are some examples of using the trigger option: To produce a Java dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump} To produce a system dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,sysdump} To produce a Java dump when a class constructor is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<init>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a class static initializer is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<clinit>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a method is entered 1000 times and 1001 times, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump,,1000,2} To start tracing this thread when it enters any method in java/lang/String , and to stop tracing the thread after exiting the method, specify the following command: -Xtrace:resumecount=1 -Xtrace:trigger=method{java/lang/String.*,resumethis,suspendthis} To resume all tracing when any thread enters a method in any class that starts with error , specify the following command: -Xtrace:trigger=method{*.error*,resume} To trace (all threads) while the application is active; that is, not starting or shut down. (The application name is HelloWorld ), specify the following command: -Xtrace:suspend,trigger=method{HelloWorld.main,resume,suspend} To print a Java stack trace to the console when the mycomponent.1 tracepoint is reached, specify the following command: -Xtrace:print=mycomponent.1,trigger=tpnid{mycomponent.1,jstacktrace} To write a Java stack trace to the trace output file when the Sample.code() method is called, specify the following command: -Xtrace:maximal=mt,output=trc.out,methods={mycompany/mypackage/Sample.code},trigger=method{mycompany/mypackage/Sample.code,jstacktrace}","title":"Actions"},{"location":"xtrace/#what","text":"-Xtrace:what Shows the current trace settings","title":"what"},{"location":"xtrace/#see-also","text":"Application trace Heap dump Java dump Dump viewer","title":"See also"},{"location":"xtunevirtualized/","text":"-Xtune:virtualized Optimizes Eclipse OpenJ9\u2122 VM function for virtualized environments, such as a cloud, by reducing OpenJ9 VM CPU consumption when idle. Note: Performance is optimized if there is a large shared classes cache (SCC) and AOT space in the SCC is not capped. Syntax -Xtune:virtualized This option is recommended for CPU-constrained environments, such as those found in cloud deployments that use containers. Internally, the option makes the JIT compiler more conservative with inlining and recompilation decisions, which saves CPU resources. The Garbage Collector also reduces the rate of heap expansion, which reduces the memory footprint. These changes to reduce the amount of CPU that is consumed are at the expense of a small loss in throughput. When -Xtune:virtualized is used in conjunction with the -Xshareclasses option, the JIT compiler is more aggressive with its use of AOT-compiled code compared to setting only -Xshareclasses . This action provides additional CPU savings during application start-up and ramp-up, but comes at the expense of an additional small loss in throughput. See also For an example of the effect of using this option, see: Measuring the strengths of OpenJDK with Eclipse OpenJ9","title":"-Xtune:virtualized"},{"location":"xtunevirtualized/#-xtunevirtualized","text":"Optimizes Eclipse OpenJ9\u2122 VM function for virtualized environments, such as a cloud, by reducing OpenJ9 VM CPU consumption when idle. Note: Performance is optimized if there is a large shared classes cache (SCC) and AOT space in the SCC is not capped.","title":"-Xtune:virtualized"},{"location":"xtunevirtualized/#syntax","text":"-Xtune:virtualized This option is recommended for CPU-constrained environments, such as those found in cloud deployments that use containers. Internally, the option makes the JIT compiler more conservative with inlining and recompilation decisions, which saves CPU resources. The Garbage Collector also reduces the rate of heap expansion, which reduces the memory footprint. These changes to reduce the amount of CPU that is consumed are at the expense of a small loss in throughput. When -Xtune:virtualized is used in conjunction with the -Xshareclasses option, the JIT compiler is more aggressive with its use of AOT-compiled code compared to setting only -Xshareclasses . This action provides additional CPU savings during application start-up and ramp-up, but comes at the expense of an additional small loss in throughput.","title":"Syntax"},{"location":"xtunevirtualized/#see-also","text":"For an example of the effect of using this option, see: Measuring the strengths of OpenJDK with Eclipse OpenJ9","title":"See also"},{"location":"xverbosegclog/","text":"-Xverbosegclog Causes garbage collection (GC) output from the -verbose:gc option to be written to a specified file. Syntax -Xverbosegclog[:<filename>[,<x>,<y>]] where <filename> is the name of the file to which output is written. Dump agent tokens can be used in the filename. If the file cannot be found, the file is created, and output is written to the new file. If the file cannot be created (for example, if an invalid filename is specified), output is redirected to stderr . If you do not specify a file name, verbosegc.%Y%m%d.%H%M%S.%pid.txt is used (for example, verbosegc.20180124.093210.1234.txt ). If you specify <x> and <y> , output is redirected to x files, each containing y GC cycles. Default behavior By default, no verbose GC logging occurs. See also Dump agent tokens for more information. Verbose GC logs and Log examples for more information about verbose GC logs.","title":"-Xverbosegclog"},{"location":"xverbosegclog/#-xverbosegclog","text":"Causes garbage collection (GC) output from the -verbose:gc option to be written to a specified file.","title":"-Xverbosegclog"},{"location":"xverbosegclog/#syntax","text":"-Xverbosegclog[:<filename>[,<x>,<y>]] where <filename> is the name of the file to which output is written. Dump agent tokens can be used in the filename. If the file cannot be found, the file is created, and output is written to the new file. If the file cannot be created (for example, if an invalid filename is specified), output is redirected to stderr . If you do not specify a file name, verbosegc.%Y%m%d.%H%M%S.%pid.txt is used (for example, verbosegc.20180124.093210.1234.txt ). If you specify <x> and <y> , output is redirected to x files, each containing y GC cycles.","title":"Syntax"},{"location":"xverbosegclog/#default-behavior","text":"By default, no verbose GC logging occurs.","title":"Default behavior"},{"location":"xverbosegclog/#see-also","text":"Dump agent tokens for more information. Verbose GC logs and Log examples for more information about verbose GC logs.","title":"See also"},{"location":"xverify/","text":"-Xverify As described in the Oracle documentation , this HotSpot option enables or disables the verifier. For compatibility, this option is also supported by the Eclipse OpenJ9\u2122 VM. Syntax Setting Effect Default -Xverify Enables verification for all non-bootstrap classes. -Xfuture verification is not enabled. yes -Xverify:all Enables verification for all classes and enables -Xfuture verification. You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier . Note: This setting might have an impact on performance. -Xverify:remote For compatibility, this parameter is accepted, but is equivalent to the default -Xverify . -Xverify:none Disables the verifier. Note: This is not a supported configuration and, as noted, was deprecated from Java 13. If you encounter problems with the verifier turned off, remove this option and try to reproduce the problem. Note: The option -Xverify:none (and its equivalent -noverify ) was deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions.","title":"-Xverify"},{"location":"xverify/#-xverify","text":"As described in the Oracle documentation , this HotSpot option enables or disables the verifier. For compatibility, this option is also supported by the Eclipse OpenJ9\u2122 VM.","title":"-Xverify"},{"location":"xverify/#syntax","text":"Setting Effect Default -Xverify Enables verification for all non-bootstrap classes. -Xfuture verification is not enabled. yes -Xverify:all Enables verification for all classes and enables -Xfuture verification. You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier . Note: This setting might have an impact on performance. -Xverify:remote For compatibility, this parameter is accepted, but is equivalent to the default -Xverify . -Xverify:none Disables the verifier. Note: This is not a supported configuration and, as noted, was deprecated from Java 13. If you encounter problems with the verifier turned off, remove this option and try to reproduce the problem. Note: The option -Xverify:none (and its equivalent -noverify ) was deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions.","title":"Syntax"},{"location":"xx_jvm_commands/","text":"Using -XX command-line options Java\u2122 VM command-line options that are specified with -XX: are not checked for validity. If the VM does not recognize the option, the option is ignored. These options can therefore be used across different VM versions without ensuring a particular level of the VM. If you want to turn off this behavior to test whether your -XX options are valid, use the -XX:-IgnoreUnrecognizedXXColonOptions option. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -XX:MaxDirectMemorySize value to 16 MB, you can specify -XX:MaxDirectMemorySize16M , -XX:MaxDirectMemorySize16m , -XX:MaxDirectMemorySize16384K , or XX:MaxDirectMemorySize16384k on the command line.","title":"Using -XX options"},{"location":"xx_jvm_commands/#using-xx-command-line-options","text":"Java\u2122 VM command-line options that are specified with -XX: are not checked for validity. If the VM does not recognize the option, the option is ignored. These options can therefore be used across different VM versions without ensuring a particular level of the VM. If you want to turn off this behavior to test whether your -XX options are valid, use the -XX:-IgnoreUnrecognizedXXColonOptions option. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -XX:MaxDirectMemorySize value to 16 MB, you can specify -XX:MaxDirectMemorySize16M , -XX:MaxDirectMemorySize16m , -XX:MaxDirectMemorySize16384K , or XX:MaxDirectMemorySize16384k on the command line.","title":"Using -XX command-line options"},{"location":"xxactiveprocessorcount/","text":"-XX:ActiveProcessorCount This HotSpot option is recognized by Eclipse OpenJ9\u2122 for compatibility. Use this option to override the number of CPUs that the VM automatically detects and uses when creating threads for various subsystems. Syntax -XX:ActiveProcessorCount=<n> Where <n> is the number of CPUs. Setting Value Default <n> 1 or greater There is no default value. This option is not enabled by default. If set to 0 , there is no effect. When you set this option the following line in a Java dump file is updated to indicate the number of CPUs specified: 2CIACTIVECPU Active CPUs If this option is not set, the value for this line is 0 Active CPUs.","title":"-XXActiveProcessorCount"},{"location":"xxactiveprocessorcount/#-xxactiveprocessorcount","text":"This HotSpot option is recognized by Eclipse OpenJ9\u2122 for compatibility. Use this option to override the number of CPUs that the VM automatically detects and uses when creating threads for various subsystems.","title":"-XX:ActiveProcessorCount"},{"location":"xxactiveprocessorcount/#syntax","text":"-XX:ActiveProcessorCount=<n> Where <n> is the number of CPUs. Setting Value Default <n> 1 or greater There is no default value. This option is not enabled by default. If set to 0 , there is no effect. When you set this option the following line in a Java dump file is updated to indicate the number of CPUs specified: 2CIACTIVECPU Active CPUs If this option is not set, the value for this line is 0 Active CPUs.","title":"Syntax"},{"location":"xxadaptivegcthreading/","text":"-XX:[+|-]AdaptiveGCThreading Restriction: Currently, this feature is available only with the gencon GC policy. When this option is enabled, the active GC thread count is adjusted for each garbage collection (GC) cycle based on heuristics. That is, when a GC cycle successfully completes, the collector evaluates parallelism using aggregated thread statistics gathered during the completed cycle and projects a new thread count for the next cycle. For example, the thread count might be reduced if it is determined that an unnecessary overhead was incurred as a result of synchronization, lack of work sharing, or CPU availability. Similarly, the thread count may be increased if there's an opportunity to gain benefits from increased parallelism. Notes: This option is ignored when the GC thread count is enforced, for example when using the -xgcthreads or -XX:ParallelGCThreads options. By default, the number of GC threads is based on the number of CPUs reported by the operating system. This value is used as the maximum thread count. However, an upper bound can be specified by using -xgcmaxthreads or XX:ParallelGCMaxThreads . Syntax -XX:[+|-]AdaptiveGCThreading Setting Effect Default -XX:+AdaptiveGCThreading Enable yes -XX:-AdaptiveGCThreading Disable This optimization aims to automatically tune the GC thread count. Manually tuning and setting a thread count can be suboptimal because workloads typically change over the lifetime of an application. You can check the active thread count value that is used by the garbage collector to complete the cycle by inspecting verbose GC output. The following example shows active thread count being reduced from 8 to 3: <gc-end id=\"8\" type=\"scavenge\" contextid=\"4\" durationms=\"2.248\" usertimems=\"3.694\" systemtimems=\"1.345\" stalltimems=\"11.003\" timestamp=\"2021-03-12T01:35:10.768\" activeThreads=\"8\"> <gc-end id=\"20\" type=\"scavenge\" contextid=\"16\" durationms=\"7.045\" usertimems=\"6.360\" systemtimems=\"0.955\" stalltimems=\"31.964\" timestamp=\"2021-03-12T01:35:10.777\" activeThreads=\"6\"> <gc-end id=\"32\" type=\"scavenge\" contextid=\"28\" durationms=\"1.943\" usertimems=\"7.112\" systemtimems=\"0.454\" stalltimems=\"6.076\" timestamp=\"2021-03-12T01:35:10.781\" activeThreads=\"5\"> <gc-end id=\"44\" type=\"scavenge\" contextid=\"40\" durationms=\"1.253\" usertimems=\"2.910\" systemtimems=\"0.297\" stalltimems=\"2.416\" timestamp=\"2021-03-12T01:35:10.788\" activeThreads=\"4\"> <gc-end id=\"56\" type=\"scavenge\" contextid=\"52\" durationms=\"1.487\" usertimems=\"3.991\" systemtimems=\"0.447\" stalltimems=\"2.918\" timestamp=\"2021-03-12T01:35:10.790\" activeThreads=\"4\"> <gc-end id=\"68\" type=\"scavenge\" contextid=\"64\" durationms=\"0.400\" usertimems=\"1.002\" systemtimems=\"0.178\" stalltimems=\"0.658\" timestamp=\"2021-03-12T01:35:10.791\" activeThreads=\"4\"> <gc-end id=\"80\" type=\"scavenge\" contextid=\"76\" durationms=\"0.187\" usertimems=\"1.099\" systemtimems=\"0.127\" stalltimems=\"0.112\" timestamp=\"2021-03-12T01:35:10.792\" activeThreads=\"3\"> <gc-end id=\"92\" type=\"scavenge\" contextid=\"88\" durationms=\"0.195\" usertimems=\"0.940\" systemtimems=\"0.114\" stalltimems=\"0.067\" timestamp=\"2021-03-12T01:35:10.796\" activeThreads=\"3\"> <gc-end id=\"104\" type=\"scavenge\" contextid=\"100\" durationms=\"0.277\" usertimems=\"0.899\" systemtimems=\"0.118\" stalltimems=\"0.139\" timestamp=\"2021-03-12T01:35:10.797\" activeThreads=\"3\">","title":"-XX:[+|-]AdaptiveGCThreading"},{"location":"xxadaptivegcthreading/#-xx-adaptivegcthreading","text":"Restriction: Currently, this feature is available only with the gencon GC policy. When this option is enabled, the active GC thread count is adjusted for each garbage collection (GC) cycle based on heuristics. That is, when a GC cycle successfully completes, the collector evaluates parallelism using aggregated thread statistics gathered during the completed cycle and projects a new thread count for the next cycle. For example, the thread count might be reduced if it is determined that an unnecessary overhead was incurred as a result of synchronization, lack of work sharing, or CPU availability. Similarly, the thread count may be increased if there's an opportunity to gain benefits from increased parallelism. Notes: This option is ignored when the GC thread count is enforced, for example when using the -xgcthreads or -XX:ParallelGCThreads options. By default, the number of GC threads is based on the number of CPUs reported by the operating system. This value is used as the maximum thread count. However, an upper bound can be specified by using -xgcmaxthreads or XX:ParallelGCMaxThreads .","title":"-XX:[+|-]AdaptiveGCThreading"},{"location":"xxadaptivegcthreading/#syntax","text":"-XX:[+|-]AdaptiveGCThreading Setting Effect Default -XX:+AdaptiveGCThreading Enable yes -XX:-AdaptiveGCThreading Disable This optimization aims to automatically tune the GC thread count. Manually tuning and setting a thread count can be suboptimal because workloads typically change over the lifetime of an application. You can check the active thread count value that is used by the garbage collector to complete the cycle by inspecting verbose GC output. The following example shows active thread count being reduced from 8 to 3: <gc-end id=\"8\" type=\"scavenge\" contextid=\"4\" durationms=\"2.248\" usertimems=\"3.694\" systemtimems=\"1.345\" stalltimems=\"11.003\" timestamp=\"2021-03-12T01:35:10.768\" activeThreads=\"8\"> <gc-end id=\"20\" type=\"scavenge\" contextid=\"16\" durationms=\"7.045\" usertimems=\"6.360\" systemtimems=\"0.955\" stalltimems=\"31.964\" timestamp=\"2021-03-12T01:35:10.777\" activeThreads=\"6\"> <gc-end id=\"32\" type=\"scavenge\" contextid=\"28\" durationms=\"1.943\" usertimems=\"7.112\" systemtimems=\"0.454\" stalltimems=\"6.076\" timestamp=\"2021-03-12T01:35:10.781\" activeThreads=\"5\"> <gc-end id=\"44\" type=\"scavenge\" contextid=\"40\" durationms=\"1.253\" usertimems=\"2.910\" systemtimems=\"0.297\" stalltimems=\"2.416\" timestamp=\"2021-03-12T01:35:10.788\" activeThreads=\"4\"> <gc-end id=\"56\" type=\"scavenge\" contextid=\"52\" durationms=\"1.487\" usertimems=\"3.991\" systemtimems=\"0.447\" stalltimems=\"2.918\" timestamp=\"2021-03-12T01:35:10.790\" activeThreads=\"4\"> <gc-end id=\"68\" type=\"scavenge\" contextid=\"64\" durationms=\"0.400\" usertimems=\"1.002\" systemtimems=\"0.178\" stalltimems=\"0.658\" timestamp=\"2021-03-12T01:35:10.791\" activeThreads=\"4\"> <gc-end id=\"80\" type=\"scavenge\" contextid=\"76\" durationms=\"0.187\" usertimems=\"1.099\" systemtimems=\"0.127\" stalltimems=\"0.112\" timestamp=\"2021-03-12T01:35:10.792\" activeThreads=\"3\"> <gc-end id=\"92\" type=\"scavenge\" contextid=\"88\" durationms=\"0.195\" usertimems=\"0.940\" systemtimems=\"0.114\" stalltimems=\"0.067\" timestamp=\"2021-03-12T01:35:10.796\" activeThreads=\"3\"> <gc-end id=\"104\" type=\"scavenge\" contextid=\"100\" durationms=\"0.277\" usertimems=\"0.899\" systemtimems=\"0.118\" stalltimems=\"0.139\" timestamp=\"2021-03-12T01:35:10.797\" activeThreads=\"3\">","title":"Syntax"},{"location":"xxallowvmshutdown/","text":"-XXallowvmshutdown This option is provided as a workaround for applications that cannot shut down cleanly, as described in APAR IZ59734 . Syntax -XX:allowvmshutdown:[false|true] Setting Effect Default false Disable true Enable yes","title":"-XXallowvmshutdown"},{"location":"xxallowvmshutdown/#-xxallowvmshutdown","text":"This option is provided as a workaround for applications that cannot shut down cleanly, as described in APAR IZ59734 .","title":"-XXallowvmshutdown"},{"location":"xxallowvmshutdown/#syntax","text":"-XX:allowvmshutdown:[false|true] Setting Effect Default false Disable true Enable yes","title":"Syntax"},{"location":"xxalwayspretouch/","text":"-XX:[+|-]AlwaysPreTouch This Oracle HotSpot option enables or disables the committing of memory during initial heap inflation or heap expansion. Syntax -XX:[+|-]AlwaysPreTouch Setting Effect Default -XX:+AlwaysPreTouch Enable -XX:-AlwaysPreTouch Disable yes","title":"-XX:[+|-]AlwaysPreTouch"},{"location":"xxalwayspretouch/#-xx-alwayspretouch","text":"This Oracle HotSpot option enables or disables the committing of memory during initial heap inflation or heap expansion.","title":"-XX:[+|-]AlwaysPreTouch"},{"location":"xxalwayspretouch/#syntax","text":"-XX:[+|-]AlwaysPreTouch Setting Effect Default -XX:+AlwaysPreTouch Enable -XX:-AlwaysPreTouch Disable yes","title":"Syntax"},{"location":"xxclassrelationshipverifier/","text":"-XX:[+|-]ClassRelationshipVerifier This option enables and disables the recording of class relationships in the verifier to delay validation until triggered by class loading. Note: You cannot use this setting in conjunction with -Xfuture or -Xverify:all , which itself enables -Xfuture . Syntax -XX:[+|-]ClassRelationshipVerifier Setting Effect Default -XX:+ClassRelationshipVerifier Enable -XX:-ClassRelationshipVerifier Disable yes Explanation When enabled, this option delays validating the relationships between classes until the classes are required to be loaded during program execution. In this way, classes that are not required, are never loaded thus reducing VM startup time. A verify error is thrown if validation fails.","title":"-XX:[+|-]ClassRelationshipVerifier"},{"location":"xxclassrelationshipverifier/#-xx-classrelationshipverifier","text":"This option enables and disables the recording of class relationships in the verifier to delay validation until triggered by class loading. Note: You cannot use this setting in conjunction with -Xfuture or -Xverify:all , which itself enables -Xfuture .","title":"-XX:[+|-]ClassRelationshipVerifier"},{"location":"xxclassrelationshipverifier/#syntax","text":"-XX:[+|-]ClassRelationshipVerifier Setting Effect Default -XX:+ClassRelationshipVerifier Enable -XX:-ClassRelationshipVerifier Disable yes","title":"Syntax"},{"location":"xxclassrelationshipverifier/#explanation","text":"When enabled, this option delays validating the relationships between classes until the classes are required to be loaded during program execution. In this way, classes that are not required, are never loaded thus reducing VM startup time. A verify error is thrown if validation fails.","title":"Explanation"},{"location":"xxcodecachetotal/","text":"-XX:codecachetotal This option is an alias for the -Xcodecachetotal option. Syntax -XX:codecachetotal=<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"-XX:codecachetotal"},{"location":"xxcodecachetotal/#-xxcodecachetotal","text":"This option is an alias for the -Xcodecachetotal option.","title":"-XX:codecachetotal"},{"location":"xxcodecachetotal/#syntax","text":"-XX:codecachetotal=<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xxcompactstrings/","text":"-XX:[+|-]CompactStrings This HotSpot option is reimplemented by Eclipse OpenJ9\u2122 and when enabled causes an ISO8859-1 (also known as Latin-1) character representation to be used internally for String objects, while preserving full API compatibility. This feature provides heap space savings by using an 8-bit character set internally. Most benefit is gained when the majority of the String objects that your application uses can be encoded using the ISO8859-1 character encoding. If the option is not enabled, the JIT compiler is nevertheless optimized so that although there is no saving in heap space, there is also no performance penalty. Further details are available at JEP 254: Compact Strings . Note: With OpenJ9, this option is supported on OpenJDK version 8 and later versions, whereas HotSpot supports it only from Java version 9. Syntax Setting Effect Default -XX:+CompactStrings Enable String compression -XX:-CompactStrings Disable String compression yes","title":"-XX:[+|-]CompactStrings"},{"location":"xxcompactstrings/#-xx-compactstrings","text":"This HotSpot option is reimplemented by Eclipse OpenJ9\u2122 and when enabled causes an ISO8859-1 (also known as Latin-1) character representation to be used internally for String objects, while preserving full API compatibility. This feature provides heap space savings by using an 8-bit character set internally. Most benefit is gained when the majority of the String objects that your application uses can be encoded using the ISO8859-1 character encoding. If the option is not enabled, the JIT compiler is nevertheless optimized so that although there is no saving in heap space, there is also no performance penalty. Further details are available at JEP 254: Compact Strings . Note: With OpenJ9, this option is supported on OpenJDK version 8 and later versions, whereas HotSpot supports it only from Java version 9.","title":"-XX:[+|-]CompactStrings"},{"location":"xxcompactstrings/#syntax","text":"Setting Effect Default -XX:+CompactStrings Enable String compression -XX:-CompactStrings Disable String compression yes","title":"Syntax"},{"location":"xxconcgcthreads/","text":"-XX:ConcGCThreads This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility. Syntax -XX:ConcGCThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"-XX:ConcGCThreads"},{"location":"xxconcgcthreads/#-xxconcgcthreads","text":"This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility.","title":"-XX:ConcGCThreads"},{"location":"xxconcgcthreads/#syntax","text":"-XX:ConcGCThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"Syntax"},{"location":"xxdiagnosesynconvaluebasedclasses/","text":"-XX:DiagnoseSyncOnValueBasedClasses This HotSpot option provides warnings about improper attempts to synchronize on instances of a value-based class. The option is recognized by Eclipse OpenJ9\u2122 for compatibility. Syntax -XX:DiagnoseSyncOnValueBasedClasses=<number> <number> value Effect 1 Generate VirtualMachineError error 2 Print a warning message","title":"-XX:DiagnoseSyncOnValueBasedClasses"},{"location":"xxdiagnosesynconvaluebasedclasses/#-xxdiagnosesynconvaluebasedclasses","text":"This HotSpot option provides warnings about improper attempts to synchronize on instances of a value-based class. The option is recognized by Eclipse OpenJ9\u2122 for compatibility.","title":"-XX:DiagnoseSyncOnValueBasedClasses"},{"location":"xxdiagnosesynconvaluebasedclasses/#syntax","text":"-XX:DiagnoseSyncOnValueBasedClasses=<number> <number> value Effect 1 Generate VirtualMachineError error 2 Print a warning message","title":"Syntax"},{"location":"xxdisableexplicitgc/","text":"-XX:[+|-]DisableExplicitGC This HotSpot option is recognized by Eclipse OpenJ9\u2122 for compatibility. See \u2011Xenableexplicitgc.md / \u2011Xdisableexplicitgc for details. Syntax Setting Effect Default -XX:+DisableExplicitGC Enable GC yes -XX:-DisableExplicitGC Disable GC","title":"-XX:[+|-]DisableExplicitGC"},{"location":"xxdisableexplicitgc/#-xx-disableexplicitgc","text":"This HotSpot option is recognized by Eclipse OpenJ9\u2122 for compatibility. See \u2011Xenableexplicitgc.md / \u2011Xdisableexplicitgc for details.","title":"-XX:[+|-]DisableExplicitGC"},{"location":"xxdisableexplicitgc/#syntax","text":"Setting Effect Default -XX:+DisableExplicitGC Enable GC yes -XX:-DisableExplicitGC Disable GC","title":"Syntax"},{"location":"xxdisclaimjitscratch/","text":"-XX:[+|-]DisclaimJitScratch Restriction: This option is deprecated; the option is accepted but ignored. (Linux\u00ae only) The -XX:+DisclaimJitScratch option signals to the operating system to discard temporary physical memory that is consumed by the JIT compilation threads. Syntax -XX:[+|-]DisclaimJitScratch Setting Effect Default -XX:+DisclaimJitScratch Enable -XX:-DisclaimJitScratch Disable yes Explanation Discarding temporary physical memory can reduce the physical memory reported in use by the Java\u2122 application. The physical memory that is released is available to other processes without the operating system needing to search for the least recently used frames. The -XX:-DisclaimJitScratch option turns off a previously enabled -XX:+DisclaimJitScratch option.","title":"-XX:[+|-]DisclaimJitScratch"},{"location":"xxdisclaimjitscratch/#-xx-disclaimjitscratch","text":"Restriction: This option is deprecated; the option is accepted but ignored. (Linux\u00ae only) The -XX:+DisclaimJitScratch option signals to the operating system to discard temporary physical memory that is consumed by the JIT compilation threads.","title":"-XX:[+|-]DisclaimJitScratch"},{"location":"xxdisclaimjitscratch/#syntax","text":"-XX:[+|-]DisclaimJitScratch Setting Effect Default -XX:+DisclaimJitScratch Enable -XX:-DisclaimJitScratch Disable yes","title":"Syntax"},{"location":"xxdisclaimjitscratch/#explanation","text":"Discarding temporary physical memory can reduce the physical memory reported in use by the Java\u2122 application. The physical memory that is released is available to other processes without the operating system needing to search for the least recently used frames. The -XX:-DisclaimJitScratch option turns off a previously enabled -XX:+DisclaimJitScratch option.","title":"Explanation"},{"location":"xxenable3164interoperability/","text":"-XX:[+|-]Enable3164Interoperability (z/OS\u00ae only) Enables support for using 31-bit native applications with the 64-bit Java\u2122 virtual machine, where that support is available. For more information, see Using 31-bit native code with the 64-bit Java VM .","title":"-XX:[+|-]Enable3164Interoperability"},{"location":"xxenable3164interoperability/#-xx-enable3164interoperability","text":"(z/OS\u00ae only) Enables support for using 31-bit native applications with the 64-bit Java\u2122 virtual machine, where that support is available. For more information, see Using 31-bit native code with the 64-bit Java VM .","title":"-XX:[+|-]Enable3164Interoperability"},{"location":"xxenablecpumonitor/","text":"-XX:[+|-]EnableCPUMonitor This option relates to the information about the CPU usage of thread categories that is available with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. Restriction: This option might not be supported in subsequent releases. Syntax -XX:[+|-]EnableCPUMonitor Setting Effect Default -XX:+EnableCPUMonitor Enable yes -XX:-EnableCPUMonitor Disable Explanation The -XX:+EnableCPUMonitor option enables CPU monitoring, which allows a JMX bean to track CPU usage on a per thread basis and attributes the usage against different categories. For more information, see the JvmCpuMonitorMXBean interface in the com.ibm.lang.management API documentation. To turn off CPU monitoring, set the -XX:-EnableCPUMonitor option on the command line. See also -XX:[+|-]ReduceCPUMonitorOverhead","title":"-XX:[+|-]EnableCPUMonitor"},{"location":"xxenablecpumonitor/#-xx-enablecpumonitor","text":"This option relates to the information about the CPU usage of thread categories that is available with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. Restriction: This option might not be supported in subsequent releases.","title":"-XX:[+|-]EnableCPUMonitor"},{"location":"xxenablecpumonitor/#syntax","text":"-XX:[+|-]EnableCPUMonitor Setting Effect Default -XX:+EnableCPUMonitor Enable yes -XX:-EnableCPUMonitor Disable","title":"Syntax"},{"location":"xxenablecpumonitor/#explanation","text":"The -XX:+EnableCPUMonitor option enables CPU monitoring, which allows a JMX bean to track CPU usage on a per thread basis and attributes the usage against different categories. For more information, see the JvmCpuMonitorMXBean interface in the com.ibm.lang.management API documentation. To turn off CPU monitoring, set the -XX:-EnableCPUMonitor option on the command line.","title":"Explanation"},{"location":"xxenablecpumonitor/#see-also","text":"-XX:[+|-]ReduceCPUMonitorOverhead","title":"See also"},{"location":"xxensurehashed/","text":"-XX:[+|-]EnsureHashed This option specifies classes to be pre-hashed. Objects that are created from these classes are hashed and extended with a slot to store the assigned hash value when the object is created or first moved during the garbage collection process. This option might improve performance for applications that frequently hash objects of a certain type. Syntax -XX:+EnsureHashed:<classes> -XX:-EnsureHashed:<classes> Setting Effect -XX:+EnsureHashed:<classes> Specify classes -XX:-EnsureHashed:<classes> Ignore classes Where <classes> is a comma-separated list of fully qualified class names, for example, java/lang/String . Explanation The -XX:+EnsureHashed:<classes> option specifies the classes and the -XX:-EnsureHashed:<classes> option ignores classes that were previously specified. These options are parsed left to right. For example, -XX:+EnsureHashed:Class1,Class2,Class3 -XX:-EnsureHashed:Class2 -XX:+EnsureHashed:Class2,Class4 -XX:-EnsureHashed:Class1,Class3 results in the set of EnsureHashed classes { Class2 , Class4 }. Objects that are created from classes Thread and Class are allocated in the tenure region directly and therefore, do not get moved by the garbage collector often. It takes time for such pre-tenured objects to get hashed and extended with a slot. To pre-hash those objects from the start and hence, improve the performance, -XX:+EnsureHashed:java/lang/Class,java/lang/Thread is added to the list of default options in the options.default file. See also -Xoptionsfile GC processing","title":"-XX:[+|-]EnsureHashed"},{"location":"xxensurehashed/#-xx-ensurehashed","text":"This option specifies classes to be pre-hashed. Objects that are created from these classes are hashed and extended with a slot to store the assigned hash value when the object is created or first moved during the garbage collection process. This option might improve performance for applications that frequently hash objects of a certain type.","title":"-XX:[+|-]EnsureHashed"},{"location":"xxensurehashed/#syntax","text":"-XX:+EnsureHashed:<classes> -XX:-EnsureHashed:<classes> Setting Effect -XX:+EnsureHashed:<classes> Specify classes -XX:-EnsureHashed:<classes> Ignore classes Where <classes> is a comma-separated list of fully qualified class names, for example, java/lang/String .","title":"Syntax"},{"location":"xxensurehashed/#explanation","text":"The -XX:+EnsureHashed:<classes> option specifies the classes and the -XX:-EnsureHashed:<classes> option ignores classes that were previously specified. These options are parsed left to right. For example, -XX:+EnsureHashed:Class1,Class2,Class3 -XX:-EnsureHashed:Class2 -XX:+EnsureHashed:Class2,Class4 -XX:-EnsureHashed:Class1,Class3 results in the set of EnsureHashed classes { Class2 , Class4 }. Objects that are created from classes Thread and Class are allocated in the tenure region directly and therefore, do not get moved by the garbage collector often. It takes time for such pre-tenured objects to get hashed and extended with a slot. To pre-hash those objects from the start and hence, improve the performance, -XX:+EnsureHashed:java/lang/Class,java/lang/Thread is added to the list of default options in the options.default file.","title":"Explanation"},{"location":"xxensurehashed/#see-also","text":"-Xoptionsfile GC processing","title":"See also"},{"location":"xxexitonoutofmemoryerror/","text":"-XX:[+|-]ExitOnOutOfMemoryError This HotSpot option is recognized by Eclipse OpenJ9\u2122. You can use the option to trigger a shut down on VM out-of-memory conditions. Note: Java\u2122, heap, snap, and system dumps are enabled by default but can be disabled by including -XX:-HeapDumpOnOutOfMemoryError . Syntax -XX:[+|-]ExitOnOutOfMemoryError Setting Effect Default -XX:+ExitOnOutOfMemoryError Enable -XX:-ExitOnOutOfMemoryError Disable yes","title":"-XX:[+|-]ExitOnOutOfMemoryError"},{"location":"xxexitonoutofmemoryerror/#-xx-exitonoutofmemoryerror","text":"This HotSpot option is recognized by Eclipse OpenJ9\u2122. You can use the option to trigger a shut down on VM out-of-memory conditions. Note: Java\u2122, heap, snap, and system dumps are enabled by default but can be disabled by including -XX:-HeapDumpOnOutOfMemoryError .","title":"-XX:[+|-]ExitOnOutOfMemoryError"},{"location":"xxexitonoutofmemoryerror/#syntax","text":"-XX:[+|-]ExitOnOutOfMemoryError Setting Effect Default -XX:+ExitOnOutOfMemoryError Enable -XX:-ExitOnOutOfMemoryError Disable yes","title":"Syntax"},{"location":"xxgloballockreservation/","text":"-XX:[+|-]GlobalLockReservation (AIX\u00ae and Linux on Power Systems\u2122 only) The -XX:+GlobalLockReservation option enables an optimization targeted towards more efficient handling of locking and unlocking Java\u2122 objects. The -XX:-GlobalLockReservation option is used to disable this optimization. The optimization is enabled by default. Syntax -XX:[+|-]GlobalLockReservation -XX:+GlobalLockReservation:<parameter> Setting Effect Default -XX:+GlobalLockReservation Enable yes -XX:-GlobalLockReservation Disable This optimization is targeted towards applications with lots of uncontended locked objects that are being locked just to be safe. When enabled, heuristics are used to try and determine when an object will be exclusively locked by a single thread so that faster, more specialized code can be used for locking the object. If the heuristics incorrectly identify an object as a target for the optimization, performance might be adversely affected. The -XX:-GlobalLockReservation option turns off global lock reservation. The -XX:+GlobalLockReservation option can be used to enable global lock reservation if it was disabled by an option that occurs earlier in command line processing or to modify some of the global lock reservation related suboptions that are described later in this document. Parameters Advanced tuning parameters are shown in the following table: Parameter Effect reservedTransitionThreshold Changes amount of time spent analyzing an object. reservedAbsoluteThreshold Changes amount of time spent analyzing a class for compatibility. minimumReservedRatio Changes aggression level for marking a class as highly compatible. cancelAbsoluteThreshold Changes amount of time spent analyzing a class for incompatibility. minimumLearningRatio Changes aggression level for marking a class as highly incompatible. reservedTransitionThreshold -XX:+GlobalLockReservation:reservedTransitionThreshold=<value> Setting Value Default <value> number 1 Number of times an object is locked by the same thread before it is considered reserved minus a value of 2. So, with a default value of 1, an object can be reserved the third time it is locked. <value> can be 0-3 inclusive. Values of 4 or higher are treated as infinity. reservedAbsoluteThreshold -XX:+GlobalLockReservation:reservedAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get reserved before the class can be considered highly compatible. Objects of that class are reserved the first time they are locked. Values of 65536 or higher are treated as infinity. minimumReservedRatio -XX:+GlobalLockReservation:minimumReservedRatio=<value> Setting Value Default <value> number 1024 Minimum ratio of reserved objects to flat objects before a class can be considered highly compatible. Values of 65536 or higher are treated as infinity. cancelAbsoluteThreshold -XX:+GlobalLockReservation:cancelAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get converted to flat before the class can be considered highly incompatible. Objects of that class are never reserved. Values of 65536 or higher are treated as infinity. minimumLearningRatio -XX:+GlobalLockReservation:minimumLearningRatio=<value> Setting Value Default <value> number 256 Minimum ratio of reserved objects to flat objects to prevent class from being considered highly incompatible. Values of 65536 or higher are treated as infinity.","title":"-XX:[+|-]GlobalLockReservation"},{"location":"xxgloballockreservation/#-xx-globallockreservation","text":"(AIX\u00ae and Linux on Power Systems\u2122 only) The -XX:+GlobalLockReservation option enables an optimization targeted towards more efficient handling of locking and unlocking Java\u2122 objects. The -XX:-GlobalLockReservation option is used to disable this optimization. The optimization is enabled by default.","title":"-XX:[+|-]GlobalLockReservation"},{"location":"xxgloballockreservation/#syntax","text":"-XX:[+|-]GlobalLockReservation -XX:+GlobalLockReservation:<parameter> Setting Effect Default -XX:+GlobalLockReservation Enable yes -XX:-GlobalLockReservation Disable This optimization is targeted towards applications with lots of uncontended locked objects that are being locked just to be safe. When enabled, heuristics are used to try and determine when an object will be exclusively locked by a single thread so that faster, more specialized code can be used for locking the object. If the heuristics incorrectly identify an object as a target for the optimization, performance might be adversely affected. The -XX:-GlobalLockReservation option turns off global lock reservation. The -XX:+GlobalLockReservation option can be used to enable global lock reservation if it was disabled by an option that occurs earlier in command line processing or to modify some of the global lock reservation related suboptions that are described later in this document.","title":"Syntax"},{"location":"xxgloballockreservation/#parameters","text":"Advanced tuning parameters are shown in the following table: Parameter Effect reservedTransitionThreshold Changes amount of time spent analyzing an object. reservedAbsoluteThreshold Changes amount of time spent analyzing a class for compatibility. minimumReservedRatio Changes aggression level for marking a class as highly compatible. cancelAbsoluteThreshold Changes amount of time spent analyzing a class for incompatibility. minimumLearningRatio Changes aggression level for marking a class as highly incompatible.","title":"Parameters"},{"location":"xxgloballockreservation/#reservedtransitionthreshold","text":"-XX:+GlobalLockReservation:reservedTransitionThreshold=<value> Setting Value Default <value> number 1 Number of times an object is locked by the same thread before it is considered reserved minus a value of 2. So, with a default value of 1, an object can be reserved the third time it is locked. <value> can be 0-3 inclusive. Values of 4 or higher are treated as infinity.","title":"reservedTransitionThreshold"},{"location":"xxgloballockreservation/#reservedabsolutethreshold","text":"-XX:+GlobalLockReservation:reservedAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get reserved before the class can be considered highly compatible. Objects of that class are reserved the first time they are locked. Values of 65536 or higher are treated as infinity.","title":"reservedAbsoluteThreshold"},{"location":"xxgloballockreservation/#minimumreservedratio","text":"-XX:+GlobalLockReservation:minimumReservedRatio=<value> Setting Value Default <value> number 1024 Minimum ratio of reserved objects to flat objects before a class can be considered highly compatible. Values of 65536 or higher are treated as infinity.","title":"minimumReservedRatio"},{"location":"xxgloballockreservation/#cancelabsolutethreshold","text":"-XX:+GlobalLockReservation:cancelAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get converted to flat before the class can be considered highly incompatible. Objects of that class are never reserved. Values of 65536 or higher are treated as infinity.","title":"cancelAbsoluteThreshold"},{"location":"xxgloballockreservation/#minimumlearningratio","text":"-XX:+GlobalLockReservation:minimumLearningRatio=<value> Setting Value Default <value> number 256 Minimum ratio of reserved objects to flat objects to prevent class from being considered highly incompatible. Values of 65536 or higher are treated as infinity.","title":"minimumLearningRatio"},{"location":"xxhandlesigabrt/","text":"-XX:[+|-]HandleSIGABRT This option affects the handling of the operating system signal SIGABRT . This signal represents abnormal termination, and it can either be generated by the abort function or the kill command. Syntax -XX:[+|-]HandleSIGABRT Setting Effect Default -XX:+HandleSIGABRT Enable yes -XX:-HandleSIGABRT Disable Explanation When enabled, the VM handles the signal SIGABRT and generates the various dump files. When the option is disabled, the VM does not handle the signal SIGABRT . Generally, this signal is handled by the default operating system handler. Note: Do not use the -XX:+HandleSIGABRT and -Xrs options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled.","title":"-XX:[+|-]HandleSIGABRT"},{"location":"xxhandlesigabrt/#-xx-handlesigabrt","text":"This option affects the handling of the operating system signal SIGABRT . This signal represents abnormal termination, and it can either be generated by the abort function or the kill command.","title":"-XX:[+|-]HandleSIGABRT"},{"location":"xxhandlesigabrt/#syntax","text":"-XX:[+|-]HandleSIGABRT Setting Effect Default -XX:+HandleSIGABRT Enable yes -XX:-HandleSIGABRT Disable","title":"Syntax"},{"location":"xxhandlesigabrt/#explanation","text":"When enabled, the VM handles the signal SIGABRT and generates the various dump files. When the option is disabled, the VM does not handle the signal SIGABRT . Generally, this signal is handled by the default operating system handler. Note: Do not use the -XX:+HandleSIGABRT and -Xrs options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled.","title":"Explanation"},{"location":"xxhandlesigxfsz/","text":"-XX:[+|-]HandleSIGXFSZ (AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae only) This option affects the handling of the operating system signal SIGXFSZ . This signal is generated when a process attempts to write to a file that causes the maximum file size ulimit to be exceeded. Syntax -XX:[+|-]HandleSIGXFSZ Setting Effect Default -XX:+HandleSIGXFSZ Enable yes -XX:-HandleSIGXFSZ Disable Explanation When enabled, the VM handles the signal SIGXFSZ and continues, without ending. When a file is written from a Java\u2122 API class that exceeds the maximum file size ulimit , an exception is raised. Log files that are created by the VM are silently truncated when they reach the maximum file size ulimit . When the option is disabled, the VM does not handle the signal SIGXFSZ . In this situation, if the maximum file size ulimit for any file is reached, the operating system ends the process with a core dump.","title":"-XX:[+|-]HandleSIGXFSZ"},{"location":"xxhandlesigxfsz/#-xx-handlesigxfsz","text":"(AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae only) This option affects the handling of the operating system signal SIGXFSZ . This signal is generated when a process attempts to write to a file that causes the maximum file size ulimit to be exceeded.","title":"-XX:[+|-]HandleSIGXFSZ"},{"location":"xxhandlesigxfsz/#syntax","text":"-XX:[+|-]HandleSIGXFSZ Setting Effect Default -XX:+HandleSIGXFSZ Enable yes -XX:-HandleSIGXFSZ Disable","title":"Syntax"},{"location":"xxhandlesigxfsz/#explanation","text":"When enabled, the VM handles the signal SIGXFSZ and continues, without ending. When a file is written from a Java\u2122 API class that exceeds the maximum file size ulimit , an exception is raised. Log files that are created by the VM are silently truncated when they reach the maximum file size ulimit . When the option is disabled, the VM does not handle the signal SIGXFSZ . In this situation, if the maximum file size ulimit for any file is reached, the operating system ends the process with a core dump.","title":"Explanation"},{"location":"xxheapdumponoutofmemory/","text":"-XX:[+|-]HeapDumpOnOutOfMemory This HotSpot option is recognized by Eclipse OpenJ9\u2122. You can use the option to to disable Java\u2122, heap, snap, and system dumps on out-of-memory conditions, which are enabled by default. Syntax -XX:[+|-]HeapDumpOnOutOfMemory Setting Effect Default -XX:+HeapDumpOnOutOfMemory Enable yes -XX:-HeapDumpOnOutOfMemory Disable","title":"-XX:[+|-]HeapDumpOnOutOfMemory"},{"location":"xxheapdumponoutofmemory/#-xx-heapdumponoutofmemory","text":"This HotSpot option is recognized by Eclipse OpenJ9\u2122. You can use the option to to disable Java\u2122, heap, snap, and system dumps on out-of-memory conditions, which are enabled by default.","title":"-XX:[+|-]HeapDumpOnOutOfMemory"},{"location":"xxheapdumponoutofmemory/#syntax","text":"-XX:[+|-]HeapDumpOnOutOfMemory Setting Effect Default -XX:+HeapDumpOnOutOfMemory Enable yes -XX:-HeapDumpOnOutOfMemory Disable","title":"Syntax"},{"location":"xxheapdumppath/","text":"-XX:HeapDumpPath This HotSpot option is recognized by Eclipse OpenJ9\u2122 for compatibility, and you can use it as an alias for -Xdump:directory=<path> . This option sets the directory for all VM dumps including heap dumps, Java\u2122 dumps, and system dumps. Syntax -XX:HeapDumpPath=<path> where <path> is the directory to which all dump types are written. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents.","title":"-XX:HeapDumpPath"},{"location":"xxheapdumppath/#-xxheapdumppath","text":"This HotSpot option is recognized by Eclipse OpenJ9\u2122 for compatibility, and you can use it as an alias for -Xdump:directory=<path> . This option sets the directory for all VM dumps including heap dumps, Java\u2122 dumps, and system dumps.","title":"-XX:HeapDumpPath"},{"location":"xxheapdumppath/#syntax","text":"-XX:HeapDumpPath=<path> where <path> is the directory to which all dump types are written. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents.","title":"Syntax"},{"location":"xxheapmanagementmxbeancompatibility/","text":"-XX:[+|-]HeapManagementMXBeanCompatibility The MXBean interface now reports more detailed information about memory pools and garbage collectors for a garbage collection policy. In addition, the names of memory pools and garbage collectors are changed to match the naming convention that is used for verbose garbage collection logging. This option provides compatibility with earlier versions of the VM. Syntax -XX:[+|-]HeapManagementMXBeanCompatibility Setting Effect Default -XX:+HeapManagementMXBeanCompatibility Enable -XX:-HeapManagementMXBeanCompatibility Disable yes Setting -XX:+HeapManagementMXBeanCompatibility on the command line turns on compatibility with earlier versions of the VM. Information about memory pools and garbage collectors are reported in the older format. When compatibility is turned off, the VM reports more detailed information and matches the naming of memory pools and garbage collectors to the naming convention that is used for verbose garbage collection logging. Explanation The additional information that is available from the MXBean interface for later versions is shown in the following table: Garbage collection policy MemoryPool names GarbageCollector names gencon nursery-allocate, nursery-survivor, tenured-LOA, tenured-SOA, tenured scavenge, global optthruput or optavgpause tenured-LOA, tenured-SOA, tenured global balanced balanced-reserved, balanced-eden, balanced-survivor, balanced-old partial gc, global garbage collect metronome JavaHeap global The MemoryPoolMXBean API reports values for 4 detailed memory pools instead of a single value for the overall Java\u2122 heap. In some cases the total sum of the 4 pools is more than the maximum heap size. This irregularity can be caused if data for each pool is collected between garbage collection cycles, where objects have been moved or reclaimed. If you want to collect memory usage data that is synchronized across the memory pools, use the GarbageCollectionNotificationInfo or GarbageCollectorMXBean.getLastGcInfo extensions. Earlier releases included only the following names: MemoryPool pool name: Java heap GarbageCollector name: Copy and MarkSweepCompact . See also Verbose garbage collection logging . For more information about IBM\u00ae MXBeans, see the com.ibm.lang.management API documentation.","title":"-XX:[+|-]HeapManagementMXBeanCompatibility"},{"location":"xxheapmanagementmxbeancompatibility/#-xx-heapmanagementmxbeancompatibility","text":"The MXBean interface now reports more detailed information about memory pools and garbage collectors for a garbage collection policy. In addition, the names of memory pools and garbage collectors are changed to match the naming convention that is used for verbose garbage collection logging. This option provides compatibility with earlier versions of the VM.","title":"-XX:[+|-]HeapManagementMXBeanCompatibility"},{"location":"xxheapmanagementmxbeancompatibility/#syntax","text":"-XX:[+|-]HeapManagementMXBeanCompatibility Setting Effect Default -XX:+HeapManagementMXBeanCompatibility Enable -XX:-HeapManagementMXBeanCompatibility Disable yes Setting -XX:+HeapManagementMXBeanCompatibility on the command line turns on compatibility with earlier versions of the VM. Information about memory pools and garbage collectors are reported in the older format. When compatibility is turned off, the VM reports more detailed information and matches the naming of memory pools and garbage collectors to the naming convention that is used for verbose garbage collection logging.","title":"Syntax"},{"location":"xxheapmanagementmxbeancompatibility/#explanation","text":"The additional information that is available from the MXBean interface for later versions is shown in the following table: Garbage collection policy MemoryPool names GarbageCollector names gencon nursery-allocate, nursery-survivor, tenured-LOA, tenured-SOA, tenured scavenge, global optthruput or optavgpause tenured-LOA, tenured-SOA, tenured global balanced balanced-reserved, balanced-eden, balanced-survivor, balanced-old partial gc, global garbage collect metronome JavaHeap global The MemoryPoolMXBean API reports values for 4 detailed memory pools instead of a single value for the overall Java\u2122 heap. In some cases the total sum of the 4 pools is more than the maximum heap size. This irregularity can be caused if data for each pool is collected between garbage collection cycles, where objects have been moved or reclaimed. If you want to collect memory usage data that is synchronized across the memory pools, use the GarbageCollectionNotificationInfo or GarbageCollectorMXBean.getLastGcInfo extensions. Earlier releases included only the following names: MemoryPool pool name: Java heap GarbageCollector name: Copy and MarkSweepCompact .","title":"Explanation"},{"location":"xxheapmanagementmxbeancompatibility/#see-also","text":"Verbose garbage collection logging . For more information about IBM\u00ae MXBeans, see the com.ibm.lang.management API documentation.","title":"See also"},{"location":"xxidletuningcompactonidle/","text":"-XX:[+|-]IdleTuningCompactOnIdle (Linux\u00ae only) Warning: From Eclipse OpenJ9\u2122 version 0.23.0 this option has no effect. In versions of OpenJ9 before 0.23.0, this option controls garbage collection processing with compaction when the state of the OpenJ9 VM is set to idle. Restrictions: This option was deprecated in release 0.15.0 due to operational changes. A compaction is now triggered by internal heuristics that look into the number of fragmented pages. Typically there is no need to force a compaction. This option will be removed in the future. This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. This option is not effective if -XX:+IdleTuningGcOnIdle is not specified. Syntax -XX:[+|-]IdleTuningCompactOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningCompactOnIdle Enable yes -XX:-IdleTuningCompactOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a container. As indicated in the table, when the VM is running in a container and the state is set to idle, the VM attempts to compact the object heap following a garbage collection cycle. The garbage collection cycle is controlled by the -XX:+IdleTuningGcOnIdle option, which is also enabled by default when the OpenJ9 VM is running inside a container. If your application is not running in a container and you want compaction to be attempted every time idle GC happens as part of the idle-tuning process, set the -XX:+IdleTuningCompactOnIdle option on the command line when you start your application. The -XX:+IdleTuningCompactOnIdle option can be used with the -XX:+IdleTuningMinIdleWaitTime , which controls the amount of time that the VM must be idle before an idle state is set. If a value for the -XX:+IdleTuningMinIdleWaitTime option is not explicitly specified, the VM sets a default value of 180 seconds. See also -XX:IdleTuningMinFreeHeapOnIdle -XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle","title":"-XX:[+|-]IdleTuningCompactOnIdle"},{"location":"xxidletuningcompactonidle/#-xx-idletuningcompactonidle","text":"(Linux\u00ae only) Warning: From Eclipse OpenJ9\u2122 version 0.23.0 this option has no effect. In versions of OpenJ9 before 0.23.0, this option controls garbage collection processing with compaction when the state of the OpenJ9 VM is set to idle. Restrictions: This option was deprecated in release 0.15.0 due to operational changes. A compaction is now triggered by internal heuristics that look into the number of fragmented pages. Typically there is no need to force a compaction. This option will be removed in the future. This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. This option is not effective if -XX:+IdleTuningGcOnIdle is not specified.","title":"-XX:[+|-]IdleTuningCompactOnIdle"},{"location":"xxidletuningcompactonidle/#syntax","text":"-XX:[+|-]IdleTuningCompactOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningCompactOnIdle Enable yes -XX:-IdleTuningCompactOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a container. As indicated in the table, when the VM is running in a container and the state is set to idle, the VM attempts to compact the object heap following a garbage collection cycle. The garbage collection cycle is controlled by the -XX:+IdleTuningGcOnIdle option, which is also enabled by default when the OpenJ9 VM is running inside a container. If your application is not running in a container and you want compaction to be attempted every time idle GC happens as part of the idle-tuning process, set the -XX:+IdleTuningCompactOnIdle option on the command line when you start your application. The -XX:+IdleTuningCompactOnIdle option can be used with the -XX:+IdleTuningMinIdleWaitTime , which controls the amount of time that the VM must be idle before an idle state is set. If a value for the -XX:+IdleTuningMinIdleWaitTime option is not explicitly specified, the VM sets a default value of 180 seconds.","title":"Syntax"},{"location":"xxidletuningcompactonidle/#see-also","text":"-XX:IdleTuningMinFreeHeapOnIdle -XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle","title":"See also"},{"location":"xxidletuninggconidle/","text":"-XX:[+|-]IdleTuningGcOnIdle (Linux\u00ae only) This option controls whether a garbage collection cycle takes place when the state of the Eclipse OpenJ9\u2122 VM is set to idle. Compaction of the heap is also attempted during the idle GC when certain triggers are met. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. Syntax -XX:[+|-]IdleTuningGcOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningGcOnIdle Enable yes -XX:-IdleTuningGcOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a docker container. As indicated in the table, when the VM is running in a container and the state is set to idle, this option causes the VM to release free memory pages in the object heap without resizing the Java\u2122 heap and attempts to compact the heap after the garbage collection cycle if certain heuristics are triggered. The pages are reclaimed by the operating system, which reduces the physical memory footprint of the VM. If your application is not running in a container and you want to enable idle-tuning, set the -XX:+IdleTuningGcOnIdle option on the command line when you start your application. When enabled, the -XX:+IdleTuningGcOnIdle option is used with the -XX:IdleTuningMinIdleWaitTime and -XX:IdleTuningMinFreeHeapOnIdle options. If values for these options are not explicitly specified, the VM sets the following defaults: -XX:IdleTuningMinIdleWaitTime =180 -XX:IdleTuningMinFreeHeapOnIdle =0 See also -XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (From OpenJ9 version 0.23.0 this option has no effect.)","title":"-XX:[+|-]IdleTuningGcOnIdle"},{"location":"xxidletuninggconidle/#-xx-idletuninggconidle","text":"(Linux\u00ae only) This option controls whether a garbage collection cycle takes place when the state of the Eclipse OpenJ9\u2122 VM is set to idle. Compaction of the heap is also attempted during the idle GC when certain triggers are met. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages.","title":"-XX:[+|-]IdleTuningGcOnIdle"},{"location":"xxidletuninggconidle/#syntax","text":"-XX:[+|-]IdleTuningGcOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningGcOnIdle Enable yes -XX:-IdleTuningGcOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a docker container. As indicated in the table, when the VM is running in a container and the state is set to idle, this option causes the VM to release free memory pages in the object heap without resizing the Java\u2122 heap and attempts to compact the heap after the garbage collection cycle if certain heuristics are triggered. The pages are reclaimed by the operating system, which reduces the physical memory footprint of the VM. If your application is not running in a container and you want to enable idle-tuning, set the -XX:+IdleTuningGcOnIdle option on the command line when you start your application. When enabled, the -XX:+IdleTuningGcOnIdle option is used with the -XX:IdleTuningMinIdleWaitTime and -XX:IdleTuningMinFreeHeapOnIdle options. If values for these options are not explicitly specified, the VM sets the following defaults: -XX:IdleTuningMinIdleWaitTime =180 -XX:IdleTuningMinFreeHeapOnIdle =0","title":"Syntax"},{"location":"xxidletuninggconidle/#see-also","text":"-XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (From OpenJ9 version 0.23.0 this option has no effect.)","title":"See also"},{"location":"xxidletuningminfreeheaponidle/","text":"-XX:IdleTuningMinFreeHeapOnIdle (Linux\u00ae only) This option controls the percentage of free memory pages in the object heap that can be released when the Eclipse OpenJ9\u2122 VM is in an idle state. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. Syntax -XX:IdleTuningMinFreeHeapOnIdle=<percentage> Setting Value Default <percentage> [0 - 100] 0 When used with -XX:+IdleTuningGcOnIdle , this option can be used to place an upper bound on the percentage of free memory pages in the object heap that can be released when the VM is in an idle state. If -XX:IdleTuningMinFreeHeapOnIdle is not specified, the VM uses a default value of 0. Example If you set -XX:IdleTuningMinFreeHeapOnIdle=10 , no more than 90% of the free memory pages in the object heap can be released by the VM when it is in an idle state. See also -XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle -XX:[+|-]IdleTuningCompactOnIdle (From OpenJ9 version 0.23.0 this option has no effect.)","title":"-XX:IdleTuningMinFreeHeapOnIdle"},{"location":"xxidletuningminfreeheaponidle/#-xxidletuningminfreeheaponidle","text":"(Linux\u00ae only) This option controls the percentage of free memory pages in the object heap that can be released when the Eclipse OpenJ9\u2122 VM is in an idle state. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages.","title":"-XX:IdleTuningMinFreeHeapOnIdle"},{"location":"xxidletuningminfreeheaponidle/#syntax","text":"-XX:IdleTuningMinFreeHeapOnIdle=<percentage> Setting Value Default <percentage> [0 - 100] 0 When used with -XX:+IdleTuningGcOnIdle , this option can be used to place an upper bound on the percentage of free memory pages in the object heap that can be released when the VM is in an idle state. If -XX:IdleTuningMinFreeHeapOnIdle is not specified, the VM uses a default value of 0.","title":"Syntax"},{"location":"xxidletuningminfreeheaponidle/#example","text":"If you set -XX:IdleTuningMinFreeHeapOnIdle=10 , no more than 90% of the free memory pages in the object heap can be released by the VM when it is in an idle state.","title":"Example"},{"location":"xxidletuningminfreeheaponidle/#see-also","text":"-XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle -XX:[+|-]IdleTuningCompactOnIdle (From OpenJ9 version 0.23.0 this option has no effect.)","title":"See also"},{"location":"xxidletuningminidlewaittime/","text":"-XX:IdleTuningMinIdleWaitTime (Linux\u00ae only) When the Eclipse OpenJ9\u2122 VM is idle, this option controls the minimum length of time that the VM must be idle before the state of the VM is set to idle. When the state changes to idle, a garbage collection cycle runs, the object heap is compacted, and free memory pages are released back to the operating system, which reduces the footprint of the VM. Garbage collection and compaction are controlled by the -XX:+IdleTuningGcOnIdle and -XX:+IdleTuningCompactOnIdle options, which are enabled by default when the OpenJ9 VM is running inside a docker container. (Note that from OpenJ9 version 0.23.0 the -XX:+IdleTuningCompactOnIdle option has no effect.) Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. Syntax -XX:IdleTuningMinIdleWaitTime=<secs> Setting Value Default Default when running in a docker container <secs> [0 or greater] 0 180 The value used for <secs> specifies the minimum length of time in seconds that the VM is idle before the state is set to idle. Idle tuning is enabled by default when the OpenJ9 VM is running in a docker container and the VM is detected as idle for 180 seconds. Setting the value to 0 disables this feature, which causes the following idle tuning options to have no effect: -XX:+IdleTuningCompactOnIdle -XX:+IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle See also -XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (From OpenJ9 version 0.23.0 this option has no effect.)","title":"-XX:IdleTuningMinIdleWaitTime"},{"location":"xxidletuningminidlewaittime/#-xxidletuningminidlewaittime","text":"(Linux\u00ae only) When the Eclipse OpenJ9\u2122 VM is idle, this option controls the minimum length of time that the VM must be idle before the state of the VM is set to idle. When the state changes to idle, a garbage collection cycle runs, the object heap is compacted, and free memory pages are released back to the operating system, which reduces the footprint of the VM. Garbage collection and compaction are controlled by the -XX:+IdleTuningGcOnIdle and -XX:+IdleTuningCompactOnIdle options, which are enabled by default when the OpenJ9 VM is running inside a docker container. (Note that from OpenJ9 version 0.23.0 the -XX:+IdleTuningCompactOnIdle option has no effect.) Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages.","title":"-XX:IdleTuningMinIdleWaitTime"},{"location":"xxidletuningminidlewaittime/#syntax","text":"-XX:IdleTuningMinIdleWaitTime=<secs> Setting Value Default Default when running in a docker container <secs> [0 or greater] 0 180 The value used for <secs> specifies the minimum length of time in seconds that the VM is idle before the state is set to idle. Idle tuning is enabled by default when the OpenJ9 VM is running in a docker container and the VM is detected as idle for 180 seconds. Setting the value to 0 disables this feature, which causes the following idle tuning options to have no effect: -XX:+IdleTuningCompactOnIdle -XX:+IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle","title":"Syntax"},{"location":"xxidletuningminidlewaittime/#see-also","text":"-XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (From OpenJ9 version 0.23.0 this option has no effect.)","title":"See also"},{"location":"xxignoreunrecognizedvmoptions/","text":"-XX:[+|-]IgnoreUnrecognizedVMOptions This Oracle option affects the behavior of the HotSpot JVM when it finds an unrecognized top-level option at startup. This option is implemented in the Eclipse OpenJ9\u2122 VM for compatibility. Syntax -XX:[+|-]IgnoreUnrecognizedVMOptions Setting Effect Default -XX:+IgnoreUnrecognizedVMOptions Enable -XX:-IgnoreUnrecognizedVMOptions Disable yes","title":"-XX:[+|-]IgnoreUnrecognizedVMOptions"},{"location":"xxignoreunrecognizedvmoptions/#-xx-ignoreunrecognizedvmoptions","text":"This Oracle option affects the behavior of the HotSpot JVM when it finds an unrecognized top-level option at startup. This option is implemented in the Eclipse OpenJ9\u2122 VM for compatibility.","title":"-XX:[+|-]IgnoreUnrecognizedVMOptions"},{"location":"xxignoreunrecognizedvmoptions/#syntax","text":"-XX:[+|-]IgnoreUnrecognizedVMOptions Setting Effect Default -XX:+IgnoreUnrecognizedVMOptions Enable -XX:-IgnoreUnrecognizedVMOptions Disable yes","title":"Syntax"},{"location":"xxignoreunrecognizedxxcolonoptions/","text":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions By default, any -XX: options that you specify on the command line are ignored if they are not recognized, which prevents an application failing to start. However, if you want to determine whether any of your -XX: options are unrecognized, you can turn off the behavior with this option. You might want to do this, for example, if you are switching to Eclipse OpenJ9\u2122 from an alternative VM implementation where you are using -XX: options to tune the runtime environment. Syntax -XX:[+|-]IgnoreUnrecognizedXXColonOptions Setting Effect Default -XX:+IgnoreUnrecognizedXXColonOptions Enable yes -XX:-IgnoreUnrecognizedXXColonOptions Disable When you specify -XX:-IgnoreUnrecognizedXXColonOptions , if you also specify a -XX: option that is not recognized, that option is reported and the VM does not start. For example: JVMJ9VM007E Command-line option unrecognised: -XX:InvalidOption Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.","title":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions"},{"location":"xxignoreunrecognizedxxcolonoptions/#-xx-ignoreunrecognizedxxcolonoptions","text":"By default, any -XX: options that you specify on the command line are ignored if they are not recognized, which prevents an application failing to start. However, if you want to determine whether any of your -XX: options are unrecognized, you can turn off the behavior with this option. You might want to do this, for example, if you are switching to Eclipse OpenJ9\u2122 from an alternative VM implementation where you are using -XX: options to tune the runtime environment.","title":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions"},{"location":"xxignoreunrecognizedxxcolonoptions/#syntax","text":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions Setting Effect Default -XX:+IgnoreUnrecognizedXXColonOptions Enable yes -XX:-IgnoreUnrecognizedXXColonOptions Disable When you specify -XX:-IgnoreUnrecognizedXXColonOptions , if you also specify a -XX: option that is not recognized, that option is reported and the VM does not start. For example: JVMJ9VM007E Command-line option unrecognised: -XX:InvalidOption Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.","title":"Syntax"},{"location":"xxinitialheapsize/","text":"-XX:InitialHeapSize / -XX:MaxHeapSize These HotSpot options for specifying heap size are recognized by Eclipse OpenJ9\u2122 for compatibility. See -Xms / -Xmx for details. Syntax Setting Effect -XX:InitialHeapSize<size> Set initial heap size -XX:MaxHeapSize<size> Set maximum heap size","title":"-XX:MaxHeapSize"},{"location":"xxinitialheapsize/#-xxinitialheapsize-xxmaxheapsize","text":"These HotSpot options for specifying heap size are recognized by Eclipse OpenJ9\u2122 for compatibility. See -Xms / -Xmx for details.","title":"-XX:InitialHeapSize / -XX:MaxHeapSize"},{"location":"xxinitialheapsize/#syntax","text":"Setting Effect -XX:InitialHeapSize<size> Set initial heap size -XX:MaxHeapSize<size> Set maximum heap size","title":"Syntax"},{"location":"xxinitialrampercentage/","text":"-XX:InitialRAMPercentage / -XX:MaxRAMPercentage These Oracle HotSpot options can be used to specify the initial and maximum size of the Java heap as a percentage of the total memory available to the VM. The options are recognized by Eclipse OpenJ9\u2122 and provided for compatibility. Syntax Setting Effect -XX:InitialRAMPercentage=N Set initial heap size as a percentage of total memory -XX:MaxRAMPercentage=N Set maximum heap size as a percentage of total memory Where N is a value between 0 and 100, which can be of type \"double\". For example, 12.3456. Note: If you set a value for -Xms , the -XX:InitialRAMPercentage option is ignored. If you set a value for -Xmx , the -XX:MaxRAMPercentage option is ignored. If your application is running in a container and you have specified -XX:+UseContainerSupport , both the default heap size for containers, the -XX:InitialRAMPercentage option, and the -XX:MaxRAMPercentage option are based on the available container memory.","title":"-XX:MaxRAMPercentage"},{"location":"xxinitialrampercentage/#-xxinitialrampercentage-xxmaxrampercentage","text":"These Oracle HotSpot options can be used to specify the initial and maximum size of the Java heap as a percentage of the total memory available to the VM. The options are recognized by Eclipse OpenJ9\u2122 and provided for compatibility.","title":"-XX:InitialRAMPercentage / -XX:MaxRAMPercentage"},{"location":"xxinitialrampercentage/#syntax","text":"Setting Effect -XX:InitialRAMPercentage=N Set initial heap size as a percentage of total memory -XX:MaxRAMPercentage=N Set maximum heap size as a percentage of total memory Where N is a value between 0 and 100, which can be of type \"double\". For example, 12.3456. Note: If you set a value for -Xms , the -XX:InitialRAMPercentage option is ignored. If you set a value for -Xmx , the -XX:MaxRAMPercentage option is ignored. If your application is running in a container and you have specified -XX:+UseContainerSupport , both the default heap size for containers, the -XX:InitialRAMPercentage option, and the -XX:MaxRAMPercentage option are based on the available container memory.","title":"Syntax"},{"location":"xxinterleavememory/","text":"-XX:[+|-]InterleaveMemory (AIX\u00ae, Linux\u00ae, and Windows\u2122 only, but not Linux on IBM Z\u00ae) Use the -XX:+InterleaveMemory option to enable the interleaving of allocated memory across NUMA nodes. Syntax -XX:[+|-]InterleaveMemory Setting Effect Default -XX:+InterleaveMemory Enable -XX:-InterleaveMemory Disable yes","title":"-XX:[+|-]InterleaveMemory"},{"location":"xxinterleavememory/#-xx-interleavememory","text":"(AIX\u00ae, Linux\u00ae, and Windows\u2122 only, but not Linux on IBM Z\u00ae) Use the -XX:+InterleaveMemory option to enable the interleaving of allocated memory across NUMA nodes.","title":"-XX:[+|-]InterleaveMemory"},{"location":"xxinterleavememory/#syntax","text":"-XX:[+|-]InterleaveMemory Setting Effect Default -XX:+InterleaveMemory Enable -XX:-InterleaveMemory Disable yes","title":"Syntax"},{"location":"xxjitinlinewatches/","text":"-XX:[+|-]JITInlineWatches This option controls JIT operations that relate to JVMTI watched fields. Syntax -XX:[+|-]JITInlineWatches Setting Effect Default -XX:+JITInlineWatches Enable yes -XX:-JITInlineWatches Disable This option enables performance improvements relating to JVMTI watched fields.","title":"-XX:[+|-]JITInlineWatches"},{"location":"xxjitinlinewatches/#-xx-jitinlinewatches","text":"This option controls JIT operations that relate to JVMTI watched fields.","title":"-XX:[+|-]JITInlineWatches"},{"location":"xxjitinlinewatches/#syntax","text":"-XX:[+|-]JITInlineWatches Setting Effect Default -XX:+JITInlineWatches Enable yes -XX:-JITInlineWatches Disable This option enables performance improvements relating to JVMTI watched fields.","title":"Syntax"},{"location":"xxjitserveraddress/","text":"-XX:JITServerAddress This option specifies the JITServer server name or IP address for a JITServer client to connect to. Syntax -XX:JITServerAddress=<address> Setting Effect Default -XX:JITServerAddress Set server's name or IP address localhost Explanation When you enable this option, the JITServer client sends compilation requests to a server with the provided name or address. If there is no server available at that address, the JIT compiler compiles locally. See also JITServer technology","title":"-XX:JITServerAddress"},{"location":"xxjitserveraddress/#-xxjitserveraddress","text":"This option specifies the JITServer server name or IP address for a JITServer client to connect to.","title":"-XX:JITServerAddress"},{"location":"xxjitserveraddress/#syntax","text":"-XX:JITServerAddress=<address> Setting Effect Default -XX:JITServerAddress Set server's name or IP address localhost","title":"Syntax"},{"location":"xxjitserveraddress/#explanation","text":"When you enable this option, the JITServer client sends compilation requests to a server with the provided name or address. If there is no server available at that address, the JIT compiler compiles locally.","title":"Explanation"},{"location":"xxjitserveraddress/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxjitserveraotcachename/","text":"-XX:JITServerAOTCacheName This option, used at the JITServer client JVMs, specifies the name of the AOT cache to be used at the JITServer server. Syntax -XX:JITServerAOTCacheName=<cache_name> where <cache_name> specifies the name of the server-side AOT cache to be used. Explanation A single JITServer instance can use multiple AOT caches, which are distinguished by their name. Clients that are running applications with significantly different execution profiles can, therefore, connect to the same JITServer instance. Specify this option at the client JVM. If you do not specify this option, the client uses a nameless cache. Note: You must specify -XX:+JITServerUseAOTCache , otherwise the -XX:JITServerAOTCacheName option is ignored. See also JITServer technology -XX:[+|-]JITServerUseAOTCache","title":"-XX:JITServerAOTCacheName"},{"location":"xxjitserveraotcachename/#-xxjitserveraotcachename","text":"This option, used at the JITServer client JVMs, specifies the name of the AOT cache to be used at the JITServer server.","title":"-XX:JITServerAOTCacheName"},{"location":"xxjitserveraotcachename/#syntax","text":"-XX:JITServerAOTCacheName=<cache_name> where <cache_name> specifies the name of the server-side AOT cache to be used.","title":"Syntax"},{"location":"xxjitserveraotcachename/#explanation","text":"A single JITServer instance can use multiple AOT caches, which are distinguished by their name. Clients that are running applications with significantly different execution profiles can, therefore, connect to the same JITServer instance. Specify this option at the client JVM. If you do not specify this option, the client uses a nameless cache. Note: You must specify -XX:+JITServerUseAOTCache , otherwise the -XX:JITServerAOTCacheName option is ignored.","title":"Explanation"},{"location":"xxjitserveraotcachename/#see-also","text":"JITServer technology -XX:[+|-]JITServerUseAOTCache","title":"See also"},{"location":"xxjitserverlocalsynccompiles/","text":"-XX:[+|-]JITServerLocalSyncCompiles When you specify this JITServer option, synchronous JIT compilations are downgraded to cold optimization level and compiled locally, with a remote asynchronous recompilation scheduled at a later point. Syntax -XX:[+|-]JITServerLocalSyncCompiles Setting Effect Default -XX:+JITServerLocalSyncCompiles Enable yes -XX:-JITServerLocalSyncCompiles Disable The option -XX:[+|-]JITServerLocalSyncCompiles is enabled by default in most cases. The option remains disabled when you specify -Xjit:count=0 and in a few advanced use cases such as running the JVM in debug mode (as described in the Improved JVM debug mode based on OSR post in the Eclipse OpenJ9\u2122 blog). Explanation During a synchronous compilation, Java\u2122 application threads have to wait for the compilation to complete. Because remote compilations usually take longer, due to network latency, remote synchronous compilations can result in large pauses in the client application. If you enable this option, the client performs synchronous compilations locally at cold optimization level and later recompiles asynchronously at a higher level remotely. This behavior can be beneficial for real-time applications. See also JITServer technology","title":"-XX:[+|-]JITServerLocalSyncCompiles"},{"location":"xxjitserverlocalsynccompiles/#-xx-jitserverlocalsynccompiles","text":"When you specify this JITServer option, synchronous JIT compilations are downgraded to cold optimization level and compiled locally, with a remote asynchronous recompilation scheduled at a later point.","title":"-XX:[+|-]JITServerLocalSyncCompiles"},{"location":"xxjitserverlocalsynccompiles/#syntax","text":"-XX:[+|-]JITServerLocalSyncCompiles Setting Effect Default -XX:+JITServerLocalSyncCompiles Enable yes -XX:-JITServerLocalSyncCompiles Disable The option -XX:[+|-]JITServerLocalSyncCompiles is enabled by default in most cases. The option remains disabled when you specify -Xjit:count=0 and in a few advanced use cases such as running the JVM in debug mode (as described in the Improved JVM debug mode based on OSR post in the Eclipse OpenJ9\u2122 blog).","title":"Syntax"},{"location":"xxjitserverlocalsynccompiles/#explanation","text":"During a synchronous compilation, Java\u2122 application threads have to wait for the compilation to complete. Because remote compilations usually take longer, due to network latency, remote synchronous compilations can result in large pauses in the client application. If you enable this option, the client performs synchronous compilations locally at cold optimization level and later recompiles asynchronously at a higher level remotely. This behavior can be beneficial for real-time applications.","title":"Explanation"},{"location":"xxjitserverlocalsynccompiles/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxjitserverlogconnections/","text":"-XX:[+|-]JITServerLogConnections This option enables the logging of connection/disconnection events between the JITServer server and the JITServer client. You can use the option on both the server and the client sides. Syntax -XX:[+|-]JITServerLogConnections Setting Effect Default -XX:+JITServerLogConnections Enable -XX:-JITServerLogConnections Disable yes Explanation This option is useful when you need to know when the server and the client successfully establish or terminate connections but verbose logs provide too much information. You can also enable the same logging by specifying the -Xjit:verbose={JITServerConns} option. If you do not specify a vlog log file ( -Xjit:vlog=<vlog_filename> ), output is written to stderr , otherwise it is written to the vlog file. Example This is what the typical output looks like: On the server side: #JITServer: t= 2318 A new client (clientUID=11937826481210274991) connected. Server allocated a new client session. ... ... #JITServer: t= 48518 Client (clientUID=4213447851416537492) disconnected. Client session deleted On the client side: #JITServer: t= 0 Connected to a server (serverUID=10444660844386807777) ... ... #JITServer: t= 698 Lost connection to the server (serverUID=10444660844386807777) See also JITServer technology -Xjit / -Xnojit","title":"-XX:[+|-]JITServerLogConnections"},{"location":"xxjitserverlogconnections/#-xx-jitserverlogconnections","text":"This option enables the logging of connection/disconnection events between the JITServer server and the JITServer client. You can use the option on both the server and the client sides.","title":"-XX:[+|-]JITServerLogConnections"},{"location":"xxjitserverlogconnections/#syntax","text":"-XX:[+|-]JITServerLogConnections Setting Effect Default -XX:+JITServerLogConnections Enable -XX:-JITServerLogConnections Disable yes","title":"Syntax"},{"location":"xxjitserverlogconnections/#explanation","text":"This option is useful when you need to know when the server and the client successfully establish or terminate connections but verbose logs provide too much information. You can also enable the same logging by specifying the -Xjit:verbose={JITServerConns} option. If you do not specify a vlog log file ( -Xjit:vlog=<vlog_filename> ), output is written to stderr , otherwise it is written to the vlog file.","title":"Explanation"},{"location":"xxjitserverlogconnections/#example","text":"This is what the typical output looks like: On the server side: #JITServer: t= 2318 A new client (clientUID=11937826481210274991) connected. Server allocated a new client session. ... ... #JITServer: t= 48518 Client (clientUID=4213447851416537492) disconnected. Client session deleted On the client side: #JITServer: t= 0 Connected to a server (serverUID=10444660844386807777) ... ... #JITServer: t= 698 Lost connection to the server (serverUID=10444660844386807777)","title":"Example"},{"location":"xxjitserverlogconnections/#see-also","text":"JITServer technology -Xjit / -Xnojit","title":"See also"},{"location":"xxjitservermetrics/","text":"-XX:[+|-]JITServerMetrics This option enables the provision of JITServer performance metrics to a monitoring agent that follows the OpenMetrics standard. When you enable this option, the following JITServer metrics are provided: The CPU utilization of the JITServer The physical memory that is available to the JITServer The number of clients that are connected to the JITServer The number of active compilation threads in the JITServer Note: You can use the -XX:JITServerMetricsSSLKey and -XX:JITServerMetricsSSLCert options for encrypting the data with SSL or TLS. Syntax -XX:[+|-]JITServerMetrics Setting Effect Default -XX:+JITServerMetrics Enable -XX:-JITServerMetrics Disable yes Explanation When you enable this option, the JITServer process opens a TCP port, which can be used by monitoring agents (like Prometheus) to collect the custom metrics exported by the JITServer. Monitoring agents must issue HTTP GET requests to a URL of the form: http://<jitserveraddress>:<port>/metrics . The path for the HTTP request must be /metrics . The default value of <port> is 38500. You can change this value by using the -XX:JITServerMetricsPort command line option. The format for the metrics returned by the JITServer follows the OpenMetrics protocol. Example The following example shows an HTTP request from a Prometheus monitoring agent and the response from the JITServer: HTTP request: GET /metrics HTTP/1.1 Host: 127.0.0.1:9403 User-Agent: Prometheus/2.31.1 Accept: application/openmetrics-text; version=0.0.1,text/plain;version=0.0.4;q=0.5,*/*;q=0.1 Accept-Encoding: gzip X-Prometheus-Scrape-Timeout-Seconds: 3 JITServer response: # HELP jitserver_cpu_utilization Cpu utilization of the JITServer # TYPE jitserver_cpu_utilization gauge jitserver_cpu_utilization 12.000000 # HELP jitserver_available_memory Available memory for JITServer # TYPE jitserver_available_memory gauge jitserver_available_memory 32036204544.000000 # HELP jitserver_connected_clients Number of connected clients # TYPE jitserver_connected_clients gauge jitserver_connected_clients 1.000000 # HELP jitserver_active_threads Number of active compilation threads # TYPE jitserver_active_threads gauge jitserver_active_threads 1.000000 See also -XX:JITServerMetricsPort JITServer technology -XX:JITServerMetricsSSLKey","title":"-XX:JITServerMetrics"},{"location":"xxjitservermetrics/#-xx-jitservermetrics","text":"This option enables the provision of JITServer performance metrics to a monitoring agent that follows the OpenMetrics standard. When you enable this option, the following JITServer metrics are provided: The CPU utilization of the JITServer The physical memory that is available to the JITServer The number of clients that are connected to the JITServer The number of active compilation threads in the JITServer Note: You can use the -XX:JITServerMetricsSSLKey and -XX:JITServerMetricsSSLCert options for encrypting the data with SSL or TLS.","title":"-XX:[+|-]JITServerMetrics"},{"location":"xxjitservermetrics/#syntax","text":"-XX:[+|-]JITServerMetrics Setting Effect Default -XX:+JITServerMetrics Enable -XX:-JITServerMetrics Disable yes","title":"Syntax"},{"location":"xxjitservermetrics/#explanation","text":"When you enable this option, the JITServer process opens a TCP port, which can be used by monitoring agents (like Prometheus) to collect the custom metrics exported by the JITServer. Monitoring agents must issue HTTP GET requests to a URL of the form: http://<jitserveraddress>:<port>/metrics . The path for the HTTP request must be /metrics . The default value of <port> is 38500. You can change this value by using the -XX:JITServerMetricsPort command line option. The format for the metrics returned by the JITServer follows the OpenMetrics protocol.","title":"Explanation"},{"location":"xxjitservermetrics/#example","text":"The following example shows an HTTP request from a Prometheus monitoring agent and the response from the JITServer: HTTP request: GET /metrics HTTP/1.1 Host: 127.0.0.1:9403 User-Agent: Prometheus/2.31.1 Accept: application/openmetrics-text; version=0.0.1,text/plain;version=0.0.4;q=0.5,*/*;q=0.1 Accept-Encoding: gzip X-Prometheus-Scrape-Timeout-Seconds: 3 JITServer response: # HELP jitserver_cpu_utilization Cpu utilization of the JITServer # TYPE jitserver_cpu_utilization gauge jitserver_cpu_utilization 12.000000 # HELP jitserver_available_memory Available memory for JITServer # TYPE jitserver_available_memory gauge jitserver_available_memory 32036204544.000000 # HELP jitserver_connected_clients Number of connected clients # TYPE jitserver_connected_clients gauge jitserver_connected_clients 1.000000 # HELP jitserver_active_threads Number of active compilation threads # TYPE jitserver_active_threads gauge jitserver_active_threads 1.000000","title":"Example"},{"location":"xxjitservermetrics/#see-also","text":"-XX:JITServerMetricsPort JITServer technology -XX:JITServerMetricsSSLKey","title":"See also"},{"location":"xxjitservermetricsport/","text":"-XX:JITServerMetricsPort This option specifies the port number on which the JITServer metrics are provided to a monitoring agent. Use this option with the -XX:+JITServerMetrics option, which enables the provision of the JITServer metrics. Syntax -XX:JITServerMetricsPort=<port> Setting Effect Default -XX:JITServerMetricsPort Set JITServer port for metrics 38500 See also -XX:[+|-]JITServerMetrics JITServer technology","title":"-XX:JITServerMetricsPort"},{"location":"xxjitservermetricsport/#-xxjitservermetricsport","text":"This option specifies the port number on which the JITServer metrics are provided to a monitoring agent. Use this option with the -XX:+JITServerMetrics option, which enables the provision of the JITServer metrics.","title":"-XX:JITServerMetricsPort"},{"location":"xxjitservermetricsport/#syntax","text":"-XX:JITServerMetricsPort=<port> Setting Effect Default -XX:JITServerMetricsPort Set JITServer port for metrics 38500","title":"Syntax"},{"location":"xxjitservermetricsport/#see-also","text":"-XX:[+|-]JITServerMetrics JITServer technology","title":"See also"},{"location":"xxjitservermetricssslkey/","text":"-XX:JITServerMetricsSSLKey / -XX:JITServerMetricsSSLCert These options specify the names of the files that contain the private TLS or SSL key and certificate that are used for authentication and encryption of the custom metrics. Syntax -XX:JITServerMetricsSSLKey=<key_file> -XX:JITServerMetricsSSLCert=<cert_file> Where <key_file> specifies the name of the file that contains the private TLS or SSL key and <cert_file> specifies the name of the file that contains the private TLS or SSL certificate. The files must all be in .pem file format. Setting Effect Default -XX:JITServerMetricsSSLKey Set metrics SSL key None -XX:JITServerMetricsSSLCert Set metrics SSL certificate None Explanation Custom metrics are exported by the JITServer server and collected by a monitoring agent, such as Prometheus. The exported data is sent in clear text by default. To secure this data with TLS or SSL authentication and encryption, specify the private key ( <key>.pem ) and the certificate ( <cert>.pem ) at the server: -XX:JITServerMetricsSSLKey=<key>.pem -XX:JITServerMetricsSSLCert=<cert>.pem You must specify both the options for TLS or SSL authentication and encryption. Note: To enable the export of custom metrics, you must specify the -XX:[+|-]JITServerMetrics option. See also -XX:[+|-]JITServerMetrics JITServer technology","title":"-XX:JITServerMetricsSSLKey"},{"location":"xxjitservermetricssslkey/#-xxjitservermetricssslkey-xxjitservermetricssslcert","text":"These options specify the names of the files that contain the private TLS or SSL key and certificate that are used for authentication and encryption of the custom metrics.","title":"-XX:JITServerMetricsSSLKey / -XX:JITServerMetricsSSLCert"},{"location":"xxjitservermetricssslkey/#syntax","text":"-XX:JITServerMetricsSSLKey=<key_file> -XX:JITServerMetricsSSLCert=<cert_file> Where <key_file> specifies the name of the file that contains the private TLS or SSL key and <cert_file> specifies the name of the file that contains the private TLS or SSL certificate. The files must all be in .pem file format. Setting Effect Default -XX:JITServerMetricsSSLKey Set metrics SSL key None -XX:JITServerMetricsSSLCert Set metrics SSL certificate None","title":"Syntax"},{"location":"xxjitservermetricssslkey/#explanation","text":"Custom metrics are exported by the JITServer server and collected by a monitoring agent, such as Prometheus. The exported data is sent in clear text by default. To secure this data with TLS or SSL authentication and encryption, specify the private key ( <key>.pem ) and the certificate ( <cert>.pem ) at the server: -XX:JITServerMetricsSSLKey=<key>.pem -XX:JITServerMetricsSSLCert=<cert>.pem You must specify both the options for TLS or SSL authentication and encryption. Note: To enable the export of custom metrics, you must specify the -XX:[+|-]JITServerMetrics option.","title":"Explanation"},{"location":"xxjitservermetricssslkey/#see-also","text":"-XX:[+|-]JITServerMetrics JITServer technology","title":"See also"},{"location":"xxjitserverport/","text":"-XX:JITServerPort This option specifies the port on which the JITServer server listens for compilation requests. On the JITServer server , this option sets the port that is open for connections. On the JITServer client , this option specifies to which server port the client should send compilation requests. Syntax -XX:JITServerPort=<port> Setting Effect Default -XX:JITServerPort Set JITServer port 38400 See also JITServer technology","title":"-XX:JITServerPort"},{"location":"xxjitserverport/#-xxjitserverport","text":"This option specifies the port on which the JITServer server listens for compilation requests. On the JITServer server , this option sets the port that is open for connections. On the JITServer client , this option specifies to which server port the client should send compilation requests.","title":"-XX:JITServerPort"},{"location":"xxjitserverport/#syntax","text":"-XX:JITServerPort=<port> Setting Effect Default -XX:JITServerPort Set JITServer port 38400","title":"Syntax"},{"location":"xxjitserverport/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxjitservershareromclasses/","text":"-XX:[+|-]JITServerShareROMClasses This option enables the JITServer server to share cached ROM classes between JITServer clients. Syntax -XX:[+|-]JITServerShareROMClasses Setting Effect Default -XX:+JITServerShareROMClasses Enable -XX:-JITServerShareROMClasses Disable yes Note: The -XX:+JITServerShareROMClasses option is enabled by default at the server on specifying the -XX:+JITServerUseAOTCache option. Explanation Enable this option when multiple clients that are running identical or similar applications connect to a single server. This option enables a caching optimization that allows the server to use ROM classes that are cached for one client while compiling for a different client. This behavior reduces the memory usage at the server because only a single copy of a particular Java\u2122 class is cached. See also JITServer technology","title":"-XX:JITServerShareROMClasses"},{"location":"xxjitservershareromclasses/#-xx-jitservershareromclasses","text":"This option enables the JITServer server to share cached ROM classes between JITServer clients.","title":"-XX:[+|-]JITServerShareROMClasses"},{"location":"xxjitservershareromclasses/#syntax","text":"-XX:[+|-]JITServerShareROMClasses Setting Effect Default -XX:+JITServerShareROMClasses Enable -XX:-JITServerShareROMClasses Disable yes Note: The -XX:+JITServerShareROMClasses option is enabled by default at the server on specifying the -XX:+JITServerUseAOTCache option.","title":"Syntax"},{"location":"xxjitservershareromclasses/#explanation","text":"Enable this option when multiple clients that are running identical or similar applications connect to a single server. This option enables a caching optimization that allows the server to use ROM classes that are cached for one client while compiling for a different client. This behavior reduces the memory usage at the server because only a single copy of a particular Java\u2122 class is cached.","title":"Explanation"},{"location":"xxjitservershareromclasses/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxjitserversslcert/","text":"-XX:JITServerSSLCert / -XX:JITServerSSLKey / -XX:JITServerSSLRootCerts Options for encrypting network communication between JITServer servers and JITServer client VMs. Syntax -XX:JITServerCert=<cert_file> -XX:JITServerKey=<key_file> -XX:JITServerSSLRootCerts=<root_certs_file> The files must all be in .pem file format. Setting Effect Default -XX:JITServerSSLCert Set server's SSL certificate None -XX:JITServerSSLKey Set server's SSL key None -XX:JITServerSSLRootCerts Set client's SSL root certificate None Explanation You can encrypt network communication by using OpenSSL 1.0.x, 1.1.x, or 3.0.x. To enable encryption, specify the private key ( <key>.pem ) and the certificate ( <cert>.pem ) at the server: -XX:JITServerSSLKey=<key>.pem -XX:JITServerSSLCert=<cert>.pem and use the certificate at the client: -XX:JITServerSSLRootCerts=<cert>.pem You must specify all three options for the client to be able to connect to the server. If the client cannot connect, it is forced to perform all compilations locally instead. For more details and further discussion about security considerations, see the blog post Free your JVM from the JIT with JITServer Technology . See also JITServer technology","title":"-XX:JITServerSSLRootCerts"},{"location":"xxjitserversslcert/#-xxjitserversslcert-xxjitserversslkey-xxjitserversslrootcerts","text":"Options for encrypting network communication between JITServer servers and JITServer client VMs.","title":"-XX:JITServerSSLCert / -XX:JITServerSSLKey / -XX:JITServerSSLRootCerts"},{"location":"xxjitserversslcert/#syntax","text":"-XX:JITServerCert=<cert_file> -XX:JITServerKey=<key_file> -XX:JITServerSSLRootCerts=<root_certs_file> The files must all be in .pem file format. Setting Effect Default -XX:JITServerSSLCert Set server's SSL certificate None -XX:JITServerSSLKey Set server's SSL key None -XX:JITServerSSLRootCerts Set client's SSL root certificate None","title":"Syntax"},{"location":"xxjitserversslcert/#explanation","text":"You can encrypt network communication by using OpenSSL 1.0.x, 1.1.x, or 3.0.x. To enable encryption, specify the private key ( <key>.pem ) and the certificate ( <cert>.pem ) at the server: -XX:JITServerSSLKey=<key>.pem -XX:JITServerSSLCert=<cert>.pem and use the certificate at the client: -XX:JITServerSSLRootCerts=<cert>.pem You must specify all three options for the client to be able to connect to the server. If the client cannot connect, it is forced to perform all compilations locally instead. For more details and further discussion about security considerations, see the blog post Free your JVM from the JIT with JITServer Technology .","title":"Explanation"},{"location":"xxjitserversslcert/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxjitservertimeout/","text":"-XX:JITServerTimeout This option specifies the socket timeout for JITServer communication. You can specify this option on both the server and the client sides. Syntax -XX:JITServerTimeout=<timeout_ms> Setting Effect Default -XX:JITServerTimeout Set the timeout value in milliseconds for socket operations 30000 ms for the JITServer process and 10000 ms when Eclipse OpenJ9\u2122 is launched as a client VM See also JITServer technology","title":"-XX:JITServerTimeout"},{"location":"xxjitservertimeout/#-xxjitservertimeout","text":"This option specifies the socket timeout for JITServer communication. You can specify this option on both the server and the client sides.","title":"-XX:JITServerTimeout"},{"location":"xxjitservertimeout/#syntax","text":"-XX:JITServerTimeout=<timeout_ms> Setting Effect Default -XX:JITServerTimeout Set the timeout value in milliseconds for socket operations 30000 ms for the JITServer process and 10000 ms when Eclipse OpenJ9\u2122 is launched as a client VM","title":"Syntax"},{"location":"xxjitservertimeout/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxjitserveruseaotcache/","text":"-XX:[+|-]JITServerUseAOTCache This option enables the caching of AOT-compiled methods in the JITServer server. Syntax -XX:[+|-]JITServerUseAOTCache Setting Effect Default -XX:+JITServerUseAOTCache Enable -XX:-JITServerUseAOTCache Disable yes Explanation When you enable this option, the JITServer server caches the AOT-compiled methods. When a JITServer client requests an AOT compilation and the requested method exists in the cache, the server does not have to recompile the method. This feature, therefore, improves the CPU utilization of the JITServer technology and of the cluster. Note: This option has the following requirements: You must specify this option both at the client JVM and at the server. The client JVM must have the shared class cache feature enabled and be allowed to generate AOT compilation requests. The -XX:+JITServerShareROMClasses option is enabled by default at the server on specifying the -XX:+JITServerUseAOTCache option. See also JITServer technology -XX:JITServerAOTCacheName","title":"-XX:[+|-]JITServerUseAOTCache"},{"location":"xxjitserveruseaotcache/#-xx-jitserveruseaotcache","text":"This option enables the caching of AOT-compiled methods in the JITServer server.","title":"-XX:[+|-]JITServerUseAOTCache"},{"location":"xxjitserveruseaotcache/#syntax","text":"-XX:[+|-]JITServerUseAOTCache Setting Effect Default -XX:+JITServerUseAOTCache Enable -XX:-JITServerUseAOTCache Disable yes","title":"Syntax"},{"location":"xxjitserveruseaotcache/#explanation","text":"When you enable this option, the JITServer server caches the AOT-compiled methods. When a JITServer client requests an AOT compilation and the requested method exists in the cache, the server does not have to recompile the method. This feature, therefore, improves the CPU utilization of the JITServer technology and of the cluster. Note: This option has the following requirements: You must specify this option both at the client JVM and at the server. The client JVM must have the shared class cache feature enabled and be allowed to generate AOT compilation requests. The -XX:+JITServerShareROMClasses option is enabled by default at the server on specifying the -XX:+JITServerUseAOTCache option.","title":"Explanation"},{"location":"xxjitserveruseaotcache/#see-also","text":"JITServer technology -XX:JITServerAOTCacheName","title":"See also"},{"location":"xxlazysymbolresolution/","text":"-XX:[+|-]LazySymbolResolution (Linux\u00ae and macOS\u00ae only) This option affects the timing of symbol resolution for functions in user native libraries. Syntax -XX:[+|-]LazySymbolResolution Setting Effect Default -XX:+LazySymbolResolution Enable yes -XX:-LazySymbolResolution Disable Explanation Enabling this option forces the VM to delay symbol resolution for each function in a user native library, until the function is called. The -XX:-LazySymbolResolution option forces the VM to immediately resolve symbols for all functions in a user native library when the library is loaded. These options apply only to functions; variable symbols are always resolved immediately when loaded. If you attempt to use these options on an operating system other than Linux or macOS, the options are accepted, but ignored.","title":"-XX:[+|-]LazySymbolResolution"},{"location":"xxlazysymbolresolution/#-xx-lazysymbolresolution","text":"(Linux\u00ae and macOS\u00ae only) This option affects the timing of symbol resolution for functions in user native libraries.","title":"-XX:[+|-]LazySymbolResolution"},{"location":"xxlazysymbolresolution/#syntax","text":"-XX:[+|-]LazySymbolResolution Setting Effect Default -XX:+LazySymbolResolution Enable yes -XX:-LazySymbolResolution Disable","title":"Syntax"},{"location":"xxlazysymbolresolution/#explanation","text":"Enabling this option forces the VM to delay symbol resolution for each function in a user native library, until the function is called. The -XX:-LazySymbolResolution option forces the VM to immediately resolve symbols for all functions in a user native library when the library is loaded. These options apply only to functions; variable symbols are always resolved immediately when loaded. If you attempt to use these options on an operating system other than Linux or macOS, the options are accepted, but ignored.","title":"Explanation"},{"location":"xxlegacyxlogoption/","text":"-XX:[+|-]LegacyXlogOption Controls processing of the -Xlog option. Syntax Setting Effect Default -XX:+LegacyXlogOption Enable legacy -Xlog behavior -XX:-LegacyXlogOption Process -Xlog requests for GC logging yes Explanation From Eclipse OpenJ9\u2122 0.24.0, the -Xlog option is replaced by the -Xsyslog option. The -XX:[+|-]LegacyXlogOption controls how the -Xlog option is processed. When -XX:-LegacyXlogOption is set, the -Xlog option is recognized only when a form of this option is run that requests garbage collection (GC) logging (for example, -Xlog:gc[:stderr|:file=<filename>] ). For more information, see -Xlog . When -XX:+LegacyXlogOption is set, the legacy -Xlog behavior is enabled. When enabled, the option is equivalent to the -Xsyslog option. That is, the -Xlog option can be used with the parameters documented in -Xsyslog .","title":"-XX:[+|-]LegacyXLogOption"},{"location":"xxlegacyxlogoption/#-xx-legacyxlogoption","text":"Controls processing of the -Xlog option.","title":"-XX:[+|-]LegacyXlogOption"},{"location":"xxlegacyxlogoption/#syntax","text":"Setting Effect Default -XX:+LegacyXlogOption Enable legacy -Xlog behavior -XX:-LegacyXlogOption Process -Xlog requests for GC logging yes","title":"Syntax"},{"location":"xxlegacyxlogoption/#explanation","text":"From Eclipse OpenJ9\u2122 0.24.0, the -Xlog option is replaced by the -Xsyslog option. The -XX:[+|-]LegacyXlogOption controls how the -Xlog option is processed. When -XX:-LegacyXlogOption is set, the -Xlog option is recognized only when a form of this option is run that requests garbage collection (GC) logging (for example, -Xlog:gc[:stderr|:file=<filename>] ). For more information, see -Xlog . When -XX:+LegacyXlogOption is set, the legacy -Xlog behavior is enabled. When enabled, the option is equivalent to the -Xsyslog option. That is, the -Xlog option can be used with the parameters documented in -Xsyslog .","title":"Explanation"},{"location":"xxmaxdirectmemorysize/","text":"-XX:MaxDirectMemorySize This Oracle HotSpot option sets a limit on the amount of memory that can be reserved for all Direct Byte Buffers. Syntax -XX:MaxDirectMemorySize=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] Depends on maximum heap size The value you choose is the limit on memory that can be reserved for all Direct Byte Buffers. If a value is set for this option, the sum of all Direct Byte Buffer sizes cannot exceed the limit. After the limit is reached, a new Direct Byte Buffer can be allocated only when enough old buffers are freed to provide enough space to allocate the new buffer. By default, the amount of native memory used for Direct Byte Buffers is limited to 87.5% of the maximum heap size. By default, the amount of native memory used for Direct Byte Buffers is limited to the maximum heap size.","title":"-XX:MaxDirectMemorySize"},{"location":"xxmaxdirectmemorysize/#-xxmaxdirectmemorysize","text":"This Oracle HotSpot option sets a limit on the amount of memory that can be reserved for all Direct Byte Buffers.","title":"-XX:MaxDirectMemorySize"},{"location":"xxmaxdirectmemorysize/#syntax","text":"-XX:MaxDirectMemorySize=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] Depends on maximum heap size The value you choose is the limit on memory that can be reserved for all Direct Byte Buffers. If a value is set for this option, the sum of all Direct Byte Buffer sizes cannot exceed the limit. After the limit is reached, a new Direct Byte Buffer can be allocated only when enough old buffers are freed to provide enough space to allocate the new buffer. By default, the amount of native memory used for Direct Byte Buffers is limited to 87.5% of the maximum heap size. By default, the amount of native memory used for Direct Byte Buffers is limited to the maximum heap size.","title":"Syntax"},{"location":"xxnosuballoc32bitmem/","text":"-XXnosuballoc32bitmem (z/OS\u00ae only) When compressed references are used with a 64-bit Eclipse OpenJ9\u2122 VM on z/OS\u00ae, this option forces the VM to use 31-bit memory allocation functions provided by z/OS. Syntax -XXnosuballoc32bitmem Setting Effect Default -XXnosuballoc32bitmem Enable No setting Disable yes Explanation This option is provided as a workaround for customers who need to use fewer pages of 31-bit virtual storage per VM invocation. Using this option might result in a small increase in the number of frames of central storage used by the VM. However, the option frees 31-bit pages for use by native code or other applications in the same address space. If this option is not specified, the VM uses an allocation strategy for 31-bit memory that reserves a region of 31-bit virtual memory.","title":"-XXnosuballoc32bitmem"},{"location":"xxnosuballoc32bitmem/#-xxnosuballoc32bitmem","text":"(z/OS\u00ae only) When compressed references are used with a 64-bit Eclipse OpenJ9\u2122 VM on z/OS\u00ae, this option forces the VM to use 31-bit memory allocation functions provided by z/OS.","title":"-XXnosuballoc32bitmem"},{"location":"xxnosuballoc32bitmem/#syntax","text":"-XXnosuballoc32bitmem Setting Effect Default -XXnosuballoc32bitmem Enable No setting Disable yes","title":"Syntax"},{"location":"xxnosuballoc32bitmem/#explanation","text":"This option is provided as a workaround for customers who need to use fewer pages of 31-bit virtual storage per VM invocation. Using this option might result in a small increase in the number of frames of central storage used by the VM. However, the option frees 31-bit pages for use by native code or other applications in the same address space. If this option is not specified, the VM uses an allocation strategy for 31-bit memory that reserves a region of 31-bit virtual memory.","title":"Explanation"},{"location":"xxonoutofmemoryerror/","text":"-XX:OnOutOfMemoryError You can use this Oracle HotSpot option to run commands when a java.lang.OutOfMemoryError is thrown. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility. Syntax -XX:OnOutOfMemoryError=\"<command_string>\" where <command_string> is a command or list of commands to run when a java.lang.OutOfMemoryError occurs. For example, the following command specifies that the java -version command is run if the Test application throws a java.lang.OutOfMemoryError exception: java -XX:OnOutOfMemoryError=\"java -version\" Test If you want to run multiple commands, use semicolons to separate them within <command_string> . For example: -XX:OnOutOfMemoryError=\"<java_path> <java_program>; cat file.txt\" The -XX:OnOutOfMemoryError option is equivalent to the following -Xdump option: -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec=<command_string> For more information, see -Xdump .","title":"-XX:OnOutOfMemoryError"},{"location":"xxonoutofmemoryerror/#-xxonoutofmemoryerror","text":"You can use this Oracle HotSpot option to run commands when a java.lang.OutOfMemoryError is thrown. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility.","title":"-XX:OnOutOfMemoryError"},{"location":"xxonoutofmemoryerror/#syntax","text":"-XX:OnOutOfMemoryError=\"<command_string>\" where <command_string> is a command or list of commands to run when a java.lang.OutOfMemoryError occurs. For example, the following command specifies that the java -version command is run if the Test application throws a java.lang.OutOfMemoryError exception: java -XX:OnOutOfMemoryError=\"java -version\" Test If you want to run multiple commands, use semicolons to separate them within <command_string> . For example: -XX:OnOutOfMemoryError=\"<java_path> <java_program>; cat file.txt\" The -XX:OnOutOfMemoryError option is equivalent to the following -Xdump option: -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec=<command_string> For more information, see -Xdump .","title":"Syntax"},{"location":"xxopenj9commandlineenv/","text":"-XX:[+|-]OpenJ9CommandLineEnv This option controls whether the VM captures the command line in the environment variable OPENJ9_JAVA_COMMAND_LINE . If enabled, the variable is set by the VM after it starts. Using this variable, you can find the command-line parameters set when the VM started. It applies not just to launchers (e.g. java ) that are included in a JDK, but to any application that uses JNI_CreateJavaVM() . Syntax -XX:[+|-]OpenJ9CommandLineEnv Setting Effect Default on z/OS Default on other platforms -XX:+OpenJ9CommandLineEnv Enable yes -XX:-OpenJ9CommandLineEnv Disable yes This option is currently disabled by default on z/OS\u00ae because it might cause the VM to crash. See also Environment variables","title":"-XX:[+|-]OpenJ9CommandLineEnv"},{"location":"xxopenj9commandlineenv/#-xx-openj9commandlineenv","text":"This option controls whether the VM captures the command line in the environment variable OPENJ9_JAVA_COMMAND_LINE . If enabled, the variable is set by the VM after it starts. Using this variable, you can find the command-line parameters set when the VM started. It applies not just to launchers (e.g. java ) that are included in a JDK, but to any application that uses JNI_CreateJavaVM() .","title":"-XX:[+|-]OpenJ9CommandLineEnv"},{"location":"xxopenj9commandlineenv/#syntax","text":"-XX:[+|-]OpenJ9CommandLineEnv Setting Effect Default on z/OS Default on other platforms -XX:+OpenJ9CommandLineEnv Enable yes -XX:-OpenJ9CommandLineEnv Disable yes This option is currently disabled by default on z/OS\u00ae because it might cause the VM to crash.","title":"Syntax"},{"location":"xxopenj9commandlineenv/#see-also","text":"Environment variables","title":"See also"},{"location":"xxoriginaljdk8heapsizecompatibilitymode/","text":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode The default value for the maximum heap size ( -Xmx ) is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. In Eclipse OpenJ9\u2122 0.18.0 and earlier releases the default is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Enable this option to revert to the earlier default value. Restriction: This option is supported only on Java\u2122 8. It is ignored on Java 11 and later versions. Syntax -XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode Setting Effect Default -XX:+OriginalJDK8HeapSizeCompatibilityMode Enable -XX:-OriginalJDK8HeapSizeCompatibilityMode Disable yes","title":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode"},{"location":"xxoriginaljdk8heapsizecompatibilitymode/#-xx-originaljdk8heapsizecompatibilitymode","text":"The default value for the maximum heap size ( -Xmx ) is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. In Eclipse OpenJ9\u2122 0.18.0 and earlier releases the default is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Enable this option to revert to the earlier default value. Restriction: This option is supported only on Java\u2122 8. It is ignored on Java 11 and later versions.","title":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode"},{"location":"xxoriginaljdk8heapsizecompatibilitymode/#syntax","text":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode Setting Effect Default -XX:+OriginalJDK8HeapSizeCompatibilityMode Enable -XX:-OriginalJDK8HeapSizeCompatibilityMode Disable yes","title":"Syntax"},{"location":"xxpagealigndirectmemory/","text":"-XX:[+|-]PageAlignDirectMemory This Oracle HotSpot option affects the alignment of direct byte buffer allocation and is implemented by the Eclipse OpenJ9\u2122 VM for compatibility. Syntax -XX:[+|-]PageAlignDirectMemory Setting Effect Default -XX:+PageAlignDirectMemory Enable -XX:-PageAlignDirectMemory Disable yes As discussed in the Oracle documentation, before Java\u2122 SE 7, direct buffers that were allocated using java.nio.ByteBuffer.allocateDirect(int) were aligned on a page boundary. This behavior changed in Java SE 7 and the -XX:+PageAlignDirectMemory option is provided to revert to the previous behavior. For more information about the changes, see RFE 4837564 , which was introduced in the Java SE 7 release notes .","title":"-XX:[+|-]PageAlignDirectMemory"},{"location":"xxpagealigndirectmemory/#-xx-pagealigndirectmemory","text":"This Oracle HotSpot option affects the alignment of direct byte buffer allocation and is implemented by the Eclipse OpenJ9\u2122 VM for compatibility.","title":"-XX:[+|-]PageAlignDirectMemory"},{"location":"xxpagealigndirectmemory/#syntax","text":"-XX:[+|-]PageAlignDirectMemory Setting Effect Default -XX:+PageAlignDirectMemory Enable -XX:-PageAlignDirectMemory Disable yes As discussed in the Oracle documentation, before Java\u2122 SE 7, direct buffers that were allocated using java.nio.ByteBuffer.allocateDirect(int) were aligned on a page boundary. This behavior changed in Java SE 7 and the -XX:+PageAlignDirectMemory option is provided to revert to the previous behavior. For more information about the changes, see RFE 4837564 , which was introduced in the Java SE 7 release notes .","title":"Syntax"},{"location":"xxparallelcmsthreads/","text":"-XX:ParallelCMSThreads This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility. Syntax -XX:ParallelCMSThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"-XX:ParallelCMSThreads"},{"location":"xxparallelcmsthreads/#-xxparallelcmsthreads","text":"This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility.","title":"-XX:ParallelCMSThreads"},{"location":"xxparallelcmsthreads/#syntax","text":"-XX:ParallelCMSThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"Syntax"},{"location":"xxparallelgcmaxthreads/","text":"-XX:ParallelGCMaxThreads This option specifies the maximum number of threads that can be used during parallel operations of the garbage collector. Unlike -XX:ParallelGCThreads , this option does not enforce a thread count, but can be used to allow the garbage collector to adjust the number of parallel GC threads, if used with the Adaptive GC Threading option. Syntax -XX:ParallelGCMaxThreads=<number> Where <number> is the maximum number of threads that can be used for parallel operations. This option is directly mapped to -Xgcmaxthreads .","title":"-XX:ParallelGCMaxThreads"},{"location":"xxparallelgcmaxthreads/#-xxparallelgcmaxthreads","text":"This option specifies the maximum number of threads that can be used during parallel operations of the garbage collector. Unlike -XX:ParallelGCThreads , this option does not enforce a thread count, but can be used to allow the garbage collector to adjust the number of parallel GC threads, if used with the Adaptive GC Threading option.","title":"-XX:ParallelGCMaxThreads"},{"location":"xxparallelgcmaxthreads/#syntax","text":"-XX:ParallelGCMaxThreads=<number> Where <number> is the maximum number of threads that can be used for parallel operations. This option is directly mapped to -Xgcmaxthreads .","title":"Syntax"},{"location":"xxparallelgcthreads/","text":"-XX:ParallelGCThreads This Oracle HotSpot option specifies the number of threads that are used during parallel operations of the default garbage collector. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility. Notes: This option enforces the thread count and cannot be used with the -XX:+AdaptiveGCThreading option, which enables the garbage collector to adjust the number of parallel threads based on heuristics. If you want to use -XX:+AdaptiveGCThreading , use -XX:ParallelGCMaxThreads instead of -XX:ParallelGCThreads . Syntax -XX:ParallelGCThreads=<number> Where <number> is the number of threads that are used for parallel operations. Within OpenJ9 this option is directly mapped to -Xgcthreads .","title":"-XX:ParallelGCThreads"},{"location":"xxparallelgcthreads/#-xxparallelgcthreads","text":"This Oracle HotSpot option specifies the number of threads that are used during parallel operations of the default garbage collector. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility. Notes: This option enforces the thread count and cannot be used with the -XX:+AdaptiveGCThreading option, which enables the garbage collector to adjust the number of parallel threads based on heuristics. If you want to use -XX:+AdaptiveGCThreading , use -XX:ParallelGCMaxThreads instead of -XX:ParallelGCThreads .","title":"-XX:ParallelGCThreads"},{"location":"xxparallelgcthreads/#syntax","text":"-XX:ParallelGCThreads=<number> Where <number> is the number of threads that are used for parallel operations. Within OpenJ9 this option is directly mapped to -Xgcthreads .","title":"Syntax"},{"location":"xxperftool/","text":"-XX:[+|-]PerfTool This option enables or disables JIT support for the perf tool without affecting the existing Xjit options. Restriction: Since this option creates a file that is used by the Linux\u00ae system profiler, perf , it applies only to Linux. Syntax -XX:[+|-]PerfTool Setting Effect Default -XX:+PerfTool Enable -XX:-PerfTool Disable yes Explanation The -XX:+PerfTool option is a stand-alone alternative for the existing -Xjit:perfTool option. If multiple -Xjit options exist, only the last option takes effect. Therefore, if the -Xjit:perfTool option is added later, it overrides the existing -Xjit options. To overcome this issue, the XX:+PerfTool option enables JIT support for the perf tool without having any impact on the existing Xjit options. This enabling option creates a /tmp/perf-<pid>.map file that is used by the perf tool to map the samples in the JIT-compiled code to the corresponding Java method names. To disable the JIT support for the perf tool, set the -XX:-PerfTool option on the command line. See also xjit","title":"-XX:[+|-]PerfTool"},{"location":"xxperftool/#-xx-perftool","text":"This option enables or disables JIT support for the perf tool without affecting the existing Xjit options. Restriction: Since this option creates a file that is used by the Linux\u00ae system profiler, perf , it applies only to Linux.","title":"-XX:[+|-]PerfTool"},{"location":"xxperftool/#syntax","text":"-XX:[+|-]PerfTool Setting Effect Default -XX:+PerfTool Enable -XX:-PerfTool Disable yes","title":"Syntax"},{"location":"xxperftool/#explanation","text":"The -XX:+PerfTool option is a stand-alone alternative for the existing -Xjit:perfTool option. If multiple -Xjit options exist, only the last option takes effect. Therefore, if the -Xjit:perfTool option is added later, it overrides the existing -Xjit options. To overcome this issue, the XX:+PerfTool option enables JIT support for the perf tool without having any impact on the existing Xjit options. This enabling option creates a /tmp/perf-<pid>.map file that is used by the perf tool to map the samples in the JIT-compiled code to the corresponding Java method names. To disable the JIT support for the perf tool, set the -XX:-PerfTool option on the command line.","title":"Explanation"},{"location":"xxperftool/#see-also","text":"xjit","title":"See also"},{"location":"xxportablesharedcache/","text":"-XX:[+|-]PortableSharedCache Use this command line option to choose whether AOT-compiled code should be portable. This option, when enabled, increases the portability of AOT-compiled code, in the following ways: The code is generated based on a particular set of processor features that ensures the AOT-compiled code to be portable across processors of different microarchitectures. AOT-compiled code generated with this option is guaranteed to be portable across Intel\u00ae Sandy Bridge or newer microarchitectures on x86 platforms, IBM\u00ae z10 or newer microarchitectures on s390 platforms and IBM POWER8\u00ae or newer microarchitectures on POWER platforms. The code is generated to be portable across Eclipse OpenJ9\u2122 VMs that use compressed references and have a heap size of 1 MB to 28 GB (previously, AOT-compiled code could not be shared between VMs that use compressed references and that have different heap sizes). This feature might introduce a small (1-2%) steady-state throughput penalty when compressed references are used and the heap size is between 1 MB and 3 GB. This feature is particularly relevant for packaging a shared classes cache into a container image (for example, applications deployed on the cloud in the form of Docker containers) due to the following reasons: - The processor on which the container image is built is likely to be different from the processor on which the container is deployed. - In a multi-layered container image where the shared classes cache is multi-layered as well, the AOT-compiled code in shared classes cache will likely come from multiple OpenJ9 VMs with different heap size requirements. Syntax -XX:[+|-]PortableSharedCache Setting Effect Default -XX:+PortableSharedCache Enable See notes that follow -XX:-PortableSharedCache Disable Default settings This option is enabled by default in containers. To disable the option in a container, specify -XX:-PortableSharedCache . The option is disabled by default outside containers. To enable the option outside a container, specify -XX:+PortableSharedCache for the initial JVM instance (when the creation of the shared class cache happens) as well as for every subsequent instance that makes use of the same shared class cache.","title":"-XX:[+|-]PortableSharedCache"},{"location":"xxportablesharedcache/#-xx-portablesharedcache","text":"Use this command line option to choose whether AOT-compiled code should be portable. This option, when enabled, increases the portability of AOT-compiled code, in the following ways: The code is generated based on a particular set of processor features that ensures the AOT-compiled code to be portable across processors of different microarchitectures. AOT-compiled code generated with this option is guaranteed to be portable across Intel\u00ae Sandy Bridge or newer microarchitectures on x86 platforms, IBM\u00ae z10 or newer microarchitectures on s390 platforms and IBM POWER8\u00ae or newer microarchitectures on POWER platforms. The code is generated to be portable across Eclipse OpenJ9\u2122 VMs that use compressed references and have a heap size of 1 MB to 28 GB (previously, AOT-compiled code could not be shared between VMs that use compressed references and that have different heap sizes). This feature might introduce a small (1-2%) steady-state throughput penalty when compressed references are used and the heap size is between 1 MB and 3 GB. This feature is particularly relevant for packaging a shared classes cache into a container image (for example, applications deployed on the cloud in the form of Docker containers) due to the following reasons: - The processor on which the container image is built is likely to be different from the processor on which the container is deployed. - In a multi-layered container image where the shared classes cache is multi-layered as well, the AOT-compiled code in shared classes cache will likely come from multiple OpenJ9 VMs with different heap size requirements.","title":"-XX:[+|-]PortableSharedCache"},{"location":"xxportablesharedcache/#syntax","text":"-XX:[+|-]PortableSharedCache Setting Effect Default -XX:+PortableSharedCache Enable See notes that follow -XX:-PortableSharedCache Disable","title":"Syntax"},{"location":"xxportablesharedcache/#default-settings","text":"This option is enabled by default in containers. To disable the option in a container, specify -XX:-PortableSharedCache . The option is disabled by default outside containers. To enable the option outside a container, specify -XX:+PortableSharedCache for the initial JVM instance (when the creation of the shared class cache happens) as well as for every subsequent instance that makes use of the same shared class cache.","title":"Default settings"},{"location":"xxpositiveidentityhash/","text":"-XX:[+|-]PositiveIdentityHash Eclipse OpenJ9\u2122 allows both positive and negative identity hashcodes ( System.identityHashCode / Object.hashCode ). This is problematic for programs that incorrectly assume hashcodes can only be positive. When enabled, this option limits identity hash codes to non-negative values. Because limiting identity hash codes to non-negative values can have an impact on the performance of hash-intensive operations, this option is not enabled by default. Syntax -XX:[+|-]PositiveIdentityHash Setting Effect Default -XX:+PositiveIdentityHash Enable -XX:-PositiveIdentityHash Disable yes","title":"-XX:[+|-]PositiveIdentityHash"},{"location":"xxpositiveidentityhash/#-xx-positiveidentityhash","text":"Eclipse OpenJ9\u2122 allows both positive and negative identity hashcodes ( System.identityHashCode / Object.hashCode ). This is problematic for programs that incorrectly assume hashcodes can only be positive. When enabled, this option limits identity hash codes to non-negative values. Because limiting identity hash codes to non-negative values can have an impact on the performance of hash-intensive operations, this option is not enabled by default.","title":"-XX:[+|-]PositiveIdentityHash"},{"location":"xxpositiveidentityhash/#syntax","text":"-XX:[+|-]PositiveIdentityHash Setting Effect Default -XX:+PositiveIdentityHash Enable -XX:-PositiveIdentityHash Disable yes","title":"Syntax"},{"location":"xxprintcodecache/","text":"-XX:[+|-]PrintCodeCache This Oracle HotSpot option prints the code cache memory usage when the application exits. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility. Syntax -XX:[+|-]PrintCodeCache Setting Effect Default -XX:+PrintCodeCache Enable -XX:-PrintCodeCache Disable yes As discussed in the Oracle documentation, the code cache usage can be shown when the application exits, by specifying \u2013XX:+PrintCodeCache on the Java launcher command line. The output looks similar to the following: CodeCache: size=262144Kb used=454Kb max_used=457Kb free=261690Kb size : The maximum size of the code cache. used : The amount of code cache memory actually in use. max_used : The high water mark for code cache usage. free : size minus used .","title":"-XX:[+|-]PrintCodeCache"},{"location":"xxprintcodecache/#-xx-printcodecache","text":"This Oracle HotSpot option prints the code cache memory usage when the application exits. This option is recognized by Eclipse OpenJ9\u2122 and provided for compatibility.","title":"-XX:[+|-]PrintCodeCache"},{"location":"xxprintcodecache/#syntax","text":"-XX:[+|-]PrintCodeCache Setting Effect Default -XX:+PrintCodeCache Enable -XX:-PrintCodeCache Disable yes As discussed in the Oracle documentation, the code cache usage can be shown when the application exits, by specifying \u2013XX:+PrintCodeCache on the Java launcher command line. The output looks similar to the following: CodeCache: size=262144Kb used=454Kb max_used=457Kb free=261690Kb size : The maximum size of the code cache. used : The amount of code cache memory actually in use. max_used : The high water mark for code cache usage. free : size minus used .","title":"Syntax"},{"location":"xxprintflagsfinal/","text":"-XX:[+|-]PrintFlagsFinal When enabled, this option outputs the values of a subset of configuration parameters in a format compatible with that produced by HotSpot. The parameters currently output are those expected by various software projects and packages. Syntax -XX:[+|-]PrintFlagsFinal Setting Effect Default -XX:+PrintFlagsFinal Enable -XX:-PrintFlagsFinal Disable yes Example Here is an example of typical output from -XX:+PrintFlagsFinal : [Global flags] size_t MaxHeapSize = 4294967296 {product} {ergonomic} uint64_t MaxDirectMemorySize = 3758096384 {product} {ergonomic}","title":"-XX:[+|-]PrintFlagsFinal"},{"location":"xxprintflagsfinal/#-xx-printflagsfinal","text":"When enabled, this option outputs the values of a subset of configuration parameters in a format compatible with that produced by HotSpot. The parameters currently output are those expected by various software projects and packages.","title":"-XX:[+|-]PrintFlagsFinal"},{"location":"xxprintflagsfinal/#syntax","text":"-XX:[+|-]PrintFlagsFinal Setting Effect Default -XX:+PrintFlagsFinal Enable -XX:-PrintFlagsFinal Disable yes","title":"Syntax"},{"location":"xxprintflagsfinal/#example","text":"Here is an example of typical output from -XX:+PrintFlagsFinal : [Global flags] size_t MaxHeapSize = 4294967296 {product} {ergonomic} uint64_t MaxDirectMemorySize = 3758096384 {product} {ergonomic}","title":"Example"},{"location":"xxreadipinfoforras/","text":"-XX:[+|-]ReadIPInfoForRAS Use this command-line option to enable and disable network queries from being used to determine the host name and IP address for RAS (reliability, availability, and serviceability) troubleshooting purposes. Syntax -XX:[+|-]ReadIPInfoForRAS Setting Effect Default -XX:+ReadIPInfoForRAS Enable yes -XX:-ReadIPInfoForRAS Disable Eclipse OpenJ9\u2122 captures the host name and IP address by default, for use in diagnosing problems. But if a nameserver cannot be contacted when a network query is made, the program will wait until the resolver times out. You can avoid this situation by using the -XX:-ReadIPInfoForRAS command-line option to prevent the query from being performed.","title":"-XX:[+|-]ReadIPInfoForRAS"},{"location":"xxreadipinfoforras/#-xx-readipinfoforras","text":"Use this command-line option to enable and disable network queries from being used to determine the host name and IP address for RAS (reliability, availability, and serviceability) troubleshooting purposes.","title":"-XX:[+|-]ReadIPInfoForRAS"},{"location":"xxreadipinfoforras/#syntax","text":"-XX:[+|-]ReadIPInfoForRAS Setting Effect Default -XX:+ReadIPInfoForRAS Enable yes -XX:-ReadIPInfoForRAS Disable Eclipse OpenJ9\u2122 captures the host name and IP address by default, for use in diagnosing problems. But if a nameserver cannot be contacted when a network query is made, the program will wait until the resolver times out. You can avoid this situation by using the -XX:-ReadIPInfoForRAS command-line option to prevent the query from being performed.","title":"Syntax"},{"location":"xxreducecpumonitoroverhead/","text":"-XX:[+|-]ReduceCPUMonitorOverhead (AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) This option relates to the CPU usage of thread categories that can be obtained with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. This option affects the way that the VM records the amount of CPU usage of non-Garbage Collection (GC) threads that do work on behalf of GC. Most GC policies require non-GC threads to do some GC housekeeping work in proportion to the amount of memory allocation that they do. Ideally the exact amount of CPU time that the thread spends doing this housekeeping work should be accounted for in the GC thread category. However there is an overhead that is associated with maintaining the CPU usage data in the correct thread category. Restriction: This option is not supported on z/OS\u00ae. If you attempt to use this option, the following message is generated: JVMJ9VM145E -XX:-ReduceCPUMonitorOverhead is unsupported on z/OS. Error: Could not create the Java Virtual Machine. Syntax -XX:[+|-]ReduceCPUMonitorOverhead Setting Effect Default -XX:+ReduceCPUMonitorOverhead Enable yes -XX:-ReduceCPUMonitorOverhead Disable When you enable this option, the VM does not maintain information on the amount of CPU usage that non-GC threads spend in doing work on behalf of GC. If you set -XX:-ReduceCPUMonitorOverhead , the Eclipse OpenJ9\u2122 VM monitors the amount of GC work that a non-GC thread does and accounts for it in the GC category. This information is made available in the com.ibm.lang.management.JvmCpuMonitorMXBean . Setting this option results in a small increase in application startup time, which varies according to platform. See also -XX:[+|-]EnableCPUMonitor","title":"-XX:[+|-]ReduceCPUMonitorOverhead"},{"location":"xxreducecpumonitoroverhead/#-xx-reducecpumonitoroverhead","text":"(AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) This option relates to the CPU usage of thread categories that can be obtained with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. This option affects the way that the VM records the amount of CPU usage of non-Garbage Collection (GC) threads that do work on behalf of GC. Most GC policies require non-GC threads to do some GC housekeeping work in proportion to the amount of memory allocation that they do. Ideally the exact amount of CPU time that the thread spends doing this housekeeping work should be accounted for in the GC thread category. However there is an overhead that is associated with maintaining the CPU usage data in the correct thread category. Restriction: This option is not supported on z/OS\u00ae. If you attempt to use this option, the following message is generated: JVMJ9VM145E -XX:-ReduceCPUMonitorOverhead is unsupported on z/OS. Error: Could not create the Java Virtual Machine.","title":"-XX:[+|-]ReduceCPUMonitorOverhead"},{"location":"xxreducecpumonitoroverhead/#syntax","text":"-XX:[+|-]ReduceCPUMonitorOverhead Setting Effect Default -XX:+ReduceCPUMonitorOverhead Enable yes -XX:-ReduceCPUMonitorOverhead Disable When you enable this option, the VM does not maintain information on the amount of CPU usage that non-GC threads spend in doing work on behalf of GC. If you set -XX:-ReduceCPUMonitorOverhead , the Eclipse OpenJ9\u2122 VM monitors the amount of GC work that a non-GC thread does and accounts for it in the GC category. This information is made available in the com.ibm.lang.management.JvmCpuMonitorMXBean . Setting this option results in a small increase in application startup time, which varies according to platform.","title":"Syntax"},{"location":"xxreducecpumonitoroverhead/#see-also","text":"-XX:[+|-]EnableCPUMonitor","title":"See also"},{"location":"xxrequirejitserver/","text":"-XX:[+|-]RequireJITServer When you enable this option, the JITServer client crashes with an assert if it detects that a JITServer server is unavailable. Syntax -XX:[+|-]RequireJITServer Setting Effect Default -XX:+RequireJITServer Enable -XX:-RequireJITServer Disable yes Explanation This option is for debugging purposes only. When this option is disabled, a server crash forces the client to perform compilations locally. You might want to enable this option if you are running a test suite with JITServer enabled, so that a test fails if the server crashes, instead of switching to local compilations and hiding the failure. See also JITServer technology","title":"-XX:[+|-]RequireJITServer"},{"location":"xxrequirejitserver/#-xx-requirejitserver","text":"When you enable this option, the JITServer client crashes with an assert if it detects that a JITServer server is unavailable.","title":"-XX:[+|-]RequireJITServer"},{"location":"xxrequirejitserver/#syntax","text":"-XX:[+|-]RequireJITServer Setting Effect Default -XX:+RequireJITServer Enable -XX:-RequireJITServer Disable yes","title":"Syntax"},{"location":"xxrequirejitserver/#explanation","text":"This option is for debugging purposes only. When this option is disabled, a server crash forces the client to perform compilations locally. You might want to enable this option if you are running a test suite with JITServer enabled, so that a test fails if the server crashes, instead of switching to local compilations and hiding the failure.","title":"Explanation"},{"location":"xxrequirejitserver/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxruntimeinstrumentation/","text":"-XX:[+|-]RuntimeInstrumentation (AIX\u00ae, Linux\u00ae, and z/OS\u00ae only) This option controls the use of the Runtime Instrumentation (RI) facility in the virtual machines that support it. The RI facility is a feature that is available in POWER8\u00ae, zEC12, and later processors that offers hardware support for collecting profiling information at run time. The process uses minimal resources. The use of the RI facility is not enabled by default. Syntax -XX:[+|-]RuntimeInstrumentation Setting Effect Default -XX:+RuntimeInstrumentation Enable -XX:-RuntimeInstrumentation Disable yes Note: On Linux, the RI facility on Power 8 and later processors uses the Performance Monitoring Unit (PMU) inside the processor. However, the PMU is also used by system profilers like oprofile or perf . Due to the current Linux kernel implementation, a user cannot reliably profile a Java\u2122 application when RI is enabled. Although this limitation might be addressed in future Linux kernels, for reliable profiling on Power systems that use Linux, the -XX:-RuntimeInstrumentation option must be used.","title":"-XX:[+|-]RuntimeInstrumentation"},{"location":"xxruntimeinstrumentation/#-xx-runtimeinstrumentation","text":"(AIX\u00ae, Linux\u00ae, and z/OS\u00ae only) This option controls the use of the Runtime Instrumentation (RI) facility in the virtual machines that support it. The RI facility is a feature that is available in POWER8\u00ae, zEC12, and later processors that offers hardware support for collecting profiling information at run time. The process uses minimal resources. The use of the RI facility is not enabled by default.","title":"-XX:[+|-]RuntimeInstrumentation"},{"location":"xxruntimeinstrumentation/#syntax","text":"-XX:[+|-]RuntimeInstrumentation Setting Effect Default -XX:+RuntimeInstrumentation Enable -XX:-RuntimeInstrumentation Disable yes Note: On Linux, the RI facility on Power 8 and later processors uses the Performance Monitoring Unit (PMU) inside the processor. However, the PMU is also used by system profilers like oprofile or perf . Due to the current Linux kernel implementation, a user cannot reliably profile a Java\u2122 application when RI is enabled. Although this limitation might be addressed in future Linux kernels, for reliable profiling on Power systems that use Linux, the -XX:-RuntimeInstrumentation option must be used.","title":"Syntax"},{"location":"xxsethwprefetch/","text":"-XXsetHWPrefetch (AIX\u00ae only) This option enables or disables hardware prefetch. Hardware prefetch can improve the performance of applications by prefetching memory. However, because of the workload characteristics of many Java\u2122 applications, prefetching often has an adverse effect on performance. Syntax -XXsetHWPrefetch=[none|os-default] Setting Effect Default none Disable yes os-default Enable The -XXsetHWPrefetch:none option disables hardware prefetch. Although you can disable hardware prefetch on AIX by issuing the command dscrctl -n -s 1 , this command disables hardware prefetch for all processes, and for all future processes, which might not be desirable in a mixed workload environment. The -XXsetHWPrefetch:none option allows hardware prefetch to be disabled for individual VMs. To enable hardware prefetch with the default value for the operating system, specify -XXsetHWPrefetch:os-default . Use this option only for applications that can obtain a performance gain from hardware prefetch.","title":"-XXsetHWPrefetch"},{"location":"xxsethwprefetch/#-xxsethwprefetch","text":"(AIX\u00ae only) This option enables or disables hardware prefetch. Hardware prefetch can improve the performance of applications by prefetching memory. However, because of the workload characteristics of many Java\u2122 applications, prefetching often has an adverse effect on performance.","title":"-XXsetHWPrefetch"},{"location":"xxsethwprefetch/#syntax","text":"-XXsetHWPrefetch=[none|os-default] Setting Effect Default none Disable yes os-default Enable The -XXsetHWPrefetch:none option disables hardware prefetch. Although you can disable hardware prefetch on AIX by issuing the command dscrctl -n -s 1 , this command disables hardware prefetch for all processes, and for all future processes, which might not be desirable in a mixed workload environment. The -XXsetHWPrefetch:none option allows hardware prefetch to be disabled for individual VMs. To enable hardware prefetch with the default value for the operating system, specify -XXsetHWPrefetch:os-default . Use this option only for applications that can obtain a performance gain from hardware prefetch.","title":"Syntax"},{"location":"xxshareanonymousclasses/","text":"-XX:[+|-]ShareAnonymousClasses This option enables and disables the storage of VM anonymous classes, those created by Unsafe.defineAnonymousClass , in the shared classes cache. In OpenJDK 15 and later versions, this option also enables and disables the storage of hidden classes in the shared classes cache. The option is enabled by default, which means that anonymous classes (and hidden classes, in OpenJDK 15 and later) are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance. Syntax -XX:[+|-]ShareAnonymousClasses Setting Effect Default -XX:+ShareAnonymousClasses Enable yes -XX:-ShareAnonymousClasses Disable See also AOT compiler Introduction to class data sharing -Xshareclasses -XX:[+|-]ShareUnsafeClasses","title":"-XX:[+|-]ShareAnonymousClasses"},{"location":"xxshareanonymousclasses/#-xx-shareanonymousclasses","text":"This option enables and disables the storage of VM anonymous classes, those created by Unsafe.defineAnonymousClass , in the shared classes cache. In OpenJDK 15 and later versions, this option also enables and disables the storage of hidden classes in the shared classes cache. The option is enabled by default, which means that anonymous classes (and hidden classes, in OpenJDK 15 and later) are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance.","title":"-XX:[+|-]ShareAnonymousClasses"},{"location":"xxshareanonymousclasses/#syntax","text":"-XX:[+|-]ShareAnonymousClasses Setting Effect Default -XX:+ShareAnonymousClasses Enable yes -XX:-ShareAnonymousClasses Disable","title":"Syntax"},{"location":"xxshareanonymousclasses/#see-also","text":"AOT compiler Introduction to class data sharing -Xshareclasses -XX:[+|-]ShareUnsafeClasses","title":"See also"},{"location":"xxshareclassesenablebci/","text":"-XX:ShareClassesDisableBCI / -XX:ShareClassesEnableBCI The option -Xshareclasses:enableBCI improves startup performance without using a modification context, when using JVMTI class modification. This suboption allows classes loaded from the shared cache to be modified using a JVMTI ClassFileLoadHook , or a java.lang.instrument agent, and prevents modified classes being stored in the shared classes cache. You can turn off this option by specifying -XX:ShareClassesDisableBCI when you start your Java\u2122 application. Syntax -XX:ShareClassesDisableBCI|ShareClassesEnableBCI Setting Effect Default -XX:ShareClassesDisableBCI Disable -XX:ShareClassesEnableBCI Enable yes These options are equivalent to -Xshareclasses:disableBCI and -Xshareclasses:enableBCI . For more information, see -Xshareclasses . See also Support for bytecode instrumentation","title":"-XX:ShareClassesEnableBCI"},{"location":"xxshareclassesenablebci/#-xxshareclassesdisablebci-xxshareclassesenablebci","text":"The option -Xshareclasses:enableBCI improves startup performance without using a modification context, when using JVMTI class modification. This suboption allows classes loaded from the shared cache to be modified using a JVMTI ClassFileLoadHook , or a java.lang.instrument agent, and prevents modified classes being stored in the shared classes cache. You can turn off this option by specifying -XX:ShareClassesDisableBCI when you start your Java\u2122 application.","title":"-XX:ShareClassesDisableBCI /  -XX:ShareClassesEnableBCI"},{"location":"xxshareclassesenablebci/#syntax","text":"-XX:ShareClassesDisableBCI|ShareClassesEnableBCI Setting Effect Default -XX:ShareClassesDisableBCI Disable -XX:ShareClassesEnableBCI Enable yes These options are equivalent to -Xshareclasses:disableBCI and -Xshareclasses:enableBCI . For more information, see -Xshareclasses .","title":"Syntax"},{"location":"xxshareclassesenablebci/#see-also","text":"Support for bytecode instrumentation","title":"See also"},{"location":"xxsharedcachehardlimit/","text":"-XX:SharedCacheHardLimit Specifies the size for a new shared classes cache. Use this option together with the -Xscmx option to set actual and soft maximum size limits respectively. Syntax -XX:SharedCacheHardLimit=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] See Using -X command-line options for more information about the <size> parameter. When you use this option with the -Xscmx option, the -Xscmx option sets the soft maximum size, and the -XX:SharedCacheHardLimit option sets the actual size, of a new shared classes cache. For more information, see -Xscmx . If you use this option without the -Xscmx option, the behavior is the same as using the -Xscmx option by itself; both options set the actual size of the shared classes cache. For more information about cache sizes, see Cache size limits . Example The following settings, when used together, set the soft maximum size of the shared classes cache to 16 MB and the actual maximum cache size to 64 MB. -XX:SharedCacheHardLimit=64m -Xscmx16m See also -Xscmx","title":"-XX:SharedCacheHardLimit"},{"location":"xxsharedcachehardlimit/#-xxsharedcachehardlimit","text":"Specifies the size for a new shared classes cache. Use this option together with the -Xscmx option to set actual and soft maximum size limits respectively.","title":"-XX:SharedCacheHardLimit"},{"location":"xxsharedcachehardlimit/#syntax","text":"-XX:SharedCacheHardLimit=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] See Using -X command-line options for more information about the <size> parameter. When you use this option with the -Xscmx option, the -Xscmx option sets the soft maximum size, and the -XX:SharedCacheHardLimit option sets the actual size, of a new shared classes cache. For more information, see -Xscmx . If you use this option without the -Xscmx option, the behavior is the same as using the -Xscmx option by itself; both options set the actual size of the shared classes cache. For more information about cache sizes, see Cache size limits .","title":"Syntax"},{"location":"xxsharedcachehardlimit/#example","text":"The following settings, when used together, set the soft maximum size of the shared classes cache to 16 MB and the actual maximum cache size to 64 MB. -XX:SharedCacheHardLimit=64m -Xscmx16m","title":"Example"},{"location":"xxsharedcachehardlimit/#see-also","text":"-Xscmx","title":"See also"},{"location":"xxshareunsafeclasses/","text":"-XX:[+|-]ShareUnsafeClasses This option enables and disables the storage of VM classes created through Unsafe.defineClass in the shared classes cache. The option is enabled by default, which means that unsafe classes are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance. Syntax -XX:[+|-]ShareUnsafeClasses Setting Effect Default -XX:+ShareUnsafeClasses Enable yes -XX:-ShareUnsafeClasses Disable See also AOT compiler Introduction to class data sharing -Xshareclasses -XX:[+|-]ShareAnonymousClasses","title":"-XX:[+|-]ShareUnsafeClasses"},{"location":"xxshareunsafeclasses/#-xx-shareunsafeclasses","text":"This option enables and disables the storage of VM classes created through Unsafe.defineClass in the shared classes cache. The option is enabled by default, which means that unsafe classes are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance.","title":"-XX:[+|-]ShareUnsafeClasses"},{"location":"xxshareunsafeclasses/#syntax","text":"-XX:[+|-]ShareUnsafeClasses Setting Effect Default -XX:+ShareUnsafeClasses Enable yes -XX:-ShareUnsafeClasses Disable","title":"Syntax"},{"location":"xxshareunsafeclasses/#see-also","text":"AOT compiler Introduction to class data sharing -Xshareclasses -XX:[+|-]ShareAnonymousClasses","title":"See also"},{"location":"xxshowhiddenframes/","text":"-XX:[+|-]ShowHiddenFrames This reimplementation of the Oracle HotSpot diagonostic option enables or disables the display of generated hidden MethodHandle frames in a stack trace. This option doesn't affect the contents of dump files. Unlike the HotSpot implementation, this option doesn't require the +UnlockDiagnosticVMOptions option. Syntax -XX:[+|-]ShowHiddenFrames Setting Effect Default -XX:+ShowHiddenFrames Enable -XX:-ShowHiddenFrames Disable yes When disabled, this option causes the VM to hide generated hidden MethodHandle frames in a stacktrace.","title":"-XX:[+|-]ShowHiddenFrames"},{"location":"xxshowhiddenframes/#-xx-showhiddenframes","text":"This reimplementation of the Oracle HotSpot diagonostic option enables or disables the display of generated hidden MethodHandle frames in a stack trace. This option doesn't affect the contents of dump files. Unlike the HotSpot implementation, this option doesn't require the +UnlockDiagnosticVMOptions option.","title":"-XX:[+|-]ShowHiddenFrames"},{"location":"xxshowhiddenframes/#syntax","text":"-XX:[+|-]ShowHiddenFrames Setting Effect Default -XX:+ShowHiddenFrames Enable -XX:-ShowHiddenFrames Disable yes When disabled, this option causes the VM to hide generated hidden MethodHandle frames in a stacktrace.","title":"Syntax"},{"location":"xxshownativestacksymbols/","text":"-XX:[+|-]ShowNativeStackSymbols This option controls whether Java\u00ae dumps show the names of functions in native call stacks. Syntax -XX:-ShowNativeStackSymbols -XX:+ShowNativeStackSymbols=<value> Setting Value Effect Default -XX:-ShowNativeStackSymbols Don't show native stack symbols, not even in response to a signal, such as a fault signal -XX:+ShowNativeStackSymbols basic Show all the available native stack symbols for a signaled or faulting thread, but only easily acquired native stack symbols for other threads yes -XX:+ShowNativeStackSymbols all Show all the available native stack symbols for all threads Explanation Java dumps take longer to produce when the native stack symbols are included. If your Java application has a lot of threads, you might get an incomplete Java dump. You can avoid this situation by reducing the number of native stack symbols in the Java dump or by omitting them altogether.","title":"-XX:[+|-]ShowNativeStackSymbols"},{"location":"xxshownativestacksymbols/#-xx-shownativestacksymbols","text":"This option controls whether Java\u00ae dumps show the names of functions in native call stacks.","title":"-XX:[+|-]ShowNativeStackSymbols"},{"location":"xxshownativestacksymbols/#syntax","text":"-XX:-ShowNativeStackSymbols -XX:+ShowNativeStackSymbols=<value> Setting Value Effect Default -XX:-ShowNativeStackSymbols Don't show native stack symbols, not even in response to a signal, such as a fault signal -XX:+ShowNativeStackSymbols basic Show all the available native stack symbols for a signaled or faulting thread, but only easily acquired native stack symbols for other threads yes -XX:+ShowNativeStackSymbols all Show all the available native stack symbols for all threads","title":"Syntax"},{"location":"xxshownativestacksymbols/#explanation","text":"Java dumps take longer to produce when the native stack symbols are included. If your Java application has a lot of threads, you might get an incomplete Java dump. You can avoid this situation by reducing the number of native stack symbols in the Java dump or by omitting them altogether.","title":"Explanation"},{"location":"xxstacktraceinthrowable/","text":"-XX:-StackTraceInThrowable This option removes stack traces from exceptions. Syntax -XX:-StackTraceInThrowable Setting Effect Default -XX:-StackTraceInThrowable Disable No While stack traces are included in exceptions by default, recording them can have a negative impact on performance. Use this option if you want to remove stack traces, although this might cause difficulties with problem determination. When this option is enabled, Throwable.getStackTrace() returns an empty array and the stack trace is displayed when an uncaught exception occurs. Thread.getStackTrace() and Thread.getAllStackTraces() are not affected by this option.","title":"-XX:-StackTraceInThrowable"},{"location":"xxstacktraceinthrowable/#-xx-stacktraceinthrowable","text":"This option removes stack traces from exceptions.","title":"-XX:-StackTraceInThrowable"},{"location":"xxstacktraceinthrowable/#syntax","text":"-XX:-StackTraceInThrowable Setting Effect Default -XX:-StackTraceInThrowable Disable No While stack traces are included in exceptions by default, recording them can have a negative impact on performance. Use this option if you want to remove stack traces, although this might cause difficulties with problem determination. When this option is enabled, Throwable.getStackTrace() returns an empty array and the stack trace is displayed when an uncaught exception occurs. Thread.getStackTrace() and Thread.getAllStackTraces() are not affected by this option.","title":"Syntax"},{"location":"xxtransparenthugepage/","text":"-XX:[+|-]TransparentHugePage (Linux\u00ae systems only: x86, POWER\u00ae, and IBM Z\u00ae) If Transparent Huge Pages (THP) is set to madvise on your system, this option, when enabled, promotes all memory allocated to huge pages. On systems without THP, or if THP is set to always or never on your system, this option is ignored. When transparent huge pages are used, your application footprint might increase. Syntax Setting Effect Default -XX:+TransparentHugePage Enable yes -XX:-TransparentHugePage Disable","title":"-XX:[+|-]TransparentHugePage"},{"location":"xxtransparenthugepage/#-xx-transparenthugepage","text":"(Linux\u00ae systems only: x86, POWER\u00ae, and IBM Z\u00ae) If Transparent Huge Pages (THP) is set to madvise on your system, this option, when enabled, promotes all memory allocated to huge pages. On systems without THP, or if THP is set to always or never on your system, this option is ignored. When transparent huge pages are used, your application footprint might increase.","title":"-XX:[+|-]TransparentHugePage"},{"location":"xxtransparenthugepage/#syntax","text":"Setting Effect Default -XX:+TransparentHugePage Enable yes -XX:-TransparentHugePage Disable","title":"Syntax"},{"location":"xxusecompressedoops/","text":"-XX:[+|-]UseCompressedOops (64-bit only) This Oracle HotSpot option enables or disables compressed references in 64-bit JVMs. The option is recognized by the Eclipse OpenJ9\u2122 VM and is provided to help when porting applications from the HotSpot JVM to the OpenJ9 VM. This option might not be supported in subsequent releases. Syntax -XX:[+|-]UseCompressedOops Setting Effect Default -XX:+UseCompressedOops Enable -XX:-UseCompressedOops Disable The -XX:+UseCompressedOops option is similar to specifying -Xcompressedrefs . Compressed references are used by default when the maximum memory size for an application is set above a platform-specific value. For more information, see -Xcompressedrefs .","title":"-XX:[+|-]UseCompressedOops"},{"location":"xxusecompressedoops/#-xx-usecompressedoops","text":"(64-bit only) This Oracle HotSpot option enables or disables compressed references in 64-bit JVMs. The option is recognized by the Eclipse OpenJ9\u2122 VM and is provided to help when porting applications from the HotSpot JVM to the OpenJ9 VM. This option might not be supported in subsequent releases.","title":"-XX:[+|-]UseCompressedOops"},{"location":"xxusecompressedoops/#syntax","text":"-XX:[+|-]UseCompressedOops Setting Effect Default -XX:+UseCompressedOops Enable -XX:-UseCompressedOops Disable The -XX:+UseCompressedOops option is similar to specifying -Xcompressedrefs . Compressed references are used by default when the maximum memory size for an application is set above a platform-specific value. For more information, see -Xcompressedrefs .","title":"Syntax"},{"location":"xxusecontainersupport/","text":"-XX:[+|-]UseContainerSupport (Linux\u00ae only) If your application is running in a container that imposes a memory limit, the VM allocates a larger fraction of memory to the Java heap. To turn off this behavior, set the -XX:-UseContainerSupport option on the command line. Syntax -XX:[+|-]UseContainerSupport Setting Effect Default -XX:-UseContainerSupport Disable -XX:+UseContainerSupport Enable yes When using container technology, applications are typically run on their own and do not need to compete for memory. The Eclipse OpenJ9\u2122 VM detects when it is running inside a container that imposes a memory limit, and adjusts the maximum Java heap size appropriately. The following table shows the values that are used when -XX:+UseContainerSupport is set: Container memory limit <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512 MB Greater than 2 GB 75% <size> The default heap size is capped at 25 GB, which is the limit of heap size for 3-bit shift of compressed references (see -Xcompressedrefs ), to prevent silent switching to 4-bit shift of compressed references, which has possible performance penalties. You can use the -Xmx option or the -XX:MaxRAMPercentage option to overwrite the 25 GB limit. The default heap size for containers takes affect only when the following conditions are met: The application is running in a container environment. The memory limit for the container is set. The -XX:+UseContainerSupport option is set, which is the default behavior. To prevent the VM adjusting the maximum heap size when running in a container, set -XX:-UseContainerSupport . When -XX:MaxRAMPercentage / -XX:InitialRAMPercentage are used with -XX:+UseContainerSupport , the corresponding heap setting is determined based on the memory limit of the container. For example, to set the maximum heap size to 80% of the container memory, specify the following options: -XX:+UseContainerSupport -XX:MaxRAMPercentage=80 Note: If you set a value for -Xms , the -XX:InitialRAMPercentage option is ignored. If you set a value for -Xmx , the -XX:MaxRAMPercentage option is ignored.","title":"-XX:[+|-]UseContainerSupport"},{"location":"xxusecontainersupport/#-xx-usecontainersupport","text":"(Linux\u00ae only) If your application is running in a container that imposes a memory limit, the VM allocates a larger fraction of memory to the Java heap. To turn off this behavior, set the -XX:-UseContainerSupport option on the command line.","title":"-XX:[+|-]UseContainerSupport"},{"location":"xxusecontainersupport/#syntax","text":"-XX:[+|-]UseContainerSupport Setting Effect Default -XX:-UseContainerSupport Disable -XX:+UseContainerSupport Enable yes When using container technology, applications are typically run on their own and do not need to compete for memory. The Eclipse OpenJ9\u2122 VM detects when it is running inside a container that imposes a memory limit, and adjusts the maximum Java heap size appropriately. The following table shows the values that are used when -XX:+UseContainerSupport is set: Container memory limit <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512 MB Greater than 2 GB 75% <size> The default heap size is capped at 25 GB, which is the limit of heap size for 3-bit shift of compressed references (see -Xcompressedrefs ), to prevent silent switching to 4-bit shift of compressed references, which has possible performance penalties. You can use the -Xmx option or the -XX:MaxRAMPercentage option to overwrite the 25 GB limit. The default heap size for containers takes affect only when the following conditions are met: The application is running in a container environment. The memory limit for the container is set. The -XX:+UseContainerSupport option is set, which is the default behavior. To prevent the VM adjusting the maximum heap size when running in a container, set -XX:-UseContainerSupport . When -XX:MaxRAMPercentage / -XX:InitialRAMPercentage are used with -XX:+UseContainerSupport , the corresponding heap setting is determined based on the memory limit of the container. For example, to set the maximum heap size to 80% of the container memory, specify the following options: -XX:+UseContainerSupport -XX:MaxRAMPercentage=80 Note: If you set a value for -Xms , the -XX:InitialRAMPercentage option is ignored. If you set a value for -Xmx , the -XX:MaxRAMPercentage option is ignored.","title":"Syntax"},{"location":"xxusegcstartuphints/","text":"-XX:[+|-]UseGCStartupHints When this option is enabled, the VM calculates, over several application restarts, an appropriate startup heap size for your application. You can therefore use this option instead of calculating and setting an -Xms value yourself. Setting an initial size for the heap that is larger than the default helps to avoid frequent garbage collections during the startup phase of an application. Syntax -XX:[+|-]UseGCStartupHints Setting Effect Default -XX:+UseGCStartupHints Enable yes -XX:-UseGCStartupHints Disable When enabled, the VM records the heap size when a startup complete event occurs, storing the value into the shared classes cache. On subsequent restarts, the garbage collector (GC) reads this value early in startup processing and expands the heap to an appropriate value. For accuracy and stability, averages are taken over a few restarts to stabilize the value used. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. You can check the value used by the garbage collector for heap expansion by inspecting verbose GC output. The following example shows heap expansion based on hints from the previous run when using the gencon policy: <heap-resize id=\"2\" type=\"expand\" space=\"nursery\" amount=\"205258752\" count=\"1\" timems=\"0.328\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.021\" /> <heap-resize id=\"3\" type=\"expand\" space=\"tenure\" amount=\"692649984\" count=\"1\" timems=\"0.326\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.022\" /> The final value stored to the shared cache is not recorded in the verbose GC output. Notes: When enabled, this option overrides any initial heap size that is specified on the command line, for example by using the -Xms option. Because the shared classes cache is used to store heap size information, this option does not work if class data sharing ( -Xshareclasses ) is disabled. Restriction: This feature is not currently available with the Balanced GC policy.","title":"-XX:[+|-]UseGCStartupHints"},{"location":"xxusegcstartuphints/#-xx-usegcstartuphints","text":"When this option is enabled, the VM calculates, over several application restarts, an appropriate startup heap size for your application. You can therefore use this option instead of calculating and setting an -Xms value yourself. Setting an initial size for the heap that is larger than the default helps to avoid frequent garbage collections during the startup phase of an application.","title":"-XX:[+|-]UseGCStartupHints"},{"location":"xxusegcstartuphints/#syntax","text":"-XX:[+|-]UseGCStartupHints Setting Effect Default -XX:+UseGCStartupHints Enable yes -XX:-UseGCStartupHints Disable When enabled, the VM records the heap size when a startup complete event occurs, storing the value into the shared classes cache. On subsequent restarts, the garbage collector (GC) reads this value early in startup processing and expands the heap to an appropriate value. For accuracy and stability, averages are taken over a few restarts to stabilize the value used. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. You can check the value used by the garbage collector for heap expansion by inspecting verbose GC output. The following example shows heap expansion based on hints from the previous run when using the gencon policy: <heap-resize id=\"2\" type=\"expand\" space=\"nursery\" amount=\"205258752\" count=\"1\" timems=\"0.328\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.021\" /> <heap-resize id=\"3\" type=\"expand\" space=\"tenure\" amount=\"692649984\" count=\"1\" timems=\"0.326\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.022\" /> The final value stored to the shared cache is not recorded in the verbose GC output. Notes: When enabled, this option overrides any initial heap size that is specified on the command line, for example by using the -Xms option. Because the shared classes cache is used to store heap size information, this option does not work if class data sharing ( -Xshareclasses ) is disabled. Restriction: This feature is not currently available with the Balanced GC policy.","title":"Syntax"},{"location":"xxusejitserver/","text":"-XX:[+|-]UseJITServer This option starts the Eclipse OpenJ9\u2122 VM in JITServer client mode. Syntax -XX:[+|-]UseJITServer Setting Effect Default -XX:+UseJITServer Enable -XX:-UseJITServer Disable yes Explanation When you enable this option, the VM tries to connect to a server and send all JIT compilation requests to it. For more information, see JITServer Technology . You must specify this option for any other -XX:*JITServer* options to take effect. See also JITServer technology","title":"-XX:[+|-]UseJITServer"},{"location":"xxusejitserver/#-xx-usejitserver","text":"This option starts the Eclipse OpenJ9\u2122 VM in JITServer client mode.","title":"-XX:[+|-]UseJITServer"},{"location":"xxusejitserver/#syntax","text":"-XX:[+|-]UseJITServer Setting Effect Default -XX:+UseJITServer Enable -XX:-UseJITServer Disable yes","title":"Syntax"},{"location":"xxusejitserver/#explanation","text":"When you enable this option, the VM tries to connect to a server and send all JIT compilation requests to it. For more information, see JITServer Technology . You must specify this option for any other -XX:*JITServer* options to take effect.","title":"Explanation"},{"location":"xxusejitserver/#see-also","text":"JITServer technology","title":"See also"},{"location":"xxusenogc/","text":"-XX:[+|-]UseNoGC The -XX:+UseNoGC option enables a garbage collection policy that expands the Java object heap in the normal way until the limit is reached, but memory is not reclaimed through garbage collection. Syntax -XX:[+|-]UseNoGC Setting Effect Default -XX:+UseNoGC Enable -XX:-UseNoGC Disable yes Explanation This policy can be useful for test purposes and for short-lived applications. When the limit is reached an OutOfMemory error is generated and the VM shuts down. The -XX:-UseNoGC option turns off a previously enabled -XX:+UseNoGC option. This policy can also be enabled with the -Xgcpolicy:nogc option. See -Xgcpolicy:nogc for more details about this policy and when it is appropriate to use it.","title":"-XX:[+|-]UseNoGC"},{"location":"xxusenogc/#-xx-usenogc","text":"The -XX:+UseNoGC option enables a garbage collection policy that expands the Java object heap in the normal way until the limit is reached, but memory is not reclaimed through garbage collection.","title":"-XX:[+|-]UseNoGC"},{"location":"xxusenogc/#syntax","text":"-XX:[+|-]UseNoGC Setting Effect Default -XX:+UseNoGC Enable -XX:-UseNoGC Disable yes","title":"Syntax"},{"location":"xxusenogc/#explanation","text":"This policy can be useful for test purposes and for short-lived applications. When the limit is reached an OutOfMemory error is generated and the VM shuts down. The -XX:-UseNoGC option turns off a previously enabled -XX:+UseNoGC option. This policy can also be enabled with the -Xgcpolicy:nogc option. See -Xgcpolicy:nogc for more details about this policy and when it is appropriate to use it.","title":"Explanation"},{"location":"xxutfcache/","text":"-XX:[+|-]UTFCache This option enables or disables the UTF to String cache used to enhance reflection performance. Syntax -XX:[+|-]UTFCache Setting Effect Default -XX:+UTFCache Enable yes -XX:-UTFCache Disable The option, -XX:+UTFCache , causes the VM to cache the conversion of UTF8 data to java String objects during reflection. This is the default option. When specifying the -XX:-UTFCache option, the VM does not performing this caching.","title":"-XX:[+|-]UTFCache"},{"location":"xxutfcache/#-xx-utfcache","text":"This option enables or disables the UTF to String cache used to enhance reflection performance.","title":"-XX:[+|-]UTFCache"},{"location":"xxutfcache/#syntax","text":"-XX:[+|-]UTFCache Setting Effect Default -XX:+UTFCache Enable yes -XX:-UTFCache Disable The option, -XX:+UTFCache , causes the VM to cache the conversion of UTF8 data to java String objects during reflection. This is the default option. When specifying the -XX:-UTFCache option, the VM does not performing this caching.","title":"Syntax"},{"location":"xxverboseverification/","text":"-XX:[+|-]VerboseVerification You can use this option to control the output of verbose diagnostic data that relates to verification. The Oracle documentation to support this option is no longer available, because it is no longer used by the HotSpot VM. An explanation is provided here. Syntax -XX:[+|-]VerboseVerification Setting Effect Default -XX:-VerboseVerification Disable yes -XX:+VerboseVerification Enable Use -XX:-VerboseVerification to enable the output of verbose diagnostic data to stderr that is generated during verification from the class file StackMapTable attribute. The data provides extra contextual information about bytecode verification, which helps diagnose bytecode or stackmap deficiencies in the field. Class files that have StackMapTable attributes (that is, class files that conform to version 50.0 or later of the class file format specification), are introduced in Java\u2122 V6. Class files with StackMapTable attributes are marked as new format in the verbose output, as shown in the example. Class files without the StackMapTable attributes are marked as old format . The StackMapTable diagnostic information is available only to classes verified with the new format. Here is an example of StackMapTable diagnostic output: Verifying class java.example.ibm.com with new format Verifying method java.example.ibm.com.foo(Ljava/lang/String;Ljava/lang/Class;[Ljava/lang/String;Ljava/io/PrintStream;)I StackMapTable: frame_count = 3 table = { bci: @37 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/ThreadDeath' } bci: @42 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/Throwable' } bci: @79 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class', 'java/lang/Throwable' } stack: { } } End class verification for: java.example.ibm.com","title":"-XX:[+|-]VerboseVerification"},{"location":"xxverboseverification/#-xx-verboseverification","text":"You can use this option to control the output of verbose diagnostic data that relates to verification. The Oracle documentation to support this option is no longer available, because it is no longer used by the HotSpot VM. An explanation is provided here.","title":"-XX:[+|-]VerboseVerification"},{"location":"xxverboseverification/#syntax","text":"-XX:[+|-]VerboseVerification Setting Effect Default -XX:-VerboseVerification Disable yes -XX:+VerboseVerification Enable Use -XX:-VerboseVerification to enable the output of verbose diagnostic data to stderr that is generated during verification from the class file StackMapTable attribute. The data provides extra contextual information about bytecode verification, which helps diagnose bytecode or stackmap deficiencies in the field. Class files that have StackMapTable attributes (that is, class files that conform to version 50.0 or later of the class file format specification), are introduced in Java\u2122 V6. Class files with StackMapTable attributes are marked as new format in the verbose output, as shown in the example. Class files without the StackMapTable attributes are marked as old format . The StackMapTable diagnostic information is available only to classes verified with the new format. Here is an example of StackMapTable diagnostic output: Verifying class java.example.ibm.com with new format Verifying method java.example.ibm.com.foo(Ljava/lang/String;Ljava/lang/Class;[Ljava/lang/String;Ljava/io/PrintStream;)I StackMapTable: frame_count = 3 table = { bci: @37 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/ThreadDeath' } bci: @42 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/Throwable' } bci: @79 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class', 'java/lang/Throwable' } stack: { } } End class verification for: java.example.ibm.com","title":"Syntax"},{"location":"xxvmlockclassloader/","text":"-XX:[+|-]VMLockClassLoader This option affects synchronization on class loaders that are not parallel-capable class loaders, during class loading. Syntax -XX:[+|-]VMLockClassLoader Setting Effect Default -XX:+VMLockClassLoader Enable yes -XX:-VMLockClassLoader Disable The option, -XX:+VMLockClassLoader , causes the VM to force synchronization on a class loader that is not a parallel capable class loader during class loading. This action occurs even if the loadClass() method for that class loader is not synchronized. For information about parallel capable class loaders, see java.lang.ClassLoader.registerAsParallelCapable() . Note that this option might cause a deadlock if class loaders use non-hierarchical delegation. For example, setting the system property osgi.classloader.lock=classname with Equinox is known to cause a deadlock. This is the default option. When specifying the -XX:-VMLockClassLoader option, the VM does not force synchronization on a class loader during class loading. The class loader still conforms to class library synchronization, such as a synchronized loadClass() method.","title":"-XX:[+|-]VMLockClassLoader"},{"location":"xxvmlockclassloader/#-xx-vmlockclassloader","text":"This option affects synchronization on class loaders that are not parallel-capable class loaders, during class loading.","title":"-XX:[+|-]VMLockClassLoader"},{"location":"xxvmlockclassloader/#syntax","text":"-XX:[+|-]VMLockClassLoader Setting Effect Default -XX:+VMLockClassLoader Enable yes -XX:-VMLockClassLoader Disable The option, -XX:+VMLockClassLoader , causes the VM to force synchronization on a class loader that is not a parallel capable class loader during class loading. This action occurs even if the loadClass() method for that class loader is not synchronized. For information about parallel capable class loaders, see java.lang.ClassLoader.registerAsParallelCapable() . Note that this option might cause a deadlock if class loaders use non-hierarchical delegation. For example, setting the system property osgi.classloader.lock=classname with Equinox is known to cause a deadlock. This is the default option. When specifying the -XX:-VMLockClassLoader option, the VM does not force synchronization on a class loader during class loading. The class loader still conforms to class library synchronization, such as a synchronized loadClass() method.","title":"Syntax"},{"location":"xzero/","text":"-Xzero Enables reduction of the memory footprint of the Java\u2122 runtime environment when concurrently running multiple Java invocations. This option is deprecated and will be removed in a future release. This option can be used only with Java SE version 8 runtime environments. -Xzero might not be appropriate for all types of applications because it changes the implementation of java.util.ZipFile , which might cause extra memory usage. Syntax Setting Effect -Xzero:none Disable all sub options -Xzero:describe Prints the sub options in effect -Xzero:sharebootzip Enables the sharebootzip sub option -Xzero:nosharebootzip Disables the sharebootzip sub option The following parameters are no longer supported. The options are parsed but do nothing: Setting Effect -Xzero:j9zip Enables the j9zip sub option -Xzero:noj9zip Disables the j9zip sub option -Xzero:sharezip Enables the sharezip sub option -Xzero:nosharezip Disables the sharezip sub option","title":"-Xzero"},{"location":"xzero/#-xzero","text":"Enables reduction of the memory footprint of the Java\u2122 runtime environment when concurrently running multiple Java invocations. This option is deprecated and will be removed in a future release. This option can be used only with Java SE version 8 runtime environments. -Xzero might not be appropriate for all types of applications because it changes the implementation of java.util.ZipFile , which might cause extra memory usage.","title":"-Xzero"},{"location":"xzero/#syntax","text":"Setting Effect -Xzero:none Disable all sub options -Xzero:describe Prints the sub options in effect -Xzero:sharebootzip Enables the sharebootzip sub option -Xzero:nosharebootzip Disables the sharebootzip sub option The following parameters are no longer supported. The options are parsed but do nothing: Setting Effect -Xzero:j9zip Enables the j9zip sub option -Xzero:noj9zip Disables the j9zip sub option -Xzero:sharezip Enables the sharezip sub option -Xzero:nosharezip Disables the sharezip sub option","title":"Syntax"}]}