{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Eclipse OpenJ9 Welcome to the user documentation for the Eclipse OpenJ9 virtual machine (VM). This user documentation supports the configuration, tuning, and diagnosis of the OpenJ9 VM in an OpenJDK runtime. However, due to differences between the Java SE class libraries, specific options might apply only to one Java SE version. Icons are used to indicate where differences apply. For example: This sentence applies only to Java 8 binaries that include the OpenJ9 VM. Icons for LTS releases are this colour. This sentence applies only to Java 14 or later binaries that include the OpenJ9 VM. Icons for feature releases are this colour. To see which Java releases are LTS releases and which are feature releases, and for information about release cadence, supported platforms, and build environments, see Supported environments . Note: Documentation to support OpenJ9 is still under construction. The current content covers some high level information about OpenJ9 components together with the command-line options and environment variables that you can use to configure the VM when you start your application. We expect further content to be contributed over time. Because OpenJ9 was contributed to the Eclipse Foundation by IBM, this content contains some links to additional information that forms part of the IBM\u00ae SDK, Java\u2122 Technology Edition product documentation in IBM Knowledge Center. That content supplements the documentation here until a more complete set of user documentation is available. We welcome contributions to the user documentation. If you would like to get involved, please read our Contribution guidelines . If you spot any errors in the documentation, please raise an issue at our GitHub repository. Supported environments OpenJDK binaries that contain the OpenJ9 VM are supported on a range of hardware and operating systems. This range is expanding as work progresses at the Eclipse foundation. See the current list of supported environments for details. Note: This user guide contains information about configuring, tuning, and debugging OpenJ9 on the z/OS\u00ae platform. This content was contributed by IBM so that it is available when the work to create OpenJDK binaries for the z/OS platform is complete. Documentation for specific releases Several versions of the documentation are available, covering all releases of OpenJ9: Online documentation for the last release Online, in-progress documentation for the forthcoming release Downloads of earlier releases : to download a zip file, click the filename, then click Download . After downloading a .zip file, extract it, then open the index.html file in your browser. Useful links Eclipse OpenJ9 website home page Eclipse OpenJ9 GitHub repository Eclipse Foundation OpenJ9 project page Pre-built binaries from the AdoptOpenJDK project","title":"About the docs"},{"location":"#eclipse-openj9","text":"Welcome to the user documentation for the Eclipse OpenJ9 virtual machine (VM). This user documentation supports the configuration, tuning, and diagnosis of the OpenJ9 VM in an OpenJDK runtime. However, due to differences between the Java SE class libraries, specific options might apply only to one Java SE version. Icons are used to indicate where differences apply. For example: This sentence applies only to Java 8 binaries that include the OpenJ9 VM. Icons for LTS releases are this colour. This sentence applies only to Java 14 or later binaries that include the OpenJ9 VM. Icons for feature releases are this colour. To see which Java releases are LTS releases and which are feature releases, and for information about release cadence, supported platforms, and build environments, see Supported environments . Note: Documentation to support OpenJ9 is still under construction. The current content covers some high level information about OpenJ9 components together with the command-line options and environment variables that you can use to configure the VM when you start your application. We expect further content to be contributed over time. Because OpenJ9 was contributed to the Eclipse Foundation by IBM, this content contains some links to additional information that forms part of the IBM\u00ae SDK, Java\u2122 Technology Edition product documentation in IBM Knowledge Center. That content supplements the documentation here until a more complete set of user documentation is available. We welcome contributions to the user documentation. If you would like to get involved, please read our Contribution guidelines . If you spot any errors in the documentation, please raise an issue at our GitHub repository.","title":"Eclipse OpenJ9"},{"location":"#supported-environments","text":"OpenJDK binaries that contain the OpenJ9 VM are supported on a range of hardware and operating systems. This range is expanding as work progresses at the Eclipse foundation. See the current list of supported environments for details. Note: This user guide contains information about configuring, tuning, and debugging OpenJ9 on the z/OS\u00ae platform. This content was contributed by IBM so that it is available when the work to create OpenJDK binaries for the z/OS platform is complete.","title":"Supported environments"},{"location":"#documentation-for-specific-releases","text":"Several versions of the documentation are available, covering all releases of OpenJ9: Online documentation for the last release Online, in-progress documentation for the forthcoming release Downloads of earlier releases : to download a zip file, click the filename, then click Download . After downloading a .zip file, extract it, then open the index.html file in your browser.","title":"Documentation for specific releases"},{"location":"#useful-links","text":"Eclipse OpenJ9 website home page Eclipse OpenJ9 GitHub repository Eclipse Foundation OpenJ9 project page Pre-built binaries from the AdoptOpenJDK project","title":"Useful links"},{"location":"adoptopenjdk/","text":"AdoptOpenJDK builds The AdoptOpenJDK community project provide pre-built binaries of OpenJDK with OpenJ9, which have been rigorously tested to meet expected quality standards. Binaries for the latest release of Eclipse OpenJ9 can be obtained from the following links: OpenJDK8 with OpenJ9 OpenJDK11 with OpenJ9 OpenJDK14 with OpenJ9 Nightly builds of OpenJDK with OpenJ9 are also available from the project. Supported platforms The community develop and maintain a build and test infrastructure for the OpenJDK source across a broad range of platforms. For information about the platforms and minimum operating system levels supported for the builds, see the AdoptOpenJDK Platform support matrix . Installation pre-requisites If you obtain binaries from the AdoptOpenJDK community, the following pre-requisites are required: From Eclipse OpenJ9 release 0.13.0, OpenJDK binaries for Linux and AIX platforms from the AdoptOpenJDK community no longer bundle the OpenSSL cryptographic library. The library is expected to be found on the system path. If you want to use OpenSSL cryptographic acceleration, you must install OpenSSL 1.0.2 or 1.1.X on your system. If the library is not found on the system path, the in-built Java crytographic implementation is used instead, which performs less well. On Linux systems, the fontconfig.x86_64 package should be installed to avoid a NullPointerException error when the AWT font subsystem is initialized. Work is ongoing at the AdoptOpenJDK project to fix this issue for their OpenJDK binaries. From Eclipse OpenJ9 release 0.16.0 (OpenJDK 13) and release 0.17.0 (OpenJDK 8 and 11), CUDA is now enabled on Windows (x86-64) and Linux (x86-64 and IBM POWER LE) platforms, which allows you to offload certain Java application processing tasks to a general purpose graphics processing unit (GPU). To take advantage of this feature, your system must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0. Building your own binaries If you want to build your own binaries of OpenJDK with OpenJ9, a complete set of build instructions for several platforms can be found in the OpenJ9 GitHub repository .","title":"AdoptOpenJDK builds"},{"location":"adoptopenjdk/#adoptopenjdk-builds","text":"The AdoptOpenJDK community project provide pre-built binaries of OpenJDK with OpenJ9, which have been rigorously tested to meet expected quality standards. Binaries for the latest release of Eclipse OpenJ9 can be obtained from the following links: OpenJDK8 with OpenJ9 OpenJDK11 with OpenJ9 OpenJDK14 with OpenJ9 Nightly builds of OpenJDK with OpenJ9 are also available from the project.","title":"AdoptOpenJDK builds"},{"location":"adoptopenjdk/#supported-platforms","text":"The community develop and maintain a build and test infrastructure for the OpenJDK source across a broad range of platforms. For information about the platforms and minimum operating system levels supported for the builds, see the AdoptOpenJDK Platform support matrix .","title":"Supported platforms"},{"location":"adoptopenjdk/#installation-pre-requisites","text":"If you obtain binaries from the AdoptOpenJDK community, the following pre-requisites are required: From Eclipse OpenJ9 release 0.13.0, OpenJDK binaries for Linux and AIX platforms from the AdoptOpenJDK community no longer bundle the OpenSSL cryptographic library. The library is expected to be found on the system path. If you want to use OpenSSL cryptographic acceleration, you must install OpenSSL 1.0.2 or 1.1.X on your system. If the library is not found on the system path, the in-built Java crytographic implementation is used instead, which performs less well. On Linux systems, the fontconfig.x86_64 package should be installed to avoid a NullPointerException error when the AWT font subsystem is initialized. Work is ongoing at the AdoptOpenJDK project to fix this issue for their OpenJDK binaries. From Eclipse OpenJ9 release 0.16.0 (OpenJDK 13) and release 0.17.0 (OpenJDK 8 and 11), CUDA is now enabled on Windows (x86-64) and Linux (x86-64 and IBM POWER LE) platforms, which allows you to offload certain Java application processing tasks to a general purpose graphics processing unit (GPU). To take advantage of this feature, your system must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0.","title":"Installation pre-requisites"},{"location":"adoptopenjdk/#building-your-own-binaries","text":"If you want to build your own binaries of OpenJDK with OpenJ9, a complete set of build instructions for several platforms can be found in the OpenJ9 GitHub repository .","title":"Building your own binaries"},{"location":"allocator/","text":"Memory allocation The process of managing memory in the VM is handled by the Allocator and the Garbage Collector (GC). These components operate on an area of memory that is reserved for VM processing called the Java\u2122 heap. See Garbage collection for more information about the GC. The Allocator The Allocator assigns areas of the Java heap for Java objects. Objects are considered as live when they have a chain of references to them that start from root references, such as those found in thread stacks. When that reference or pointer no longer exists, the objects are considered as garbage . The Allocator is a component of memory management that is typically overshadowed by the task of garbage collection. However, it is a critical, if not small part, of the overall process. The Allocator manages pools of free memory and how the free memory is consumed. It is also responsible for allocating areas of storage in the Java heap for objects at the request of applications, class libraries, or the VM. Every allocation requires a heap lock to stop concurrent threads trying to access the same area of memory at the same time. When an object is allocated, the heap lock is released. If there is insufficient space to allocate the object, allocation fails, the heap lock is released, and the GC is called. If the GC manages to recover some space on the heap, the Allocator can resume operations. If the GC does not recover enough space, it returns an OutOfMemoryError exception. Acquiring a heap lock for every allocation would be an intensive operation with a knock on impact to performance. To get around this problem, small objects are allocated to thread local heaps (TLH). Thread local heaps (TLH) To improve performance, allocation caches are reserved in the heap for different threads. These allocation caches are known as thread local heaps (TLH) and allow each thread to allocate memory from its cache without acquiring the heap lock. A TLH is typically used for small objects of less than 512 bytes (768 bytes on 64-bit VMs) although larger objects can be allocated from the cache if there is sufficient space. If a thread allocates a lot of objects, the allocator gives that thread a larger TLH to reduce contention on the heap lock. A TLH is predefined with an initial default size of 2 KB. On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). The requested size can grow up to a predefined maximum (default 128 KB). After every GC cycle, the TLH requested size for each thread is reduced, sometimes by as much as 50%, to take account of threads that reduce their allocation rate and no longer need large TLHs. For very inactive threads, the requested size can even drop below the initial value, down to the predefined minimum (512/768 bytes). For very active threads, the maximum TLH requested size might be reached before the next GC occurs. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilisation and increase heap fragmentation. The following options control the requested TLH size: -Xgc:tlhMaximumSize=<bytes> -Xgc:tlhInitialSize=<bytes> -Xgc:tlhIncrementSize=<bytes> Typically, when the maximum TLH size is increased, you should also increase the increment proportionally, so that active threads can reach the maximum requested TLH size more quickly.","title":"Memory allocation"},{"location":"allocator/#memory-allocation","text":"The process of managing memory in the VM is handled by the Allocator and the Garbage Collector (GC). These components operate on an area of memory that is reserved for VM processing called the Java\u2122 heap. See Garbage collection for more information about the GC.","title":"Memory allocation"},{"location":"allocator/#the-allocator","text":"The Allocator assigns areas of the Java heap for Java objects. Objects are considered as live when they have a chain of references to them that start from root references, such as those found in thread stacks. When that reference or pointer no longer exists, the objects are considered as garbage . The Allocator is a component of memory management that is typically overshadowed by the task of garbage collection. However, it is a critical, if not small part, of the overall process. The Allocator manages pools of free memory and how the free memory is consumed. It is also responsible for allocating areas of storage in the Java heap for objects at the request of applications, class libraries, or the VM. Every allocation requires a heap lock to stop concurrent threads trying to access the same area of memory at the same time. When an object is allocated, the heap lock is released. If there is insufficient space to allocate the object, allocation fails, the heap lock is released, and the GC is called. If the GC manages to recover some space on the heap, the Allocator can resume operations. If the GC does not recover enough space, it returns an OutOfMemoryError exception. Acquiring a heap lock for every allocation would be an intensive operation with a knock on impact to performance. To get around this problem, small objects are allocated to thread local heaps (TLH).","title":"The Allocator"},{"location":"allocator/#thread-local-heaps-tlh","text":"To improve performance, allocation caches are reserved in the heap for different threads. These allocation caches are known as thread local heaps (TLH) and allow each thread to allocate memory from its cache without acquiring the heap lock. A TLH is typically used for small objects of less than 512 bytes (768 bytes on 64-bit VMs) although larger objects can be allocated from the cache if there is sufficient space. If a thread allocates a lot of objects, the allocator gives that thread a larger TLH to reduce contention on the heap lock. A TLH is predefined with an initial default size of 2 KB. On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). The requested size can grow up to a predefined maximum (default 128 KB). After every GC cycle, the TLH requested size for each thread is reduced, sometimes by as much as 50%, to take account of threads that reduce their allocation rate and no longer need large TLHs. For very inactive threads, the requested size can even drop below the initial value, down to the predefined minimum (512/768 bytes). For very active threads, the maximum TLH requested size might be reached before the next GC occurs. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilisation and increase heap fragmentation. The following options control the requested TLH size: -Xgc:tlhMaximumSize=<bytes> -Xgc:tlhInitialSize=<bytes> -Xgc:tlhIncrementSize=<bytes> Typically, when the maximum TLH size is increased, you should also increase the increment proportionally, so that active threads can reach the maximum requested TLH size more quickly.","title":"Thread local heaps (TLH)"},{"location":"aot/","text":"Ahead-Of-Time (AOT) compiler The AOT compiler dynamically compiles Java methods into native AOT code at runtime and stores them in the shared classes cache. This activity enables the VM to start an application faster the next time it runs because it doesn't need to spend time interpreting Java methods. The VM automatically chooses which methods should be AOT-compiled based on heuristics that identify the start-up phase of large applications. AOT code is always used in combination with class data sharing and is enabled automatically when -Xshareclasses is set on the command line. When a cached AOT method is run it might also be optimized further by the Just-In-Time (JIT) compiler. If you want to turn off AOT compilation and disable the use of AOT-compiled code, set the -Xnoaot suboption. When the AOT compiler is disabled, the JIT compiles frequently used methods into native code. However, because the JIT compiler operates while the application is running, the startup time for an application will increase. See also Diagnosing a JIT or AOT problem JIT compiler Class data sharing","title":"AOT Compiler"},{"location":"aot/#ahead-of-time-aot-compiler","text":"The AOT compiler dynamically compiles Java methods into native AOT code at runtime and stores them in the shared classes cache. This activity enables the VM to start an application faster the next time it runs because it doesn't need to spend time interpreting Java methods. The VM automatically chooses which methods should be AOT-compiled based on heuristics that identify the start-up phase of large applications. AOT code is always used in combination with class data sharing and is enabled automatically when -Xshareclasses is set on the command line. When a cached AOT method is run it might also be optimized further by the Just-In-Time (JIT) compiler. If you want to turn off AOT compilation and disable the use of AOT-compiled code, set the -Xnoaot suboption. When the AOT compiler is disabled, the JIT compiles frequently used methods into native code. However, because the JIT compiler operates while the application is running, the startup time for an application will increase.","title":"Ahead-Of-Time (AOT) compiler"},{"location":"aot/#see-also","text":"Diagnosing a JIT or AOT problem JIT compiler Class data sharing","title":"See also"},{"location":"api-conditionhandling/","text":"Condition Handling API documentation","title":"Condition exception handling"},{"location":"api-conditionhandling/#condition-handling-api-documentation","text":"","title":"Condition Handling API documentation"},{"location":"api-cuda/","text":"CUDA4J API documentation","title":"CUDA4J"},{"location":"api-cuda/#cuda4j-api-documentation","text":"","title":"CUDA4J API documentation"},{"location":"api-daa/","text":"Data access acceleration API documentation","title":"Data access acceleration"},{"location":"api-daa/#data-access-acceleration-api-documentation","text":"","title":"Data access acceleration API documentation"},{"location":"api-dtfj/","text":"DTFJ API documentation","title":"DTFJ"},{"location":"api-dtfj/#dtfj-api-documentation","text":"","title":"DTFJ API documentation"},{"location":"api-gpu/","text":"GPU API documentation","title":"GPU"},{"location":"api-gpu/#gpu-api-documentation","text":"","title":"GPU API documentation"},{"location":"api-jdk11/","text":"OpenJ9 JDK 11 API documentation","title":"Java 11 API"},{"location":"api-jdk11/#openj9-jdk-11-api-documentation","text":"","title":"OpenJ9 JDK 11 API documentation"},{"location":"api-jvm/","text":"JVM diagnostic utilities API documentation","title":"JVM diagnostic utilities"},{"location":"api-jvm/#jvm-diagnostic-utilities-api-documentation","text":"","title":"JVM diagnostic utilities API documentation"},{"location":"api-langmgmt/","text":"Monitoring and management API documentation","title":"Monitoring and management"},{"location":"api-langmgmt/#monitoring-and-management-api-documentation","text":"","title":"Monitoring and management API documentation"},{"location":"api-overview/","text":"API documentation This documentation applies to the OpenJ9 API. The documentation includes links to Oracle API documentation.","title":"Overview"},{"location":"api-overview/#api-documentation","text":"This documentation applies to the OpenJ9 API. The documentation includes links to Oracle API documentation.","title":"API documentation"},{"location":"api-shrc/","text":"Shared classes API documentation","title":"Shared classes"},{"location":"api-shrc/#shared-classes-api-documentation","text":"","title":"Shared classes API documentation"},{"location":"cmdline_general/","text":"Standard command-line options The OpenJ9 virtual machine supports the standard Java\u2122 options that are common to all Java virtual machine implementations, including Oracle's HotSpot VM. Some of the common options supported are summarised in the following table: Standard option name Purpose -classpath:<resource_name>[:<resource_name>] Sets the search path for application classes and resources (directories and compressed or .jar files). cp can be used instead of classpath . -help , -? Prints a usage message. -fullversion Prints the build and version information for a VM -showversion Prints product version and continues. -verbose:<option>[,<option>] Enables verbose output. Options include class , dynload , gc , init , jni , sizes and stack . (See Notes ) -version Prints the full build and version information a VM Notes: -verbose:class : Writes an entry to stderr for each class that is loaded. -verbose:dynload : Writes detailed class information to stderr as each bootstrap class is loaded by the VM: -verbose:gc : Provides verbose garbage collection information. -verbose:init : Writes information to stderr describing VM initialization and termination. -verbose:jni : Writes information to stderr describing the JNI services called by the application and VM. -verbose:sizes : Writes information to stderr describing the active memory usage settings. -verbose:stack : Writes information to stderr describing the Java and C stack usage for each thread. For more information about standard options, see Oracle Java SE Standard Options","title":"Standard options"},{"location":"cmdline_general/#standard-command-line-options","text":"The OpenJ9 virtual machine supports the standard Java\u2122 options that are common to all Java virtual machine implementations, including Oracle's HotSpot VM. Some of the common options supported are summarised in the following table: Standard option name Purpose -classpath:<resource_name>[:<resource_name>] Sets the search path for application classes and resources (directories and compressed or .jar files). cp can be used instead of classpath . -help , -? Prints a usage message. -fullversion Prints the build and version information for a VM -showversion Prints product version and continues. -verbose:<option>[,<option>] Enables verbose output. Options include class , dynload , gc , init , jni , sizes and stack . (See Notes ) -version Prints the full build and version information a VM Notes: -verbose:class : Writes an entry to stderr for each class that is loaded. -verbose:dynload : Writes detailed class information to stderr as each bootstrap class is loaded by the VM: -verbose:gc : Provides verbose garbage collection information. -verbose:init : Writes information to stderr describing VM initialization and termination. -verbose:jni : Writes information to stderr describing the JNI services called by the application and VM. -verbose:sizes : Writes information to stderr describing the active memory usage settings. -verbose:stack : Writes information to stderr describing the Java and C stack usage for each thread. For more information about standard options, see Oracle Java SE Standard Options","title":"Standard command-line options"},{"location":"cmdline_migration/","text":"Switching to OpenJ9 If you are already familiar with HotSpot command-line options but want the advantages of OpenJ9, the following information will prove helpful. In all cases, check individual topics for minor discrepancies in the way these options might work. Note: For information about HotSpot equivalences and differences for items other than command-line options, see New to OpenJ9? Compatible options You can use the following command-line options in OpenJ9, just as you did in HotSpot; you can continue to use the HotSpot option in OpenJ9 without having to change your code: Option Usage -X Displays help on nonstandard options. -Xbootclasspath Specifies the search path for bootstrap classes and resources. -Xcheck:jni Runs additional checks for JNI functions during VM startup. -Xfuture Turns on strict class-file format checks. -Xint Runs an application in interpreted-only mode. -Xmn Sets the initial and maximum size of the new area when using -Xgcpolicy:gencon. -Xms Sets the initial size of the heap. (Equivalent to -XX:InitialHeapSize ) -Xmx Specifies the maximum size of the object memory allocation pool. (Equivalent to -XX:MaxHeapSize ) -Xnoclassgc Disables class garbage collection (GC). -Xrs Prevents the OpenJ9 run time environment from handling signals. -Xss Sets the Java\u2122 thread stack size. (Equivalent to -XX:ThreadStackSize ). Note: Unlike HotSpot, this option applies only to the Java stack. OpenJ9 has a separate native stack for operating system threads (see -Xmso ) -Xverify:mode Enables or disables the verifier. -XX:ConcGCThreads Configures the number of GC mutator background threads. -XX:[+|-]CompactStrings Enables/disables String compression -XX:[+|-]DisableExplicitGC Enables/disables System.gc() calls. (Alias for -Xdisableexplicitgc / -Xenableexplicitgc ) -XX:[+|-]ExitOnOutOfMemoryError Triggers VM shutdown on out-of-memory conditions. -XX:[+|-]HeapDumpOnOutOfMemory Enables/disables dumps on out-of-memory conditions. -XX:HeapDumpPath Specifies a directory for all VM dumps including heap dumps, javacores, and system dumps. (Alias for -Xdump:directory ) -XX:[+|-]IgnoreUnrecognizedVMOptions Specifies whether to ignore unrecognized top-level VM options -XX:InitialHeapSize Sets the initial size of the heap. (Alias for -Xms ) -XX:InitialRAMPercentage Sets the initial size of the Java heap as a percentage of total memory. -XX:MaxDirectMemorySize Sets a limit on the amount of memory that can be reserved for all direct byte buffers. -XX:MaxHeapSize Specifies the maximum size of the object memory allocation pool. (Alias for -Xmx ) -XX:MaxRAMPercentage Sets the maximum size of the Java heap as a percentage of total memory. -XX:OnOutOfMemoryError Runs specified commands when a java.lang.OutOfMemoryError is thrown. (Equivalent to -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec= ) -XX:ParallelCMSThreads Configures the number of GC mutator background threads. -XX:ParallelGCThreads Configures the number of GC threads. -XX:[+|-]PrintCodeCache Prints code cache usage when the application exits. -XX:[+|-]UseCompressedOops Disables compressed references in 64-bit JVMs. (See also -Xcompressedrefs ) -XX:[+|-]UseContainerSupport Sets a larger fraction of memory to the Java heap when the VM detects that it is running in a container. Equivalent options These HotSpot command-line options have equivalents in OpenJ9 that are not specified in the same way, but perform a related function: HotSpot Option OpenJ9 Option Usage -Xcomp -Xjit:count=0 1 -Xcomp disables interpreted method invocations. -Xgc -Xgcpolicy 2 Configuring your garbage collection policy. -XX:+UseNUMA -Xnuma:none 3 Controls non-uniform memory architecture (NUMA) awareness. Notes: HotSpot uses -Xcomp to force compilation of methods on first invocation. However, this option is deprecated. Whilst it can be used for compatibility, using -Xjit:count=0 is preferred. HotSpot uses -Xgc to both select policies and configure them; OpenJ9 uses -Xgcpolicy to select policies, reserving -Xgc for configuration. In HotSpot, NUMA awareness is turned off by default and is turned on by using the -XX:+UseNUMA option. Conversely, the OpenJ9 VM automatically enables NUMA awareness and uses -Xnuma:none to turn it off . If you were previously using HotSpot in its default mode, you must now explicitly turn off NUMA awareness in OpenJ9. If you are used to using -XX:+UseNUMA in HotSpot, you no longer need to explicitly turn on NUMA awareness; it's on by default. Creating compatible behavior You can set the following options to make OpenJ9 behave in the same way as HotSpot. Option Usage -Djava.lang.string.substring.nocopy=true Avoid String sharing by String.substring(). -Xnuma:none Disable non-uniform memory architecture (NUMA) awareness. -XXHandleSIGABRT Force handling of SIGABRT signals to be compatible with HotSpot","title":"Switching to OpenJ9"},{"location":"cmdline_migration/#switching-to-openj9","text":"If you are already familiar with HotSpot command-line options but want the advantages of OpenJ9, the following information will prove helpful. In all cases, check individual topics for minor discrepancies in the way these options might work. Note: For information about HotSpot equivalences and differences for items other than command-line options, see New to OpenJ9?","title":"Switching to OpenJ9"},{"location":"cmdline_migration/#compatible-options","text":"You can use the following command-line options in OpenJ9, just as you did in HotSpot; you can continue to use the HotSpot option in OpenJ9 without having to change your code: Option Usage -X Displays help on nonstandard options. -Xbootclasspath Specifies the search path for bootstrap classes and resources. -Xcheck:jni Runs additional checks for JNI functions during VM startup. -Xfuture Turns on strict class-file format checks. -Xint Runs an application in interpreted-only mode. -Xmn Sets the initial and maximum size of the new area when using -Xgcpolicy:gencon. -Xms Sets the initial size of the heap. (Equivalent to -XX:InitialHeapSize ) -Xmx Specifies the maximum size of the object memory allocation pool. (Equivalent to -XX:MaxHeapSize ) -Xnoclassgc Disables class garbage collection (GC). -Xrs Prevents the OpenJ9 run time environment from handling signals. -Xss Sets the Java\u2122 thread stack size. (Equivalent to -XX:ThreadStackSize ). Note: Unlike HotSpot, this option applies only to the Java stack. OpenJ9 has a separate native stack for operating system threads (see -Xmso ) -Xverify:mode Enables or disables the verifier. -XX:ConcGCThreads Configures the number of GC mutator background threads. -XX:[+|-]CompactStrings Enables/disables String compression -XX:[+|-]DisableExplicitGC Enables/disables System.gc() calls. (Alias for -Xdisableexplicitgc / -Xenableexplicitgc ) -XX:[+|-]ExitOnOutOfMemoryError Triggers VM shutdown on out-of-memory conditions. -XX:[+|-]HeapDumpOnOutOfMemory Enables/disables dumps on out-of-memory conditions. -XX:HeapDumpPath Specifies a directory for all VM dumps including heap dumps, javacores, and system dumps. (Alias for -Xdump:directory ) -XX:[+|-]IgnoreUnrecognizedVMOptions Specifies whether to ignore unrecognized top-level VM options -XX:InitialHeapSize Sets the initial size of the heap. (Alias for -Xms ) -XX:InitialRAMPercentage Sets the initial size of the Java heap as a percentage of total memory. -XX:MaxDirectMemorySize Sets a limit on the amount of memory that can be reserved for all direct byte buffers. -XX:MaxHeapSize Specifies the maximum size of the object memory allocation pool. (Alias for -Xmx ) -XX:MaxRAMPercentage Sets the maximum size of the Java heap as a percentage of total memory. -XX:OnOutOfMemoryError Runs specified commands when a java.lang.OutOfMemoryError is thrown. (Equivalent to -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec= ) -XX:ParallelCMSThreads Configures the number of GC mutator background threads. -XX:ParallelGCThreads Configures the number of GC threads. -XX:[+|-]PrintCodeCache Prints code cache usage when the application exits. -XX:[+|-]UseCompressedOops Disables compressed references in 64-bit JVMs. (See also -Xcompressedrefs ) -XX:[+|-]UseContainerSupport Sets a larger fraction of memory to the Java heap when the VM detects that it is running in a container.","title":"Compatible options"},{"location":"cmdline_migration/#equivalent-options","text":"These HotSpot command-line options have equivalents in OpenJ9 that are not specified in the same way, but perform a related function: HotSpot Option OpenJ9 Option Usage -Xcomp -Xjit:count=0 1 -Xcomp disables interpreted method invocations. -Xgc -Xgcpolicy 2 Configuring your garbage collection policy. -XX:+UseNUMA -Xnuma:none 3 Controls non-uniform memory architecture (NUMA) awareness. Notes: HotSpot uses -Xcomp to force compilation of methods on first invocation. However, this option is deprecated. Whilst it can be used for compatibility, using -Xjit:count=0 is preferred. HotSpot uses -Xgc to both select policies and configure them; OpenJ9 uses -Xgcpolicy to select policies, reserving -Xgc for configuration. In HotSpot, NUMA awareness is turned off by default and is turned on by using the -XX:+UseNUMA option. Conversely, the OpenJ9 VM automatically enables NUMA awareness and uses -Xnuma:none to turn it off . If you were previously using HotSpot in its default mode, you must now explicitly turn off NUMA awareness in OpenJ9. If you are used to using -XX:+UseNUMA in HotSpot, you no longer need to explicitly turn on NUMA awareness; it's on by default.","title":"Equivalent options"},{"location":"cmdline_migration/#creating-compatible-behavior","text":"You can set the following options to make OpenJ9 behave in the same way as HotSpot. Option Usage -Djava.lang.string.substring.nocopy=true Avoid String sharing by String.substring(). -Xnuma:none Disable non-uniform memory architecture (NUMA) awareness. -XXHandleSIGABRT Force handling of SIGABRT signals to be compatible with HotSpot","title":"Creating compatible behavior"},{"location":"cmdline_specifying/","text":"OpenJ9 command-line options When you start a Java\u2122 application you can specify various options on the command line to configure the runtime environment. These options include: System properties Standard options Nonstandard (or -X) options -XX options Although the command line is the traditional way to specify command-line options, you can also pass options to the OpenJ9 virtual machine (VM) by using a manifest file, options files, and environment variables. Options specified on the command line override the equivalent environment variables. For example, specifying java -cp <dir1> completely overrides setting the environment variable CLASSPATH=<dir2> . Quotation marks Use single or double quotation marks for command-line options only when explicitly directed to do so. Single and double quotation marks have different meanings on different platforms, operating systems, and shells. Do not use '-X<option>' or \"-X<option>\" . Instead, you must use -X<option> . For example, do not use '-Xmx500m' and \"-Xmx500m\" . Write this option as -Xmx500m . Precedence The sequence of the Java options on the command line defines which options take precedence during startup. Rightmost options have precedence over leftmost options. In the following example, the -Xjit option takes precedence: java -Xint -Xjit myClass At startup, the list of VM arguments is constructed in the following order, with the lowest precedence first: Certain options are created automatically by the VM, which specify arguments such as search paths and version information. The VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. You can modify the options.default file to include any options that you want to specify for your application instead of entering these options on the command line. For more information about the path and construction of the file, see -Xoptionsfile . Options can be specified in an executable JAR file by using the META-INF/MANIFEST.MF file. Options are placed in the main section in a header named IBM-Java-Options . Only one IBM-Java-Options header is permitted, but the header can contain multiple options, separated by spaces. A long sequence of options can be split using a header continuation but are treated as a single line. Example manifest file: Manifest-Version: 1.0 Class-Path: . Main-Class: HelloWorld IBM-Java-Options: -Xshareclasses:name=mycache,nonfa tal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.pro perty=\"this is a long system property value to demonstrate long VM arguments in the manifest file\" This example manifest file is parsed as the following string: -Xshareclasses:name=mycache,nonfatal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.property=this is a long system property value to demonstrate long VM arguments in the manifest file Options specified in the manifest file are subject to the same restrictions as options files. For more information, see the -Xoptionsfile topic in the user guide. Environment variables that are described in OpenJ9 environment variables are translated into command-line options. For example, the following environment variable adds the parameter -Xrs to the list of arguments: On Windows\u2122 systems: set IBM_NOSIGHANDLER=<non_null_string> On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: export IBM_NOSIGHANDLER=<non_null_string> The OPENJ9_JAVA_OPTIONS environment variable. You can set command-line options using this environment variable. The options that you specify with this environment variable are added to the command line when a VM starts in that environment. The environment variable can contain multiple blank-delimited argument strings, but must not contain comments. For example: On Windows systems: set OPENJ9_JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" On AIX, Linux, macOS, and z/OS systems: export OPENJ9_JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" Note: The environment variable JAVA_TOOL_OPTIONS is equivalent to OPENJ9_JAVA_OPTIONS and is available for compatibility with JVMTI. The equivalent IBM_JAVA_OPTIONS environment variable is deprecated and will be removed in a future release. Options that are specified on the command line. For example: java -Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump MyJavaClass The Java launcher adds some automatically generated arguments to this list, such as the names of the main class. You can also use the -Xoptionsfile parameter to specify VM options. This parameter can be used on the command line, or as part of the OPENJ9_JAVA_OPTIONS environment variable. The contents of an option file are expanded in place during startup. For more information about the structure and contents of this type of file, see -Xoptionsfile . To troubleshoot startup problems, you can check which options are used by the OpenJ9 VM. Append the following command-line option, and inspect the Java core file that is generated: -Xdump:java:events=vmstart Here is an extract from a Java core file that shows the options that are used: 2CIUSERARG -Xdump:java:file=/home/test_javacore.txt,events=vmstop 2CIUSERARG -Dtest.cmdlineOption=1 2CIUSERARG -XXallowvmshutdown:true 2CIUSERARG -Xoptionsfile=test1.test_options_file","title":"Specifying options"},{"location":"cmdline_specifying/#openj9-command-line-options","text":"When you start a Java\u2122 application you can specify various options on the command line to configure the runtime environment. These options include: System properties Standard options Nonstandard (or -X) options -XX options Although the command line is the traditional way to specify command-line options, you can also pass options to the OpenJ9 virtual machine (VM) by using a manifest file, options files, and environment variables. Options specified on the command line override the equivalent environment variables. For example, specifying java -cp <dir1> completely overrides setting the environment variable CLASSPATH=<dir2> .","title":"OpenJ9 command-line options"},{"location":"cmdline_specifying/#quotation-marks","text":"Use single or double quotation marks for command-line options only when explicitly directed to do so. Single and double quotation marks have different meanings on different platforms, operating systems, and shells. Do not use '-X<option>' or \"-X<option>\" . Instead, you must use -X<option> . For example, do not use '-Xmx500m' and \"-Xmx500m\" . Write this option as -Xmx500m .","title":"Quotation marks"},{"location":"cmdline_specifying/#precedence","text":"The sequence of the Java options on the command line defines which options take precedence during startup. Rightmost options have precedence over leftmost options. In the following example, the -Xjit option takes precedence: java -Xint -Xjit myClass At startup, the list of VM arguments is constructed in the following order, with the lowest precedence first: Certain options are created automatically by the VM, which specify arguments such as search paths and version information. The VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. You can modify the options.default file to include any options that you want to specify for your application instead of entering these options on the command line. For more information about the path and construction of the file, see -Xoptionsfile . Options can be specified in an executable JAR file by using the META-INF/MANIFEST.MF file. Options are placed in the main section in a header named IBM-Java-Options . Only one IBM-Java-Options header is permitted, but the header can contain multiple options, separated by spaces. A long sequence of options can be split using a header continuation but are treated as a single line. Example manifest file: Manifest-Version: 1.0 Class-Path: . Main-Class: HelloWorld IBM-Java-Options: -Xshareclasses:name=mycache,nonfa tal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.pro perty=\"this is a long system property value to demonstrate long VM arguments in the manifest file\" This example manifest file is parsed as the following string: -Xshareclasses:name=mycache,nonfatal,cacheDirPerm=1000 -Dproperty=example -Da.long.system.property=this is a long system property value to demonstrate long VM arguments in the manifest file Options specified in the manifest file are subject to the same restrictions as options files. For more information, see the -Xoptionsfile topic in the user guide. Environment variables that are described in OpenJ9 environment variables are translated into command-line options. For example, the following environment variable adds the parameter -Xrs to the list of arguments: On Windows\u2122 systems: set IBM_NOSIGHANDLER=<non_null_string> On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: export IBM_NOSIGHANDLER=<non_null_string> The OPENJ9_JAVA_OPTIONS environment variable. You can set command-line options using this environment variable. The options that you specify with this environment variable are added to the command line when a VM starts in that environment. The environment variable can contain multiple blank-delimited argument strings, but must not contain comments. For example: On Windows systems: set OPENJ9_JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" On AIX, Linux, macOS, and z/OS systems: export OPENJ9_JAVA_OPTIONS=\"-Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump\" Note: The environment variable JAVA_TOOL_OPTIONS is equivalent to OPENJ9_JAVA_OPTIONS and is available for compatibility with JVMTI. The equivalent IBM_JAVA_OPTIONS environment variable is deprecated and will be removed in a future release. Options that are specified on the command line. For example: java -Dmysysprop1=tcpip -Dmysysprop2=wait -Xdisablejavadump MyJavaClass The Java launcher adds some automatically generated arguments to this list, such as the names of the main class. You can also use the -Xoptionsfile parameter to specify VM options. This parameter can be used on the command line, or as part of the OPENJ9_JAVA_OPTIONS environment variable. The contents of an option file are expanded in place during startup. For more information about the structure and contents of this type of file, see -Xoptionsfile . To troubleshoot startup problems, you can check which options are used by the OpenJ9 VM. Append the following command-line option, and inspect the Java core file that is generated: -Xdump:java:events=vmstart Here is an extract from a Java core file that shows the options that are used: 2CIUSERARG -Xdump:java:file=/home/test_javacore.txt,events=vmstop 2CIUSERARG -Dtest.cmdlineOption=1 2CIUSERARG -XXallowvmshutdown:true 2CIUSERARG -Xoptionsfile=test1.test_options_file","title":"Precedence"},{"location":"d_jvm_commands/","text":"Using system property command-line options Java\u2122 system properties determine the environment in which a Java program runs by starting a Java virtual machine with a set of values. You can choose to use the default values for Java system properties or you can specify values for them by adding parameters to the command line when you start your application. To set a system property from the command line, use: java -D<property_name>=<value> <program_name> For example, to specify the UTF-8 file encoding for your application MyProgram , use: java -Dfile.encoding=UTF-8 MyProgram","title":"Using System properties"},{"location":"d_jvm_commands/#using-system-property-command-line-options","text":"Java\u2122 system properties determine the environment in which a Java program runs by starting a Java virtual machine with a set of values. You can choose to use the default values for Java system properties or you can specify values for them by adding parameters to the command line when you start your application. To set a system property from the command line, use: java -D<property_name>=<value> <program_name> For example, to specify the UTF-8 file encoding for your application MyProgram , use: java -Dfile.encoding=UTF-8 MyProgram","title":"Using system property command-line options"},{"location":"dcomibmenableclasscaching/","text":"-Dcom.ibm.enableClassCaching Setting this property to true enables caching of the Latest User Defined Class Loader (LUDCL). Syntax -Dcom.ibm.enableClassCaching=[true|false] Setting Effect Default true Enable yes false Disable Explanation By reducing repeated lookups, Java\u2122 applications that use deserialization extensively can see a performance improvement. See also Java Object Serialization Specification","title":"-Dcom.ibm.enableClassCaching"},{"location":"dcomibmenableclasscaching/#-dcomibmenableclasscaching","text":"Setting this property to true enables caching of the Latest User Defined Class Loader (LUDCL).","title":"-Dcom.ibm.enableClassCaching"},{"location":"dcomibmenableclasscaching/#syntax","text":"-Dcom.ibm.enableClassCaching=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenableclasscaching/#explanation","text":"By reducing repeated lookups, Java\u2122 applications that use deserialization extensively can see a performance improvement.","title":"Explanation"},{"location":"dcomibmenableclasscaching/#see-also","text":"Java Object Serialization Specification","title":"See also"},{"location":"dcomibmenablelegacydumpsecurity/","text":"-Dcom.ibm.enableLegacyDumpSecurity To improve security, the security checks in the certain com.ibm.jvm.Dump APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs. Syntax -Dcom.ibm.enableLegacyDumpSecurity=[true|false] Setting Effect Default true Enable yes false Disable Explanation Security checking is enabled in the following APIs: com.ibm.jvm.Dump.JavaDump() com.ibm.jvm.Dump.HeapDump() com.ibm.jvm.Dump.SnapDump() See also -Dcom.ibm.enableLegacyLogSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"-Dcom.ibm.enableLegacyDumpSecurity"},{"location":"dcomibmenablelegacydumpsecurity/#-dcomibmenablelegacydumpsecurity","text":"To improve security, the security checks in the certain com.ibm.jvm.Dump APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs.","title":"-Dcom.ibm.enableLegacyDumpSecurity"},{"location":"dcomibmenablelegacydumpsecurity/#syntax","text":"-Dcom.ibm.enableLegacyDumpSecurity=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenablelegacydumpsecurity/#explanation","text":"Security checking is enabled in the following APIs: com.ibm.jvm.Dump.JavaDump() com.ibm.jvm.Dump.HeapDump() com.ibm.jvm.Dump.SnapDump()","title":"Explanation"},{"location":"dcomibmenablelegacydumpsecurity/#see-also","text":"-Dcom.ibm.enableLegacyLogSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"See also"},{"location":"dcomibmenablelegacylogsecurity/","text":"-Dcom.ibm.enableLegacyLogSecurity To improve security, the security checks in the certain com.ibm.jvm.Log APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs. Syntax -Dcom.ibm.enableLegacyLogSecurity=[true|false] Setting Effect Default true Enable yes false Disable Explanation Security checking is enabled in the following APIs: com.ibm.jvm.Log.QueryOptions() com.ibm.jvm.Log.SetOptions(String) See also -Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"-Dcom.ibm.enableLegacyLogSecurity"},{"location":"dcomibmenablelegacylogsecurity/#-dcomibmenablelegacylogsecurity","text":"To improve security, the security checks in the certain com.ibm.jvm.Log APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs.","title":"-Dcom.ibm.enableLegacyLogSecurity"},{"location":"dcomibmenablelegacylogsecurity/#syntax","text":"-Dcom.ibm.enableLegacyLogSecurity=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenablelegacylogsecurity/#explanation","text":"Security checking is enabled in the following APIs: com.ibm.jvm.Log.QueryOptions() com.ibm.jvm.Log.SetOptions(String)","title":"Explanation"},{"location":"dcomibmenablelegacylogsecurity/#see-also","text":"-Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyTraceSecurity","title":"See also"},{"location":"dcomibmenablelegacytracesecurity/","text":"-Dcom.ibm.enableLegacyTraceSecurity To improve security, the security checks in certain com.ibm.jvm.Trace APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs. Syntax -Dcom.ibm.enableLegacyTraceSecurity=[true|false] Setting Effect Default true Enable yes false Disable Explanation Security checking is enabled in the following APIs: com.ibm.jvm.Trace.set(String) com.ibm.jvm.Trace.snap() com.ibm.jvm.Trace.suspend() com.ibm.jvm.Trace.suspendThis() com.ibm.jvm.Trace.resume() com.ibm.jvm.Trace.resumeThis() com.ibm.jvm.Trace.registerApplication(String, String[]) See also -Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyLogSecurity","title":"-Dcom.ibm.enableLegacyTraceSecurity"},{"location":"dcomibmenablelegacytracesecurity/#-dcomibmenablelegacytracesecurity","text":"To improve security, the security checks in certain com.ibm.jvm.Trace APIs are now enabled by default, when the SecurityManger is enabled. Use this system property to turn off security checking for these APIs.","title":"-Dcom.ibm.enableLegacyTraceSecurity"},{"location":"dcomibmenablelegacytracesecurity/#syntax","text":"-Dcom.ibm.enableLegacyTraceSecurity=[true|false] Setting Effect Default true Enable yes false Disable","title":"Syntax"},{"location":"dcomibmenablelegacytracesecurity/#explanation","text":"Security checking is enabled in the following APIs: com.ibm.jvm.Trace.set(String) com.ibm.jvm.Trace.snap() com.ibm.jvm.Trace.suspend() com.ibm.jvm.Trace.suspendThis() com.ibm.jvm.Trace.resume() com.ibm.jvm.Trace.resumeThis() com.ibm.jvm.Trace.registerApplication(String, String[])","title":"Explanation"},{"location":"dcomibmenablelegacytracesecurity/#see-also","text":"-Dcom.ibm.enableLegacyDumpSecurity -Dcom.ibm.enableLegacyLogSecurity","title":"See also"},{"location":"dcomibmgpudisable/","text":"-Dcom.ibm.gpu.disable Restriction: This system property is supported only on Java\u2122 11 and later If you have enabled GPU processing with -Dcom.ibm.gpu.enable , use this system property to turn off processing that can be offloaded to a graphics processing unit (GPU). Syntax -Dcom.ibm.gpu.disable Explanation Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. GPU processing is therefore disabled by default. However, if you have enabled GPU processing with -Dcom.ibm.gpu.enable , this property turns GPU processing off. See also Exploiting GPUs -Dcom.ibm.gpu.enable -Dcom.ibm.gpu.verbose","title":"-Dcom.ibm.gpu.disable"},{"location":"dcomibmgpudisable/#-dcomibmgpudisable","text":"Restriction: This system property is supported only on Java\u2122 11 and later If you have enabled GPU processing with -Dcom.ibm.gpu.enable , use this system property to turn off processing that can be offloaded to a graphics processing unit (GPU).","title":"-Dcom.ibm.gpu.disable"},{"location":"dcomibmgpudisable/#syntax","text":"-Dcom.ibm.gpu.disable","title":"Syntax"},{"location":"dcomibmgpudisable/#explanation","text":"Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. GPU processing is therefore disabled by default. However, if you have enabled GPU processing with -Dcom.ibm.gpu.enable , this property turns GPU processing off.","title":"Explanation"},{"location":"dcomibmgpudisable/#see-also","text":"Exploiting GPUs -Dcom.ibm.gpu.enable -Dcom.ibm.gpu.verbose","title":"See also"},{"location":"dcomibmgpuenable/","text":"-Dcom.ibm.gpu.enable Restriction: This system property is supported only on Java\u2122 11 and later Use this system property to control the type of processing that can be offloaded to a graphics processing unit (GPU) when processing requirements meet a specific threshold. This feature can improve the performance of certain Java functions. Syntax -Dcom.ibm.gpu.enable=[all|sort] Setting Effect all Turns on GPU processing for all possible Java functions. sort Turns on GPU processing only for the Java sort() function. By default, this property is not set. Explanation Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. When set, this property enables GPU processing for any array that meets a minimum size. See also Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.verbose","title":"-Dcom.ibm.gpu.enable"},{"location":"dcomibmgpuenable/#-dcomibmgpuenable","text":"Restriction: This system property is supported only on Java\u2122 11 and later Use this system property to control the type of processing that can be offloaded to a graphics processing unit (GPU) when processing requirements meet a specific threshold. This feature can improve the performance of certain Java functions.","title":"-Dcom.ibm.gpu.enable"},{"location":"dcomibmgpuenable/#syntax","text":"-Dcom.ibm.gpu.enable=[all|sort] Setting Effect all Turns on GPU processing for all possible Java functions. sort Turns on GPU processing only for the Java sort() function. By default, this property is not set.","title":"Syntax"},{"location":"dcomibmgpuenable/#explanation","text":"Because establishing and completing communication with a GPU incurs an additional overhead, not all processing requirements benefit from being offloaded to the GPU. When set, this property enables GPU processing for any array that meets a minimum size.","title":"Explanation"},{"location":"dcomibmgpuenable/#see-also","text":"Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.verbose","title":"See also"},{"location":"dcomibmgpuverbose/","text":"-Dcom.ibm.gpu.verbose Restriction: This system property is supported only on Java\u2122 11 and later This system property can be used to help identify problems with graphics processing unit (GPU) processing. Syntax -Dcom.ibm.gpu.verbose This property is not set by default. Explanation When specified, this option generates verbose output to STDOUT, which can be piped to a file. See also Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.enable","title":"-Dcom.ibm.gpu.verbose"},{"location":"dcomibmgpuverbose/#-dcomibmgpuverbose","text":"Restriction: This system property is supported only on Java\u2122 11 and later This system property can be used to help identify problems with graphics processing unit (GPU) processing.","title":"-Dcom.ibm.gpu.verbose"},{"location":"dcomibmgpuverbose/#syntax","text":"-Dcom.ibm.gpu.verbose This property is not set by default.","title":"Syntax"},{"location":"dcomibmgpuverbose/#explanation","text":"When specified, this option generates verbose output to STDOUT, which can be piped to a file.","title":"Explanation"},{"location":"dcomibmgpuverbose/#see-also","text":"Exploiting GPUs -Dcom.ibm.gpu.disable -Dcom.ibm.gpu.enable","title":"See also"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/","text":"-Dcom.ibm.lang.management. OperatingSystemMXBean.isCpuTime100ns Changes the unit of the return value of the OperatingSystemMXBean.getProcessCpuTime() method. Syntax -Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns=[true|false] Setting Effect Default true Enable false Disable yes Explanation The Oracle java.lang.management package includes MBean categories such as Memory , OperatingSystem , and GarbageCollector . The OpenJ9 VM provides additional MXBeans to extend the monitoring and management capabilities. For example, the OperatingSystemMXBean , which monitors operating system settings such as physical and virtual memory size, processor capacity, and processor utilization. The OperatingSystemMXBean.getProcessCpuTime() method returns a value in nanoseconds (10 -9 s), for compatibility with the com.sun.management.OperatingSystemMXBean and UnixOperatingSystemMXBean interfaces. In earlier VM releases, the return value was in hundreds of nanoseconds. If you want to revert to this behavior, set the -Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns property to true . The default value for this property is false . See also Monitoring and management API documentation","title":"-Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#-dcomibmlangmanagementoperatingsystemmxbeaniscputime100ns","text":"Changes the unit of the return value of the OperatingSystemMXBean.getProcessCpuTime() method.","title":"-Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#syntax","text":"-Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns=[true|false] Setting Effect Default true Enable false Disable yes","title":"Syntax"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#explanation","text":"The Oracle java.lang.management package includes MBean categories such as Memory , OperatingSystem , and GarbageCollector . The OpenJ9 VM provides additional MXBeans to extend the monitoring and management capabilities. For example, the OperatingSystemMXBean , which monitors operating system settings such as physical and virtual memory size, processor capacity, and processor utilization. The OperatingSystemMXBean.getProcessCpuTime() method returns a value in nanoseconds (10 -9 s), for compatibility with the com.sun.management.OperatingSystemMXBean and UnixOperatingSystemMXBean interfaces. In earlier VM releases, the return value was in hundreds of nanoseconds. If you want to revert to this behavior, set the -Dcom.ibm.lang.management.OperatingSystemMXBean.isCpuTime100ns property to true . The default value for this property is false .","title":"Explanation"},{"location":"dcomibmlangmanagementosmxbeaniscputime100ns/#see-also","text":"Monitoring and management API documentation","title":"See also"},{"location":"dcomibmlangmanagementverbose/","text":"-Dcom.ibm.lang.management.verbose Enables verbose information from java.lang.management operations to be written to the output channel during VM operations. Syntax -Dcom.ibm.lang.management.verbose There are no options for this system property.","title":"-Dcom.ibm.lang.management.verbose"},{"location":"dcomibmlangmanagementverbose/#-dcomibmlangmanagementverbose","text":"Enables verbose information from java.lang.management operations to be written to the output channel during VM operations.","title":"-Dcom.ibm.lang.management.verbose"},{"location":"dcomibmlangmanagementverbose/#syntax","text":"-Dcom.ibm.lang.management.verbose There are no options for this system property.","title":"Syntax"},{"location":"dcomibmtoolsattachdirectory/","text":"-Dcom.ibm.tools.attach.directory Specify a different common directory for Attach API working files. Syntax -Dcom.ibm.tools.attach.directory=<directory_name> Setting Value Default <directory_name> [string] .com_ibm_tools_attach To change the value for directory_name , specify a different directory name. If the directory does not exist, it is created. However, if a parent directory is specified, it must exist. See also Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.directory"},{"location":"dcomibmtoolsattachdirectory/#-dcomibmtoolsattachdirectory","text":"Specify a different common directory for Attach API working files.","title":"-Dcom.ibm.tools.attach.directory"},{"location":"dcomibmtoolsattachdirectory/#syntax","text":"-Dcom.ibm.tools.attach.directory=<directory_name> Setting Value Default <directory_name> [string] .com_ibm_tools_attach To change the value for directory_name , specify a different directory name. If the directory does not exist, it is created. However, if a parent directory is specified, it must exist.","title":"Syntax"},{"location":"dcomibmtoolsattachdirectory/#see-also","text":"Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachdisplayname/","text":"-Dcom.ibm.tools.attach.displayName Change the default display name for the target virtual machine. Syntax -Dcom.ibm.tools.attach.displayName=<display_name> Setting Value Default <display_name> [string] The command line invocation used to start the application To change the value for <display_name> , enter a character string of your choice. See also Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.displayName"},{"location":"dcomibmtoolsattachdisplayname/#-dcomibmtoolsattachdisplayname","text":"Change the default display name for the target virtual machine.","title":"-Dcom.ibm.tools.attach.displayName"},{"location":"dcomibmtoolsattachdisplayname/#syntax","text":"-Dcom.ibm.tools.attach.displayName=<display_name> Setting Value Default <display_name> [string] The command line invocation used to start the application To change the value for <display_name> , enter a character string of your choice.","title":"Syntax"},{"location":"dcomibmtoolsattachdisplayname/#see-also","text":"Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachenable/","text":"-Dcom.ibm.tools.attach.enable Enable the Attach API for this application. Syntax -Dcom.ibm.tools.attach.enable=[yes|no] On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 systems, the following default applies: Value Effect Default yes Enable yes no Disable On z/OS\u00ae systems, the following default applies: Value Effect Default yes Enable no Disable yes Explanation A useful reference for information about the Java\u2122 Attach API can be found at http://docs.oracle.com/javase/8/docs/technotes/guides/attach/index.html . The following extract is taken from the Oracle documentation: The Attach API is an extension that provides a mechanism to attach to a Java virtual machine. A tool written in the Java Language, uses this API to attach to a target virtual machine and load its tool agent into that virtual machine. For example, to late attach the IBM\u00ae Health Center agent to a virtual machine (VM) that is already running. The OpenJ9 implementation of the Attach API is equivalent to the Oracle implementation. However, the OpenJ9 implementation cannot be used to attach to, or accept attach requests from, other VM implementations. See also Support for the Java Attach API -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.enable"},{"location":"dcomibmtoolsattachenable/#-dcomibmtoolsattachenable","text":"Enable the Attach API for this application.","title":"-Dcom.ibm.tools.attach.enable"},{"location":"dcomibmtoolsattachenable/#syntax","text":"-Dcom.ibm.tools.attach.enable=[yes|no] On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 systems, the following default applies: Value Effect Default yes Enable yes no Disable On z/OS\u00ae systems, the following default applies: Value Effect Default yes Enable no Disable yes","title":"Syntax"},{"location":"dcomibmtoolsattachenable/#explanation","text":"A useful reference for information about the Java\u2122 Attach API can be found at http://docs.oracle.com/javase/8/docs/technotes/guides/attach/index.html . The following extract is taken from the Oracle documentation: The Attach API is an extension that provides a mechanism to attach to a Java virtual machine. A tool written in the Java Language, uses this API to attach to a target virtual machine and load its tool agent into that virtual machine. For example, to late attach the IBM\u00ae Health Center agent to a virtual machine (VM) that is already running. The OpenJ9 implementation of the Attach API is equivalent to the Oracle implementation. However, the OpenJ9 implementation cannot be used to attach to, or accept attach requests from, other VM implementations.","title":"Explanation"},{"location":"dcomibmtoolsattachenable/#see-also","text":"Support for the Java Attach API -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachid/","text":"-Dcom.ibm.tools.attach.id Specify a different target virtual machine (VM) to attach to. Syntax -Dcom.ibm.tools.attach.id=<process_ID> Setting Value Default <process_ID> [string] Target VM process ID To use a different target, change the value for <process_ID> . See also Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.timeout","title":"-Dcom.ibm.tools.attach.id"},{"location":"dcomibmtoolsattachid/#-dcomibmtoolsattachid","text":"Specify a different target virtual machine (VM) to attach to.","title":"-Dcom.ibm.tools.attach.id"},{"location":"dcomibmtoolsattachid/#syntax","text":"-Dcom.ibm.tools.attach.id=<process_ID> Setting Value Default <process_ID> [string] Target VM process ID To use a different target, change the value for <process_ID> .","title":"Syntax"},{"location":"dcomibmtoolsattachid/#see-also","text":"Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.timeout","title":"See also"},{"location":"dcomibmtoolsattachtimeout/","text":"-Dcom.ibm.tools.attach.timeout Specify a time that an application should wait when attempting to connect to a target virtual machine (VM) before ending. Syntax -Dcom.ibm.tools.attach.timeout=<ms> Setting Value Default <ms> [1 millisecond or greater] 120000 milliseconds (120 seconds) Example To timeout after 60 seconds, specify: -Dcom.ibm.tools.attach.timeout=60000 See also Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id","title":"-Dcom.ibm.tools.attach.timeout"},{"location":"dcomibmtoolsattachtimeout/#-dcomibmtoolsattachtimeout","text":"Specify a time that an application should wait when attempting to connect to a target virtual machine (VM) before ending.","title":"-Dcom.ibm.tools.attach.timeout"},{"location":"dcomibmtoolsattachtimeout/#syntax","text":"-Dcom.ibm.tools.attach.timeout=<ms> Setting Value Default <ms> [1 millisecond or greater] 120000 milliseconds (120 seconds)","title":"Syntax"},{"location":"dcomibmtoolsattachtimeout/#example","text":"To timeout after 60 seconds, specify: -Dcom.ibm.tools.attach.timeout=60000","title":"Example"},{"location":"dcomibmtoolsattachtimeout/#see-also","text":"Support for the Java\u2122 Attach API -Dcom.ibm.tools.attach.enable -Dcom.ibm.tools.attach.directory -Dcom.ibm.tools.attach.displayName -Dcom.ibm.tools.attach.id","title":"See also"},{"location":"dfileencoding/","text":"-Dfile.encoding Use this OpenJDK property to define the file encoding that is required. Syntax -Dfile.encoding=<value> Setting Value Default <value> [string] Unicode 3.0 standards where <value> defines the file encoding that is required. Explanation By default the GBK converter follows Unicode 3.0 standards. To force the GBK converter to follow Unicode 2.0 standards, use a value of bestfit936 .","title":"-Dfile.encoding"},{"location":"dfileencoding/#-dfileencoding","text":"Use this OpenJDK property to define the file encoding that is required.","title":"-Dfile.encoding"},{"location":"dfileencoding/#syntax","text":"-Dfile.encoding=<value> Setting Value Default <value> [string] Unicode 3.0 standards where <value> defines the file encoding that is required.","title":"Syntax"},{"location":"dfileencoding/#explanation","text":"By default the GBK converter follows Unicode 3.0 standards. To force the GBK converter to follow Unicode 2.0 standards, use a value of bestfit936 .","title":"Explanation"},{"location":"diag_overview/","text":"Diagnostic data and tooling OpenJ9 contains a broad range of diagnostic capabilities to help identify, isolate, and solve run time problems. These capabilities include dump files, verbose logs, and trace files, which are supported by a variety of diagnostic tools and interfaces. Dumps Various types of dumps are produced by default in response to certain events, such as a GPF fault or an OutOfMemoryError exception. You can also trigger the production of dumps by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. All dumps are produced by dump agents, which are initialized when the OpenJ9 VM starts. Different dumps target different areas of the runtime environment. If you want to generate a dump to diagnose a particular type of problem, you need to understand what data the dump will provide. The following dumps are typically used for problem diagnosis: Java dumps ( -Xdump:java ) contain information that relates to the OpenJ9 VM and the Java\u2122 application, such as the operating environment, locks, threads, hooks, shared classes, and class loaders. Heap dumps ( -Xdump:heap ) show the content of the Java heap. System dumps ( -Xdump:system ) contain a raw process image or address space of an application. Other types of dump include binary JIT dumps, stack dumps, and snap dumps. For a complete list of dump agents and the diagnostic data they produce, see Dump agents . Verbose log files Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination. Class data sharing provides a number of -Xshareclasses suboptions to provide detailed data about the content of a shared classes cache, cache I/O activity, and information about the Java Helper API (where used). For example, the -Xshareclasses:printAllStats suboption lists every class in chronological order with a reference to the location from which it was loaded. For more information, see -Xshareclasses . Garbage collection operations can be analyzed by producing verbose output from the -verbose:gc standard option. This output can be redirected to a file by specifying the -Xverbosegclog option. Information can be obtained about GC initialization, stop-the-world processing, finalization, reference processing, and allocation failures. Even more granular information can be obtained with the -Xtgc option. The JIT compiler provides verbose logging, which records all compiler operations. To find out how to enable logging, read the JIT troubleshooting content. Class loader operations can be analyzed by producing verbose output from the -verbose:dynload standard option, which shows detailed information as each class is loaded by the VM. Trace files The OpenJ9 trace facility can be used to trace applications, Java methods, or internal JVM operations with minimal impact on performance. Trace is configured by using the -Xtrace command line option, which allows you to control what is traced and when. Trace data is produced in binary format and must be processed by the OpenJ9 trace formatter to convert it to a readable form. For more information, see Trace formatter . Diagnostic tools A number of diagnostic tools are available with OpenJ9 to assist with the analysis of dump and trace files. Dump extractor The dump extractor ( jextract ) supports a full analysis of core files on specific platforms by collecting key files from a system and packaging them into an archive along with a core dump. This archive file is extremely useful when reporting issues to the OpenJ9 community, helping to ensure a faster analysis and turnaround. For more information, see Dump extractor . Dump viewer Because system dumps are binary files, OpenJ9 provides a dump viewer tool ( jdmpview ) to analyze the contents. This tool can work with dumps from any platforms independently of a system debugger. For more information, see Dump viewer . Trace formatter The trace formatter tool converts binary trace point data in a trace file into a readable format for analysis. For more information, see Trace formatter . Option builder OpenJ9 contains an extensive set of command-line options to assist with problem diagnosis. Certain options are complex, containing many sub-options with numerous parameters. Whilst these offer a great degree of flexibility, the syntax can be difficult to construct. Option builder tools are available that provide a simple graphical user interface to help you construct your command-line argument. For more information, see Option builder . HotSpot-compatible tools A number of tools are available for compatibility with the reference implementation. These tools are independently implemented by OpenJ9 but have similar functions, allowing users to migrate more easily. The available tools are listed in the Tools section. Note: If you are already familiar with tools that are provided with HotSpot, see Switching to OpenJ9 , which explains some of the differences you might encounter when using OpenJ9. Eclipse marketplace tools OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Memory Analyzer: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . Interactive Diagnostic Data Explorer (IDDE): A GUI alternative to the OpenJ9 dump viewer , which can examine the contents of an OpenJ9 system dump. For more information, read the IDDE documentation . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center. Interfaces JVM tool interface (JVMTI) OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information, see Java Virtual Machine Tool Interface . DTFJ Interface OpenJ9 includes the Diagnostic Tool Framework for Java (DTFJ) API. Custom applications can be written that use this API to access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer Toolkit (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information, see Diagnostic Tool Framework for Java . Language Management interface OpenJ9 provides MXBean additions and extensions to the standard java.lang.management API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface . JPDA tools OpenJ9 is compliant with the Java Platform Debugging Architecture (JPDA), which means you can use any JPDA tool for diagnosis, including Eclipse JDT Debug .","title":"Overview"},{"location":"diag_overview/#diagnostic-data-and-tooling","text":"OpenJ9 contains a broad range of diagnostic capabilities to help identify, isolate, and solve run time problems. These capabilities include dump files, verbose logs, and trace files, which are supported by a variety of diagnostic tools and interfaces.","title":"Diagnostic data and tooling"},{"location":"diag_overview/#dumps","text":"Various types of dumps are produced by default in response to certain events, such as a GPF fault or an OutOfMemoryError exception. You can also trigger the production of dumps by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. All dumps are produced by dump agents, which are initialized when the OpenJ9 VM starts. Different dumps target different areas of the runtime environment. If you want to generate a dump to diagnose a particular type of problem, you need to understand what data the dump will provide. The following dumps are typically used for problem diagnosis: Java dumps ( -Xdump:java ) contain information that relates to the OpenJ9 VM and the Java\u2122 application, such as the operating environment, locks, threads, hooks, shared classes, and class loaders. Heap dumps ( -Xdump:heap ) show the content of the Java heap. System dumps ( -Xdump:system ) contain a raw process image or address space of an application. Other types of dump include binary JIT dumps, stack dumps, and snap dumps. For a complete list of dump agents and the diagnostic data they produce, see Dump agents .","title":"Dumps"},{"location":"diag_overview/#verbose-log-files","text":"Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination. Class data sharing provides a number of -Xshareclasses suboptions to provide detailed data about the content of a shared classes cache, cache I/O activity, and information about the Java Helper API (where used). For example, the -Xshareclasses:printAllStats suboption lists every class in chronological order with a reference to the location from which it was loaded. For more information, see -Xshareclasses . Garbage collection operations can be analyzed by producing verbose output from the -verbose:gc standard option. This output can be redirected to a file by specifying the -Xverbosegclog option. Information can be obtained about GC initialization, stop-the-world processing, finalization, reference processing, and allocation failures. Even more granular information can be obtained with the -Xtgc option. The JIT compiler provides verbose logging, which records all compiler operations. To find out how to enable logging, read the JIT troubleshooting content. Class loader operations can be analyzed by producing verbose output from the -verbose:dynload standard option, which shows detailed information as each class is loaded by the VM.","title":"Verbose log files"},{"location":"diag_overview/#trace-files","text":"The OpenJ9 trace facility can be used to trace applications, Java methods, or internal JVM operations with minimal impact on performance. Trace is configured by using the -Xtrace command line option, which allows you to control what is traced and when. Trace data is produced in binary format and must be processed by the OpenJ9 trace formatter to convert it to a readable form. For more information, see Trace formatter .","title":"Trace files"},{"location":"diag_overview/#diagnostic-tools","text":"A number of diagnostic tools are available with OpenJ9 to assist with the analysis of dump and trace files.","title":"Diagnostic tools"},{"location":"diag_overview/#dump-extractor","text":"The dump extractor ( jextract ) supports a full analysis of core files on specific platforms by collecting key files from a system and packaging them into an archive along with a core dump. This archive file is extremely useful when reporting issues to the OpenJ9 community, helping to ensure a faster analysis and turnaround. For more information, see Dump extractor .","title":"Dump extractor"},{"location":"diag_overview/#dump-viewer","text":"Because system dumps are binary files, OpenJ9 provides a dump viewer tool ( jdmpview ) to analyze the contents. This tool can work with dumps from any platforms independently of a system debugger. For more information, see Dump viewer .","title":"Dump viewer"},{"location":"diag_overview/#trace-formatter","text":"The trace formatter tool converts binary trace point data in a trace file into a readable format for analysis. For more information, see Trace formatter .","title":"Trace formatter"},{"location":"diag_overview/#option-builder","text":"OpenJ9 contains an extensive set of command-line options to assist with problem diagnosis. Certain options are complex, containing many sub-options with numerous parameters. Whilst these offer a great degree of flexibility, the syntax can be difficult to construct. Option builder tools are available that provide a simple graphical user interface to help you construct your command-line argument. For more information, see Option builder .","title":"Option builder"},{"location":"diag_overview/#hotspot-compatible-tools","text":"A number of tools are available for compatibility with the reference implementation. These tools are independently implemented by OpenJ9 but have similar functions, allowing users to migrate more easily. The available tools are listed in the Tools section. Note: If you are already familiar with tools that are provided with HotSpot, see Switching to OpenJ9 , which explains some of the differences you might encounter when using OpenJ9.","title":"HotSpot-compatible tools"},{"location":"diag_overview/#eclipse-marketplace-tools","text":"OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Memory Analyzer: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . Interactive Diagnostic Data Explorer (IDDE): A GUI alternative to the OpenJ9 dump viewer , which can examine the contents of an OpenJ9 system dump. For more information, read the IDDE documentation . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center.","title":"Eclipse marketplace tools"},{"location":"diag_overview/#interfaces","text":"","title":"Interfaces"},{"location":"diag_overview/#jvm-tool-interface-jvmti","text":"OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information, see Java Virtual Machine Tool Interface .","title":"JVM tool interface (JVMTI)"},{"location":"diag_overview/#dtfj-interface","text":"OpenJ9 includes the Diagnostic Tool Framework for Java (DTFJ) API. Custom applications can be written that use this API to access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer Toolkit (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information, see Diagnostic Tool Framework for Java .","title":"DTFJ Interface"},{"location":"diag_overview/#language-management-interface","text":"OpenJ9 provides MXBean additions and extensions to the standard java.lang.management API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface .","title":"Language Management interface"},{"location":"diag_overview/#jpda-tools","text":"OpenJ9 is compliant with the Java Platform Debugging Architecture (JPDA), which means you can use any JPDA tool for diagnosis, including Eclipse JDT Debug .","title":"JPDA tools"},{"location":"djavacompiler/","text":"-Djava.compiler This Oracle HotSpot property is used for loading a JIT compiler from a named, native library. This option can be used on the command line to specify the JIT compiler for the OpenJ9 VM. Syntax -Djava.compiler=j9jit29","title":"-Djava.compiler"},{"location":"djavacompiler/#-djavacompiler","text":"This Oracle HotSpot property is used for loading a JIT compiler from a named, native library. This option can be used on the command line to specify the JIT compiler for the OpenJ9 VM.","title":"-Djava.compiler"},{"location":"djavacompiler/#syntax","text":"-Djava.compiler=j9jit29","title":"Syntax"},{"location":"djavalangstringbuffergrowaggressively/","text":"-Djava.lang.stringBuffer.growAggressively Restriction: This system property is supported only on Java\u2122 8. Setting this property to false reverts to the behavior (OpenJ9 0.18 and earlier) of growing a 1 G char[] or larger StringBuffer or StringBuilder only as much as necessary to accommodate the String being added. The default behavior is to immediately grow to the maximum possible size, similarly to Java 11 and later. The default behavior is compatible with the Oracle HotSpot VM. Syntax -Djava.lang.stringBufferAndBuilder.growAggressively=[true|false] Setting Effect Default true Above 1 G, grow to the maximum size yes false Above 1 G, grow only as required","title":"-Djava.lang.stringBuffer.growAggressively"},{"location":"djavalangstringbuffergrowaggressively/#-djavalangstringbuffergrowaggressively","text":"Restriction: This system property is supported only on Java\u2122 8. Setting this property to false reverts to the behavior (OpenJ9 0.18 and earlier) of growing a 1 G char[] or larger StringBuffer or StringBuilder only as much as necessary to accommodate the String being added. The default behavior is to immediately grow to the maximum possible size, similarly to Java 11 and later. The default behavior is compatible with the Oracle HotSpot VM.","title":"-Djava.lang.stringBuffer.growAggressively"},{"location":"djavalangstringbuffergrowaggressively/#syntax","text":"-Djava.lang.stringBufferAndBuilder.growAggressively=[true|false] Setting Effect Default true Above 1 G, grow to the maximum size yes false Above 1 G, grow only as required","title":"Syntax"},{"location":"djavalangstringsubstringnocopy/","text":"-Djava.lang.string.substring.nocopy Restriction: This system property is supported only on Java\u2122 8. String sharing cannot be enabled on Java 11 and later. Setting this property to true avoids sharing a String object when substring() is used to subset a String beginning from offset zero. Avoiding sharing is compatible with the Oracle HotSpot VM. Syntax -Djava.lang.string.substring.nocopy=[true|false] Setting Effect Default true No sharing false Sharing yes","title":"-Djava.lang.string.substring.nocopy"},{"location":"djavalangstringsubstringnocopy/#-djavalangstringsubstringnocopy","text":"Restriction: This system property is supported only on Java\u2122 8. String sharing cannot be enabled on Java 11 and later. Setting this property to true avoids sharing a String object when substring() is used to subset a String beginning from offset zero. Avoiding sharing is compatible with the Oracle HotSpot VM.","title":"-Djava.lang.string.substring.nocopy"},{"location":"djavalangstringsubstringnocopy/#syntax","text":"-Djava.lang.string.substring.nocopy=[true|false] Setting Effect Default true No sharing false Sharing yes","title":"Syntax"},{"location":"djdknativecbc/","text":"-Djdk.nativeCBC This option enables or disables OpenSSL native cryptographic support for the CBC algorithm. Syntax -Djdk.nativeCBC=[true|false] Setting value Default -Djdk.nativeCBC true yes -Djdk.nativeCBC false Explanation OpenSSL support is enabled by default for the CBC algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeCBC"},{"location":"djdknativecbc/#-djdknativecbc","text":"This option enables or disables OpenSSL native cryptographic support for the CBC algorithm.","title":"-Djdk.nativeCBC"},{"location":"djdknativecbc/#syntax","text":"-Djdk.nativeCBC=[true|false] Setting value Default -Djdk.nativeCBC true yes -Djdk.nativeCBC false","title":"Syntax"},{"location":"djdknativecbc/#explanation","text":"OpenSSL support is enabled by default for the CBC algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativechacha20/","text":"-Djdk.nativeChaCha20 This option enables or disables OpenSSL native cryptographic support for the ChaCha20 and ChaCha20-Poly1305 algorithms. Restrictions: These algorithms are not supported on Java 8. These algorithms are not supported on OpenSSL 1.0.x. Syntax -Djdk.nativeChaCha20=[true|false] Setting value Default -Djdk.nativeChaCha20 true yes -Djdk.nativeChaCha20 false Explanation OpenSSL support is enabled by default for the ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off support for these algorithms only, set this option to false . To turn off support for these and other algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeChaCha20"},{"location":"djdknativechacha20/#-djdknativechacha20","text":"This option enables or disables OpenSSL native cryptographic support for the ChaCha20 and ChaCha20-Poly1305 algorithms. Restrictions: These algorithms are not supported on Java 8. These algorithms are not supported on OpenSSL 1.0.x.","title":"-Djdk.nativeChaCha20"},{"location":"djdknativechacha20/#syntax","text":"-Djdk.nativeChaCha20=[true|false] Setting value Default -Djdk.nativeChaCha20 true yes -Djdk.nativeChaCha20 false","title":"Syntax"},{"location":"djdknativechacha20/#explanation","text":"OpenSSL support is enabled by default for the ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off support for these algorithms only, set this option to false . To turn off support for these and other algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativecrypto/","text":"-Djdk.nativeCrypto This option controls the use of OpenSSL native cryptographic support. Syntax -Djdk.nativeCrypto=[true|false] Setting value Default -Djdk.nativeCrypto true yes -Djdk.nativeCrypto false Explanation OpenSSL support is enabled by default for the Digest, CBC, GCM, RSA, and ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off the OpenSSL implementation, set this option to false . Restriction: The ChaCha20 and ChaCha20-Poly1305 algorithms are not supported on Java 8. If you want to turn off the algorithms individually, use the following system properties: -Djdk.nativeCBC -Djdk.nativeChaCha20 ( Not supported on Java 8. ) -Djdk.nativeGCM -Djdk.nativeRSA -Djdk.nativeDigest","title":"-Djdk.nativeCrypto"},{"location":"djdknativecrypto/#-djdknativecrypto","text":"This option controls the use of OpenSSL native cryptographic support.","title":"-Djdk.nativeCrypto"},{"location":"djdknativecrypto/#syntax","text":"-Djdk.nativeCrypto=[true|false] Setting value Default -Djdk.nativeCrypto true yes -Djdk.nativeCrypto false","title":"Syntax"},{"location":"djdknativecrypto/#explanation","text":"OpenSSL support is enabled by default for the Digest, CBC, GCM, RSA, and ChaCha20 and ChaCha20-Poly1305 algorithms. If you want to turn off the OpenSSL implementation, set this option to false . Restriction: The ChaCha20 and ChaCha20-Poly1305 algorithms are not supported on Java 8. If you want to turn off the algorithms individually, use the following system properties: -Djdk.nativeCBC -Djdk.nativeChaCha20 ( Not supported on Java 8. ) -Djdk.nativeGCM -Djdk.nativeRSA -Djdk.nativeDigest","title":"Explanation"},{"location":"djdknativedigest/","text":"-Djdk.nativeDigest This option enables or disables OpenSSL native cryptographic support for the Digest algorithm. Syntax -Djdk.nativeDigest=[true|false] Setting value Default -Djdk.nativeDigest true yes -Djdk.nativeDigest false Explanation To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeDigest"},{"location":"djdknativedigest/#-djdknativedigest","text":"This option enables or disables OpenSSL native cryptographic support for the Digest algorithm.","title":"-Djdk.nativeDigest"},{"location":"djdknativedigest/#syntax","text":"-Djdk.nativeDigest=[true|false] Setting value Default -Djdk.nativeDigest true yes -Djdk.nativeDigest false","title":"Syntax"},{"location":"djdknativedigest/#explanation","text":"To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativegcm/","text":"-Djdk.nativeGCM This option enables or disables OpenSSL native cryptographic support for the GCM algorithm. Syntax -Djdk.nativeGCM=[true|false] Setting value Default -Djdk.nativeGCM true yes -Djdk.nativeGCM false Explanation OpenSSL support is enabled by default for the GCM algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeGCM"},{"location":"djdknativegcm/#-djdknativegcm","text":"This option enables or disables OpenSSL native cryptographic support for the GCM algorithm.","title":"-Djdk.nativeGCM"},{"location":"djdknativegcm/#syntax","text":"-Djdk.nativeGCM=[true|false] Setting value Default -Djdk.nativeGCM true yes -Djdk.nativeGCM false","title":"Syntax"},{"location":"djdknativegcm/#explanation","text":"OpenSSL support is enabled by default for the GCM algorithm. If you want to turn off this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"djdknativersa/","text":"-Djdk.nativeRSA This option enables or disables OpenSSL native cryptographic support for the RSA algorithm. Syntax -Djdk.nativeRSA=[true|false] Setting value Default -Djdk.nativeRSA true yes -Djdk.nativeRSA false Explanation OpenSSL support is enabled by default for the RSA algorithm. If you want to turn off support for this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"-Djdk.nativeRSA"},{"location":"djdknativersa/#-djdknativersa","text":"This option enables or disables OpenSSL native cryptographic support for the RSA algorithm.","title":"-Djdk.nativeRSA"},{"location":"djdknativersa/#syntax","text":"-Djdk.nativeRSA=[true|false] Setting value Default -Djdk.nativeRSA true yes -Djdk.nativeRSA false","title":"Syntax"},{"location":"djdknativersa/#explanation","text":"OpenSSL support is enabled by default for the RSA algorithm. If you want to turn off support for this algorithm only, set this option to false . To turn off all the algorithms, see the -Djdk.nativeCrypto system property command line option.","title":"Explanation"},{"location":"dump_heapdump/","text":"Heap dump Heap dumps contain a snapshot of all the live objects that are being used by a running Java\u2122 application on the Java heap. You can obtain detailed information for each object instance, such as the address, type, class name, or size, and whether the instance has references to other objects. There are two formats for heap dumps; the classic format and the Portable Heap Dump (PHD) format, which is the default. Whilst the classic format is generated in ascii text and can be read, the PHD format is binary and and must be processed for analysis. Obtaining dumps Heap dumps are generated by default in PHD format when the Java heap runs out of space. If you want to trigger the production of a heap dump in response to other situations, or in classic format, you can use one of the following options: Configure the heap dump agent. For more information, see the -Xdump option. Use the com.ibm.jvm.Dump API programmatically in your application code. For more information, see the JVM diagnostic utilities API documentation . Analyzing dumps The best method to analyze a PHD heap dump is to use the Eclipse Memory Analyzer tool (MAT) or the IBM Memory Analyzer tool . These tools process the dump file and provide a visual representation of the objects in the Java Heap. Both tools require the Diagnostic Tool Framework for Java (DTFJ) plugin. To install the DTFJ plugin in the Eclipse IDE, select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java The following sections contain detailed information about the content of each type of heap dump file. Portable Heap Dump (PHD) format A PHD format dump file contains a header section and a body section. The body section can contain information about object, array, or class records. Primitive numbers are used to describe the file format, as detailed in the following table: Primitive number Length in bytes byte 1 short 2 int 4 long 8 word 4 (32-bit platforms) or 8 (64-bit platforms) General structure The following structure comprises the header section of a PHD file: A UTF string indicating that the file is a portable heap dump An int containing the PHD version number An int containing flags: 1 indicates that the word length is 64-bit. 2 indicates that all the objects in the dump are hashed. This flag is set for heap dumps that use 16-bit hash codes. OpenJ9 heap dumps use 32-bit hash codes that are created only when used. For example, these hash codes are created when the APIs Object.hashCode() or Object.toString() are called in a Java application. If this flag is not set, the presence of a hash code is indicated by the hash code flag on the individual PHD records. 4 indicates that the dump is from an OpenJ9 VM. A byte containing a tag with a value of 1 that indicates the start of the header. A number of optional header records, each preceded by a one-byte header tag. Header record tags have a different range of values from the body, or object record tags. The end of the header is indicated by the end of header tag. The following tags are included: header tag 1 - not used header tag 2 - indicates the end of the header header tag 3 - not used header tag 4 - indicates the VM version (Variable length UTF string) The body of a PHD file is indicated by a byte that contains a tag with a value of 2, after which there are a number of dump records. Dump records are preceded by a 1 byte tag with the following record types: Short object: 0x80 bit of the tag is set Medium object: 0x40 bit of the tag is set (top bit value is 0) Primitive Array: 0x20 bit if the tag is set (all other tag values have the top 3 bits with a value of 0) Long record: tag value is 4 Class record: tag value is 6 Long primitive array: tag value is 7 Object array: tag value is 8 These records are described in more detail in the sections that follow. The end of the PHD body is indicated by a byte that contains a tag with a value of 3. Object records Object records can be short, medium, or long, depending on the number of object references in the heap dump. 1. Short object record The following information is contained within the tag byte: The 1 byte tag, which consists of the following bits: Bit number Value or description 1 Bit is set (0x80) 2 and 3 Indicates the class cache index. The value represents an index into a cache of the last 4 classes used. 4 and 5 Contain the number of references. Most objects contain 0 - 3 references. If there are 4 - 7 references, the Medium object record is used. If there are more than 7 references, the Long object record is used. 6 Indicates whether the gap is a 1 byte value or a short . The gap is the difference between the address of this object and the previous object. If set, the gap is a short . If the gap does not fit into a short , the Long object record format is used. 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object. The value is signed and represents the number of 32-bit words between the two addresses. Most gaps fit into 1 byte. If all objects are hashed, a short containing the hash code. The array of references, if references exist. The tag shows the number of elements, and the size of each element. The value in each element is the gap between the address of the references and the address of the current object. The value is a signed number of 32-bit words. Null references are not included. 2. Medium object record These records provide the actual address of the class rather than a cache index. The following format is used: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 0 2 Set (0x40) 3, 4, and 5 Contain the number of references 6 Indicates whether the gap is a 1 byte value or a short (see Short object record description) 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object (See the Short object record description) A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. The array of references (See the Short object record description). 3. Long object record This record format is used when there are more than 7 references, or if there are extra flags or a hash code. The following format is used: The 1 byte tag, containing the value 4. A byte containing flags, consisting of the following bits: Bit number Value or description 1 and 2 Indicates whether the gap is a byte , short , int or long format 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code 8 Indicates if the object was hashed A byte , short , int , or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An int containing the length of the array of references. The array of references (See the Short object record description). Array records PHD arrays can be primitive arrays or object arrays, as described in the sections that follow. 1. Primitive array record The following information is contained in an array record: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 and 2 0 3 Set (0x20) 4, 5, and 6 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 7 and 8 Indicates the length of the array size and the length of the gap (0= byte , 1= short , 2= int , 3= long ) byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). byte , short , int or long containing the array length. If all objects are hashed, a short containing the hash code. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 2. Long primitive array record This type of record is used when a primitive array has been hashed. The 1 byte tag with a value of 7. A byte containing the following flags: Bit number Value or description 1, 2, and 3 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 4 Indicates the length of the array size and the length of the gap (0= byte , 1= word ). 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed a byte or word containing the gap between the address of this object and the address of the preceding object (See the Short object record description). a byte or word containing the array length. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 3. Object array record The following format applies: The 1 byte tag with a value of 8. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte , short , int or long . 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed A byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record format description). A word containing the address of the class of the objects in the array. Object array records do not update the class cache. If all objects are hashed, a short containing the hash code. If the hashed and moved bit is set in the records flag, this field contains an int . An int containing the length of the array of references. The array of references (See the Short object record description). An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . An final int value is shown at the end. This int contains the true array length, shown as a number of array elements. The true array length might differ from the length of the array of references because null references are excluded. Class records The PHD class record encodes a class object and contains the following format: The 1 byte tag, containing the value 6. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte, short , int or long 3 and 4 Indicates the size of each static reference (0= byte , 1= short , 2= int , 3= long ) 5 Indicates if the object was hashed A byte, short , int or long containing the gap between the address of this class and the address of the preceding object (See the Short object record description). An int containing the instance size. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. A word containing the address of the superclass. A UTF string containing the name of this class. An int containing the number of static references. The array of static references (See the Short object record description). Classic Heap Dump format Classic heap dumps are produced in ascii text on all platforms except z/OS, which are encoded in EBCDIC. The dump is divided into the following sections: Header record A single string containing information about the runtime environment, platform, and build levels, similar to the following example: // Version: JRE 1.8.0 Linux amd64-64 (build 1.8.0_232-b09) Object records A record of each object instance in the heap with the following format: <object address, in hexadecimal> [<length in bytes of object instance, in decimal>] OBJ <object type> <heap reference, in hexadecimal> <heap reference, in hexadecimal> ... The following object types ( object type ) might be shown: class name (including package name) class array type primitive array type These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found are also listed, excluding references to an object's class or NULL references. The following example shows an object instance (16 bytes in length) of type java/lang/String , with a reference to a char array: 0x00000000E0000AF0 [16] OBJ java/lang/String 0x00000000E0000B00 The object instance (length 32 bytes) of type char array, as referenced from the java/lang/String , is shown in the following example: 0x00000000E0000B00 [32] OBJ [C The following example shows an object instance (24 bytes in length) of type array of java/lang/String : 0x00000000FFF07498 [24] OBJ [Ljava/lang/String; 0x00000000E0005D78 0x00000000E0005D50 0x00000000E0005D28 0x00000000E0005D00 Class records A record of each class in the following format: <class object address, in hexadecimal> [<length in bytes of class object, in decimal>] CLS <class type> <heap reference, in hexadecimal> <heap reference, in hexadecimal>... The following class types ( <class type> ) might be shown: class name (including package name) class array type primitive array types These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found in the class block are also listed, excluding NULL references. The following example shows a class object (80 bytes in length) for java/util/Date , with heap references: 0x00000000E00174F0 [80] CLS java/util/Date 0x00000000FFF1BB60 0x00000000FFF29630 Trailer record 1 A single record containing record counts, in decimal. For example: // Breakdown - Classes: 630, Objects: 3692, ObjectArrays: 576, PrimitiveArrays: 2249 Trailer record 2 A single record containing totals, in decimal. For example: // EOF: Total 'Objects',Refs(null) : 7147,22040(12379) The values in the example reflect the following counts: 7147 total objects 22040 total references (12379) total NULL references as a proportion of the total references count Java VM Type Signatures The following table shows the abbreviations used for different Java types in the heap dump records: Java VM Type Signature Java Type Z boolean B byte C char S short I int J long F float D double L<fully-qualified class>; <fully-qualified class> [<type> <type>[](array of <type>) (<arg-types>)<ret-type> method See also DTFJ interface","title":"Heap dump"},{"location":"dump_heapdump/#heap-dump","text":"Heap dumps contain a snapshot of all the live objects that are being used by a running Java\u2122 application on the Java heap. You can obtain detailed information for each object instance, such as the address, type, class name, or size, and whether the instance has references to other objects. There are two formats for heap dumps; the classic format and the Portable Heap Dump (PHD) format, which is the default. Whilst the classic format is generated in ascii text and can be read, the PHD format is binary and and must be processed for analysis.","title":"Heap dump"},{"location":"dump_heapdump/#obtaining-dumps","text":"Heap dumps are generated by default in PHD format when the Java heap runs out of space. If you want to trigger the production of a heap dump in response to other situations, or in classic format, you can use one of the following options: Configure the heap dump agent. For more information, see the -Xdump option. Use the com.ibm.jvm.Dump API programmatically in your application code. For more information, see the JVM diagnostic utilities API documentation .","title":"Obtaining dumps"},{"location":"dump_heapdump/#analyzing-dumps","text":"The best method to analyze a PHD heap dump is to use the Eclipse Memory Analyzer tool (MAT) or the IBM Memory Analyzer tool . These tools process the dump file and provide a visual representation of the objects in the Java Heap. Both tools require the Diagnostic Tool Framework for Java (DTFJ) plugin. To install the DTFJ plugin in the Eclipse IDE, select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java The following sections contain detailed information about the content of each type of heap dump file.","title":"Analyzing dumps"},{"location":"dump_heapdump/#portable-heap-dump-phd-format","text":"A PHD format dump file contains a header section and a body section. The body section can contain information about object, array, or class records. Primitive numbers are used to describe the file format, as detailed in the following table: Primitive number Length in bytes byte 1 short 2 int 4 long 8 word 4 (32-bit platforms) or 8 (64-bit platforms)","title":"Portable Heap Dump (PHD) format"},{"location":"dump_heapdump/#general-structure","text":"The following structure comprises the header section of a PHD file: A UTF string indicating that the file is a portable heap dump An int containing the PHD version number An int containing flags: 1 indicates that the word length is 64-bit. 2 indicates that all the objects in the dump are hashed. This flag is set for heap dumps that use 16-bit hash codes. OpenJ9 heap dumps use 32-bit hash codes that are created only when used. For example, these hash codes are created when the APIs Object.hashCode() or Object.toString() are called in a Java application. If this flag is not set, the presence of a hash code is indicated by the hash code flag on the individual PHD records. 4 indicates that the dump is from an OpenJ9 VM. A byte containing a tag with a value of 1 that indicates the start of the header. A number of optional header records, each preceded by a one-byte header tag. Header record tags have a different range of values from the body, or object record tags. The end of the header is indicated by the end of header tag. The following tags are included: header tag 1 - not used header tag 2 - indicates the end of the header header tag 3 - not used header tag 4 - indicates the VM version (Variable length UTF string) The body of a PHD file is indicated by a byte that contains a tag with a value of 2, after which there are a number of dump records. Dump records are preceded by a 1 byte tag with the following record types: Short object: 0x80 bit of the tag is set Medium object: 0x40 bit of the tag is set (top bit value is 0) Primitive Array: 0x20 bit if the tag is set (all other tag values have the top 3 bits with a value of 0) Long record: tag value is 4 Class record: tag value is 6 Long primitive array: tag value is 7 Object array: tag value is 8 These records are described in more detail in the sections that follow. The end of the PHD body is indicated by a byte that contains a tag with a value of 3.","title":"General structure"},{"location":"dump_heapdump/#object-records","text":"Object records can be short, medium, or long, depending on the number of object references in the heap dump. 1. Short object record The following information is contained within the tag byte: The 1 byte tag, which consists of the following bits: Bit number Value or description 1 Bit is set (0x80) 2 and 3 Indicates the class cache index. The value represents an index into a cache of the last 4 classes used. 4 and 5 Contain the number of references. Most objects contain 0 - 3 references. If there are 4 - 7 references, the Medium object record is used. If there are more than 7 references, the Long object record is used. 6 Indicates whether the gap is a 1 byte value or a short . The gap is the difference between the address of this object and the previous object. If set, the gap is a short . If the gap does not fit into a short , the Long object record format is used. 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object. The value is signed and represents the number of 32-bit words between the two addresses. Most gaps fit into 1 byte. If all objects are hashed, a short containing the hash code. The array of references, if references exist. The tag shows the number of elements, and the size of each element. The value in each element is the gap between the address of the references and the address of the current object. The value is a signed number of 32-bit words. Null references are not included. 2. Medium object record These records provide the actual address of the class rather than a cache index. The following format is used: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 0 2 Set (0x40) 3, 4, and 5 Contain the number of references 6 Indicates whether the gap is a 1 byte value or a short (see Short object record description) 7 and 8 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) A byte or a short containing the gap between the address of this object and the address of the preceding object (See the Short object record description) A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. The array of references (See the Short object record description). 3. Long object record This record format is used when there are more than 7 references, or if there are extra flags or a hash code. The following format is used: The 1 byte tag, containing the value 4. A byte containing flags, consisting of the following bits: Bit number Value or description 1 and 2 Indicates whether the gap is a byte , short , int or long format 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code 8 Indicates if the object was hashed A byte , short , int , or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). A word containing the address of the class of this object. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An int containing the length of the array of references. The array of references (See the Short object record description).","title":"Object records"},{"location":"dump_heapdump/#array-records","text":"PHD arrays can be primitive arrays or object arrays, as described in the sections that follow. 1. Primitive array record The following information is contained in an array record: The 1 byte tag, consisting of the following bits: Bit number Value or description 1 and 2 0 3 Set (0x20) 4, 5, and 6 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 7 and 8 Indicates the length of the array size and the length of the gap (0= byte , 1= short , 2= int , 3= long ) byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record description). byte , short , int or long containing the array length. If all objects are hashed, a short containing the hash code. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 2. Long primitive array record This type of record is used when a primitive array has been hashed. The 1 byte tag with a value of 7. A byte containing the following flags: Bit number Value or description 1, 2, and 3 Contains the array type ( 0=bool, 1=char, 2=float, 3=double, 4= byte , 5= short , 6= int , and 7= long ) 4 Indicates the length of the array size and the length of the gap (0= byte , 1= word ). 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed a byte or word containing the gap between the address of this object and the address of the preceding object (See the Short object record description). a byte or word containing the array length. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . 3. Object array record The following format applies: The 1 byte tag with a value of 8. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte , short , int or long . 3 and 4 Indicates the size of each reference (0= byte , 1= short , 2= int , 3= long ) 5 and 6 Unused 7 Indicates if the object was hashed and moved. If this bit is set, the record includes the hash code. 8 Indicates if the object was hashed A byte , short , int or long containing the gap between the address of this object and the address of the preceding object (See the Short object record format description). A word containing the address of the class of the objects in the array. Object array records do not update the class cache. If all objects are hashed, a short containing the hash code. If the hashed and moved bit is set in the records flag, this field contains an int . An int containing the length of the array of references. The array of references (See the Short object record description). An unsigned int containing the size of the instance of the array on the heap, including header and padding. The size is measured in 32-bit words, which you can multiply by four to obtain the size in bytes. This format allows encoding of lengths up to 16GB in an unsigned int . An final int value is shown at the end. This int contains the true array length, shown as a number of array elements. The true array length might differ from the length of the array of references because null references are excluded.","title":"Array records"},{"location":"dump_heapdump/#class-records","text":"The PHD class record encodes a class object and contains the following format: The 1 byte tag, containing the value 6. A byte containing the following flags: Bit number Value or description 1 and 2 Indicates whether the gap is byte, short , int or long 3 and 4 Indicates the size of each static reference (0= byte , 1= short , 2= int , 3= long ) 5 Indicates if the object was hashed A byte, short , int or long containing the gap between the address of this class and the address of the preceding object (See the Short object record description). An int containing the instance size. If all objects are hashed, a short containing the hash code. Otherwise, an optional int containing the hash code if the hashed and moved bit is set in the record flag byte. A word containing the address of the superclass. A UTF string containing the name of this class. An int containing the number of static references. The array of static references (See the Short object record description).","title":"Class records"},{"location":"dump_heapdump/#classic-heap-dump-format","text":"Classic heap dumps are produced in ascii text on all platforms except z/OS, which are encoded in EBCDIC. The dump is divided into the following sections:","title":"Classic Heap Dump format"},{"location":"dump_heapdump/#header-record","text":"A single string containing information about the runtime environment, platform, and build levels, similar to the following example: // Version: JRE 1.8.0 Linux amd64-64 (build 1.8.0_232-b09)","title":"Header record"},{"location":"dump_heapdump/#object-records_1","text":"A record of each object instance in the heap with the following format: <object address, in hexadecimal> [<length in bytes of object instance, in decimal>] OBJ <object type> <heap reference, in hexadecimal> <heap reference, in hexadecimal> ... The following object types ( object type ) might be shown: class name (including package name) class array type primitive array type These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found are also listed, excluding references to an object's class or NULL references. The following example shows an object instance (16 bytes in length) of type java/lang/String , with a reference to a char array: 0x00000000E0000AF0 [16] OBJ java/lang/String 0x00000000E0000B00 The object instance (length 32 bytes) of type char array, as referenced from the java/lang/String , is shown in the following example: 0x00000000E0000B00 [32] OBJ [C The following example shows an object instance (24 bytes in length) of type array of java/lang/String : 0x00000000FFF07498 [24] OBJ [Ljava/lang/String; 0x00000000E0005D78 0x00000000E0005D50 0x00000000E0005D28 0x00000000E0005D00","title":"Object records"},{"location":"dump_heapdump/#class-records_1","text":"A record of each class in the following format: <class object address, in hexadecimal> [<length in bytes of class object, in decimal>] CLS <class type> <heap reference, in hexadecimal> <heap reference, in hexadecimal>... The following class types ( <class type> ) might be shown: class name (including package name) class array type primitive array types These types are abbreviated in the record. To determine the type, see the Java VM Type Signature table . Any references found in the class block are also listed, excluding NULL references. The following example shows a class object (80 bytes in length) for java/util/Date , with heap references: 0x00000000E00174F0 [80] CLS java/util/Date 0x00000000FFF1BB60 0x00000000FFF29630","title":"Class records"},{"location":"dump_heapdump/#trailer-record-1","text":"A single record containing record counts, in decimal. For example: // Breakdown - Classes: 630, Objects: 3692, ObjectArrays: 576, PrimitiveArrays: 2249","title":"Trailer record 1"},{"location":"dump_heapdump/#trailer-record-2","text":"A single record containing totals, in decimal. For example: // EOF: Total 'Objects',Refs(null) : 7147,22040(12379) The values in the example reflect the following counts: 7147 total objects 22040 total references (12379) total NULL references as a proportion of the total references count","title":"Trailer record 2"},{"location":"dump_heapdump/#java-vm-type-signatures","text":"The following table shows the abbreviations used for different Java types in the heap dump records: Java VM Type Signature Java Type Z boolean B byte C char S short I int J long F float D double L<fully-qualified class>; <fully-qualified class> [<type> <type>[](array of <type>) (<arg-types>)<ret-type> method","title":"Java VM Type Signatures"},{"location":"dump_heapdump/#see-also","text":"DTFJ interface","title":"See also"},{"location":"dump_javadump/","text":"Java dump Java dumps, sometimes referred to as Java cores , are produced when the VM ends unexpectedly because of an operating system signal, OutOfMemoryError , or a user-initiated keystroke combination. You can also generate a Java dump by calling the Dump API programmatically from your application or specifying the -Xdump:java option on the command line. If your Java application crashes or hangs, Java dumps can provide useful information to help you diagnose the root cause. If your application crashes, Java dumps are generated automatically for the following types of failure: the VM receives an unexpected signal or an assertion failure the VM runs out of memory If your application hangs, you can trigger the generation of a Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. Note: On Windows, if you started the VM in a console window you can force the VM to produce a Java dump in response to a SIGBREAK signal (Ctrl-Break keyboard combination). If you didn't start in a console window there is no equivalent to a Linux kill command on Windows for sending signals. The only option here is to trigger a full system dump by finding the VM process in the Processes tab of the Windows Task Manager and clicking Create dump file . To help you understand how a Java dump can help you with problem diagnosis, this topic includes a few scenarios to help you interpret the data: A crash caused by a general protection fault (gpf) A Java heap OutOfMemoryError (OOM) A native OutOfMemoryError (OOM) A deadlock situation A hang Java dump contents Java dumps summarize the state of the VM when the event occurs, with most of the information relating to components of the VM. The file is made up of a number of sections that provide different types of information. TITLE The first section of the Java dump file provides information about the event that triggered the production of the dump. In the following example you can see that a vmstop event triggered the dump at a specified date and time. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"vmstop\" (00000002) Detail \"#0000000000000000\" received 1TIDATETIME Date: 2018/08/30 at 21:55:47:607 1TINANOTIME System nanotime: 22012355276134 1TIFILENAME Javacore filename: /home/doc-javacore/javacore.20180830.215547.30285.0001.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x106 (vm_access+exclusive_vm_access+trace_disabled) GPINFO The GPINFO section provides general information about the system that the VM is running on. The following example is taken from a Java dump that was generated on a Linux system. NULL ------------------------------------------------------------------------ 0SECTION GPINFO subcomponent dump routine NULL ================================ 2XHOSLEVEL OS Level : Linux 3.10.0-862.11.6.el7.x86_64 2XHCPUS Processors - 3XHCPUARCH Architecture : amd64 3XHNUMCPUS How Many : 4 3XHNUMASUP NUMA is either not supported or has been disabled by user NULL 1XHERROR2 Register dump section only produced for SIGSEGV, SIGILL or SIGFPE. NULL The content of this section can vary, depending on the cause of the dump. For example, if the dump was caused by a general protection fault (gpf), the library in which the crash occurred is also recorded, together with a value shown as VM flags . This value can provide some clues about which component of the VM might have been involved. Look for the following line in the output: 1XHFLAGS VM flags:0000000000000000 The hexadecimal number recorded for VM flags ends in MSSSS, where M is the VM component and SSSS is component-specific code as shown in the following table: Component Code value INTERPRETER 0x10000 GC 0x20000 GROW_STACK 0x30000 JNI 0x40000 JIT_CODEGEN 0x50000 BCVERIFY 0x60000 RTVERIFY 0x70000 SHAREDCLASSES 0x80000 A value of 0000000000000000 (0x00000) indicates that a crash occurred outside of the VM. ENVINFO This section contains useful information about the environment in which the crash took place, including the following data: Java version ( 1CIJAVAVERSION ) OpenJ9 VM and subcomponent version information ( 1CIVMVERSION , 1CIJ9VMVERSION , 1CIJITVERSION , 1CIOMRVERSION , 1CIJCLVERSION ) VM start time ( 1CISTARTTIME ) and process information ( 1CIPROCESSID ) Java home ( 1CIJAVAHOMEDIR ) and DLL ( 1CIJAVADLLDIR ) directories User arguments passed on the command line ( 1CIUSERARG ) User limits imposed by the system ( 1CIUSERLIMITS ) Environment variables in place ( 1CIENVVARS ) System information ( 1CISYSINFO ) CPU information ( 1CICPUINFO ) Control group (Cgroup) information ( 1CICGRPINFO ) For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION ENVINFO subcomponent dump routine NULL ================================= 1CIJAVAVERSION JRE 9 Linux amd64-64 (build 9.0.4-internal+0-adhoc..openj9-openjdk-jdk9) 1CIVMVERSION 20180830_000000 1CIJ9VMVERSION 8e7c6ec 1CIJITVERSION 8e7c6ec 1CIOMRVERSION 553811b_CMPRSS 1CIJCLVERSION ec1d223 based on jdk-9.0.4+12 1CIJITMODES JIT enabled, AOT enabled, FSD disabled, HCR enabled 1CIRUNNINGAS Running as a standalone JVM 1CIVMIDLESTATE VM Idle State: ACTIVE 1CICONTINFO Running in container : FALSE 1CICGRPINFO JVM support for cgroups enabled : TRUE 1CISTARTTIME JVM start time: 2018/08/30 at 21:55:47:387 1CISTARTNANO JVM start nanotime: 22012135233549 1CIPROCESSID Process ID: 30285 (0x764D) 1CICMDLINE [not available] 1CIJAVAHOMEDIR Java Home Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk 1CIJAVADLLDIR Java DLL Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/bin 1CISYSCP Sys Classpath: 1CIUSERARGS UserArgs: 2CIUSERARG -Xoptionsfile=/home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/options.default ... NULL 1CIUSERLIMITS User Limits (in bytes except for NOFILE and NPROC) NULL ------------------------------------------------------------------------ NULL type soft limit hard limit 2CIUSERLIMIT RLIMIT_AS unlimited unlimited 2CIUSERLIMIT RLIMIT_CORE 0 unlimited 2CIUSERLIMIT RLIMIT_CPU unlimited unlimited 2CIUSERLIMIT RLIMIT_DATA unlimited unlimited 2CIUSERLIMIT RLIMIT_FSIZE unlimited unlimited 2CIUSERLIMIT RLIMIT_LOCKS unlimited unlimited 2CIUSERLIMIT RLIMIT_MEMLOCK 65536 65536 2CIUSERLIMIT RLIMIT_NOFILE 4096 4096 2CIUSERLIMIT RLIMIT_NPROC 4096 30592 2CIUSERLIMIT RLIMIT_RSS unlimited unlimited 2CIUSERLIMIT RLIMIT_STACK 8388608 unlimited 2CIUSERLIMIT RLIMIT_MSGQUEUE 819200 819200 2CIUSERLIMIT RLIMIT_NICE 0 0 2CIUSERLIMIT RLIMIT_RTPRIO 0 0 2CIUSERLIMIT RLIMIT_SIGPENDING 30592 30592 NULL 1CIENVVARS Environment Variables NULL ------------------------------------------------------------------------ 2CIENVVAR XDG_VTNR=1 2CIENVVAR SSH_AGENT_PID=2653 ... NULL 1CISYSINFO System Information NULL ------------------------------------------------------------------------ 2CISYSINFO /proc/sys/kernel/core_pattern = core 2CISYSINFO /proc/sys/kernel/core_uses_pid = 1 NULL 1CICPUINFO CPU Information NULL ------------------------------------------------------------------------ 2CIPHYSCPU Physical CPUs: 4 2CIONLNCPU Online CPUs: 4 2CIBOUNDCPU Bound CPUs: 4 2CIACTIVECPU Active CPUs: 0 2CITARGETCPU Target CPUs: 4 NULL 1CICGRPINFO Cgroup Information NULL ------------------------------------------------------------------------ 2CICGRPINFO subsystem : cpu 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU Period : 100000 microseconds 3CICGRPINFO CPU Quota : Not Set 3CICGRPINFO CPU Shares : 1024 3CICGRPINFO Period intervals elapsed count : 0 3CICGRPINFO Throttled count : 0 3CICGRPINFO Total throttle time : 0 nanoseconds 2CICGRPINFO subsystem : cpuset 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU exclusive : 1 3CICGRPINFO Mem exclusive : 1 3CICGRPINFO CPUs : 0-3 3CICGRPINFO Mems : 0 2CICGRPINFO subsystem : memory 2CICGRPINFO cgroup name : / 3CICGRPINFO Memory Limit : Not Set 3CICGRPINFO Memory + Swap Limit : Not Set 3CICGRPINFO Memory Usage : 5363396608 bytes 3CICGRPINFO Memory + Swap Usage : 5363396608 bytes 3CICGRPINFO Memory Max Usage : 0 bytes 3CICGRPINFO Memory + Swap Max Usage : 0 bytes 3CICGRPINFO Memory limit exceeded count : 0 3CICGRPINFO Memory + Swap limit exceeded count : 0 3CICGRPINFO OOM Killer Disabled : 0 3CICGRPINFO Under OOM : 0 NULL NATIVEMEMINFO This section records information about native memory that is requested by using library functions such as malloc() and mmap() . Values are provided as a breakdown, per component, indicating the total number of bytes allocated and the number of native memory allocations. In the following example, 4,682,840 bytes of native memory are allocated (but not yet freed) to VM Classes, which corresponds to 141 allocations. NULL ------------------------------------------------------------------------ 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 2,569,088,312 bytes / 4653 allocations 1MEMUSER | 2MEMUSER +--VM: 2,280,088,336 bytes / 2423 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 4,682,840 bytes / 141 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 2,054,966,784 bytes / 433 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 2,014,113,792 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 40,852,992 bytes / 432 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,970,016 bytes / 156 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 197,760 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 155,424 bytes / 123 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 180,056 bytes / 263 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,776 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 36,184 bytes / 52 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 208,179,632 bytes / 72 allocations 3MEMUSER | | | 4MEMUSER | | +--Unused <32bit allocation regions: 208,168,752 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,880 bytes / 71 allocations 2MEMUSER | | 3MEMUSER | +--Other: 1,055,048 bytes / 1293 allocations 1MEMUSER | 2MEMUSER +--JIT: 288,472,816 bytes / 140 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 268,435,456 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 2,097,216 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 17,940,144 bytes / 138 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 13,432 bytes / 25 allocations 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 13,432 bytes / 25 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 3,184 bytes / 13 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 1,056 bytes / 12 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Other: 2,128 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,248 bytes / 12 allocations 1MEMUSER | 2MEMUSER +--Unknown: 513,728 bytes / 2065 allocations NULL This section does not record memory that is allocated by application or JNI code and is typically a little less than the value recorded by operating system tools. MEMINFO This section relates to memory management, providing a breakdown of memory usage in the VM for the object heap, internal memory, memory used for classes, the JIT code cache, and JIT data cache in decimal and hexadecimal format. You can also find out which garbage collection policy is in use when the dump is produced. The object memory area ( 1STHEAPTYPE ) records each memory region in use, its start and end address, and region size. Further information is recorded about the memory segments used for internal memory, class memory, the JIT code cache and JIT data cache ( 1STSEGMENT ). This information includes the address of the segment control data structure, the start and end address of the native memory segment, as well as the segment size. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0x00007FF4F00744A0 -- -- -- Generational 1STHEAPREGION 0x00007FF4F0074CE0 0x0000000087F40000 0x0000000088540000 0x0000000000600000 Generational/Tenured Region 1STHEAPREGION 0x00007FF4F0074930 0x00000000FFE00000 0x00000000FFF00000 0x0000000000100000 Generational/Nursery Region 1STHEAPREGION 0x00007FF4F0074580 0x00000000FFF00000 0x0000000100000000 0x0000000000100000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 8388608 (0x0000000000800000) 1STHEAPINUSE Total memory in use: 2030408 (0x00000000001EFB48) 1STHEAPFREE Total memory free: 6358200 (0x00000000006104B8) NULL 1STSEGTYPE Internal Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F004CBC8 0x00007FF4CD33C000 0x00007FF4CD33C000 0x00007FF4CE33C000 0x01000440 0x0000000001000000 1STSEGMENT 0x00007FF4F004CB08 0x00007FF4DE43D030 0x00007FF4DE517770 0x00007FF4DE53D030 0x00800040 0x0000000000100000 NULL 1STSEGTOTAL Total memory: 17825792 (0x0000000001100000) 1STSEGINUSE Total memory in use: 894784 (0x00000000000DA740) 1STSEGFREE Total memory free: 16931008 (0x00000000010258C0) NULL 1STSEGTYPE Class Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F03B5638 0x0000000001053D98 0x000000000105BD98 0x000000000105BD98 0x00010040 0x0000000000008000 1STSEGMENT 0x00007FF4F03B5578 0x0000000001048188 0x0000000001050188 0x0000000001050188 0x00010040 0x0000000000008000 ... NULL 1STSEGTOTAL Total memory: 3512520 (0x00000000003598C8) 1STSEGINUSE Total memory in use: 3433944 (0x00000000003465D8) 1STSEGFREE Total memory free: 78576 (0x00000000000132F0) NULL 1STSEGTYPE JIT Code Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F00961F8 0x00007FF4CE43D000 0x00007FF4CE445790 0x00007FF4DE43D000 0x00000068 0x0000000010000000 NULL 1STSEGTOTAL Total memory: 268435456 (0x0000000010000000) 1STSEGINUSE Total memory in use: 34704 (0x0000000000008790) 1STSEGFREE Total memory free: 268400752 (0x000000000FFF7870) 1STSEGLIMIT Allocation limit: 268435456 (0x0000000010000000) NULL 1STSEGTYPE JIT Data Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F0096668 0x00007FF4CC553030 0x00007FF4CC753030 0x00007FF4CC753030 0x00000048 0x0000000000200000 NULL 1STSEGTOTAL Total memory: 2097152 (0x0000000000200000) 1STSEGINUSE Total memory in use: 2097152 (0x0000000000200000) 1STSEGFREE Total memory free: 0 (0x0000000000000000) 1STSEGLIMIT Allocation limit: 402653184 (0x0000000018000000) NULL 1STGCHTYPE GC History NULL In the example, the GC History ( 1STGCHTYPE ) section is blank. This section is populated if a garbage collection cycle occurred in a VM that is being diagnosed with the trace facility. LOCKS This section of the Java dump provides information about locks, which protect shared resources from being accessed by more than one entity at a time. The information is essential in a deadlock situation, where two threads attempt to synchronize on an object and lock an instance of a class. Precise information is recorded about the threads that are causing the problem, which enables you to identify the root cause. The following example shows a typical LOCKS section, where no deadlocks existed at the time the dump was triggered. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 3 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x00007FF4B0001D78 infl_mon_t: 0x00007FF4B0001DF8: 3LKMONOBJECT java/lang/ref/ReferenceQueue@0x00000000FFE26A10: <unowned> 3LKNOTIFYQ Waiting to be notified: 3LKWAITNOTIFY \"Common-Cleaner\" (J9VMThread:0x0000000000FD0100) NULL 1LKREGMONDUMP JVM System Monitor Dump (registered monitors): 2LKREGMON Thread global lock (0x00007FF4F0004FE8): <unowned> 2LKREGMON &(PPG_mem_mem32_subAllocHeapMem32.monitor) lock (0x00007FF4F0005098): <unowned> 2LKREGMON NLS hash table lock (0x00007FF4F0005148): <unowned> ... NULL THREADS The THREADS section of a Java dump file provides summary information about the VM thread pool and detailed information about Java threads, native threads, and stack traces. Understanding the content of this section can help you diagnose problems that are caused by blocked or waiting threads. A Java thread runs on a native thread. Several lines are recorded for each Java thread in the Thread Details subsection, which include the following key pieces of information: 3XMTHREADINFO : The thread name, address information for the VM thread structures and Java thread object, the thread state, and thread priority. 3XMJAVALTHREAD : The Java thread ID and daemon status from the thread object. 3XMTHREADINFO1 : The native operating system thread ID, priority, scheduling policy, internal VM thread state, and VM thread flags. 3XMTHREADINFO2 : The native stack address range. 3XMTHREADINFO3 : Java callstack information ( 4XESTACKTRACE ) or Native call stack information ( 4XENATIVESTACK ). 5XESTACKTRACE : This line indicates whether locks were taken by a specific method. Java thread priorities are mapped to operating system priority values. Thread states are shown in the following table: Thread state value Status Description R Runnable The thread is able to run CW Condition Wait The thread is waiting S Suspended The thread is suspended by another thread Z Zombie The thread is destroyed P Parked The thread is parked by java.util.concurrent B Blocked The thread is waiting to obtain a lock For threads that are parked (P), blocked (B), or waiting (CW), an additional line ( 3XMTHREADBLOCK ) is included in the output that shows what the thread is parked on, blocked on, or waiting for. For clarity, the following example shows a shortened version of a typical THREADS section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 18 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMTHDINFO Thread Details NULL 3XMTHREADINFO \"JIT Diagnostic Compilation Thread-7 Suspended\" J9VMThread:0x0000000000EFC500, omrthread_t:0x00007FF4F00A77E8, java/lang/Thread:0x00000000FFE97480, state:R, prio=10 3XMJAVALTHREAD (java/lang/Thread getId:0xA, isDaemon:true) 3XMTHREADINFO1 (native thread ID:0x7657, native priority:0xB, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000081) 3XMTHREADINFO2 (native stack address range from:0x00007FF4CCC36000, to:0x00007FF4CCD36000, size:0x100000) 3XMCPUTIME CPU usage total: 0.000037663 secs, current category=\"JIT\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 No Java callstack associated with this thread 3XMTHREADINFO3 No native callstack available for this thread NULL ... 3XMTHREADINFO \"Common-Cleaner\" J9VMThread:0x0000000000FD0100, omrthread_t:0x00007FF4F022A520, java/lang/Thread:0x00000000FFE26F40, state:CW, prio=8 3XMJAVALTHREAD (java/lang/Thread getId:0x2, isDaemon:true) 3XMTHREADINFO1 (native thread ID:0x765A, native priority:0x8, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00080181) 3XMTHREADINFO2 (native stack address range from:0x00007FF4CC0B8000, to:0x00007FF4CC0F8000, size:0x40000) 3XMCPUTIME CPU usage total: 0.000150926 secs, current category=\"Application\" 3XMTHREADBLOCK Waiting on: java/lang/ref/ReferenceQueue@0x00000000FFE26A10 Owned by: <unowned> 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Object.wait(Native Method) 4XESTACKTRACE at java/lang/Object.wait(Object.java:221) 4XESTACKTRACE at java/lang/ref/ReferenceQueue.remove(ReferenceQueue.java:138) 5XESTACKTRACE (entered lock: java/lang/ref/ReferenceQueue@0x00000000FFE26A10, entry count: 1) 4XESTACKTRACE at jdk/internal/ref/CleanerImpl.run(CleanerImpl.java:148) 4XESTACKTRACE at java/lang/Thread.run(Thread.java:835) 4XESTACKTRACE at jdk/internal/misc/InnocuousThread.run(InnocuousThread.java:122) 3XMTHREADINFO3 No native callstack available for this thread NULL NULL 3XMTHREADINFO \"IProfiler\" J9VMThread:0x0000000000F03D00, omrthread_t:0x00007FF4F00B06F8, java/lang/Thread:0x00000000FFE97B60, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0xC, isDaemon:true) 3XMTHREADINFO1 (native thread ID:0x7659, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000081) 3XMTHREADINFO2 (native stack address range from:0x00007FF4F8940000, to:0x00007FF4F8960000, size:0x20000) 3XMCPUTIME CPU usage total: 0.004753103 secs, current category=\"JIT\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 No Java callstack associated with this thread 3XMTHREADINFO3 No native callstack available for this thread NULL ... 1XMWLKTHDERR The following was reported while collecting native stacks: 2XMWLKTHDERR unable to count threads(3, -2) NULL 1XMTHDSUMMARY Threads CPU Usage Summary NULL ========================= NULL 1XMTHDCATINFO Warning: to get more accurate CPU times for the GC, the option -XX:-ReduceCPUMonitorOverhead can be used. See the user guide for more information. NULL 1XMTHDCATEGORY All JVM attached threads: 0.280083000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--System-JVM: 0.270814000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--GC: 0.000599000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--JIT: 0.071904000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--Application: 0.009269000 secs NULL HOOKS This section shows internal VM event callbacks, which are used for diagnosing performance problems in the VM. Multiple hook interfaces are listed, which include their individual hook events. The following example shows data for the J9VMHookInterface , including the total time for all previous events, the call site location (<source file>:<line number>), start time, and duration of the last callback and the longest callback (all times measured in microseconds). The hook data is reset after each Java dump. NULL ------------------------------------------------------------------------ SECTION HOOK subcomponent dump routine NULL ========================= 1NOTE These data are reset every time a javacore is taken 1HKINTERFACE MM_OMRHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_PrivateHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_HookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9VMHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 1 3HKCALLCOUNT 1239 3HKTOTALTIME 219564us 3HKLAST Last Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T00:15:14.664 4HKDURATION Duration : 16us 3HKLONGST Longest Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T21:28:34.895 4HKDURATION Duration : 5012us NULL ... 1HKINTERFACE J9VMZipCachePoolHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9JITHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 3 3HKCALLCOUNT 3113 3HKTOTALTIME 4904us 3HKLAST Last Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:04:15.320 4HKDURATION Duration : 3us 3HKLONGST Longest Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:37:17.633 4HKDURATION Duration : 27us NULL ... SHARED CLASSES If the shared classes cache is enabled at run time, the information provided in a Java dump file describes settings that were used when creating the cache, together with summary information about the size and content of the cache. In the following example, the shared classes cache was created with a Class Debug Area ( -Xnolinenumbers=false ). Byte code instrumentation (BCI) is enabled, which is the default, and VMs sharing the cache are allowed to store classpaths, which is also the default. The Cache Summary shows a cache size ( 2SCLTEXTCSZ ) of 16776608 bytes, with a soft maximum size ( 2SCLTEXTSMB ) also of 16776608 bytes, which leaves 12691668 bytes of free space ( 2SCLTEXTFRB ). The size of the Class Debug Area ( 2SCLTEXTDAS ) is 1331200 bytes and only 11% of this space is used. In the Cache Memory Status subsection, the line 2SCLTEXTCMDT indicates the name and location of the shared cache and cr indicates that the cache is a 64-bit compressed references cache. NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = true NULL 2SCLTEXTRCS ROMClass start address = 0x00007F423061C000 2SCLTEXTRCE ROMClass end address = 0x00007F42307B9A28 2SCLTEXTMSA Metadata start address = 0x00007F42313D42FC 2SCLTEXTCEA Cache end address = 0x00007F4231600000 2SCLTEXTRTF Runtime flags = 0x00102001ECA6028B 2SCLTEXTCGN Cache generation = 35 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 12691668 2SCLTEXTRCB ROMClass bytes = 1694248 2SCLTEXTAOB AOT code bytes = 0 2SCLTEXTADB AOT data bytes = 0 2SCLTEXTAHB AOT class hierarchy bytes = 32 2SCLTEXTATB AOT thunk bytes = 0 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJHB JIT hint bytes = 308 2SCLTEXTJPB JIT profile bytes = 2296 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 919328 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 2SCLTEXTMDA Metadata bytes = 23448 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 11% 2SCLTEXTDAN Class LineNumberTable bytes = 156240 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 595 2SCLTEXTNAM Number AOT Methods = 0 2SCLTEXTNAD Number AOT Data Entries = 0 2SCLTEXTNAH Number AOT Class Hierarchy = 1 2SCLTEXTNAT Number AOT Thunks = 0 2SCLTEXTNJH Number JIT Hints = 14 2SCLTEXTNJP Number JIT Profiles = 20 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 5 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0% NULL 2SCLTEXTCPF Cache is 24% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT sharedcc_doc-javacore CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_sharedcc_doc-javacore_G35 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL The following example shows information for a layered cache: NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCSTL Cache Statistics for Top Layer NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = false NULL 2SCLTEXTRCS ROMClass start address = 0x00007F0EDB567000 2SCLTEXTRCE ROMClass end address = 0x00007F0EDB567000 2SCLTEXTMSA Metadata start address = 0x00007F0EDC40241C 2SCLTEXTCEA Cache end address = 0x00007F0EDC54B000 2SCLTEXTRTF Runtime flags = 0x80102001ECA602BB 2SCLTEXTCGN Cache generation = 41 2SCLTEXTCLY Cache layer = 1 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 15315996 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 0% 2SCLTEXTDAN Class LineNumberTable bytes = 0 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTCPF Cache is 8% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT Cache1 CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_Cache1_G41L01 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL 1SCLTEXTCSAL Cache Statistics for All Layers NULL 2SCLTEXTRCB ROMClass bytes = 1459040 2SCLTEXTAOB AOT code bytes = 57624 2SCLTEXTADB AOT data bytes = 272 2SCLTEXTAHB AOT class hierarchy bytes = 1840 2SCLTEXTATB AOT thunk bytes = 632 2SCLTEXTJHB JIT hint bytes = 484 2SCLTEXTJPB JIT profile bytes = 0 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 1134016 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 503 2SCLTEXTNAM Number AOT Methods = 16 2SCLTEXTNAD Number AOT Data Entries = 1 2SCLTEXTNAH Number AOT Class Hierarchy = 28 2SCLTEXTNAT Number AOT Thunks = 11 2SCLTEXTNJH Number JIT Hints = 15 2SCLTEXTNJP Number JIT Profiles = 0 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 21 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0% CLASSES The classes section shows information about class loaders. The first part is a summary that records each available class loader ( 2CLTEXTCLLOADER ) followed by the number of libraries and classes that it loaded. This information is followed by a more detailed list of libraries ( 1CLTEXTCLLIB ) and classes ( 1CLTEXTCLLO ) that are loaded. In the example you can see that the java/lang/InternalAnonymousClassLoader loaded 2 classes, jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) and jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) . NULL ------------------------------------------------------------------------ 0SECTION CLASSES subcomponent dump routine NULL ================================= 1CLTEXTCLLOS Classloader summaries 1CLTEXTCLLSS 12345678: 1=primordial,2=extension,3=shareable,4=middleware,5=system,6=trusted,7=application,8=delegating 2CLTEXTCLLOADER p---st-- Loader *System*(0x00000000FFE1D258) 3CLNMBRLOADEDLIB Number of loaded libraries 5 3CLNMBRLOADEDCL Number of loaded classes 638 2CLTEXTCLLOADER -x--st-- Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 2CLTEXTCLLOADER ----st-- Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 2 2CLTEXTCLLOADER -----ta- Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0), Parent jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 1CLTEXTCLLIB ClassLoader loaded libraries 2CLTEXTCLLIB Loader *System*(0x00000000FFE1D258) 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/jclse9_29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/java 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/j9jit29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/zip 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/nio 1CLTEXTCLLOD ClassLoader loaded classes 2CLTEXTCLLOAD Loader *System*(0x00000000FFE1D258) 3CLTEXTCLASS [Ljava/lang/Thread$State;(0x0000000001056400) ... 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 2CLTEXTCLLOAD Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0) Scenarios General Protection Fault In this scenario, a Java application has crashed due to a General Protection Fault (GPF), automatically generating a Java dump file. The first section of the file (TITLE) tells you that the GPF triggered the Java dump. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"gpf\" (00002000) received 1TIDATETIME Date: 2018/09/24 at 15:18:03:115 1TINANOTIME System nanotime: 4498949283020796 1TIFILENAME Javacore filename: /home/test/JNICrasher/javacore.20180924.151801.29399.0002.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x100 (trace_disabled) 1TIPREPINFO Exclusive VM access not taken: data may not be consistent across javacore sections To troubleshoot this problem, you need to know which thread caused the GPF to occur. The thread that was running at the time of the crash is reported as the current thread in the THREADS section of the Java dump. Here is an extract from the THREADS section: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 15 2XMPOOLDAEMON Current total number of live daemon threads: 14 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60E00, omrthread_t:0xB6B049D8, java/lang/Thread:0xB55444D0, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x72D8, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00000000) 3XMTHREADINFO2 (native stack address range from:0xB6CE3000, to:0xB74E4000, size:0x801000) 3XMCPUTIME CPU usage total: 0.319865924 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=778008 (0xBDF18) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at JNICrasher.doSomethingThatCrashes(Native Method) 4XESTACKTRACE at JNICrasher.main(JNICrasher.java:7) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C6F663 [libj9prt29.so+0x3b663]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6F1CE [libj9prt29.so+0x3b1ce]) 4XENATIVESTACK (0xB6C6F2C6 [libj9prt29.so+0x3b2c6]) 4XENATIVESTACK (0xB6C6ED93 [libj9prt29.so+0x3ad93]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6ED07 [libj9prt29.so+0x3ad07]) 4XENATIVESTACK (0xB6C6AA3D [libj9prt29.so+0x36a3d]) 4XENATIVESTACK (0xB6C6C3A4 [libj9prt29.so+0x383a4]) 4XENATIVESTACK (0xB667FA19 [libj9dmp29.so+0xfa19]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66878CF [libj9dmp29.so+0x178cf]) 4XENATIVESTACK (0xB6688083 [libj9dmp29.so+0x18083]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6680C0D [libj9dmp29.so+0x10c0d]) 4XENATIVESTACK (0xB667F9D7 [libj9dmp29.so+0xf9d7]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB668B02F [libj9dmp29.so+0x1b02f]) 4XENATIVESTACK (0xB668B4D3 [libj9dmp29.so+0x1b4d3]) 4XENATIVESTACK (0xB66740F1 [libj9dmp29.so+0x40f1]) 4XENATIVESTACK (0xB66726FA [libj9dmp29.so+0x26fa]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66726A9 [libj9dmp29.so+0x26a9]) 4XENATIVESTACK (0xB6676AE4 [libj9dmp29.so+0x6ae4]) 4XENATIVESTACK (0xB668D75A [libj9dmp29.so+0x1d75a]) 4XENATIVESTACK (0xB6A28DD4 [libj9vm29.so+0x81dd4]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A289EE [libj9vm29.so+0x819ee]) 4XENATIVESTACK (0xB6A29A40 [libj9vm29.so+0x82a40]) 4XENATIVESTACK (0xB6C52B6A [libj9prt29.so+0x1eb6a]) 4XENATIVESTACK __kernel_rt_sigreturn+0x0 (0xB7747410) 4XENATIVESTACK (0xB75330B6 [libffi29.so+0x50b6]) 4XENATIVESTACK ffi_raw_call+0xad (0xB7531C53 [libffi29.so+0x3c53]) 4XENATIVESTACK (0xB69BE4AB [libj9vm29.so+0x174ab]) 4XENATIVESTACK (0xB6A665BC [libj9vm29.so+0xbf5bc]) 4XENATIVESTACK (0xB6A15552 [libj9vm29.so+0x6e552]) 4XENATIVESTACK (0xB6A30894 [libj9vm29.so+0x89894]) 4XENATIVESTACK (0xB6A6F169 [libj9vm29.so+0xc8169]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A6F1FA [libj9vm29.so+0xc81fa]) 4XENATIVESTACK (0xB6A30994 [libj9vm29.so+0x89994]) 4XENATIVESTACK (0xB6A2CE4C [libj9vm29.so+0x85e4c]) 4XENATIVESTACK (0xB770487D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7719F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB763543E [libc.so.6+0xee43e]) The extract tells you that the current thread was java/lang/Thread , and information is provided about the Java callstack and native callstack ( 3XMTHREADINFO3 ) at the point at which the crash occurred. To simulate a crash caused by a bug in an application, this example calls a JNI method whose native implementation causes a crash. The Java callstack shows the call to the JNI native method ( JNIcrasher ), and the native callstack shows the point of failure. In this example, the native call stack does not include any function names to help you isolate the error in the native code. You can get this information from a system dump, which is usually produced alongside the Java dump. Open the system dump with the Dump viewer and use the info thread command to print the Java and native stack for the current thread. Java OutOfMemoryError In this scenario, the Java heap runs out of memory, causing an OutOfMemoryError , which automatically generates a Java dump file. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for Java heap space. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"Java heap space\" received 1TIDATETIME Date: 2018/09/14 at 15:29:42:709 1TINANOTIME System nanotime: 3635648876608448 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20180914.152929.18885.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) The MEMINFO section records how much memory is allocated to the Java heap ( 1STHEAPTYPE Object Memory ), how much is in use, and how much is free. Solving your problem might be as simple as setting a larger heap size when you start your application. If you don't know what size the Java heap was set to, you might find that information in the ENVINFO section, which records the command line options that were used when the application started. Look or search for the 1CIUSERARGS UserArgs: string and review the entries recorded for all lines that start 2CIUSERARG . The Java heap size is set by the -Xmx option. If the size has not been set on the command line by -Xmx , the default value applies, which you can find in Default Settings . In this scenario the solution to the problem is not an adjustment to the Java heap size. Here is the MEMINFO section: 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0xB6B49D20 -- -- -- Generational 1STHEAPREGION 0xB6B4A078 0x95750000 0xB5470000 0x1FD20000 Generational/Tenured Region 1STHEAPREGION 0xB6B49F10 0xB5470000 0xB54C0000 0x00050000 Generational/Nursery Region 1STHEAPREGION 0xB6B49DA8 0xB54C0000 0xB5750000 0x00290000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 536870912 (0x20000000) 1STHEAPINUSE Total memory in use: 302603160 (0x12095B98) 1STHEAPFREE Total memory free: 234267752 (0x0DF6A468) The output shows that only 56% of the Java heap is in use, so this suggests that the application is trying to do something sub-optimal. To investigate further you need to work out which thread was the current thread when the OOM occurred to see what it was trying to do. As in the previous scenario, you can find the current thread in the THREADS section. Here is an extract from the output: 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60C00, omrthread_t:0xB6B049D8, java/lang/Thread:0x95764520, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x49C6, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6CB5000, to:0xB74B6000, size:0x801000) 3XMCPUTIME CPU usage total: 8.537823831 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/StringBuffer.ensureCapacityImpl(StringBuffer.java:696) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:486(Compiled Code)) 5XESTACKTRACE (entered lock: java/lang/StringBuffer@0x957645B8, entry count: 1) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:428(Compiled Code)) 4XESTACKTRACE at HeapBreaker.main(HeapBreaker.java:34(Compiled Code)) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C535B3 [libj9prt29.so+0x3b5b3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C5311E [libj9prt29.so+0x3b11e]) 4XENATIVESTACK (0xB6C53216 [libj9prt29.so+0x3b216]) 4XENATIVESTACK (0xB6C52CE3 [libj9prt29.so+0x3ace3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C52C57 [libj9prt29.so+0x3ac57]) 4XENATIVESTACK (0xB6C4E9CD [libj9prt29.so+0x369cd]) 4XENATIVESTACK (0xB6C502FA [libj9prt29.so+0x382fa]) To simulate a Java OutOfMemoryError , this example application repeatedly appends characters to a StringBuffer object in an infinite loop. The Java callstack shows the HeapBreaker.main method appending characters ( java/lang/StringGuffer.append ) until the method java/lang/StringBuffer.ensureCapacityImpl() throws the OutOfMemoryError . StringBuffer objects are wrappers for character arrays ( char[] ) and when the capacity of the underlying array is reached, the contents are automatically copied into a new, larger array. The new array is created in the StringBuffer.ensureCapacity() method, which more or less doubles the size of the old array. In this scenario, the array takes up all the remaining space in the Java heap. The MEMINFO section of the Java dump file can also tell you when an unexpectedly large allocation request causes an OOM. Look for the GC History ( 1STGCHTYPE ) section, which details allocation requests that trigger GC activity. In the sample output you can see that a large allocation request ( requestedbytes=603979784 ) triggered a global GC. When the GC could not free up sufficient space in the heap to satisfy the request, the allocation failure generated the OOM. 1STGCHTYPE GC History 3STHSTTYPE 14:29:29:580239000 GMT j9mm.101 - J9AllocateIndexableObject() returning NULL! 0 bytes requested for object of class B6BBC300 from memory space 'Generational' id=B6B49D20 3STHSTTYPE 14:29:29:579916000 GMT j9mm.134 - Allocation failure end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579905000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579859000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:579807000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:579776000 GMT j9mm.137 - Compact end: bytesmoved=301989896 3STHSTTYPE 14:29:29:313899000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:313555000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:310772000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:310765000 GMT j9mm.94 - Class unloading end: classloadersunloaded=0 classesunloaded=0 3STHSTTYPE 14:29:29:310753000 GMT j9mm.60 - Class unloading start 3STHSTTYPE 14:29:29:310750000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:306013000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:305957000 GMT j9mm.474 - GlobalGC start: globalcount=9 3STHSTTYPE 14:29:29:305888000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:305837000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:305808000 GMT j9mm.137 - Compact end: bytesmoved=189784 3STHSTTYPE 14:29:29:298042000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:297695000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:291696000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:291692000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:284994000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:284941000 GMT j9mm.474 - GlobalGC start: globalcount=8 3STHSTTYPE 14:29:29:284916000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:284914000 GMT j9mm.469 - Allocation failure cycle start: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:284893000 GMT j9mm.470 - Allocation failure cycle end: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:284858000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=2 flipbytes=64 newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:284140000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:283160000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=335 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:283123000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:283120000 GMT j9mm.469 - Allocation failure cycle start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:283117000 GMT j9mm.133 - Allocation failure start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:269762000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269751000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269718000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:268981000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:268007000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=334 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:267969000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:267966000 GMT j9mm.469 - Allocation failure cycle start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:267963000 GMT j9mm.133 - Allocation failure start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:249015000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:249003000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:248971000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 Although the Java code that was used in this scenario deliberately triggered an OutOfMemoryError in a pronounced way, similar allocation issues can and do occur when dealing with large data sets such as XML files. The next step in diagnosing the problem is to open the system dump that gets generated automatically when an OutOfMemoryError occurs. Open the dump with the Eclipse Memory Analyzer tool (MAT) and search for the StringBuffer object, which should provide further clues about what went wrong. A common example is seeing the same String duplicated over and over again, which might indicate that code is stuck in a loop. Note: If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plugin in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > If, unlike the previous scenario, you receive an OutOfMemoryError and the MEMINFO section shows that there is very little space left on the Java heap, the current thread information is typically not important. The current thread is simply the thread that happened to be current when the space ran out. In this situation you might want to increase your Java heap size. For help with this task, see How to do heap sizing . Native OutOfMemoryError In this scenario, the VM runs out of native memory. Native memory is memory that is used by the VM for storing all virtualized resources and data that it needs for VM operations. Native memory that is available to the VM process is limited by the operating system. The native memory available to the VM might also be subject to additional limits imposed by the operating system, for example Unix ulimits . When a NativeOutOfMemoryError occurs, a Java dump is generated by default. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for native memory. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"native memory exhausted\" received 1TIDATETIME Date: 2018/09/14 at 15:49:55:887 1TINANOTIME System nanotime: 3636862054495675 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20180914.154814.19708.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) Sometimes, the current thread is responsible for causing the NativeOutOfMemoryError . Information about the current thread can be found in the THREADS section, as shown in the following output. 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6C60C00, omrthread_t:0xB6C049D8, java/lang/Thread:0xB55E3C10, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x4CFD, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6D4E000, to:0xB754F000, size:0x801000) 3XMCPUTIME CPU usage total: 3.654896026 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at sun/misc/Unsafe.allocateDBBMemory(Native Method) 4XESTACKTRACE at java/nio/DirectByteBuffer.<init>(DirectByteBuffer.java:127(Compiled Code)) 4XESTACKTRACE at java/nio/ByteBuffer.allocateDirect(ByteBuffer.java:311) 4XESTACKTRACE at NativeHeapBreaker.main(NativeHeapBreaker.java:9) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6A9F5B3 [libj9prt29.so+0x3b5b3]) ... 4XENATIVESTACK (0xB582CC9C [libjclse7b_29.so+0x40c9c]) 4XENATIVESTACK Java_sun_misc_Unsafe_allocateDBBMemory+0x88 (0xB5827F6B [libjclse7b_29.so+0x3bf6b]) 4XENATIVESTACK (0x94A2084A [<unknown>+0x0]) 4XENATIVESTACK (0xB6B2538B [libj9vm29.so+0x6c38b]) 4XENATIVESTACK (0xB6B4074C [libj9vm29.so+0x8774c]) 4XENATIVESTACK (0xB6B7F299 [libj9vm29.so+0xc6299]) 4XENATIVESTACK (0xB6A82F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6B7F32A [libj9vm29.so+0xc632a]) 4XENATIVESTACK (0xB6B4084C [libj9vm29.so+0x8784c]) 4XENATIVESTACK (0xB6B3CD0C [libj9vm29.so+0x83d0c]) 4XENATIVESTACK (0xB776F87D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7784F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB76A043E [libc.so.6+0xee43e]) For clarity in the Native callstack output, ... indicates that some lines are removed. The Java callstack shows the transition from Java to native code ( sun/misc/Unsafe.allocateDBBMemory(Native Method) ), indicating a request for Direct Byte Buffer (DBB) storage. DBB storage is backed by native memory, with the Java heap containing only a reference to the native heap buffer. In this scenario, DBB storage is the likely culprit for this NativeOutOfMemoryError . The next step is to investigate the NATIVEMEMINFO section of the Java dump file, which reports the amount of memory used by the JRE process, broken down into component areas. 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 3,166,386,688 bytes / 4388 allocations 1MEMUSER | 2MEMUSER +--VM: 563,176,824 bytes / 1518 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 3,104,416 bytes / 120 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 548,181,888 bytes / 398 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 536,932,352 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 11,249,536 bytes / 397 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,817,120 bytes / 147 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 115,584 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 84,704 bytes / 114 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 163,688 bytes / 268 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,320 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 23,296 bytes / 55 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 8,576 bytes / 74 allocations 2MEMUSER | | 3MEMUSER | +--Other: 860,520 bytes / 443 allocations 1MEMUSER | 2MEMUSER +--JIT: 3,744,728 bytes / 122 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 2,097,152 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 524,336 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 1,123,240 bytes / 120 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 2,599,463,024 bytes / 2732 allocations 2MEMUSER | | 3MEMUSER | +--Harmony Class Libraries: 1,024 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 2,599,462,000 bytes / 2731 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 2,598,510,480 bytes / 2484 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 2,598,510,480 bytes / 2484 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 951,520 bytes / 247 allocations 1MEMUSER | 2MEMUSER +--Unknown: 2,112 bytes / 16 allocations NULL In the VM Class Libraries section, the amount of memory allocated for Direct Byte Buffers is shown. Because the NativeOutOfMemoryError was received on a small 32-bit system, a value of 2,598,510,480 bytes indicates that the operating system has run out of memory. On a larger UNIX system, the process might have run out of memory because of the ulimit setting. Increasing the value for ulimit might avoid the error, which you can do temporarily by setting ulimit -f unlimited in your current session. The theoretical maximum size for a 32-bit process is the size of the 32-bit address space, which is 4 GB. On most operating systems a portion of the address space for each process is used by the kernel, such that the real limit for 32-bit processes is actually significantly less than 4GB. As a result, running out of native memory with a 32-bit VM is quite common. The same 4 GB limit is also important if you are using a 64-bit VM with compressed references. In compressed references mode, all references to objects, classes, threads, and monitors are represented by 32-bit values for performance reasons, so these structures can be allocated only at 32-bit addresses. However, the operating system might place other allocations within this 4 GB of address space, and if this area becomes sufficiently full or fragmented, the VM throws a native NativeOutOfMemoryError error. These errors typically occur when the VM tries to create a new thread or load a class. The Current Thread History section should contain more information about what the thread was doing at the VM level when the NativeOutOfMemoryError error occurred. You can usually avoid this type of problem by using the -Xmcrs option to reserve a contiguous area of memory within the lowest 4GB of memory at VM startup. Another common cause of a NativeOutOfMemoryError is when an application loads duplicate classes. Classes are allocated outside of the Java heap in native memory. If the value reported for Classes in the NATIVEMEMINFO section is very large, duplicate classes might be the cause of your problem. The Eclipse Memory Analyzer Tool (MAT) can tell you if you have duplicate classes by using the Class Loader Explorer feature. Because a system dump is automatically generated as well as a Java dump in response to a NativeOutOfMemoryError , simply open the system dump in MAT to continue your diagnosis. Deadlock Deadlocks occur when two threads attempt to synchronize on an object and lock an instance of a class. When this happens, your application stops responding and hangs. Generating a Java dump file will quickly tell you whether you have a deadlock situation. Trigger the Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. The VM can detect the most common types of deadlock scenario involving Java monitors. If this type of deadlock is detected, information is provided in the LOCKS section. More complex deadlocks, including those that involve a mixture of native mutexes and Java monitors, are not detected. Here is the output from the code that was used to cause a common deadlock scenario: NULL 1LKDEADLOCK Deadlock detected !!! NULL --------------------- NULL 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) 3LKDEADLOCKWTR is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B344 infl_mon_t: 0x08C2B384: 4LKDEADLOCKOBJ java/lang/Object@0xB5666698 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 3\" (0x94507500) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B3A0 infl_mon_t: 0x08C2B3E0: 4LKDEADLOCKOBJ java/lang/Object@0xB5666678 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 1\" (0x92A3EC00) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B2E8 infl_mon_t: 0x08C2B328: 4LKDEADLOCKOBJ java/lang/Object@0xB5666688 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) This output tells you that Worker Thread 2 is waiting for Worker Thread 3 , which is waiting for Worker Thread 1 . Because Worker Thread 1 is also waiting for Worker Thread 2 , there is a deadlock. The next place to look is the output for Java and native stacks, in the THREADS section. By looking at the stack for each of these worker threads you can trace the problem back to specific lines in your application code. In this example, you can see from the following output that for all worker threads, the stack traces ( 4XESTACKTRACE / 5XESTACKTRACE ) indicate a problem in line 35 of the application DeadLockTest.java : 3XMTHREADINFO \"Worker Thread 1\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C2B0, java/lang/Thread:0xB5666778, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52CF, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004365543 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666688 Owned by: \"Worker Thread 2\" (J9VMThread:0x94501D00, java/lang/Thread:0xB56668D0) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666678, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 2\" J9VMThread:0x94501D00, omrthread_t:0x92A3C8F0, java/lang/Thread:0xB56668D0, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x14, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D0, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x946BF000, to:0x94700000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004555580 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666698 Owned by: \"Worker Thread 3\" (J9VMThread:0x94507500, java/lang/Thread:0xB5666A18) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666688, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 3\" J9VMThread:0x94507500, omrthread_t:0x92A3CC10, java/lang/Thread:0xB5666A18, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x15, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D1, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9467E000, to:0x946BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.003657010 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666678 Owned by: \"Worker Thread 1\" (J9VMThread:0x92A3EC00, java/lang/Thread:0xB5666778) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666698, entry count: 1) Hang An application can hang for a number of reasons but the most common cause is excessive global garbage collection (GC) activity, where your application is repeatedly paused because your Java heap has almost run out of memory. You can identify this problem by looking at verbose GC output. Collect this output by specifying the -verbose:gc option. Deadlock situations can also manifest themselves as hangs. For more information on diagnosing this type of problem from a Java dump, see the deadlock scenario. If you have eliminated verbose GC activity and deadlocks, another common hang scenario involves threads that compete and wait for Java object locks. This type of problem can usually be diagnosed by examining a Java dump. The simplest hang scenario involving Java object locks is where a thread acquires a lock that other threads are waiting for, but it doesn't release the lock for some reason. The first place to look in the Java dump output is the LOCKS section. This section lists all the monitors and shows which threads have acquired a lock and which threads are waiting. If the hang is caused by a thread not releasing a lock that other threads need, you can see a list of waiting threads in the output. In this example scenario, the Java dump LOCKS section shows that Worker Thread 0 ( 3LKMONOBJECT ) has acquired a lock and there are 19 other worker threads waiting to obtain the lock. NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 1 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x92711200 infl_mon_t: 0x92711240: 3LKMONOBJECT java/lang/Object@0xB56658D8: Flat locked by \"Worker Thread 0\" (J9VMThread:0x92A3EC00), entry count 1 3LKWAITERQ Waiting to enter: 3LKWAITER \"Worker Thread 1\" (J9VMThread:0x92703F00) 3LKWAITER \"Worker Thread 2\" (J9VMThread:0x92709C00) 3LKWAITER \"Worker Thread 3\" (J9VMThread:0x92710A00) 3LKWAITER \"Worker Thread 4\" (J9VMThread:0x92717F00) 3LKWAITER \"Worker Thread 5\" (J9VMThread:0x9271DC00) 3LKWAITER \"Worker Thread 6\" (J9VMThread:0x92723A00) 3LKWAITER \"Worker Thread 7\" (J9VMThread:0x92729800) 3LKWAITER \"Worker Thread 8\" (J9VMThread:0x92733700) 3LKWAITER \"Worker Thread 9\" (J9VMThread:0x92739400) 3LKWAITER \"Worker Thread 10\" (J9VMThread:0x92740200) 3LKWAITER \"Worker Thread 11\" (J9VMThread:0x92748100) 3LKWAITER \"Worker Thread 12\" (J9VMThread:0x9274DF00) 3LKWAITER \"Worker Thread 13\" (J9VMThread:0x92754D00) 3LKWAITER \"Worker Thread 14\" (J9VMThread:0x9275AA00) 3LKWAITER \"Worker Thread 15\" (J9VMThread:0x92760800) 3LKWAITER \"Worker Thread 16\" (J9VMThread:0x92766600) 3LKWAITER \"Worker Thread 17\" (J9VMThread:0x9276C300) 3LKWAITER \"Worker Thread 18\" (J9VMThread:0x92773100) 3LKWAITER \"Worker Thread 19\" (J9VMThread:0x92778F00) NULL The next step is to determine why Worker Thread 0 is not releasing the lock. The best place to start is the stack trace for this thread, which you can find by searching on the thread name or J9VMThread ID in the THREADS section. The following extract shows the details for \"Worker Thread 0\" (J9VMThread:0x92A3EC00) : NULL 3XMTHREADINFO \"Worker Thread 0\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C280, java/lang/Thread:0xB56668B8, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x511F, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000401) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.000211878 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Thread.sleep(Native Method) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:941) 4XESTACKTRACE at WorkerThread.doWork(HangTest.java:37) 4XESTACKTRACE at WorkerThread.run(HangTest.java:31) 5XESTACKTRACE (entered lock: java/lang/Object@0xB56658D8, entry count: 1) In the last line of this output you can see where the thread acquired the lock. Working up from this line, you can see that WorkerThread.run was called, which in turn called WorkerThread.doWork . The stack shows that the thread then entered a call to java/lang/Thread.sleep in HangTest.java on line 37, which is preventing the thread from completing its work and releasing the lock. In this example the sleep call was added to induce a hang, but in real-world scenarios the cause could be any blocking operation, such as reading from an input stream or socket. Another possibility is that the thread is waiting for another lock owned by yet another thread. It is important to remember that each Java dump represents a single snapshot in time. You should generate at least three Java dumps separated by a short pause, for example 30 seconds, and compare the output. This comparison tells you whether the threads involved are stuck in a fixed state or whether they are moving. In this example, the threads do not move and the investigation needs to focus on the logic in WorkerThread.doWork to understand why Worker Thread 0 entered the java/lang/Thread.sleep call. Another common scenario is where each Java dump shows a number of threads waiting for a lock owned by another thread, but the list of waiting threads and the lock-owning thread change over time. In this case the cause is likely to be a bottleneck caused by thread contention, where the threads are continually competing for the same lock. In severe cases, the lock is held only for a small amount of time but there are lots of threads trying to obtain it. Because more time is spent handling the lock and scheduling the thread than executing application code, the degradation in performance is manifested as a hang. Thread contention is usually caused by an application design problem. You can use a similar approach to the one used in this scenario to determime which lines of code are responsible for the contention.","title":"Java dump"},{"location":"dump_javadump/#java-dump","text":"Java dumps, sometimes referred to as Java cores , are produced when the VM ends unexpectedly because of an operating system signal, OutOfMemoryError , or a user-initiated keystroke combination. You can also generate a Java dump by calling the Dump API programmatically from your application or specifying the -Xdump:java option on the command line. If your Java application crashes or hangs, Java dumps can provide useful information to help you diagnose the root cause. If your application crashes, Java dumps are generated automatically for the following types of failure: the VM receives an unexpected signal or an assertion failure the VM runs out of memory If your application hangs, you can trigger the generation of a Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. Note: On Windows, if you started the VM in a console window you can force the VM to produce a Java dump in response to a SIGBREAK signal (Ctrl-Break keyboard combination). If you didn't start in a console window there is no equivalent to a Linux kill command on Windows for sending signals. The only option here is to trigger a full system dump by finding the VM process in the Processes tab of the Windows Task Manager and clicking Create dump file . To help you understand how a Java dump can help you with problem diagnosis, this topic includes a few scenarios to help you interpret the data: A crash caused by a general protection fault (gpf) A Java heap OutOfMemoryError (OOM) A native OutOfMemoryError (OOM) A deadlock situation A hang","title":"Java dump"},{"location":"dump_javadump/#java-dump-contents","text":"Java dumps summarize the state of the VM when the event occurs, with most of the information relating to components of the VM. The file is made up of a number of sections that provide different types of information.","title":"Java dump contents"},{"location":"dump_javadump/#title","text":"The first section of the Java dump file provides information about the event that triggered the production of the dump. In the following example you can see that a vmstop event triggered the dump at a specified date and time. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"vmstop\" (00000002) Detail \"#0000000000000000\" received 1TIDATETIME Date: 2018/08/30 at 21:55:47:607 1TINANOTIME System nanotime: 22012355276134 1TIFILENAME Javacore filename: /home/doc-javacore/javacore.20180830.215547.30285.0001.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x106 (vm_access+exclusive_vm_access+trace_disabled)","title":"TITLE"},{"location":"dump_javadump/#gpinfo","text":"The GPINFO section provides general information about the system that the VM is running on. The following example is taken from a Java dump that was generated on a Linux system. NULL ------------------------------------------------------------------------ 0SECTION GPINFO subcomponent dump routine NULL ================================ 2XHOSLEVEL OS Level : Linux 3.10.0-862.11.6.el7.x86_64 2XHCPUS Processors - 3XHCPUARCH Architecture : amd64 3XHNUMCPUS How Many : 4 3XHNUMASUP NUMA is either not supported or has been disabled by user NULL 1XHERROR2 Register dump section only produced for SIGSEGV, SIGILL or SIGFPE. NULL The content of this section can vary, depending on the cause of the dump. For example, if the dump was caused by a general protection fault (gpf), the library in which the crash occurred is also recorded, together with a value shown as VM flags . This value can provide some clues about which component of the VM might have been involved. Look for the following line in the output: 1XHFLAGS VM flags:0000000000000000 The hexadecimal number recorded for VM flags ends in MSSSS, where M is the VM component and SSSS is component-specific code as shown in the following table: Component Code value INTERPRETER 0x10000 GC 0x20000 GROW_STACK 0x30000 JNI 0x40000 JIT_CODEGEN 0x50000 BCVERIFY 0x60000 RTVERIFY 0x70000 SHAREDCLASSES 0x80000 A value of 0000000000000000 (0x00000) indicates that a crash occurred outside of the VM.","title":"GPINFO"},{"location":"dump_javadump/#envinfo","text":"This section contains useful information about the environment in which the crash took place, including the following data: Java version ( 1CIJAVAVERSION ) OpenJ9 VM and subcomponent version information ( 1CIVMVERSION , 1CIJ9VMVERSION , 1CIJITVERSION , 1CIOMRVERSION , 1CIJCLVERSION ) VM start time ( 1CISTARTTIME ) and process information ( 1CIPROCESSID ) Java home ( 1CIJAVAHOMEDIR ) and DLL ( 1CIJAVADLLDIR ) directories User arguments passed on the command line ( 1CIUSERARG ) User limits imposed by the system ( 1CIUSERLIMITS ) Environment variables in place ( 1CIENVVARS ) System information ( 1CISYSINFO ) CPU information ( 1CICPUINFO ) Control group (Cgroup) information ( 1CICGRPINFO ) For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION ENVINFO subcomponent dump routine NULL ================================= 1CIJAVAVERSION JRE 9 Linux amd64-64 (build 9.0.4-internal+0-adhoc..openj9-openjdk-jdk9) 1CIVMVERSION 20180830_000000 1CIJ9VMVERSION 8e7c6ec 1CIJITVERSION 8e7c6ec 1CIOMRVERSION 553811b_CMPRSS 1CIJCLVERSION ec1d223 based on jdk-9.0.4+12 1CIJITMODES JIT enabled, AOT enabled, FSD disabled, HCR enabled 1CIRUNNINGAS Running as a standalone JVM 1CIVMIDLESTATE VM Idle State: ACTIVE 1CICONTINFO Running in container : FALSE 1CICGRPINFO JVM support for cgroups enabled : TRUE 1CISTARTTIME JVM start time: 2018/08/30 at 21:55:47:387 1CISTARTNANO JVM start nanotime: 22012135233549 1CIPROCESSID Process ID: 30285 (0x764D) 1CICMDLINE [not available] 1CIJAVAHOMEDIR Java Home Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk 1CIJAVADLLDIR Java DLL Dir: /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/bin 1CISYSCP Sys Classpath: 1CIUSERARGS UserArgs: 2CIUSERARG -Xoptionsfile=/home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/options.default ... NULL 1CIUSERLIMITS User Limits (in bytes except for NOFILE and NPROC) NULL ------------------------------------------------------------------------ NULL type soft limit hard limit 2CIUSERLIMIT RLIMIT_AS unlimited unlimited 2CIUSERLIMIT RLIMIT_CORE 0 unlimited 2CIUSERLIMIT RLIMIT_CPU unlimited unlimited 2CIUSERLIMIT RLIMIT_DATA unlimited unlimited 2CIUSERLIMIT RLIMIT_FSIZE unlimited unlimited 2CIUSERLIMIT RLIMIT_LOCKS unlimited unlimited 2CIUSERLIMIT RLIMIT_MEMLOCK 65536 65536 2CIUSERLIMIT RLIMIT_NOFILE 4096 4096 2CIUSERLIMIT RLIMIT_NPROC 4096 30592 2CIUSERLIMIT RLIMIT_RSS unlimited unlimited 2CIUSERLIMIT RLIMIT_STACK 8388608 unlimited 2CIUSERLIMIT RLIMIT_MSGQUEUE 819200 819200 2CIUSERLIMIT RLIMIT_NICE 0 0 2CIUSERLIMIT RLIMIT_RTPRIO 0 0 2CIUSERLIMIT RLIMIT_SIGPENDING 30592 30592 NULL 1CIENVVARS Environment Variables NULL ------------------------------------------------------------------------ 2CIENVVAR XDG_VTNR=1 2CIENVVAR SSH_AGENT_PID=2653 ... NULL 1CISYSINFO System Information NULL ------------------------------------------------------------------------ 2CISYSINFO /proc/sys/kernel/core_pattern = core 2CISYSINFO /proc/sys/kernel/core_uses_pid = 1 NULL 1CICPUINFO CPU Information NULL ------------------------------------------------------------------------ 2CIPHYSCPU Physical CPUs: 4 2CIONLNCPU Online CPUs: 4 2CIBOUNDCPU Bound CPUs: 4 2CIACTIVECPU Active CPUs: 0 2CITARGETCPU Target CPUs: 4 NULL 1CICGRPINFO Cgroup Information NULL ------------------------------------------------------------------------ 2CICGRPINFO subsystem : cpu 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU Period : 100000 microseconds 3CICGRPINFO CPU Quota : Not Set 3CICGRPINFO CPU Shares : 1024 3CICGRPINFO Period intervals elapsed count : 0 3CICGRPINFO Throttled count : 0 3CICGRPINFO Total throttle time : 0 nanoseconds 2CICGRPINFO subsystem : cpuset 2CICGRPINFO cgroup name : / 3CICGRPINFO CPU exclusive : 1 3CICGRPINFO Mem exclusive : 1 3CICGRPINFO CPUs : 0-3 3CICGRPINFO Mems : 0 2CICGRPINFO subsystem : memory 2CICGRPINFO cgroup name : / 3CICGRPINFO Memory Limit : Not Set 3CICGRPINFO Memory + Swap Limit : Not Set 3CICGRPINFO Memory Usage : 5363396608 bytes 3CICGRPINFO Memory + Swap Usage : 5363396608 bytes 3CICGRPINFO Memory Max Usage : 0 bytes 3CICGRPINFO Memory + Swap Max Usage : 0 bytes 3CICGRPINFO Memory limit exceeded count : 0 3CICGRPINFO Memory + Swap limit exceeded count : 0 3CICGRPINFO OOM Killer Disabled : 0 3CICGRPINFO Under OOM : 0 NULL","title":"ENVINFO"},{"location":"dump_javadump/#nativememinfo","text":"This section records information about native memory that is requested by using library functions such as malloc() and mmap() . Values are provided as a breakdown, per component, indicating the total number of bytes allocated and the number of native memory allocations. In the following example, 4,682,840 bytes of native memory are allocated (but not yet freed) to VM Classes, which corresponds to 141 allocations. NULL ------------------------------------------------------------------------ 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 2,569,088,312 bytes / 4653 allocations 1MEMUSER | 2MEMUSER +--VM: 2,280,088,336 bytes / 2423 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 4,682,840 bytes / 141 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 2,054,966,784 bytes / 433 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 2,014,113,792 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 40,852,992 bytes / 432 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,970,016 bytes / 156 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 197,760 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 155,424 bytes / 123 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 180,056 bytes / 263 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,776 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 36,184 bytes / 52 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 208,179,632 bytes / 72 allocations 3MEMUSER | | | 4MEMUSER | | +--Unused <32bit allocation regions: 208,168,752 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,880 bytes / 71 allocations 2MEMUSER | | 3MEMUSER | +--Other: 1,055,048 bytes / 1293 allocations 1MEMUSER | 2MEMUSER +--JIT: 288,472,816 bytes / 140 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 268,435,456 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 2,097,216 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 17,940,144 bytes / 138 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 13,432 bytes / 25 allocations 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 13,432 bytes / 25 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 3,184 bytes / 13 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 1,056 bytes / 12 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Other: 2,128 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 10,248 bytes / 12 allocations 1MEMUSER | 2MEMUSER +--Unknown: 513,728 bytes / 2065 allocations NULL This section does not record memory that is allocated by application or JNI code and is typically a little less than the value recorded by operating system tools.","title":"NATIVEMEMINFO"},{"location":"dump_javadump/#meminfo","text":"This section relates to memory management, providing a breakdown of memory usage in the VM for the object heap, internal memory, memory used for classes, the JIT code cache, and JIT data cache in decimal and hexadecimal format. You can also find out which garbage collection policy is in use when the dump is produced. The object memory area ( 1STHEAPTYPE ) records each memory region in use, its start and end address, and region size. Further information is recorded about the memory segments used for internal memory, class memory, the JIT code cache and JIT data cache ( 1STSEGMENT ). This information includes the address of the segment control data structure, the start and end address of the native memory segment, as well as the segment size. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0x00007FF4F00744A0 -- -- -- Generational 1STHEAPREGION 0x00007FF4F0074CE0 0x0000000087F40000 0x0000000088540000 0x0000000000600000 Generational/Tenured Region 1STHEAPREGION 0x00007FF4F0074930 0x00000000FFE00000 0x00000000FFF00000 0x0000000000100000 Generational/Nursery Region 1STHEAPREGION 0x00007FF4F0074580 0x00000000FFF00000 0x0000000100000000 0x0000000000100000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 8388608 (0x0000000000800000) 1STHEAPINUSE Total memory in use: 2030408 (0x00000000001EFB48) 1STHEAPFREE Total memory free: 6358200 (0x00000000006104B8) NULL 1STSEGTYPE Internal Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F004CBC8 0x00007FF4CD33C000 0x00007FF4CD33C000 0x00007FF4CE33C000 0x01000440 0x0000000001000000 1STSEGMENT 0x00007FF4F004CB08 0x00007FF4DE43D030 0x00007FF4DE517770 0x00007FF4DE53D030 0x00800040 0x0000000000100000 NULL 1STSEGTOTAL Total memory: 17825792 (0x0000000001100000) 1STSEGINUSE Total memory in use: 894784 (0x00000000000DA740) 1STSEGFREE Total memory free: 16931008 (0x00000000010258C0) NULL 1STSEGTYPE Class Memory NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F03B5638 0x0000000001053D98 0x000000000105BD98 0x000000000105BD98 0x00010040 0x0000000000008000 1STSEGMENT 0x00007FF4F03B5578 0x0000000001048188 0x0000000001050188 0x0000000001050188 0x00010040 0x0000000000008000 ... NULL 1STSEGTOTAL Total memory: 3512520 (0x00000000003598C8) 1STSEGINUSE Total memory in use: 3433944 (0x00000000003465D8) 1STSEGFREE Total memory free: 78576 (0x00000000000132F0) NULL 1STSEGTYPE JIT Code Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F00961F8 0x00007FF4CE43D000 0x00007FF4CE445790 0x00007FF4DE43D000 0x00000068 0x0000000010000000 NULL 1STSEGTOTAL Total memory: 268435456 (0x0000000010000000) 1STSEGINUSE Total memory in use: 34704 (0x0000000000008790) 1STSEGFREE Total memory free: 268400752 (0x000000000FFF7870) 1STSEGLIMIT Allocation limit: 268435456 (0x0000000010000000) NULL 1STSEGTYPE JIT Data Cache NULL segment start alloc end type size 1STSEGMENT 0x00007FF4F0096668 0x00007FF4CC553030 0x00007FF4CC753030 0x00007FF4CC753030 0x00000048 0x0000000000200000 NULL 1STSEGTOTAL Total memory: 2097152 (0x0000000000200000) 1STSEGINUSE Total memory in use: 2097152 (0x0000000000200000) 1STSEGFREE Total memory free: 0 (0x0000000000000000) 1STSEGLIMIT Allocation limit: 402653184 (0x0000000018000000) NULL 1STGCHTYPE GC History NULL In the example, the GC History ( 1STGCHTYPE ) section is blank. This section is populated if a garbage collection cycle occurred in a VM that is being diagnosed with the trace facility.","title":"MEMINFO"},{"location":"dump_javadump/#locks","text":"This section of the Java dump provides information about locks, which protect shared resources from being accessed by more than one entity at a time. The information is essential in a deadlock situation, where two threads attempt to synchronize on an object and lock an instance of a class. Precise information is recorded about the threads that are causing the problem, which enables you to identify the root cause. The following example shows a typical LOCKS section, where no deadlocks existed at the time the dump was triggered. For clarity, the following example shows a shortened version of this section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 3 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x00007FF4B0001D78 infl_mon_t: 0x00007FF4B0001DF8: 3LKMONOBJECT java/lang/ref/ReferenceQueue@0x00000000FFE26A10: <unowned> 3LKNOTIFYQ Waiting to be notified: 3LKWAITNOTIFY \"Common-Cleaner\" (J9VMThread:0x0000000000FD0100) NULL 1LKREGMONDUMP JVM System Monitor Dump (registered monitors): 2LKREGMON Thread global lock (0x00007FF4F0004FE8): <unowned> 2LKREGMON &(PPG_mem_mem32_subAllocHeapMem32.monitor) lock (0x00007FF4F0005098): <unowned> 2LKREGMON NLS hash table lock (0x00007FF4F0005148): <unowned> ... NULL","title":"LOCKS"},{"location":"dump_javadump/#threads","text":"The THREADS section of a Java dump file provides summary information about the VM thread pool and detailed information about Java threads, native threads, and stack traces. Understanding the content of this section can help you diagnose problems that are caused by blocked or waiting threads. A Java thread runs on a native thread. Several lines are recorded for each Java thread in the Thread Details subsection, which include the following key pieces of information: 3XMTHREADINFO : The thread name, address information for the VM thread structures and Java thread object, the thread state, and thread priority. 3XMJAVALTHREAD : The Java thread ID and daemon status from the thread object. 3XMTHREADINFO1 : The native operating system thread ID, priority, scheduling policy, internal VM thread state, and VM thread flags. 3XMTHREADINFO2 : The native stack address range. 3XMTHREADINFO3 : Java callstack information ( 4XESTACKTRACE ) or Native call stack information ( 4XENATIVESTACK ). 5XESTACKTRACE : This line indicates whether locks were taken by a specific method. Java thread priorities are mapped to operating system priority values. Thread states are shown in the following table: Thread state value Status Description R Runnable The thread is able to run CW Condition Wait The thread is waiting S Suspended The thread is suspended by another thread Z Zombie The thread is destroyed P Parked The thread is parked by java.util.concurrent B Blocked The thread is waiting to obtain a lock For threads that are parked (P), blocked (B), or waiting (CW), an additional line ( 3XMTHREADBLOCK ) is included in the output that shows what the thread is parked on, blocked on, or waiting for. For clarity, the following example shows a shortened version of a typical THREADS section, where ... indicates that lines are removed: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 18 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMTHDINFO Thread Details NULL 3XMTHREADINFO \"JIT Diagnostic Compilation Thread-7 Suspended\" J9VMThread:0x0000000000EFC500, omrthread_t:0x00007FF4F00A77E8, java/lang/Thread:0x00000000FFE97480, state:R, prio=10 3XMJAVALTHREAD (java/lang/Thread getId:0xA, isDaemon:true) 3XMTHREADINFO1 (native thread ID:0x7657, native priority:0xB, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000081) 3XMTHREADINFO2 (native stack address range from:0x00007FF4CCC36000, to:0x00007FF4CCD36000, size:0x100000) 3XMCPUTIME CPU usage total: 0.000037663 secs, current category=\"JIT\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 No Java callstack associated with this thread 3XMTHREADINFO3 No native callstack available for this thread NULL ... 3XMTHREADINFO \"Common-Cleaner\" J9VMThread:0x0000000000FD0100, omrthread_t:0x00007FF4F022A520, java/lang/Thread:0x00000000FFE26F40, state:CW, prio=8 3XMJAVALTHREAD (java/lang/Thread getId:0x2, isDaemon:true) 3XMTHREADINFO1 (native thread ID:0x765A, native priority:0x8, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00080181) 3XMTHREADINFO2 (native stack address range from:0x00007FF4CC0B8000, to:0x00007FF4CC0F8000, size:0x40000) 3XMCPUTIME CPU usage total: 0.000150926 secs, current category=\"Application\" 3XMTHREADBLOCK Waiting on: java/lang/ref/ReferenceQueue@0x00000000FFE26A10 Owned by: <unowned> 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Object.wait(Native Method) 4XESTACKTRACE at java/lang/Object.wait(Object.java:221) 4XESTACKTRACE at java/lang/ref/ReferenceQueue.remove(ReferenceQueue.java:138) 5XESTACKTRACE (entered lock: java/lang/ref/ReferenceQueue@0x00000000FFE26A10, entry count: 1) 4XESTACKTRACE at jdk/internal/ref/CleanerImpl.run(CleanerImpl.java:148) 4XESTACKTRACE at java/lang/Thread.run(Thread.java:835) 4XESTACKTRACE at jdk/internal/misc/InnocuousThread.run(InnocuousThread.java:122) 3XMTHREADINFO3 No native callstack available for this thread NULL NULL 3XMTHREADINFO \"IProfiler\" J9VMThread:0x0000000000F03D00, omrthread_t:0x00007FF4F00B06F8, java/lang/Thread:0x00000000FFE97B60, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0xC, isDaemon:true) 3XMTHREADINFO1 (native thread ID:0x7659, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000081) 3XMTHREADINFO2 (native stack address range from:0x00007FF4F8940000, to:0x00007FF4F8960000, size:0x20000) 3XMCPUTIME CPU usage total: 0.004753103 secs, current category=\"JIT\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 No Java callstack associated with this thread 3XMTHREADINFO3 No native callstack available for this thread NULL ... 1XMWLKTHDERR The following was reported while collecting native stacks: 2XMWLKTHDERR unable to count threads(3, -2) NULL 1XMTHDSUMMARY Threads CPU Usage Summary NULL ========================= NULL 1XMTHDCATINFO Warning: to get more accurate CPU times for the GC, the option -XX:-ReduceCPUMonitorOverhead can be used. See the user guide for more information. NULL 1XMTHDCATEGORY All JVM attached threads: 0.280083000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--System-JVM: 0.270814000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--GC: 0.000599000 secs 2XMTHDCATEGORY | | 3XMTHDCATEGORY | +--JIT: 0.071904000 secs 1XMTHDCATEGORY | 2XMTHDCATEGORY +--Application: 0.009269000 secs NULL","title":"THREADS"},{"location":"dump_javadump/#hooks","text":"This section shows internal VM event callbacks, which are used for diagnosing performance problems in the VM. Multiple hook interfaces are listed, which include their individual hook events. The following example shows data for the J9VMHookInterface , including the total time for all previous events, the call site location (<source file>:<line number>), start time, and duration of the last callback and the longest callback (all times measured in microseconds). The hook data is reset after each Java dump. NULL ------------------------------------------------------------------------ SECTION HOOK subcomponent dump routine NULL ========================= 1NOTE These data are reset every time a javacore is taken 1HKINTERFACE MM_OMRHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_PrivateHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE MM_HookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9VMHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 1 3HKCALLCOUNT 1239 3HKTOTALTIME 219564us 3HKLAST Last Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T00:15:14.664 4HKDURATION Duration : 16us 3HKLONGST Longest Callback 4HKCALLSITE trcengine.c:395 4HKSTARTTIME Start Time: 2019-10-18T21:28:34.895 4HKDURATION Duration : 5012us NULL ... 1HKINTERFACE J9VMZipCachePoolHookInterface NULL ------------------------------------------------------------------------ 1HKINTERFACE J9JITHookInterface NULL ------------------------------------------------------------------------ 2HKEVENTID 3 3HKCALLCOUNT 3113 3HKTOTALTIME 4904us 3HKLAST Last Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:04:15.320 4HKDURATION Duration : 3us 3HKLONGST Longest Callback 4HKCALLSITE common/mgmtinit.c:193 4HKSTARTTIME Start Time: 2019-10-18T16:37:17.633 4HKDURATION Duration : 27us NULL ...","title":"HOOKS"},{"location":"dump_javadump/#shared-classes","text":"If the shared classes cache is enabled at run time, the information provided in a Java dump file describes settings that were used when creating the cache, together with summary information about the size and content of the cache. In the following example, the shared classes cache was created with a Class Debug Area ( -Xnolinenumbers=false ). Byte code instrumentation (BCI) is enabled, which is the default, and VMs sharing the cache are allowed to store classpaths, which is also the default. The Cache Summary shows a cache size ( 2SCLTEXTCSZ ) of 16776608 bytes, with a soft maximum size ( 2SCLTEXTSMB ) also of 16776608 bytes, which leaves 12691668 bytes of free space ( 2SCLTEXTFRB ). The size of the Class Debug Area ( 2SCLTEXTDAS ) is 1331200 bytes and only 11% of this space is used. In the Cache Memory Status subsection, the line 2SCLTEXTCMDT indicates the name and location of the shared cache and cr indicates that the cache is a 64-bit compressed references cache. NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = true NULL 2SCLTEXTRCS ROMClass start address = 0x00007F423061C000 2SCLTEXTRCE ROMClass end address = 0x00007F42307B9A28 2SCLTEXTMSA Metadata start address = 0x00007F42313D42FC 2SCLTEXTCEA Cache end address = 0x00007F4231600000 2SCLTEXTRTF Runtime flags = 0x00102001ECA6028B 2SCLTEXTCGN Cache generation = 35 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 12691668 2SCLTEXTRCB ROMClass bytes = 1694248 2SCLTEXTAOB AOT code bytes = 0 2SCLTEXTADB AOT data bytes = 0 2SCLTEXTAHB AOT class hierarchy bytes = 32 2SCLTEXTATB AOT thunk bytes = 0 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJHB JIT hint bytes = 308 2SCLTEXTJPB JIT profile bytes = 2296 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 919328 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 2SCLTEXTMDA Metadata bytes = 23448 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 11% 2SCLTEXTDAN Class LineNumberTable bytes = 156240 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 595 2SCLTEXTNAM Number AOT Methods = 0 2SCLTEXTNAD Number AOT Data Entries = 0 2SCLTEXTNAH Number AOT Class Hierarchy = 1 2SCLTEXTNAT Number AOT Thunks = 0 2SCLTEXTNJH Number JIT Hints = 14 2SCLTEXTNJP Number JIT Profiles = 20 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 5 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0% NULL 2SCLTEXTCPF Cache is 24% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT sharedcc_doc-javacore CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_sharedcc_doc-javacore_G35 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL The following example shows information for a layered cache: NULL ------------------------------------------------------------------------ 0SECTION SHARED CLASSES subcomponent dump routine NULL ======================================== NULL 1SCLTEXTCSTL Cache Statistics for Top Layer NULL 1SCLTEXTCRTW Cache Created With NULL ------------------ NULL 2SCLTEXTXNL -Xnolinenumbers = false 2SCLTEXTBCI BCI Enabled = true 2SCLTEXTBCI Restrict Classpaths = false NULL 1SCLTEXTCSUM Cache Summary NULL ------------------ NULL 2SCLTEXTNLC No line number content = false 2SCLTEXTLNC Line number content = false NULL 2SCLTEXTRCS ROMClass start address = 0x00007F0EDB567000 2SCLTEXTRCE ROMClass end address = 0x00007F0EDB567000 2SCLTEXTMSA Metadata start address = 0x00007F0EDC40241C 2SCLTEXTCEA Cache end address = 0x00007F0EDC54B000 2SCLTEXTRTF Runtime flags = 0x80102001ECA602BB 2SCLTEXTCGN Cache generation = 41 2SCLTEXTCLY Cache layer = 1 NULL 2SCLTEXTCSZ Cache size = 16776608 2SCLTEXTSMB Softmx bytes = 16776608 2SCLTEXTFRB Free bytes = 15315996 2SCLTEXTARB Reserved space for AOT bytes = -1 2SCLTEXTAMB Maximum space for AOT bytes = -1 2SCLTEXTJRB Reserved space for JIT data bytes = -1 2SCLTEXTJMB Maximum space for JIT data bytes = -1 2SCLTEXTRWB ReadWrite bytes = 114080 2SCLTEXTDAS Class debug area size = 1331200 2SCLTEXTDAU Class debug area % used = 0% 2SCLTEXTDAN Class LineNumberTable bytes = 0 2SCLTEXTDAV Class LocalVariableTable bytes = 0 NULL 2SCLTEXTCPF Cache is 8% full NULL 1SCLTEXTCMST Cache Memory Status NULL ------------------ 1SCLTEXTCNTD Cache Name Feature Memory type Cache path NULL 2SCLTEXTCMDT Cache1 CR Memory mapped file /tmp/javasharedresources/C290M4F1A64P_Cache1_G41L01 NULL 1SCLTEXTCMST Cache Lock Status NULL ------------------ 1SCLTEXTCNTD Lock Name Lock type TID owning lock NULL 2SCLTEXTCWRL Cache write lock File lock Unowned 2SCLTEXTCRWL Cache read/write lock File lock Unowned NULL 1SCLTEXTCSAL Cache Statistics for All Layers NULL 2SCLTEXTRCB ROMClass bytes = 1459040 2SCLTEXTAOB AOT code bytes = 57624 2SCLTEXTADB AOT data bytes = 272 2SCLTEXTAHB AOT class hierarchy bytes = 1840 2SCLTEXTATB AOT thunk bytes = 632 2SCLTEXTJHB JIT hint bytes = 484 2SCLTEXTJPB JIT profile bytes = 0 2SCLTEXTNOB Java Object bytes = 0 2SCLTEXTZCB Zip cache bytes = 1134016 2SCLTEXTSHB Startup hint bytes = 0 2SCLTEXTJCB JCL data bytes = 0 2SCLTEXTBDA Byte data bytes = 0 NULL 2SCLTEXTNRC Number ROMClasses = 503 2SCLTEXTNAM Number AOT Methods = 16 2SCLTEXTNAD Number AOT Data Entries = 1 2SCLTEXTNAH Number AOT Class Hierarchy = 28 2SCLTEXTNAT Number AOT Thunks = 11 2SCLTEXTNJH Number JIT Hints = 15 2SCLTEXTNJP Number JIT Profiles = 0 2SCLTEXTNCP Number Classpaths = 1 2SCLTEXTNUR Number URLs = 0 2SCLTEXTNTK Number Tokens = 0 2SCLTEXTNOJ Number Java Objects = 0 2SCLTEXTNZC Number Zip Caches = 21 2SCLTEXTNSH Number Startup Hint Entries = 0 2SCLTEXTNJC Number JCL Entries = 0 2SCLTEXTNST Number Stale classes = 0 2SCLTEXTPST Percent Stale classes = 0%","title":"SHARED CLASSES"},{"location":"dump_javadump/#classes","text":"The classes section shows information about class loaders. The first part is a summary that records each available class loader ( 2CLTEXTCLLOADER ) followed by the number of libraries and classes that it loaded. This information is followed by a more detailed list of libraries ( 1CLTEXTCLLIB ) and classes ( 1CLTEXTCLLO ) that are loaded. In the example you can see that the java/lang/InternalAnonymousClassLoader loaded 2 classes, jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) and jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) . NULL ------------------------------------------------------------------------ 0SECTION CLASSES subcomponent dump routine NULL ================================= 1CLTEXTCLLOS Classloader summaries 1CLTEXTCLLSS 12345678: 1=primordial,2=extension,3=shareable,4=middleware,5=system,6=trusted,7=application,8=delegating 2CLTEXTCLLOADER p---st-- Loader *System*(0x00000000FFE1D258) 3CLNMBRLOADEDLIB Number of loaded libraries 5 3CLNMBRLOADEDCL Number of loaded classes 638 2CLTEXTCLLOADER -x--st-- Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 2CLTEXTCLLOADER ----st-- Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0), Parent *none*(0x0000000000000000) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 2 2CLTEXTCLLOADER -----ta- Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0), Parent jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 3CLNMBRLOADEDLIB Number of loaded libraries 0 3CLNMBRLOADEDCL Number of loaded classes 0 1CLTEXTCLLIB ClassLoader loaded libraries 2CLTEXTCLLIB Loader *System*(0x00000000FFE1D258) 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/jclse9_29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/java 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/compressedrefs/j9jit29 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/zip 3CLTEXTLIB /home/me/openj9-openjdk-jdk9/build/linux-x86_64-normal-server-release/images/jdk/lib/nio 1CLTEXTCLLOD ClassLoader loaded classes 2CLTEXTCLLOAD Loader *System*(0x00000000FFE1D258) 3CLTEXTCLASS [Ljava/lang/Thread$State;(0x0000000001056400) ... 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$PlatformClassLoader(0x00000000FFE1D4F0) 2CLTEXTCLLOAD Loader java/lang/InternalAnonymousClassLoader(0x00000000FFE1DFD0) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$2/00000000F03876A0(0x0000000001030F00) 3CLTEXTCLASS jdk/internal/loader/BuiltinClassLoader$$Lambda$1/00000000F00D2460(0x0000000001018A00) 2CLTEXTCLLOAD Loader jdk/internal/loader/ClassLoaders$AppClassLoader(0x00000000FFE1DAD0)","title":"CLASSES"},{"location":"dump_javadump/#scenarios","text":"","title":"Scenarios"},{"location":"dump_javadump/#general-protection-fault","text":"In this scenario, a Java application has crashed due to a General Protection Fault (GPF), automatically generating a Java dump file. The first section of the file (TITLE) tells you that the GPF triggered the Java dump. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"gpf\" (00002000) received 1TIDATETIME Date: 2018/09/24 at 15:18:03:115 1TINANOTIME System nanotime: 4498949283020796 1TIFILENAME Javacore filename: /home/test/JNICrasher/javacore.20180924.151801.29399.0002.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x100 (trace_disabled) 1TIPREPINFO Exclusive VM access not taken: data may not be consistent across javacore sections To troubleshoot this problem, you need to know which thread caused the GPF to occur. The thread that was running at the time of the crash is reported as the current thread in the THREADS section of the Java dump. Here is an extract from the THREADS section: NULL ------------------------------------------------------------------------ 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 15 2XMPOOLDAEMON Current total number of live daemon threads: 14 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60E00, omrthread_t:0xB6B049D8, java/lang/Thread:0xB55444D0, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x72D8, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00000000) 3XMTHREADINFO2 (native stack address range from:0xB6CE3000, to:0xB74E4000, size:0x801000) 3XMCPUTIME CPU usage total: 0.319865924 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=778008 (0xBDF18) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at JNICrasher.doSomethingThatCrashes(Native Method) 4XESTACKTRACE at JNICrasher.main(JNICrasher.java:7) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C6F663 [libj9prt29.so+0x3b663]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6F1CE [libj9prt29.so+0x3b1ce]) 4XENATIVESTACK (0xB6C6F2C6 [libj9prt29.so+0x3b2c6]) 4XENATIVESTACK (0xB6C6ED93 [libj9prt29.so+0x3ad93]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6C6ED07 [libj9prt29.so+0x3ad07]) 4XENATIVESTACK (0xB6C6AA3D [libj9prt29.so+0x36a3d]) 4XENATIVESTACK (0xB6C6C3A4 [libj9prt29.so+0x383a4]) 4XENATIVESTACK (0xB667FA19 [libj9dmp29.so+0xfa19]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66878CF [libj9dmp29.so+0x178cf]) 4XENATIVESTACK (0xB6688083 [libj9dmp29.so+0x18083]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6680C0D [libj9dmp29.so+0x10c0d]) 4XENATIVESTACK (0xB667F9D7 [libj9dmp29.so+0xf9d7]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB668B02F [libj9dmp29.so+0x1b02f]) 4XENATIVESTACK (0xB668B4D3 [libj9dmp29.so+0x1b4d3]) 4XENATIVESTACK (0xB66740F1 [libj9dmp29.so+0x40f1]) 4XENATIVESTACK (0xB66726FA [libj9dmp29.so+0x26fa]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB66726A9 [libj9dmp29.so+0x26a9]) 4XENATIVESTACK (0xB6676AE4 [libj9dmp29.so+0x6ae4]) 4XENATIVESTACK (0xB668D75A [libj9dmp29.so+0x1d75a]) 4XENATIVESTACK (0xB6A28DD4 [libj9vm29.so+0x81dd4]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A289EE [libj9vm29.so+0x819ee]) 4XENATIVESTACK (0xB6A29A40 [libj9vm29.so+0x82a40]) 4XENATIVESTACK (0xB6C52B6A [libj9prt29.so+0x1eb6a]) 4XENATIVESTACK __kernel_rt_sigreturn+0x0 (0xB7747410) 4XENATIVESTACK (0xB75330B6 [libffi29.so+0x50b6]) 4XENATIVESTACK ffi_raw_call+0xad (0xB7531C53 [libffi29.so+0x3c53]) 4XENATIVESTACK (0xB69BE4AB [libj9vm29.so+0x174ab]) 4XENATIVESTACK (0xB6A665BC [libj9vm29.so+0xbf5bc]) 4XENATIVESTACK (0xB6A15552 [libj9vm29.so+0x6e552]) 4XENATIVESTACK (0xB6A30894 [libj9vm29.so+0x89894]) 4XENATIVESTACK (0xB6A6F169 [libj9vm29.so+0xc8169]) 4XENATIVESTACK (0xB6C52F6E [libj9prt29.so+0x1ef6e]) 4XENATIVESTACK (0xB6A6F1FA [libj9vm29.so+0xc81fa]) 4XENATIVESTACK (0xB6A30994 [libj9vm29.so+0x89994]) 4XENATIVESTACK (0xB6A2CE4C [libj9vm29.so+0x85e4c]) 4XENATIVESTACK (0xB770487D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7719F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB763543E [libc.so.6+0xee43e]) The extract tells you that the current thread was java/lang/Thread , and information is provided about the Java callstack and native callstack ( 3XMTHREADINFO3 ) at the point at which the crash occurred. To simulate a crash caused by a bug in an application, this example calls a JNI method whose native implementation causes a crash. The Java callstack shows the call to the JNI native method ( JNIcrasher ), and the native callstack shows the point of failure. In this example, the native call stack does not include any function names to help you isolate the error in the native code. You can get this information from a system dump, which is usually produced alongside the Java dump. Open the system dump with the Dump viewer and use the info thread command to print the Java and native stack for the current thread.","title":"General Protection Fault"},{"location":"dump_javadump/#java-outofmemoryerror","text":"In this scenario, the Java heap runs out of memory, causing an OutOfMemoryError , which automatically generates a Java dump file. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for Java heap space. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"Java heap space\" received 1TIDATETIME Date: 2018/09/14 at 15:29:42:709 1TINANOTIME System nanotime: 3635648876608448 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20180914.152929.18885.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) The MEMINFO section records how much memory is allocated to the Java heap ( 1STHEAPTYPE Object Memory ), how much is in use, and how much is free. Solving your problem might be as simple as setting a larger heap size when you start your application. If you don't know what size the Java heap was set to, you might find that information in the ENVINFO section, which records the command line options that were used when the application started. Look or search for the 1CIUSERARGS UserArgs: string and review the entries recorded for all lines that start 2CIUSERARG . The Java heap size is set by the -Xmx option. If the size has not been set on the command line by -Xmx , the default value applies, which you can find in Default Settings . In this scenario the solution to the problem is not an adjustment to the Java heap size. Here is the MEMINFO section: 0SECTION MEMINFO subcomponent dump routine NULL ================================= NULL 1STHEAPTYPE Object Memory NULL id start end size space/region 1STHEAPSPACE 0xB6B49D20 -- -- -- Generational 1STHEAPREGION 0xB6B4A078 0x95750000 0xB5470000 0x1FD20000 Generational/Tenured Region 1STHEAPREGION 0xB6B49F10 0xB5470000 0xB54C0000 0x00050000 Generational/Nursery Region 1STHEAPREGION 0xB6B49DA8 0xB54C0000 0xB5750000 0x00290000 Generational/Nursery Region NULL 1STHEAPTOTAL Total memory: 536870912 (0x20000000) 1STHEAPINUSE Total memory in use: 302603160 (0x12095B98) 1STHEAPFREE Total memory free: 234267752 (0x0DF6A468) The output shows that only 56% of the Java heap is in use, so this suggests that the application is trying to do something sub-optimal. To investigate further you need to work out which thread was the current thread when the OOM occurred to see what it was trying to do. As in the previous scenario, you can find the current thread in the THREADS section. Here is an extract from the output: 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6B60C00, omrthread_t:0xB6B049D8, java/lang/Thread:0x95764520, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x49C6, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6CB5000, to:0xB74B6000, size:0x801000) 3XMCPUTIME CPU usage total: 8.537823831 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/StringBuffer.ensureCapacityImpl(StringBuffer.java:696) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:486(Compiled Code)) 5XESTACKTRACE (entered lock: java/lang/StringBuffer@0x957645B8, entry count: 1) 4XESTACKTRACE at java/lang/StringBuffer.append(StringBuffer.java:428(Compiled Code)) 4XESTACKTRACE at HeapBreaker.main(HeapBreaker.java:34(Compiled Code)) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6C535B3 [libj9prt29.so+0x3b5b3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C5311E [libj9prt29.so+0x3b11e]) 4XENATIVESTACK (0xB6C53216 [libj9prt29.so+0x3b216]) 4XENATIVESTACK (0xB6C52CE3 [libj9prt29.so+0x3ace3]) 4XENATIVESTACK (0xB6C36F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6C52C57 [libj9prt29.so+0x3ac57]) 4XENATIVESTACK (0xB6C4E9CD [libj9prt29.so+0x369cd]) 4XENATIVESTACK (0xB6C502FA [libj9prt29.so+0x382fa]) To simulate a Java OutOfMemoryError , this example application repeatedly appends characters to a StringBuffer object in an infinite loop. The Java callstack shows the HeapBreaker.main method appending characters ( java/lang/StringGuffer.append ) until the method java/lang/StringBuffer.ensureCapacityImpl() throws the OutOfMemoryError . StringBuffer objects are wrappers for character arrays ( char[] ) and when the capacity of the underlying array is reached, the contents are automatically copied into a new, larger array. The new array is created in the StringBuffer.ensureCapacity() method, which more or less doubles the size of the old array. In this scenario, the array takes up all the remaining space in the Java heap. The MEMINFO section of the Java dump file can also tell you when an unexpectedly large allocation request causes an OOM. Look for the GC History ( 1STGCHTYPE ) section, which details allocation requests that trigger GC activity. In the sample output you can see that a large allocation request ( requestedbytes=603979784 ) triggered a global GC. When the GC could not free up sufficient space in the heap to satisfy the request, the allocation failure generated the OOM. 1STGCHTYPE GC History 3STHSTTYPE 14:29:29:580239000 GMT j9mm.101 - J9AllocateIndexableObject() returning NULL! 0 bytes requested for object of class B6BBC300 from memory space 'Generational' id=B6B49D20 3STHSTTYPE 14:29:29:579916000 GMT j9mm.134 - Allocation failure end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579905000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686912/3014656 oldspace=231597224/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:579859000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:579807000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:579776000 GMT j9mm.137 - Compact end: bytesmoved=301989896 3STHSTTYPE 14:29:29:313899000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:313555000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:310772000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:310765000 GMT j9mm.94 - Class unloading end: classloadersunloaded=0 classesunloaded=0 3STHSTTYPE 14:29:29:310753000 GMT j9mm.60 - Class unloading start 3STHSTTYPE 14:29:29:310750000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:306013000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:305957000 GMT j9mm.474 - GlobalGC start: globalcount=9 3STHSTTYPE 14:29:29:305888000 GMT j9mm.475 - GlobalGC end: workstackoverflow=0 overflowcount=0 memory=234284136/536870912 3STHSTTYPE 14:29:29:305837000 GMT j9mm.90 - GlobalGC collect complete 3STHSTTYPE 14:29:29:305808000 GMT j9mm.137 - Compact end: bytesmoved=189784 3STHSTTYPE 14:29:29:298042000 GMT j9mm.136 - Compact start: reason=compact to meet allocation 3STHSTTYPE 14:29:29:297695000 GMT j9mm.57 - Sweep end 3STHSTTYPE 14:29:29:291696000 GMT j9mm.56 - Sweep start 3STHSTTYPE 14:29:29:291692000 GMT j9mm.55 - Mark end 3STHSTTYPE 14:29:29:284994000 GMT j9mm.54 - Mark start 3STHSTTYPE 14:29:29:284941000 GMT j9mm.474 - GlobalGC start: globalcount=8 3STHSTTYPE 14:29:29:284916000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:284914000 GMT j9mm.469 - Allocation failure cycle start: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:284893000 GMT j9mm.470 - Allocation failure cycle end: newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:284858000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=2 flipbytes=64 newspace=2678784/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:284140000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:283160000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=335 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:283123000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:283120000 GMT j9mm.469 - Allocation failure cycle start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:283117000 GMT j9mm.133 - Allocation failure start: newspace=753616/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=603979784 3STHSTTYPE 14:29:29:269762000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269751000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:269718000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 3STHSTTYPE 14:29:29:268981000 GMT j9mm.140 - Tilt ratio: 89 3STHSTTYPE 14:29:29:268007000 GMT j9mm.64 - LocalGC start: globalcount=8 scavengecount=334 weakrefs=0 soft=0 phantom=0 finalizers=0 3STHSTTYPE 14:29:29:267969000 GMT j9mm.135 - Exclusive access: exclusiveaccessms=0.016 meanexclusiveaccessms=0.016 threads=0 lastthreadtid=0xB6B61100 beatenbyotherthread=0 3STHSTTYPE 14:29:29:267966000 GMT j9mm.469 - Allocation failure cycle start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:267963000 GMT j9mm.133 - Allocation failure start: newspace=0/3014656 oldspace=80601248/533856256 loa=5338112/5338112 requestedbytes=48 3STHSTTYPE 14:29:29:249015000 GMT j9mm.134 - Allocation failure end: newspace=2686928/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:249003000 GMT j9mm.470 - Allocation failure cycle end: newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 3STHSTTYPE 14:29:29:248971000 GMT j9mm.560 - LocalGC end: rememberedsetoverflow=0 causedrememberedsetoverflow=0 scancacheoverflow=0 failedflipcount=0 failedflipbytes=0 failedtenurecount=0 failedtenurebytes=0 flipcount=0 flipbytes=0 newspace=2686976/3014656 oldspace=80601248/533856256 loa=5338112/5338112 tenureage=0 Although the Java code that was used in this scenario deliberately triggered an OutOfMemoryError in a pronounced way, similar allocation issues can and do occur when dealing with large data sets such as XML files. The next step in diagnosing the problem is to open the system dump that gets generated automatically when an OutOfMemoryError occurs. Open the dump with the Eclipse Memory Analyzer tool (MAT) and search for the StringBuffer object, which should provide further clues about what went wrong. A common example is seeing the same String duplicated over and over again, which might indicate that code is stuck in a loop. Note: If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plugin in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > If, unlike the previous scenario, you receive an OutOfMemoryError and the MEMINFO section shows that there is very little space left on the Java heap, the current thread information is typically not important. The current thread is simply the thread that happened to be current when the space ran out. In this situation you might want to increase your Java heap size. For help with this task, see How to do heap sizing .","title":"Java OutOfMemoryError"},{"location":"dump_javadump/#native-outofmemoryerror","text":"In this scenario, the VM runs out of native memory. Native memory is memory that is used by the VM for storing all virtualized resources and data that it needs for VM operations. Native memory that is available to the VM process is limited by the operating system. The native memory available to the VM might also be subject to additional limits imposed by the operating system, for example Unix ulimits . When a NativeOutOfMemoryError occurs, a Java dump is generated by default. The first section of the file (TITLE) tells you that a systhrow event triggered the Java dump as a result of an OOM ( java/lang/OutOfMemoryError ) for native memory. 0SECTION TITLE subcomponent dump routine NULL =============================== 1TICHARSET UTF-8 1TISIGINFO Dump Event \"systhrow\" (00040000) Detail \"java/lang/OutOfMemoryError\" \"native memory exhausted\" received 1TIDATETIME Date: 2018/09/14 at 15:49:55:887 1TINANOTIME System nanotime: 3636862054495675 1TIFILENAME Javacore filename: /home/cheesemp/test/javacore.20180914.154814.19708.0003.txt 1TIREQFLAGS Request Flags: 0x81 (exclusive+preempt) 1TIPREPSTATE Prep State: 0x104 (exclusive_vm_access+trace_disabled) Sometimes, the current thread is responsible for causing the NativeOutOfMemoryError . Information about the current thread can be found in the THREADS section, as shown in the following output. 0SECTION THREADS subcomponent dump routine NULL ================================= NULL 1XMPOOLINFO JVM Thread pool info: 2XMPOOLTOTAL Current total number of pooled threads: 16 2XMPOOLLIVE Current total number of live threads: 16 2XMPOOLDAEMON Current total number of live daemon threads: 15 NULL 1XMCURTHDINFO Current thread 3XMTHREADINFO \"main\" J9VMThread:0xB6C60C00, omrthread_t:0xB6C049D8, java/lang/Thread:0xB55E3C10, state:R, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x1, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x4CFD, native priority:0x5, native policy:UNKNOWN, vmstate:R, vm thread flags:0x00001020) 3XMTHREADINFO2 (native stack address range from:0xB6D4E000, to:0xB754F000, size:0x801000) 3XMCPUTIME CPU usage total: 3.654896026 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at sun/misc/Unsafe.allocateDBBMemory(Native Method) 4XESTACKTRACE at java/nio/DirectByteBuffer.<init>(DirectByteBuffer.java:127(Compiled Code)) 4XESTACKTRACE at java/nio/ByteBuffer.allocateDirect(ByteBuffer.java:311) 4XESTACKTRACE at NativeHeapBreaker.main(NativeHeapBreaker.java:9) 3XMTHREADINFO3 Native callstack: 4XENATIVESTACK (0xB6A9F5B3 [libj9prt29.so+0x3b5b3]) ... 4XENATIVESTACK (0xB582CC9C [libjclse7b_29.so+0x40c9c]) 4XENATIVESTACK Java_sun_misc_Unsafe_allocateDBBMemory+0x88 (0xB5827F6B [libjclse7b_29.so+0x3bf6b]) 4XENATIVESTACK (0x94A2084A [<unknown>+0x0]) 4XENATIVESTACK (0xB6B2538B [libj9vm29.so+0x6c38b]) 4XENATIVESTACK (0xB6B4074C [libj9vm29.so+0x8774c]) 4XENATIVESTACK (0xB6B7F299 [libj9vm29.so+0xc6299]) 4XENATIVESTACK (0xB6A82F3E [libj9prt29.so+0x1ef3e]) 4XENATIVESTACK (0xB6B7F32A [libj9vm29.so+0xc632a]) 4XENATIVESTACK (0xB6B4084C [libj9vm29.so+0x8784c]) 4XENATIVESTACK (0xB6B3CD0C [libj9vm29.so+0x83d0c]) 4XENATIVESTACK (0xB776F87D [libjli.so+0x787d]) 4XENATIVESTACK (0xB7784F72 [libpthread.so.0+0x6f72]) 4XENATIVESTACK clone+0x5e (0xB76A043E [libc.so.6+0xee43e]) For clarity in the Native callstack output, ... indicates that some lines are removed. The Java callstack shows the transition from Java to native code ( sun/misc/Unsafe.allocateDBBMemory(Native Method) ), indicating a request for Direct Byte Buffer (DBB) storage. DBB storage is backed by native memory, with the Java heap containing only a reference to the native heap buffer. In this scenario, DBB storage is the likely culprit for this NativeOutOfMemoryError . The next step is to investigate the NATIVEMEMINFO section of the Java dump file, which reports the amount of memory used by the JRE process, broken down into component areas. 0SECTION NATIVEMEMINFO subcomponent dump routine NULL ================================= 0MEMUSER 1MEMUSER JRE: 3,166,386,688 bytes / 4388 allocations 1MEMUSER | 2MEMUSER +--VM: 563,176,824 bytes / 1518 allocations 2MEMUSER | | 3MEMUSER | +--Classes: 3,104,416 bytes / 120 allocations 2MEMUSER | | 3MEMUSER | +--Memory Manager (GC): 548,181,888 bytes / 398 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Heap: 536,932,352 bytes / 1 allocation 3MEMUSER | | | 4MEMUSER | | +--Other: 11,249,536 bytes / 397 allocations 2MEMUSER | | 3MEMUSER | +--Threads: 10,817,120 bytes / 147 allocations 3MEMUSER | | | 4MEMUSER | | +--Java Stack: 115,584 bytes / 16 allocations 3MEMUSER | | | 4MEMUSER | | +--Native Stack: 10,616,832 bytes / 17 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 84,704 bytes / 114 allocations 2MEMUSER | | 3MEMUSER | +--Trace: 163,688 bytes / 268 allocations 2MEMUSER | | 3MEMUSER | +--JVMTI: 17,320 bytes / 13 allocations 2MEMUSER | | 3MEMUSER | +--JNI: 23,296 bytes / 55 allocations 2MEMUSER | | 3MEMUSER | +--Port Library: 8,576 bytes / 74 allocations 2MEMUSER | | 3MEMUSER | +--Other: 860,520 bytes / 443 allocations 1MEMUSER | 2MEMUSER +--JIT: 3,744,728 bytes / 122 allocations 2MEMUSER | | 3MEMUSER | +--JIT Code Cache: 2,097,152 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--JIT Data Cache: 524,336 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--Other: 1,123,240 bytes / 120 allocations 1MEMUSER | 2MEMUSER +--Class Libraries: 2,599,463,024 bytes / 2732 allocations 2MEMUSER | | 3MEMUSER | +--Harmony Class Libraries: 1,024 bytes / 1 allocation 2MEMUSER | | 3MEMUSER | +--VM Class Libraries: 2,599,462,000 bytes / 2731 allocations 3MEMUSER | | | 4MEMUSER | | +--sun.misc.Unsafe: 2,598,510,480 bytes / 2484 allocations 4MEMUSER | | | | 5MEMUSER | | | +--Direct Byte Buffers: 2,598,510,480 bytes / 2484 allocations 3MEMUSER | | | 4MEMUSER | | +--Other: 951,520 bytes / 247 allocations 1MEMUSER | 2MEMUSER +--Unknown: 2,112 bytes / 16 allocations NULL In the VM Class Libraries section, the amount of memory allocated for Direct Byte Buffers is shown. Because the NativeOutOfMemoryError was received on a small 32-bit system, a value of 2,598,510,480 bytes indicates that the operating system has run out of memory. On a larger UNIX system, the process might have run out of memory because of the ulimit setting. Increasing the value for ulimit might avoid the error, which you can do temporarily by setting ulimit -f unlimited in your current session. The theoretical maximum size for a 32-bit process is the size of the 32-bit address space, which is 4 GB. On most operating systems a portion of the address space for each process is used by the kernel, such that the real limit for 32-bit processes is actually significantly less than 4GB. As a result, running out of native memory with a 32-bit VM is quite common. The same 4 GB limit is also important if you are using a 64-bit VM with compressed references. In compressed references mode, all references to objects, classes, threads, and monitors are represented by 32-bit values for performance reasons, so these structures can be allocated only at 32-bit addresses. However, the operating system might place other allocations within this 4 GB of address space, and if this area becomes sufficiently full or fragmented, the VM throws a native NativeOutOfMemoryError error. These errors typically occur when the VM tries to create a new thread or load a class. The Current Thread History section should contain more information about what the thread was doing at the VM level when the NativeOutOfMemoryError error occurred. You can usually avoid this type of problem by using the -Xmcrs option to reserve a contiguous area of memory within the lowest 4GB of memory at VM startup. Another common cause of a NativeOutOfMemoryError is when an application loads duplicate classes. Classes are allocated outside of the Java heap in native memory. If the value reported for Classes in the NATIVEMEMINFO section is very large, duplicate classes might be the cause of your problem. The Eclipse Memory Analyzer Tool (MAT) can tell you if you have duplicate classes by using the Class Loader Explorer feature. Because a system dump is automatically generated as well as a Java dump in response to a NativeOutOfMemoryError , simply open the system dump in MAT to continue your diagnosis.","title":"Native OutOfMemoryError"},{"location":"dump_javadump/#deadlock","text":"Deadlocks occur when two threads attempt to synchronize on an object and lock an instance of a class. When this happens, your application stops responding and hangs. Generating a Java dump file will quickly tell you whether you have a deadlock situation. Trigger the Java dump by sending a SIGQUIT signal ( kill -3 ) to the VM. The VM can detect the most common types of deadlock scenario involving Java monitors. If this type of deadlock is detected, information is provided in the LOCKS section. More complex deadlocks, including those that involve a mixture of native mutexes and Java monitors, are not detected. Here is the output from the code that was used to cause a common deadlock scenario: NULL 1LKDEADLOCK Deadlock detected !!! NULL --------------------- NULL 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) 3LKDEADLOCKWTR is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B344 infl_mon_t: 0x08C2B384: 4LKDEADLOCKOBJ java/lang/Object@0xB5666698 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 3\" (0x94507500) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B3A0 infl_mon_t: 0x08C2B3E0: 4LKDEADLOCKOBJ java/lang/Object@0xB5666678 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 1\" (0x92A3EC00) 3LKDEADLOCKWTR which is waiting for: 4LKDEADLOCKMON sys_mon_t:0x08C2B2E8 infl_mon_t: 0x08C2B328: 4LKDEADLOCKOBJ java/lang/Object@0xB5666688 3LKDEADLOCKOWN which is owned by: 2LKDEADLOCKTHR Thread \"Worker Thread 2\" (0x94501D00) This output tells you that Worker Thread 2 is waiting for Worker Thread 3 , which is waiting for Worker Thread 1 . Because Worker Thread 1 is also waiting for Worker Thread 2 , there is a deadlock. The next place to look is the output for Java and native stacks, in the THREADS section. By looking at the stack for each of these worker threads you can trace the problem back to specific lines in your application code. In this example, you can see from the following output that for all worker threads, the stack traces ( 4XESTACKTRACE / 5XESTACKTRACE ) indicate a problem in line 35 of the application DeadLockTest.java : 3XMTHREADINFO \"Worker Thread 1\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C2B0, java/lang/Thread:0xB5666778, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52CF, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004365543 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666688 Owned by: \"Worker Thread 2\" (J9VMThread:0x94501D00, java/lang/Thread:0xB56668D0) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666678, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 2\" J9VMThread:0x94501D00, omrthread_t:0x92A3C8F0, java/lang/Thread:0xB56668D0, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x14, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D0, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x946BF000, to:0x94700000, size:0x41000) 3XMCPUTIME CPU usage total: 0.004555580 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666698 Owned by: \"Worker Thread 3\" (J9VMThread:0x94507500, java/lang/Thread:0xB5666A18) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666688, entry count: 1) ... 3XMTHREADINFO \"Worker Thread 3\" J9VMThread:0x94507500, omrthread_t:0x92A3CC10, java/lang/Thread:0xB5666A18, state:B, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x15, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x52D1, native priority:0x5, native policy:UNKNOWN, vmstate:B, vm thread flags:0x00000201) 3XMTHREADINFO2 (native stack address range from:0x9467E000, to:0x946BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.003657010 secs, current category=\"Application\" 3XMTHREADBLOCK Blocked on: java/lang/Object@0xB5666678 Owned by: \"Worker Thread 1\" (J9VMThread:0x92A3EC00, java/lang/Thread:0xB5666778) 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at WorkerThread.run(DeadLockTest.java:35) 5XESTACKTRACE (entered lock: java/lang/Object@0xB5666698, entry count: 1)","title":"Deadlock"},{"location":"dump_javadump/#hang","text":"An application can hang for a number of reasons but the most common cause is excessive global garbage collection (GC) activity, where your application is repeatedly paused because your Java heap has almost run out of memory. You can identify this problem by looking at verbose GC output. Collect this output by specifying the -verbose:gc option. Deadlock situations can also manifest themselves as hangs. For more information on diagnosing this type of problem from a Java dump, see the deadlock scenario. If you have eliminated verbose GC activity and deadlocks, another common hang scenario involves threads that compete and wait for Java object locks. This type of problem can usually be diagnosed by examining a Java dump. The simplest hang scenario involving Java object locks is where a thread acquires a lock that other threads are waiting for, but it doesn't release the lock for some reason. The first place to look in the Java dump output is the LOCKS section. This section lists all the monitors and shows which threads have acquired a lock and which threads are waiting. If the hang is caused by a thread not releasing a lock that other threads need, you can see a list of waiting threads in the output. In this example scenario, the Java dump LOCKS section shows that Worker Thread 0 ( 3LKMONOBJECT ) has acquired a lock and there are 19 other worker threads waiting to obtain the lock. NULL ------------------------------------------------------------------------ 0SECTION LOCKS subcomponent dump routine NULL =============================== NULL 1LKPOOLINFO Monitor pool info: 2LKPOOLTOTAL Current total number of monitors: 1 NULL 1LKMONPOOLDUMP Monitor Pool Dump (flat & inflated object-monitors): 2LKMONINUSE sys_mon_t:0x92711200 infl_mon_t: 0x92711240: 3LKMONOBJECT java/lang/Object@0xB56658D8: Flat locked by \"Worker Thread 0\" (J9VMThread:0x92A3EC00), entry count 1 3LKWAITERQ Waiting to enter: 3LKWAITER \"Worker Thread 1\" (J9VMThread:0x92703F00) 3LKWAITER \"Worker Thread 2\" (J9VMThread:0x92709C00) 3LKWAITER \"Worker Thread 3\" (J9VMThread:0x92710A00) 3LKWAITER \"Worker Thread 4\" (J9VMThread:0x92717F00) 3LKWAITER \"Worker Thread 5\" (J9VMThread:0x9271DC00) 3LKWAITER \"Worker Thread 6\" (J9VMThread:0x92723A00) 3LKWAITER \"Worker Thread 7\" (J9VMThread:0x92729800) 3LKWAITER \"Worker Thread 8\" (J9VMThread:0x92733700) 3LKWAITER \"Worker Thread 9\" (J9VMThread:0x92739400) 3LKWAITER \"Worker Thread 10\" (J9VMThread:0x92740200) 3LKWAITER \"Worker Thread 11\" (J9VMThread:0x92748100) 3LKWAITER \"Worker Thread 12\" (J9VMThread:0x9274DF00) 3LKWAITER \"Worker Thread 13\" (J9VMThread:0x92754D00) 3LKWAITER \"Worker Thread 14\" (J9VMThread:0x9275AA00) 3LKWAITER \"Worker Thread 15\" (J9VMThread:0x92760800) 3LKWAITER \"Worker Thread 16\" (J9VMThread:0x92766600) 3LKWAITER \"Worker Thread 17\" (J9VMThread:0x9276C300) 3LKWAITER \"Worker Thread 18\" (J9VMThread:0x92773100) 3LKWAITER \"Worker Thread 19\" (J9VMThread:0x92778F00) NULL The next step is to determine why Worker Thread 0 is not releasing the lock. The best place to start is the stack trace for this thread, which you can find by searching on the thread name or J9VMThread ID in the THREADS section. The following extract shows the details for \"Worker Thread 0\" (J9VMThread:0x92A3EC00) : NULL 3XMTHREADINFO \"Worker Thread 0\" J9VMThread:0x92A3EC00, omrthread_t:0x92A3C280, java/lang/Thread:0xB56668B8, state:CW, prio=5 3XMJAVALTHREAD (java/lang/Thread getId:0x13, isDaemon:false) 3XMTHREADINFO1 (native thread ID:0x511F, native priority:0x5, native policy:UNKNOWN, vmstate:CW, vm thread flags:0x00000401) 3XMTHREADINFO2 (native stack address range from:0x9297E000, to:0x929BF000, size:0x41000) 3XMCPUTIME CPU usage total: 0.000211878 secs, current category=\"Application\" 3XMHEAPALLOC Heap bytes allocated since last GC cycle=0 (0x0) 3XMTHREADINFO3 Java callstack: 4XESTACKTRACE at java/lang/Thread.sleep(Native Method) 4XESTACKTRACE at java/lang/Thread.sleep(Thread.java:941) 4XESTACKTRACE at WorkerThread.doWork(HangTest.java:37) 4XESTACKTRACE at WorkerThread.run(HangTest.java:31) 5XESTACKTRACE (entered lock: java/lang/Object@0xB56658D8, entry count: 1) In the last line of this output you can see where the thread acquired the lock. Working up from this line, you can see that WorkerThread.run was called, which in turn called WorkerThread.doWork . The stack shows that the thread then entered a call to java/lang/Thread.sleep in HangTest.java on line 37, which is preventing the thread from completing its work and releasing the lock. In this example the sleep call was added to induce a hang, but in real-world scenarios the cause could be any blocking operation, such as reading from an input stream or socket. Another possibility is that the thread is waiting for another lock owned by yet another thread. It is important to remember that each Java dump represents a single snapshot in time. You should generate at least three Java dumps separated by a short pause, for example 30 seconds, and compare the output. This comparison tells you whether the threads involved are stuck in a fixed state or whether they are moving. In this example, the threads do not move and the investigation needs to focus on the logic in WorkerThread.doWork to understand why Worker Thread 0 entered the java/lang/Thread.sleep call. Another common scenario is where each Java dump shows a number of threads waiting for a lock owned by another thread, but the list of waiting threads and the lock-owning thread change over time. In this case the cause is likely to be a bottleneck caused by thread contention, where the threads are continually competing for the same lock. In severe cases, the lock is held only for a small amount of time but there are lots of threads trying to obtain it. Because more time is spent handling the lock and scheduling the thread than executing application code, the degradation in performance is manifested as a hang. Thread contention is usually caused by an application design problem. You can use a similar approach to the one used in this scenario to determime which lines of code are responsible for the contention.","title":"Hang"},{"location":"dump_systemdump/","text":"System dump System dumps, often known as core dumps , are platform-specific and contain a raw binary dump of the process memory. This type of dump has a complete copy of the Java heap, including the contents of all Java objects in the application. To examine a system dump you can use the OpenJ9 dump viewer ( jdmpview ), a platform-specific debugging tool, or the Eclipse Memory Analyzer tool (MAT) . If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plugin in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java","title":"System dump"},{"location":"dump_systemdump/#system-dump","text":"System dumps, often known as core dumps , are platform-specific and contain a raw binary dump of the process memory. This type of dump has a complete copy of the Java heap, including the contents of all Java objects in the application. To examine a system dump you can use the OpenJ9 dump viewer ( jdmpview ), a platform-specific debugging tool, or the Eclipse Memory Analyzer tool (MAT) . If you want to use MAT to analyze your system dump, you must install the Diagnostic Tool Framework for Java (DTFJ) plugin in the Eclipse IDE. Select the following menu items: Help > Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java","title":"System dump"},{"location":"env_var/","text":"Environment variables Although the OpenJ9 virtual machine (VM) recognizes many environment variables, most are superseded by command-line arguments. Use command-line arguments rather than environment variables, which are retained only for compatibility. Note: Environment variables are overridden by command-line arguments. Finding and setting environment variables To show the current environment, run: set (Windows\u2122) env (AIX\u00ae, Linux\u00ae, and macOS\u00ae) set (z/OS\u00ae) To show a particular environment variable, run: echo %ENVNAME% (Windows) echo $ENVNAME (AIX, Linux, macOS, and z/OS) Use values exactly as shown in the documentation. The names of environment variables are case-sensitive in AIX, Linux, macOS, and z/OS. To set the environment variable LOGIN_NAME to Fred , run: set LOGIN_NAME=Fred (Windows) export LOGIN_NAME=Fred (AIX/Linux/macOS: ksh or bash shells) setenv LOGIN_NAME Fred (csh shells) These variables are set only for the current shell or command-line session. If you are setting multiple values for an environment variable in a list: On AIX, Linux, macOS, and z/OS the separator is typically a colon (:). On Windows the separator is typically a semicolon (;). General options General VM environment variables are shown in the following table: Environment variable Usage information IBM_JAVA_COMMAND_LINE This variable is set by the VM after it starts. Using this variable, you can find the command-line parameters set when the VM started. This setting is not available if the VM is invoked by using JNI. OPENJ9_JAVA_OPTIONS=<option> Set this variable to store default Java options, including -X , -D , or -verbose:gc style options. For example, -Xms256m -Djava.compiler . Any options set are overridden by equivalent options that are specified when Java is started. This variable does not support certain options, see the list in -Xoptionsfile . If you specify the name of a trace output file either directly, or indirectly, by using a properties file, the output file might be accidentally overwritten if you run utilities such as the trace formatter, dump extractor, or dump viewer. To avoid this problem, add %d, %p or %t to the trace file names. See -Xtrace:output . Note: The equivalent IBM_JAVA_OPTIONS is deprecated and will be removed in a future release. JAVA_FONTS=<list of directories> Set this environment variable to specify the font directory. Setting this variable is equivalent to setting the property java.awt.fonts on Windows operating systems, and sun.java2d.fontpath on other operating systems. Dump agent options The preferred mechanism for controlling the production of dumps is by using the -Xdump option. However, these legacy environment variables are preserved and can still be used. The following table describes dump agent options: Environment Variable Usage Information JAVA_DUMP_OPTS Used to control the conditions under which dumps are produced. If you set agents for a condition by using the JAVA_DUMP_OPTS environment variable, default dump agents for that condition are disabled; however, any -Xdump options that are specified on the command line are used. The JAVA_DUMP_OPTS environment variable uses the following syntax: JAVA_DUMP_OPTS=\"ON<condition>(<agent>[<count>],<agent>[<count>]), ON<condition>(<agent>[<count>],...),...)\" Where: <condition> is one of the following values: ANYSIGNAL DUMP ERROR INTERRUPT EXCEPTION OUTOFMEMORY <agent> is one of the following values: ALL NONE JAVADUMP SYSDUMP HEAPDUMP CEEDUMP (z/OS specific) <count> is the number of times to run the specified agent for the specified condition. This value is optional. By default, the agent runs every time that the condition occurs. JAVA_DUMP_OPTS is parsed by taking the leftmost occurrence of each condition, so duplicates are ignored. The following setting produces a system dump for the first error condition only: ONERROR(SYSDUMP[1]),ONERROR(JAVADUMP) Also, the ONANYSIGNAL condition is parsed before all others, so ONINTERRUPT(NONE),ONANYSIGNAL(SYSDUMP) has the same effect as ONANYSIGNAL(SYSDUMP),ONINTERRUPT(NONE) If the JAVA_DUMP_TOOL environment variable is set, that variable is assumed to specify a valid executable name and is parsed for replaceable fields, such as %pid . If %pid is detected in the string, the string is replaced with the VM's own process ID. The tool that is specified by JAVA_DUMP_TOOL is run after any system dump or heap dump is taken, before anything else. The dump settings are applied in the following order. Settings later in the list take precedence: Default VM dump behavior. -Xdump command-line options that specify -Xdump:<type>:defaults , see OpenJ9 default options . DISABLE_JAVADUMP , IBM_HEAPDUMP , and IBM_HEAP_DUMP environment variables. IBM_JAVADUMP_OUTOFMEMORY and IBM_HEAPDUMP_OUTOFMEMORY environment variables. JAVA_DUMP_OPTS environment variable. Remaining -Xdump command-line options. Setting JAVA_DUMP_OPTS affects only those conditions that you specify. Actions on other conditions are unchanged. Signal mapping When setting the JAVA_DUMP_OPTS environment variable, the mapping of operating system signals to the \"condition\" is shown in the following table: Condition z/OS Windows Linux, macOS, and AIX EXCEPTION SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGSYS, SIGXFSV SIGILL, SIGSEGV, SIGFPE SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGXFSV INTERRUPT SIGINT, SIGTERM, SIGHUP SIGINT, SIGTERM SIGINT, SIGTERM, SIGHUP ERROR SIGABRT SIGABRT SIGABRT DUMP SIGQUIT SIGBREAK SIGQUIT Java dump options The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:java option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information DISABLE_JAVADUMP=[TRUE|FALSE] Setting DISABLE_JAVADUMP to TRUE is the equivalent of using -Xdump:java:none and stops the default production of Java dumps. IBM_JAVACOREDIR=<directory> The default location into which the Java dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_JAVADUMP_OUTOFMEMORY=[TRUE|FALSE] By setting this environment variable to FALSE , you disable Java dumps for an out-of-memory exception. When not set, a Java dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable Java dumps for an out-of-memory exception. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and Heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Java dumps are produced. Heap dump options The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:heap option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information IBM_HEAPDUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAP_DUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAPDUMPDIR=<directory> The default location into which the heap dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_HEAPDUMP_OUTOFMEMORY=[TRUE|FALSE] Controls the generation of a heap dump when an out-of-memory exception is thrown. When not set, a heap dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable heap dump for an out-of-memory exception. IBM_JAVA_HEAPDUMP_TEST Use this environment variable to cause the VM to generate both PHD and text versions of heap dumps. Equivalent to opts=PHD+CLASSIC on the -Xdump:heap option. IBM_JAVA_HEAPDUMP_TEXT Use this environment variable to cause the VM to generate a text (human readable) Heap dump. Equivalent to opts=CLASSIC on the -Xdump:heap option. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Heap dumps are produced. Other diagnostic options The following table lists other environment variables that can be set for diagnostic purposes: Environment variable Usage Instructions IBM_COREDIR=<directory> Set this variable to specify an alternative location for system dumps, JIT dumps, and snap trace. On z/OS, _CEE_DMPTARG is used instead for snap trace, and transaction dumps are written to TSO according to JAVA_DUMP_TDUMP_PATTERN . On Linux and macOS, the dump is written to the directory that is specified directory by the operating system before being moved to the specified location. IBM_JAVA_ABEND_ON_FAILURE=Y (z/OS only) This setting tells the Java launcher to mark the Task Control Block (TCB) with an abend code if the OpenJ9 VM fails to load or is terminated by an uncaught exception. By default, the Java launcher does not mark the TCB. JAVA_DUMP_TDUMP_PATTERN=<string> (z/OS only) The specified <string> is passed to IEATDUMP to use as the data/set name for the Transaction Dump. The default <string> is %uid.JVM.TDUMP.%job.D%y%m%d.T%H%M%S (31-bit) or %uid.JVM.%job.D%y%m%d.T%H%M%S.X&amp;DS (64-bit), where %uid is found from the C code fragment shown in Notes . JAVA_THREAD_MODEL=<string> <string> can be defined as one of the following values: NATIVE (all threads are created as _MEDIUM_WEIGHT ), HEAVY (all threads are created as _HEAVY_WEIGHT ), MEDIUM (same as NATIVE ), or NULL . The default is NATIVE . IBM_XE_COE_NAME=<value> Set this variable to generate a system dump when the specified exception occurs. The value that is supplied is the package description of the exception; for example, java/lang/InternalError . A Signal 11 is followed by a JVMXE message and then the VM ends. JAVA_PLUGIN_TRACE=TRUE When this variable is set to TRUE or 1, a Java plug-in trace is produced for the session when an application runs. Traces are produced from both the Java and Native layer. By default, this variable is set to FALSE , so that a Java plug-in trace is not produced. Notes: C code fragment to discover %uid for JAVA_DUMP_TDUMP_PATTERN=<string> : pwd = getpwuid(getuid()); pwd->pw_name; Deprecated JIT options The following table describes deprecated environment variables for the JIT compiler: Environment Variable Usage Information IBM_MIXED_MODE_THRESHOLD Use -Xjit:count=<value> instead of this variable. JAVA_COMPILER Use -Djava.compiler=<value> instead of this variable.","title":"Environment variables"},{"location":"env_var/#environment-variables","text":"Although the OpenJ9 virtual machine (VM) recognizes many environment variables, most are superseded by command-line arguments. Use command-line arguments rather than environment variables, which are retained only for compatibility. Note: Environment variables are overridden by command-line arguments.","title":"Environment variables"},{"location":"env_var/#finding-and-setting-environment-variables","text":"To show the current environment, run: set (Windows\u2122) env (AIX\u00ae, Linux\u00ae, and macOS\u00ae) set (z/OS\u00ae) To show a particular environment variable, run: echo %ENVNAME% (Windows) echo $ENVNAME (AIX, Linux, macOS, and z/OS) Use values exactly as shown in the documentation. The names of environment variables are case-sensitive in AIX, Linux, macOS, and z/OS. To set the environment variable LOGIN_NAME to Fred , run: set LOGIN_NAME=Fred (Windows) export LOGIN_NAME=Fred (AIX/Linux/macOS: ksh or bash shells) setenv LOGIN_NAME Fred (csh shells) These variables are set only for the current shell or command-line session. If you are setting multiple values for an environment variable in a list: On AIX, Linux, macOS, and z/OS the separator is typically a colon (:). On Windows the separator is typically a semicolon (;).","title":"Finding and setting environment variables"},{"location":"env_var/#general-options","text":"General VM environment variables are shown in the following table: Environment variable Usage information IBM_JAVA_COMMAND_LINE This variable is set by the VM after it starts. Using this variable, you can find the command-line parameters set when the VM started. This setting is not available if the VM is invoked by using JNI. OPENJ9_JAVA_OPTIONS=<option> Set this variable to store default Java options, including -X , -D , or -verbose:gc style options. For example, -Xms256m -Djava.compiler . Any options set are overridden by equivalent options that are specified when Java is started. This variable does not support certain options, see the list in -Xoptionsfile . If you specify the name of a trace output file either directly, or indirectly, by using a properties file, the output file might be accidentally overwritten if you run utilities such as the trace formatter, dump extractor, or dump viewer. To avoid this problem, add %d, %p or %t to the trace file names. See -Xtrace:output . Note: The equivalent IBM_JAVA_OPTIONS is deprecated and will be removed in a future release. JAVA_FONTS=<list of directories> Set this environment variable to specify the font directory. Setting this variable is equivalent to setting the property java.awt.fonts on Windows operating systems, and sun.java2d.fontpath on other operating systems.","title":"General options"},{"location":"env_var/#dump-agent-options","text":"The preferred mechanism for controlling the production of dumps is by using the -Xdump option. However, these legacy environment variables are preserved and can still be used. The following table describes dump agent options: Environment Variable Usage Information JAVA_DUMP_OPTS Used to control the conditions under which dumps are produced. If you set agents for a condition by using the JAVA_DUMP_OPTS environment variable, default dump agents for that condition are disabled; however, any -Xdump options that are specified on the command line are used. The JAVA_DUMP_OPTS environment variable uses the following syntax: JAVA_DUMP_OPTS=\"ON<condition>(<agent>[<count>],<agent>[<count>]), ON<condition>(<agent>[<count>],...),...)\" Where: <condition> is one of the following values: ANYSIGNAL DUMP ERROR INTERRUPT EXCEPTION OUTOFMEMORY <agent> is one of the following values: ALL NONE JAVADUMP SYSDUMP HEAPDUMP CEEDUMP (z/OS specific) <count> is the number of times to run the specified agent for the specified condition. This value is optional. By default, the agent runs every time that the condition occurs. JAVA_DUMP_OPTS is parsed by taking the leftmost occurrence of each condition, so duplicates are ignored. The following setting produces a system dump for the first error condition only: ONERROR(SYSDUMP[1]),ONERROR(JAVADUMP) Also, the ONANYSIGNAL condition is parsed before all others, so ONINTERRUPT(NONE),ONANYSIGNAL(SYSDUMP) has the same effect as ONANYSIGNAL(SYSDUMP),ONINTERRUPT(NONE) If the JAVA_DUMP_TOOL environment variable is set, that variable is assumed to specify a valid executable name and is parsed for replaceable fields, such as %pid . If %pid is detected in the string, the string is replaced with the VM's own process ID. The tool that is specified by JAVA_DUMP_TOOL is run after any system dump or heap dump is taken, before anything else. The dump settings are applied in the following order. Settings later in the list take precedence: Default VM dump behavior. -Xdump command-line options that specify -Xdump:<type>:defaults , see OpenJ9 default options . DISABLE_JAVADUMP , IBM_HEAPDUMP , and IBM_HEAP_DUMP environment variables. IBM_JAVADUMP_OUTOFMEMORY and IBM_HEAPDUMP_OUTOFMEMORY environment variables. JAVA_DUMP_OPTS environment variable. Remaining -Xdump command-line options. Setting JAVA_DUMP_OPTS affects only those conditions that you specify. Actions on other conditions are unchanged.","title":"Dump agent options"},{"location":"env_var/#signal-mapping","text":"When setting the JAVA_DUMP_OPTS environment variable, the mapping of operating system signals to the \"condition\" is shown in the following table: Condition z/OS Windows Linux, macOS, and AIX EXCEPTION SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGSYS, SIGXFSV SIGILL, SIGSEGV, SIGFPE SIGTRAP, SIGILL, SIGSEGV, SIGFPE, SIGBUS, SIGXFSV INTERRUPT SIGINT, SIGTERM, SIGHUP SIGINT, SIGTERM SIGINT, SIGTERM, SIGHUP ERROR SIGABRT SIGABRT SIGABRT DUMP SIGQUIT SIGBREAK SIGQUIT","title":"Signal mapping"},{"location":"env_var/#java-dump-options","text":"The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:java option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information DISABLE_JAVADUMP=[TRUE|FALSE] Setting DISABLE_JAVADUMP to TRUE is the equivalent of using -Xdump:java:none and stops the default production of Java dumps. IBM_JAVACOREDIR=<directory> The default location into which the Java dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_JAVADUMP_OUTOFMEMORY=[TRUE|FALSE] By setting this environment variable to FALSE , you disable Java dumps for an out-of-memory exception. When not set, a Java dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable Java dumps for an out-of-memory exception. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and Heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Java dumps are produced.","title":"Java dump options"},{"location":"env_var/#heap-dump-options","text":"The preferred mechanism for controlling the production of Java dumps is by using the -Xdump:heap option. However, these legacy environment variables are preserved and can still be used. Environment Variable Usage Information IBM_HEAPDUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAP_DUMP=[TRUE|FALSE] Setting this option to TRUE enables heap dump production by using signals. IBM_HEAPDUMPDIR=<directory> The default location into which the heap dump is written. On z/OS, the _CEE_DMPTARG environment variable is used instead. IBM_HEAPDUMP_OUTOFMEMORY=[TRUE|FALSE] Controls the generation of a heap dump when an out-of-memory exception is thrown. When not set, a heap dump is generated when an out-of-memory exception is thrown but not caught and handled by the application. Set to TRUE to generate a dump when an out-of-memory exception is thrown, even if it is handled by the application. Set to FALSE to disable heap dump for an out-of-memory exception. IBM_JAVA_HEAPDUMP_TEST Use this environment variable to cause the VM to generate both PHD and text versions of heap dumps. Equivalent to opts=PHD+CLASSIC on the -Xdump:heap option. IBM_JAVA_HEAPDUMP_TEXT Use this environment variable to cause the VM to generate a text (human readable) Heap dump. Equivalent to opts=CLASSIC on the -Xdump:heap option. TMPDIR=<directory> This variable specifies an alternative temporary directory. This directory is used only when Java dumps and heap dumps cannot be written to their target directories, or the current working directory. The default is /tmp ( C:\\temp for Windows). Note: You can use the dump agent JAVA_DUMP_OPTS variable to control the conditions under which Heap dumps are produced.","title":"Heap dump options"},{"location":"env_var/#other-diagnostic-options","text":"The following table lists other environment variables that can be set for diagnostic purposes: Environment variable Usage Instructions IBM_COREDIR=<directory> Set this variable to specify an alternative location for system dumps, JIT dumps, and snap trace. On z/OS, _CEE_DMPTARG is used instead for snap trace, and transaction dumps are written to TSO according to JAVA_DUMP_TDUMP_PATTERN . On Linux and macOS, the dump is written to the directory that is specified directory by the operating system before being moved to the specified location. IBM_JAVA_ABEND_ON_FAILURE=Y (z/OS only) This setting tells the Java launcher to mark the Task Control Block (TCB) with an abend code if the OpenJ9 VM fails to load or is terminated by an uncaught exception. By default, the Java launcher does not mark the TCB. JAVA_DUMP_TDUMP_PATTERN=<string> (z/OS only) The specified <string> is passed to IEATDUMP to use as the data/set name for the Transaction Dump. The default <string> is %uid.JVM.TDUMP.%job.D%y%m%d.T%H%M%S (31-bit) or %uid.JVM.%job.D%y%m%d.T%H%M%S.X&amp;DS (64-bit), where %uid is found from the C code fragment shown in Notes . JAVA_THREAD_MODEL=<string> <string> can be defined as one of the following values: NATIVE (all threads are created as _MEDIUM_WEIGHT ), HEAVY (all threads are created as _HEAVY_WEIGHT ), MEDIUM (same as NATIVE ), or NULL . The default is NATIVE . IBM_XE_COE_NAME=<value> Set this variable to generate a system dump when the specified exception occurs. The value that is supplied is the package description of the exception; for example, java/lang/InternalError . A Signal 11 is followed by a JVMXE message and then the VM ends. JAVA_PLUGIN_TRACE=TRUE When this variable is set to TRUE or 1, a Java plug-in trace is produced for the session when an application runs. Traces are produced from both the Java and Native layer. By default, this variable is set to FALSE , so that a Java plug-in trace is not produced. Notes: C code fragment to discover %uid for JAVA_DUMP_TDUMP_PATTERN=<string> : pwd = getpwuid(getuid()); pwd->pw_name;","title":"Other diagnostic options"},{"location":"env_var/#deprecated-jit-options","text":"The following table describes deprecated environment variables for the JIT compiler: Environment Variable Usage Information IBM_MIXED_MODE_THRESHOLD Use -Xjit:count=<value> instead of this variable. JAVA_COMPILER Use -Djava.compiler=<value> instead of this variable.","title":"Deprecated JIT options"},{"location":"gc/","text":"Garbage collection The process of managing memory in the VM is handled by the Allocator and the Garbage Collector (GC). These components operate on an area of memory that is reserved for VM processing called the Java heap. The Allocator assigns areas of the Java heap for Java objects. See Memory allocation for more information about the Allocator. The garbage collector To prevent applications running out of memory, objects in the Java heap that are no longer required must be reclaimed. This process is known as garbage collection. When garbage is collected, the garbage collector must obtain exclusive access to the heap, which causes an application to pause while the clean up is done. This pause is often referred to as a stop-the-world pause because an application must halt until the process completes. In general, the first step in the GC process is to mark the objects that are reachable, which means they are still in use. The next step is to sweep away the unmarked objects to reclaim memory. The last step, which isn't always required unless the heap has become very fragmented, is to compact the heap. GC policies Eclipse OpenJ9 has a number of GC policies designed around different types of applications and workloads. Picking the right policy very much depends on your usage and performance goals. For more information about these garbage collection policies and options, see -Xgcpolicy . gencon policy If you have a transactional application, with many short lived objects, the Generational Concurrent GC policy ( -Xgcpolicy:gencon ) is probably best suited, which aims to minimize GC pause times without compromising throughput. This is the default policy employed by the VM, so if you want to use it you don't need to specify it on the command line when you start your application. With the gencon policy, the Java heap is divided into two main areas, the nursery area, where new objects are created and the tenure area, where objects are moved if they have reached tenure age . The nursery area is subdivided into two further areas, the allocate space and the survivor space. The GC process is illustrated in the following diagram, which shows a sequence of 4 main events: Objects are created in the allocate space. The allocate space is full. A local GC scavenge process runs and reachable objects are either copied into the survivor space or into the tenure area if they have reached tenure age . Any objects that can't be reached are left untouched and subsequently cleared. The allocate and survivor spaces swap roles. The original survivor space becomes the allocate space where new objects are created, and the original allocate space becomes the survivor space ready for the next local GC scavenge process. The relative sizes of the allocate and survivor spaces are dynamically adjusted by a technique called tilting . When the nursery area is first created, it is evenly divided between the allocate and survivor spaces. If, after a GC scavenge process is run, the amount of space required for the survivor area is comparatively small, the boundary between the two spaces is adjusted by tilting . For example, if the survivor space requires only 10% of the nursery area, the tilt ratio is adjusted to give 90% of the nursery area to the allocate space. With more space available for new objects, garbage collection can be delayed. The tenure age of an object is determined by the VM and reflects the number of times that an object has been copied between the allocate space and the survivor space. The age is in the range 1 - 14 and is adjusted dynamically by the VM depending on the overall amount of space that is used in the nursery area . For example, if an object has a tenure age of 5, it has been copied backwards and forwards between allocate and survivor spaces 5 times. If the VM sets a tenure age of 5 based on the percentage of space remaining in the nursery area, the next scavenge moves the object from the nursery to the tenure area. You can set an initial tenure age with the -Xgc:scvTenureAge option. You can also prevent the VM dynamically adjusting the tenure age by setting the Xgc:scvNoAdaptiveTenure option so that the intial age is maintained throughout the run time of the VM. Within the tenure area, new objects are allocated into the small object area (SOA), which is illustrated in the earlier diagram (see 3.). A large object area (LOA) is set aside for objects greater than 64 KB that cannot be allocated into the SOA to minimize fragmentation. The LOA is allocated by default but is reduced and removed after a few GC cycles if it isn't populated. To prevent the creation of an LOA, you can specify the -Xnoloa option on the command line when you start your application. When the tenure area is close to full a global GC is triggered. The local GC scavenge reduces pause times by freqently reclaiming memory in the nursery area which, for a transactional application with many short-lived objects, has the most recyclable space. However, over time the tenure area might become full. So, whilst a local GC scavenge process is operating on the nursery area, a concurrent global GC process also runs alongside normal program execution to mark and remove unreachable objects from the tenure area. These two GC approaches combine to provide a good trade-off between shorter pause times and consistent throughput. Concurrent Scavenge A special mode of the gencon policy is known as Concurrent Scavenge ( -Xgc:concurrentScavenge ), which aims to minimize the time spent in stop-the-world pauses by collecting nursery garbage in parallel with running application threads. This mode can be enabled with hardware-based support and software-based support. Hardware-based support: (Linux on IBM Z\u00ae and z/OS\u00ae) This mode works on the IBM z14\u2122 and later mainframe system with the Guarded Storage (GS) Facility. The GS Facility provides hardware-based support to detect when potentially stale references to objects are accessed by an application. This means that the garbage collector can start processing objects in parts of the heap without halting an application because the GS Facility is on hand to spot accesses to an object and send a notification. The object that was ready to be swept away can be moved, and references to it can be reset. You can read more about this mode in the following blog posts: Reducing Garbage Collection pause times with Concurrent Scavenge and the Guarded Storage Facility How Concurrent Scavenge using the Guarded Storage Facility Works Software-based support: (64-bit: Linux on (x86-64, POWER, IBM Z\u00ae), AIX\u00ae, macOS\u00ae, and z/OS\u00ae) With software-based support, Concurrent Scavenge can be enabled without any pre-requisite hardware although the performance throughput is not as good as hardware-based support. For more information about enabling Concurrent Scavenge, see the -Xgc:concurrentScavenge option. balanced policy -Xgcpolicy:balanced divides the Java heap into regions, which are individually managed to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The aim of the policy is to avoid global collections by matching object allocation and survival rates. If you have problems with application pause times that are caused by global garbage collections, particularly compactions, this policy might improve application performance, particularly on large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER platforms). metronome policy -Xgcpolicy:metronome is designed for applications that require precise response times. Garbage collection occurs in small interruptible steps to avoid stop-the-world pauses. This policy is available only on x86 Linux and AIX platforms. optavgpause policy -Xgcpolicy:optavgpause uses concurrent mark and sweep phases, which means that pause times are reduced when compared to optthruput, but at the expense of some performance throughput. optthruput policy -Xgcpolicy:optthruput is optimized for throughput by disabling the concurrent mark phase, which means that applications will stop for long pauses while garbage collection takes place. You might consider using this policy when high application throughput, rather than short garbage collection pauses, is the main performance goal. nogc policy -Xgcpolicy:nogc handles only memory allocation and heap expansion, but doesn't reclaim any memory. The GC impact on runtime performance is therefore minimized, but if the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops. Troubleshooting You can diagnose problems with garbage collection operations by turning on verbose garbage collection logging. By default, the information is printed to STDERR but can be redirected to a file by specifying the -Xverbosegclog option. The log files contain detailed information about all operations, including initialization, stop-the-world processing, finalization, reference processing, and allocation failures. For more information, see Verbose garbage collection If verbose logs do not provide enough information to help you diagnose GC problems, you can use GC trace to analyze operations at a more granular level. For more information, see -Xtgc .","title":"Garbage collection"},{"location":"gc/#garbage-collection","text":"The process of managing memory in the VM is handled by the Allocator and the Garbage Collector (GC). These components operate on an area of memory that is reserved for VM processing called the Java heap. The Allocator assigns areas of the Java heap for Java objects. See Memory allocation for more information about the Allocator.","title":"Garbage collection"},{"location":"gc/#the-garbage-collector","text":"To prevent applications running out of memory, objects in the Java heap that are no longer required must be reclaimed. This process is known as garbage collection. When garbage is collected, the garbage collector must obtain exclusive access to the heap, which causes an application to pause while the clean up is done. This pause is often referred to as a stop-the-world pause because an application must halt until the process completes. In general, the first step in the GC process is to mark the objects that are reachable, which means they are still in use. The next step is to sweep away the unmarked objects to reclaim memory. The last step, which isn't always required unless the heap has become very fragmented, is to compact the heap.","title":"The garbage collector"},{"location":"gc/#gc-policies","text":"Eclipse OpenJ9 has a number of GC policies designed around different types of applications and workloads. Picking the right policy very much depends on your usage and performance goals. For more information about these garbage collection policies and options, see -Xgcpolicy .","title":"GC policies"},{"location":"gc/#gencon-policy","text":"If you have a transactional application, with many short lived objects, the Generational Concurrent GC policy ( -Xgcpolicy:gencon ) is probably best suited, which aims to minimize GC pause times without compromising throughput. This is the default policy employed by the VM, so if you want to use it you don't need to specify it on the command line when you start your application. With the gencon policy, the Java heap is divided into two main areas, the nursery area, where new objects are created and the tenure area, where objects are moved if they have reached tenure age . The nursery area is subdivided into two further areas, the allocate space and the survivor space. The GC process is illustrated in the following diagram, which shows a sequence of 4 main events: Objects are created in the allocate space. The allocate space is full. A local GC scavenge process runs and reachable objects are either copied into the survivor space or into the tenure area if they have reached tenure age . Any objects that can't be reached are left untouched and subsequently cleared. The allocate and survivor spaces swap roles. The original survivor space becomes the allocate space where new objects are created, and the original allocate space becomes the survivor space ready for the next local GC scavenge process. The relative sizes of the allocate and survivor spaces are dynamically adjusted by a technique called tilting . When the nursery area is first created, it is evenly divided between the allocate and survivor spaces. If, after a GC scavenge process is run, the amount of space required for the survivor area is comparatively small, the boundary between the two spaces is adjusted by tilting . For example, if the survivor space requires only 10% of the nursery area, the tilt ratio is adjusted to give 90% of the nursery area to the allocate space. With more space available for new objects, garbage collection can be delayed. The tenure age of an object is determined by the VM and reflects the number of times that an object has been copied between the allocate space and the survivor space. The age is in the range 1 - 14 and is adjusted dynamically by the VM depending on the overall amount of space that is used in the nursery area . For example, if an object has a tenure age of 5, it has been copied backwards and forwards between allocate and survivor spaces 5 times. If the VM sets a tenure age of 5 based on the percentage of space remaining in the nursery area, the next scavenge moves the object from the nursery to the tenure area. You can set an initial tenure age with the -Xgc:scvTenureAge option. You can also prevent the VM dynamically adjusting the tenure age by setting the Xgc:scvNoAdaptiveTenure option so that the intial age is maintained throughout the run time of the VM. Within the tenure area, new objects are allocated into the small object area (SOA), which is illustrated in the earlier diagram (see 3.). A large object area (LOA) is set aside for objects greater than 64 KB that cannot be allocated into the SOA to minimize fragmentation. The LOA is allocated by default but is reduced and removed after a few GC cycles if it isn't populated. To prevent the creation of an LOA, you can specify the -Xnoloa option on the command line when you start your application. When the tenure area is close to full a global GC is triggered. The local GC scavenge reduces pause times by freqently reclaiming memory in the nursery area which, for a transactional application with many short-lived objects, has the most recyclable space. However, over time the tenure area might become full. So, whilst a local GC scavenge process is operating on the nursery area, a concurrent global GC process also runs alongside normal program execution to mark and remove unreachable objects from the tenure area. These two GC approaches combine to provide a good trade-off between shorter pause times and consistent throughput.","title":"gencon policy"},{"location":"gc/#concurrent-scavenge","text":"A special mode of the gencon policy is known as Concurrent Scavenge ( -Xgc:concurrentScavenge ), which aims to minimize the time spent in stop-the-world pauses by collecting nursery garbage in parallel with running application threads. This mode can be enabled with hardware-based support and software-based support. Hardware-based support: (Linux on IBM Z\u00ae and z/OS\u00ae) This mode works on the IBM z14\u2122 and later mainframe system with the Guarded Storage (GS) Facility. The GS Facility provides hardware-based support to detect when potentially stale references to objects are accessed by an application. This means that the garbage collector can start processing objects in parts of the heap without halting an application because the GS Facility is on hand to spot accesses to an object and send a notification. The object that was ready to be swept away can be moved, and references to it can be reset. You can read more about this mode in the following blog posts: Reducing Garbage Collection pause times with Concurrent Scavenge and the Guarded Storage Facility How Concurrent Scavenge using the Guarded Storage Facility Works Software-based support: (64-bit: Linux on (x86-64, POWER, IBM Z\u00ae), AIX\u00ae, macOS\u00ae, and z/OS\u00ae) With software-based support, Concurrent Scavenge can be enabled without any pre-requisite hardware although the performance throughput is not as good as hardware-based support. For more information about enabling Concurrent Scavenge, see the -Xgc:concurrentScavenge option.","title":"Concurrent Scavenge"},{"location":"gc/#balanced-policy","text":"-Xgcpolicy:balanced divides the Java heap into regions, which are individually managed to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The aim of the policy is to avoid global collections by matching object allocation and survival rates. If you have problems with application pause times that are caused by global garbage collections, particularly compactions, this policy might improve application performance, particularly on large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER platforms).","title":"balanced policy"},{"location":"gc/#metronome-policy","text":"-Xgcpolicy:metronome is designed for applications that require precise response times. Garbage collection occurs in small interruptible steps to avoid stop-the-world pauses. This policy is available only on x86 Linux and AIX platforms.","title":"metronome policy"},{"location":"gc/#optavgpause-policy","text":"-Xgcpolicy:optavgpause uses concurrent mark and sweep phases, which means that pause times are reduced when compared to optthruput, but at the expense of some performance throughput.","title":"optavgpause policy"},{"location":"gc/#optthruput-policy","text":"-Xgcpolicy:optthruput is optimized for throughput by disabling the concurrent mark phase, which means that applications will stop for long pauses while garbage collection takes place. You might consider using this policy when high application throughput, rather than short garbage collection pauses, is the main performance goal.","title":"optthruput policy"},{"location":"gc/#nogc-policy","text":"-Xgcpolicy:nogc handles only memory allocation and heap expansion, but doesn't reclaim any memory. The GC impact on runtime performance is therefore minimized, but if the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops.","title":"nogc policy"},{"location":"gc/#troubleshooting","text":"You can diagnose problems with garbage collection operations by turning on verbose garbage collection logging. By default, the information is printed to STDERR but can be redirected to a file by specifying the -Xverbosegclog option. The log files contain detailed information about all operations, including initialization, stop-the-world processing, finalization, reference processing, and allocation failures. For more information, see Verbose garbage collection If verbose logs do not provide enough information to help you diagnose GC problems, you can use GC trace to analyze operations at a more granular level. For more information, see -Xtgc .","title":"Troubleshooting"},{"location":"interface_dtfj/","text":"Diagnostic Tool Framework for Java The Diagnostic Tool Framework for Java\u2122 (DTFJ) is a Java application programming interface (API) that is used to support the building of Java diagnostic tools. DTFJ works with data from a system dump or a Java dump. On Linux and AIX\u00ae operating systems, you can get more information from a system dump if you also have copies of executable files and libraries. You can run the jextract utility provided in the SDK to collect these files into a single archive for use in subsequent problem diagnosis. For more information, see Dump extractor . The DTFJ API helps diagnostic tools access the following information: Memory locations stored in the dump (System dumps only) Relationships between memory locations and Java internals (System dumps only) Java threads running in the VM Native threads held in the dump (System dumps only) Java classes and their class loaders that were present Java objects that were present in the heap (System dumps only) Java monitors and the objects and threads they are associated with Details of the workstation on which the dump was produced (System dumps only) Details of the Java version that was being used The command line that launched the VM If your DTFJ application requests information that is not available in the Java dump, the API will return null or throw a DataUnavailable exception. You might need to adapt DTFJ applications written to process system dumps to make them work with Java dumps. DTFJ is implemented in pure Java and tools written using DTFJ can be cross-platform. Therefore, you can analyze a dump taken from one workstation on another (remote and more convenient) machine. For example, a dump produced on an AIX\u00ae Power\u00ae system can be analyzed on a Windows laptop. See the DTFJ API documentation . Using the DTFJ interface To create applications that use DTFJ, you must use the DTFJ interface. Implementations of this interface have been written that work with system dumps and Java dumps. The diagram that follows illustrates the DTFJ interface. The starting point for working with a dump is to obtain an Image instance by using the ImageFactory class supplied with the concrete implementation of the API. Working with a system dump The following example shows how to work with a system dump. In this example, the only section of code that ties the dump to a particular implementation of DTFJ is the generation of the factory class. Change the factory if you want to use a different implementation. If there is a problem with the file that is passed to the getImage() method, an IOException is thrown and an appropriate message is issued. If a missing file is passed to the example shown, the following output is produced: Could not find/use required file(s) java.io.FileNotFoundException: core_file.xml (The system cannot find the file specified.) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.<init>(FileInputStream.java:135) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:47) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:35) at DTFJEX1.main(DTFJEX1.java:23)Copy In this case, the DTFJ implementation is expecting a dump file to exist. Different errors are caught if the file existed but was not recognized as a valid dump file. Example of working with a system dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX1 { public static void main(String[] args) { Image image = null; if (args.length > 0) { File f = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.j9.ImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(f); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } } Working with a Java dump To work with a Java dump, change the factory class to com.ibm.dtfj.image.javacore.JCImageFactory and pass the Java dump file to the getImage() method. Example of working with a Java dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX2 { public static void main(String[] args) { Image image=null; if (args.length > 0) { File javacoreFile = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.javacore.JCImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(javacoreFile); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } } Analyze the dump After you have obtained an Image instance, you can begin analyzing the dump. The Image instance is the second instance in the class hierarchy for DTFJ illustrated by the following diagram: Some things to note from the diagram: The DTFJ interface is separated into two parts: classes with names that start with Image (the dump, a sequence of bytes with different contents on different platforms) and classes with names that start with Java (the Java internal knowledge). Image and Java classes are linked using a ManagedRuntime class (which is extended by JavaRuntime ). An Image object contains one ImageAddressSpace object (or, on z/OS\u00ae, possibly more). An ImageAddressSpace object contains one ImageProcess object (or, on z/OS, possibly more). Conceptually, you can apply the Image model to any program running with the ImageProcess . For the purposes of this document discussion is limited to the OpenJ9 virtual machine implementations. There is a link from a JavaThread object to its corresponding ImageThread object. Use this link to find out about native code associated with a Java thread, for example JNI functions that have been called from Java. If a JavaThread was not running Java code when the dump was taken, the JavaThread object has no JavaStackFrame objects. In these cases, use the link to the corresponding ImageThread object to find out what native code was running in that thread. This situation is typically the case with the JIT compilation thread and Garbage Collection threads. The DTFJ interface enables you to obtain information about native memory. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . When the Java runtime allocates native memory, the memory is associated with a high-level memory category. For more information about native memory detailed in a Java dump, see Java dump: NATIVEMEMINFO DTFJ example application This example is a fully working DTFJ application. Many DTFJ applications will follow a similar model. Sample DTFJ application import java.io.File; import java.util.Iterator; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.CorruptDataException; import com.ibm.dtfj.image.DataUnavailable; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageAddressSpace; import com.ibm.dtfj.image.ImageFactory; import com.ibm.dtfj.image.ImageProcess; import com.ibm.dtfj.java.JavaRuntime; import com.ibm.dtfj.java.JavaThread; import com.ibm.dtfj.image.ImageThread; public class DTFJEX2 { public static void main( String[] args ) { Image image = null; if ( args.length > 0 ) { File f = new File( args[0] ); try { Class factoryClass = Class .forName( \"com.ibm.dtfj.image.j9.ImageFactory\" ); ImageFactory factory = (ImageFactory) factoryClass.newInstance( ); image = factory.getImage( f ); } catch ( Exception ex ) { /* * Should use the error handling as shown in DTFJEX1. */ System.err.println( \"Error in DTFJEX2\" ); ex.printStackTrace( System.err ); } } else { System.err.println( \"No filename specified\" ); } if ( null == image ) { return; } MatchingThreads( image ); } public static void MatchingThreads( Image image ) { ImageThread imgThread = null; Iterator asIt = image.getAddressSpaces( ); while ( asIt.hasNext( ) ) { System.out.println( \"Found ImageAddressSpace...\" ); ImageAddressSpace as = (ImageAddressSpace) asIt.next( ); Iterator prIt = as.getProcesses( ); while ( prIt.hasNext( ) ) { System.out.println( \"Found ImageProcess...\" ); ImageProcess process = (ImageProcess) prIt.next( ); Iterator runTimesIt = process.getRuntimes( ); while ( runTimesIt.hasNext( ) ) { System.out.println( \"Found Runtime...\" ); JavaRuntime javaRT = (JavaRuntime) runTimesIt.next( ); Iterator javaThreadIt = javaRT.getThreads( ); while ( javaThreadIt.hasNext( ) ) { Object tempObj = javaThreadIt.next( ); /* * Should use CorruptData handling for all iterators */ if ( tempObj instanceof CorruptData ) { System.out.println( \"We have some corrupt data\" ); } else { JavaThread javaThread = (JavaThread) tempObj; System.out.println( \"Found JavaThread...\" ); try { imgThread = (ImageThread) javaThread.getImageThread( ); // Now we have a Java thread we can iterator // through the image threads Iterator imgThreadIt = process.getThreads( ); while ( imgThreadIt.hasNext( ) ) { ImageThread imgThread2 = (ImageThread) imgThreadIt .next( ); if ( imgThread.equals( imgThread2 ) ) { System.out.println( \"Found a match:\" ); System.out.println( \"\\tjavaThread \" + javaThread.getName( ) + \" is the same as \" + imgThread2.getID( ) ); } } } catch ( CorruptDataException e ) { System.err.println( \"ImageThread was corrupt: \" + e.getMessage( ) ); } catch ( DataUnavailable e ) { System.out.println( \"DataUnavailable: \" + e.getMessage( ) ); } } } } } } } } For clarity, the example does not perform full error checking when constructing the main Image object and does not perform CorruptData handling in all of the iterators. In a production environment, you use the techniques illustrated in the previous examples under Working with a system dump and Working with a Java dump . In the example, the program iterates through every available Java thread and checks whether it is equal to any of the available image threads. When they are found to be equal, the program displays the following message: \"Found a match\". The example demonstrates: How to iterate down through the class hierarchy. How to handle CorruptData objects from the iterators. The use of the .equals method for testing equality between objects.","title":"DTFJ"},{"location":"interface_dtfj/#diagnostic-tool-framework-for-java","text":"The Diagnostic Tool Framework for Java\u2122 (DTFJ) is a Java application programming interface (API) that is used to support the building of Java diagnostic tools. DTFJ works with data from a system dump or a Java dump. On Linux and AIX\u00ae operating systems, you can get more information from a system dump if you also have copies of executable files and libraries. You can run the jextract utility provided in the SDK to collect these files into a single archive for use in subsequent problem diagnosis. For more information, see Dump extractor . The DTFJ API helps diagnostic tools access the following information: Memory locations stored in the dump (System dumps only) Relationships between memory locations and Java internals (System dumps only) Java threads running in the VM Native threads held in the dump (System dumps only) Java classes and their class loaders that were present Java objects that were present in the heap (System dumps only) Java monitors and the objects and threads they are associated with Details of the workstation on which the dump was produced (System dumps only) Details of the Java version that was being used The command line that launched the VM If your DTFJ application requests information that is not available in the Java dump, the API will return null or throw a DataUnavailable exception. You might need to adapt DTFJ applications written to process system dumps to make them work with Java dumps. DTFJ is implemented in pure Java and tools written using DTFJ can be cross-platform. Therefore, you can analyze a dump taken from one workstation on another (remote and more convenient) machine. For example, a dump produced on an AIX\u00ae Power\u00ae system can be analyzed on a Windows laptop. See the DTFJ API documentation .","title":"Diagnostic Tool Framework for Java"},{"location":"interface_dtfj/#using-the-dtfj-interface","text":"To create applications that use DTFJ, you must use the DTFJ interface. Implementations of this interface have been written that work with system dumps and Java dumps. The diagram that follows illustrates the DTFJ interface. The starting point for working with a dump is to obtain an Image instance by using the ImageFactory class supplied with the concrete implementation of the API.","title":"Using the DTFJ interface"},{"location":"interface_dtfj/#working-with-a-system-dump","text":"The following example shows how to work with a system dump. In this example, the only section of code that ties the dump to a particular implementation of DTFJ is the generation of the factory class. Change the factory if you want to use a different implementation. If there is a problem with the file that is passed to the getImage() method, an IOException is thrown and an appropriate message is issued. If a missing file is passed to the example shown, the following output is produced: Could not find/use required file(s) java.io.FileNotFoundException: core_file.xml (The system cannot find the file specified.) at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.<init>(FileInputStream.java:135) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:47) at com.ibm.dtfj.image.j9.ImageFactory.getImage(ImageFactory.java:35) at DTFJEX1.main(DTFJEX1.java:23)Copy In this case, the DTFJ implementation is expecting a dump file to exist. Different errors are caught if the file existed but was not recognized as a valid dump file. Example of working with a system dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX1 { public static void main(String[] args) { Image image = null; if (args.length > 0) { File f = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.j9.ImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(f); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } }","title":"Working with a system dump"},{"location":"interface_dtfj/#working-with-a-java-dump","text":"To work with a Java dump, change the factory class to com.ibm.dtfj.image.javacore.JCImageFactory and pass the Java dump file to the getImage() method. Example of working with a Java dump import java.io.File; import java.util.Iterator; import java.io.IOException; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageFactory; public class DTFJEX2 { public static void main(String[] args) { Image image=null; if (args.length > 0) { File javacoreFile = new File(args[0]); try { Class factoryClass = Class.forName(\"com.ibm.dtfj.image.javacore.JCImageFactory\"); ImageFactory factory = (ImageFactory) factoryClass.newInstance(); image = factory.getImage(javacoreFile); } catch (ClassNotFoundException e) { System.err.println(\"Could not find DTFJ factory class\"); e.printStackTrace(System.err); } catch (IllegalAccessException e) { System.err.println(\"IllegalAccessException for DTFJ factory class\"); e.printStackTrace(System.err); } catch (InstantiationException e) { System.err.println(\"Could not instantiate DTFJ factory class\"); e.printStackTrace(System.err); } catch (IOException e) { System.err.println(\"Could not find/use required file(s)\"); e.printStackTrace(System.err); } } else { System.err.println(\"No filename specified\"); } if (image == null) { return; } Iterator asIt = image.getAddressSpaces(); int count = 0; while (asIt.hasNext()) { Object tempObj = asIt.next(); if (tempObj instanceof CorruptData) { System.err.println(\"Address Space object is corrupt: \" + (CorruptData) tempObj); } else { count++; } } System.out.println(\"The number of address spaces is: \" + count); } }","title":"Working with a Java dump"},{"location":"interface_dtfj/#analyze-the-dump","text":"After you have obtained an Image instance, you can begin analyzing the dump. The Image instance is the second instance in the class hierarchy for DTFJ illustrated by the following diagram: Some things to note from the diagram: The DTFJ interface is separated into two parts: classes with names that start with Image (the dump, a sequence of bytes with different contents on different platforms) and classes with names that start with Java (the Java internal knowledge). Image and Java classes are linked using a ManagedRuntime class (which is extended by JavaRuntime ). An Image object contains one ImageAddressSpace object (or, on z/OS\u00ae, possibly more). An ImageAddressSpace object contains one ImageProcess object (or, on z/OS, possibly more). Conceptually, you can apply the Image model to any program running with the ImageProcess . For the purposes of this document discussion is limited to the OpenJ9 virtual machine implementations. There is a link from a JavaThread object to its corresponding ImageThread object. Use this link to find out about native code associated with a Java thread, for example JNI functions that have been called from Java. If a JavaThread was not running Java code when the dump was taken, the JavaThread object has no JavaStackFrame objects. In these cases, use the link to the corresponding ImageThread object to find out what native code was running in that thread. This situation is typically the case with the JIT compilation thread and Garbage Collection threads. The DTFJ interface enables you to obtain information about native memory. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . When the Java runtime allocates native memory, the memory is associated with a high-level memory category. For more information about native memory detailed in a Java dump, see Java dump: NATIVEMEMINFO","title":"Analyze the dump"},{"location":"interface_dtfj/#dtfj-example-application","text":"This example is a fully working DTFJ application. Many DTFJ applications will follow a similar model. Sample DTFJ application import java.io.File; import java.util.Iterator; import com.ibm.dtfj.image.CorruptData; import com.ibm.dtfj.image.CorruptDataException; import com.ibm.dtfj.image.DataUnavailable; import com.ibm.dtfj.image.Image; import com.ibm.dtfj.image.ImageAddressSpace; import com.ibm.dtfj.image.ImageFactory; import com.ibm.dtfj.image.ImageProcess; import com.ibm.dtfj.java.JavaRuntime; import com.ibm.dtfj.java.JavaThread; import com.ibm.dtfj.image.ImageThread; public class DTFJEX2 { public static void main( String[] args ) { Image image = null; if ( args.length > 0 ) { File f = new File( args[0] ); try { Class factoryClass = Class .forName( \"com.ibm.dtfj.image.j9.ImageFactory\" ); ImageFactory factory = (ImageFactory) factoryClass.newInstance( ); image = factory.getImage( f ); } catch ( Exception ex ) { /* * Should use the error handling as shown in DTFJEX1. */ System.err.println( \"Error in DTFJEX2\" ); ex.printStackTrace( System.err ); } } else { System.err.println( \"No filename specified\" ); } if ( null == image ) { return; } MatchingThreads( image ); } public static void MatchingThreads( Image image ) { ImageThread imgThread = null; Iterator asIt = image.getAddressSpaces( ); while ( asIt.hasNext( ) ) { System.out.println( \"Found ImageAddressSpace...\" ); ImageAddressSpace as = (ImageAddressSpace) asIt.next( ); Iterator prIt = as.getProcesses( ); while ( prIt.hasNext( ) ) { System.out.println( \"Found ImageProcess...\" ); ImageProcess process = (ImageProcess) prIt.next( ); Iterator runTimesIt = process.getRuntimes( ); while ( runTimesIt.hasNext( ) ) { System.out.println( \"Found Runtime...\" ); JavaRuntime javaRT = (JavaRuntime) runTimesIt.next( ); Iterator javaThreadIt = javaRT.getThreads( ); while ( javaThreadIt.hasNext( ) ) { Object tempObj = javaThreadIt.next( ); /* * Should use CorruptData handling for all iterators */ if ( tempObj instanceof CorruptData ) { System.out.println( \"We have some corrupt data\" ); } else { JavaThread javaThread = (JavaThread) tempObj; System.out.println( \"Found JavaThread...\" ); try { imgThread = (ImageThread) javaThread.getImageThread( ); // Now we have a Java thread we can iterator // through the image threads Iterator imgThreadIt = process.getThreads( ); while ( imgThreadIt.hasNext( ) ) { ImageThread imgThread2 = (ImageThread) imgThreadIt .next( ); if ( imgThread.equals( imgThread2 ) ) { System.out.println( \"Found a match:\" ); System.out.println( \"\\tjavaThread \" + javaThread.getName( ) + \" is the same as \" + imgThread2.getID( ) ); } } } catch ( CorruptDataException e ) { System.err.println( \"ImageThread was corrupt: \" + e.getMessage( ) ); } catch ( DataUnavailable e ) { System.out.println( \"DataUnavailable: \" + e.getMessage( ) ); } } } } } } } } For clarity, the example does not perform full error checking when constructing the main Image object and does not perform CorruptData handling in all of the iterators. In a production environment, you use the techniques illustrated in the previous examples under Working with a system dump and Working with a Java dump . In the example, the program iterates through every available Java thread and checks whether it is equal to any of the available image threads. When they are found to be equal, the program displays the following message: \"Found a match\". The example demonstrates: How to iterate down through the class hierarchy. How to handle CorruptData objects from the iterators. The use of the .equals method for testing equality between objects.","title":"DTFJ example application"},{"location":"interface_jvmti/","text":"Java Virtual Machine Tool Interface The Java\u2122 Virtual Machine Tool Interface (JVMTI) is a two-way interface that allows communication between the VM and a native agent. It replaces both the Java Virtual Machine Debug Interface (JVMDI) and Java Virtual Machine Profiler Interface (JVMPI). Overview The JVMTI allows third parties to develop debugging, profiling, and monitoring tools for the VM. The interface contains mechanisms for the agent to notify the VM about the kinds of information it requires, and also provides a means of receiving relevant notifications. Several agents can be attached to a VM at any one time. JVMTI agents can be loaded at startup using short or long forms of the command-line option: -agentlib:<agent-lib-name>=<options> or -agentpath:<path-to-agent>=<options> In the example that follows (see Sample JVMTI agent ), the directory containing the jdwp library is assumed to be on the library path. If you require a specific library, such as jdwp , with your JVMTI agent, you can specify the path at startup, for example: -agentlib:jdwp=<options> For more information about JVMTI, see https://docs.oracle.com/javase/8/docs/technotes/guides/management/index.html . For a guide about writing a JVMTI agent, see http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html . OpenJ9 extensions OpenJ9 extensions to the JVMTI allow a JVMTI agent to query or automatically trigger operations in the VM, including the following tasks: Task OpenJ9 extensions Get the OS thread ID GetOSThreadID Query, set, and reset the VM dump options QueryVmDump , SetVmDump , ResetVmDump Trigger a VM dump, and monitor JVMTI event functions when VM dumps start and end TriggerVmDump , VMDumpStart , VMDumpEnd Set VM trace options SetVmTrace Subscribe to and unsubscribe from VM tracepoints RegisterTracePointSubscriber , DeregisterTracePointSubscriber Query runtime environment native memory categories GetMemoryCategories Query and set VM log options QueryVmLogOptions , SetVmLogOptions Search for and remove a shared classes cache IterateSharedCaches , DestroySharedCache Subscribe to and unsubscribe from verbose garbage collection (GC) data logging RegisterVerboseGCSubscriber , DeregisterVerboseGCSubscriber The definitions that you need when you write a JVMTI agent are provided in the header files jvmti.h and ibmjvmti.h , in the include directory. Sample JVMTI agent The following sample shows you how to write a simple JVMTI agent that uses OpenJ9 extensions to the JVMTI. Sample JVMTI agent written in C/C++, which uses the OpenJ9 extensions /* * tiSample.c * * Sample JVMTI agent to demonstrate the OpenJ9 JVMTI dump extensions */ #include \"jvmti.h\" #include \"ibmjvmti.h\" /* Forward declarations for JVMTI callback functions */ void JNICALL VMInitCallback(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread); void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...); /* * Agent_Onload() * * JVMTI agent initialisation function, invoked as agent is loaded by the VM */ JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) { jvmtiEnv *jvmti = NULL; jvmtiError rc; jint extensionEventCount = 0; jvmtiExtensionEventInfo *extensionEvents = NULL; jint extensionFunctionCount = 0; jvmtiExtensionFunctionInfo *extensionFunctions = NULL; int i = 0, j = 0; printf(\"tiSample: Loading JVMTI sample agent\\n\"); /* Get access to JVMTI */ (*jvm)->GetEnv(jvm, (void **)&jvmti, JVMTI_VERSION_1_0); /* Look up all the JVMTI extension events and functions */ (*jvmti)->GetExtensionEvents(jvmti, &extensionEventCount, &extensionEvents); (*jvmti)->GetExtensionFunctions(jvmti, &extensionFunctionCount, &extensionFunctions); printf(\"tiSample: Found %i JVMTI extension events, %i extension functions\\n\", extensionEventCount, extensionFunctionCount); /* Find the JVMTI extension event we want */ while (i++ < extensionEventCount) { if (strcmp(extensionEvents->id, COM_IBM_VM_DUMP_START) == 0) { /* Found the dump start extension event, now set up a callback for it */ rc = (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents->extension_event_index, &DumpStartCallback); printf(\"tiSample: Setting JVMTI event callback %s, rc=%i\\n\", COM_IBM_VM_DUMP_START, rc); break; } extensionEvents++; /* move on to the next extension event */ } /* Find the JVMTI extension function we want */ while (j++ < extensionFunctionCount) { jvmtiExtensionFunction function = extensionFunctions->func; if (strcmp(extensionFunctions->id, COM_IBM_SET_VM_DUMP) == 0) { /* Found the set dump extension function, now set a dump option to generate javadumps on thread starts */ rc = function(jvmti, \"java:events=thrstart\"); printf(\"tiSample: Calling JVMTI extension %s, rc=%i\\n\", COM_IBM_SET_VM_DUMP, rc); break; } extensionFunctions++; /* move on to the next extension function */ } return JNI_OK; } /* * DumpStartCallback() * JVMTI callback for dump start event (IBM JVMTI extension) */ void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...) { printf(\"tiSample: Received JVMTI event callback, for event %s\\n\", event); } The sample JVMTI agent consists of two functions, Agent_OnLoad() and DumpStartCallback() : Agent_OnLoad() This function is called by the VM when the agent is loaded at VM startup, which allows the JVMTI agent to modify VM behavior before initialization is complete. The sample agent obtains access to the JVMTI interface by using the JNI Invocation API function GetEnv() . The agent calls the APIs GetExtensionEvents() and GetExtensionFunctions() to find the JVMTI extensions that are supported by the VM. These APIs provide access to the list of extensions available in the jvmtiExtensionEventInfo and jvmtiExtensionFunctionInfo structures. The sample uses an extension event and an extension function in the following way: Extension event: The sample JVMTI agent searches for the extension event VmDumpStart in the list of jvmtiExtensionEventInfo structures, by using the identifier COM_IBM_VM_DUMP_START provided in ibmjvmti.h . When the event is found, the JVMTI agent calls the JVMTI interface SetExtensionEventCallback() to enable the event, providing a function DumpStartCallback() that is called when the event is triggered. Extension function: Next, the sample JVMTI agent searches for the extension function SetVMDump in the list of jvmtiExtensionFunctionInfo structures, by using the identifier COM_IBM_SET_VM_DUMP provided in ibmjvmti.h . The JVMTI agent calls the function by using the jvmtiExtensionFunction pointer to set a VM dump option java:events=thrstart . This option requests the VM to trigger a Java dump every time a VM thread is started. DumpStartCallback() This callback function issues a message when the associated extension event is called. In the sample code, DumpStartCallback() is used when the VmDumpStart event is triggered. Using the sample JVMTI agent Build the sample JVMTI agent: Windows: cl /I<jre_path>\\include /MD /FetiSample.dll tiSample.c /link /DLL Linux, AIX\u00ae, and z/OS\u00ae: gcc -I<jre_path>/include -o libtiSample.so -shared tiSample.c where <jre_path> is the path to your Java runtime environment installation. To run the sample JVMTI agent, use the command: java -agentlib:tiSample -version When the sample JVMTI agent loads, messages are generated. When the JVMTI agent initiates a Java dump, the message JVMDUMP010 is issued. API reference The following sections provide reference information for the OpenJ9 extensions to the JVMTI. GetOSThreadID You can get the OS thread ID by using the GetOSThreadID() API: jvmtiError GetOSThreadID(jvmtiEnv* jvmti_env, jthread thread, jlong * threadid_ptr); Parameters jvmti_env : A pointer to the JVMTI environment. thread : The thread for which the ID is required. threadid_ptr : A pointer to a variable, used to return the thread ID that corresponds to the thread specified by the thread parameter. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The threadid_ptr parameter is null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_INVALID_THREAD : The thread is not valid. JVMTI_ERROR_THREAD_NOT_ALIVE : The VM state of the thread is not started or has died. JVMTI_ERROR_UNATTACHED_THREAD : The current thread is not attached to the VM. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI start or live phase. Identifiers JVMTI Extension Function identifier: com.ibm.GetOSThreadID Macro declaration in the ibmjvmti.h file: COM_IBM_GET_OS_THREAD_ID QueryVmDump You can query the VM dump options that are set for a VM by using the QueryVmDump() API: jvmtiError QueryVmDump(jvmtiEnv* jvmti_env, jint buffer_size, void* options_buffer, jint* data_size_ptr) This extension returns a set of dump option specifications as ASCII strings. The syntax of the option string is the same as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . The option strings are separated by newline characters. If the memory buffer is too small to contain the current VM dump option strings, you can expect the following results: The error message JVMTI_ERROR_ILLEGAL_ARGUMENT is returned. The variable for data_size_ptr is set to the required buffer size. Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option strings. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options_buffer or data_size_ptr parameters are null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer in options_buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_DUMP SetVmDump You can set VM dump options by using the SetVmDump() API: jvmtiError SetVmDump(jvmtiEnv* jvmti_env, char* option) The dump option is passed in as an ASCII character string. Use the same syntax as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . When dumps are in progress, the dump configuration is locked, and calls to SetVmDump() fail with a return value of JVMTI_ERROR_NOT_AVAILABLE . Parameters jvmti_env : A pointer to the JVMTI environment. option : The VM dump option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xdump string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_DUMP TriggerVmDump You can trigger a VM dump and specify the type of dump you want by using the TriggerVmDump() API: jvmtiError TriggerVmDump(jvmtiEnv* jvmti_env, char* option) Choose the type of dump required by specifying an ASCII string that contains one of the supported dump agent types. See -Xdump . JVMTI events are provided at the start and end of the dump. Parameters jvmti_env : A pointer to the JVMTI environment. option : A pointer to the dump type string, which can be one of the following types: stack java system console tool heap snap ceedump (z/OS only) Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.TriggerVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_TRIGGER_VM_DUMP ResetVmDump You can reset VM dump options to the values at VM initialization by using the ResetVmDump() API: jvmtiError ResetVmDump(jvmtiEnv* jvmti_env) Parameters jvmti_env : The JVMTI environment pointer. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.ResetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_RESET_VM_DUMP VMDumpStart The following JVMTI event function is called when a VM dump starts: void JNICALL VMDumpStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait.\" Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name, such as com.ibm.VmDumpStart . detail : The dump event detail string. The string can be empty. Returns None VMDumpEnd The following JVMTI event function is called when a VM dump ends: void JNICALL VMDumpEnd(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait. Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name com.ibm.VmDumpEnd . detail : The dump event detail string. The string can be empty. Returns None SetVmTrace You can set VM trace options by using the SetVmTrace() API: jvmtiError SetVmTrace(jvmtiEnv* jvmti_env, char* option) The trace option is passed in as an ASCII character string. Use the same syntax as the -Xtrace command-line option, with the initial -Xtrace: omitted. See -Xtrace . Parameters jvmti_env : JVMTI environment pointer. option : Enter the VM trace option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The option parameter contains an invalid -Xtrace string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmTrace Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_TRACE RegisterTracePointSubscriber You can subscribe to VM tracepoints by using the RegisterTracePointSubscriber() API: jvmtiError RegisterTracePointSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiTraceSubscriber subscriber, jvmtiTraceAlarm alarm, void *userData, void **subscriptionID) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiTraceSubscriber . alarm : A function pointer of type jvmtiTraceAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterTracePointSubscriber call if successful. The value must be supplied to a future call to the DeregisterTracePointSubscriber API, which is used to unsubscribe from the VM tracepoint. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : VM trace is not available. JVMTI_ERROR_INTERNAL : An internal error occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_TRACEPOINT_SUBSCRIBER jvmtiTraceSubscriber function The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiTraceSubscriber)(jvmtiEnv *jvmti_env, void *record, jlong length, void *user_data); The subscriber function must be of type jvmtiTraceSubscriber , which is declared in ibmjvmti.h . This function is called with each tracepoint record that is selected through the -Xtrace:external option. The tracepoint record that is supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, the subscription is disconnected, and no further tracepoints are sent to the subscriber. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : A UTF-8 string that contains a tracepoint record. length : The number of UTF-8 characters in the tracepoint record. user_data : User data that is supplied when the subscriber is registered. jvmtiTraceAlarm function The alarm function type is defined as follows: typedef jvmtiError (*jvmtiTraceAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiTraceAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier. user_data : User data that is supplied when the subscriber is registered. DeregisterTracePointSubscriber You can unsubscribe from VM tracepoints by using the DeregisterTracePointSubscriber() API: jvmtiError DeregisterTracePointSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterTracePointSubscriber() API is called, no further calls are made to the subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterTracePointSubscriber API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_TRACEPOINT_SUBSCRIBER GetMemoryCategories You can query runtime environment native memory categories by using the GetMemoryCategories() API: jvmtiError GetMemoryCategories(jvmtiEnv* env, jint version, jint max_categories, jvmtiMemoryCategory * categories_buffer, jint * written_count_ptr, jint * total_categories_ptr); You can query the total native memory consumption of the runtime environment for each memory category by using this API. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . Runtime environment native memory use is grouped under high-level memory categories, as described in the NATIVEMEMINFO section of the Java dump topic. The data returned by the GetMemoryCategories() API is consistent with this format. See Java dump: NATIVEMEMINFO . The extension writes native memory information to a memory buffer specified by the user. Each memory category is recorded as a jvmtiMemoryCategory structure, whose format is defined in ibmjvmti.h . You can use the GetMemoryCategories() API to work out the buffer size you must allocate to hold all memory categories defined inside the VM. To calculate the size, call the API with a null categories_buffer argument and a non-null total_categories_ptr argument. Parameters env : A pointer to the JVMTI environment. version : The version of the jvmtiMemoryCategory structure that you are using. Use COM_IBM_GET_MEMORY_CATEGORIES_VERSION_1 for this argument, unless you must work with an obsolete version of the jvmtiMemoryCategory structure. max_categories : The number of jvmtiMemoryCategory structures that can fit in the categories_buffer memory buffer. categories_buffer : A pointer to the memory buffer for holding the result of the GetMemoryCategories() call. The number of jvmtiMemoryCategory slots available in the categories_buffer memory buffer must be accurately specified with max_categories , otherwise GetMemoryCategories() can overflow the memory buffer. The value can be null. written_count_ptr : A pointer to jint to store the number of jvmtiMemoryCategory structures to be written to the categories_buffer memory buffer. The value can be null. total_categories_ptr : A pointer to jint to store the total number of memory categories declared in the VM. The value can be null. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_UNSUPPORTED_VERSION : Unrecognized value passed for version. JVMTI_ERROR_ILLEGAL_ARGUMENT : Illegal argument; categories_buffer , count_ptr , and total_categories_ptr all have null values. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is invalid. JVMTI_ERROR_OUT_OF_MEMORY : Memory category data is truncated because max_categories is not large enough. Identifiers JVMTI Extension Function identifier: com.ibm.GetMemoryCategories Macro declaration in the ibmjvmti.h file: COM_IBM_GET_MEMORY_CATEGORIES QueryVmLogOptions You can query VM log options by using the QueryVmLogOptions() API: jvmtiError QueryVmLogOptions(jvmtiEnv* jvmti_env, jint buffer_size, void* options, jint* data_size_ptr) This extension returns the current log options as an ASCII string. The syntax of the string is the same as the -Xlog command-line option, with the initial -Xlog: omitted. For example, the string \"error,warn\" indicates that the VM is set to log error and warning messages only. For more information, see -Xlog . Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. If the memory buffer is too small to contain the current VM log option string, the JVMTI_ERROR_ILLEGAL_ARGUMENT error message is returned. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option string. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options or data_size_ptr parameters are null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_LOG_OPTIONS SetVmLogOptions You can set VM log options by using the SetVmLogOptions() API: jvmtiError SetVmLogOptions(jvmtiEnv* jvmti_env, char* options_buffer) The log option is passed in as an ASCII character string. Use the same syntax as the -Xlog command-line option, with the initial -Xlog: omitted. For example, to set the VM to log error and warning messages, pass in a string containing \"error,warn\". For more information, see -Xlog . Parameters jvmti_env : A pointer to the JVMTI environment. options_buffer : A pointer to memory containing the log option. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xlog string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_LOG_OPTIONS IterateSharedCaches You can search for shared classes caches that exist in a specified cache directory by using the IterateSharedCaches() API: jvmtiError IterateSharedCaches(jvmtiEnv* env, jint version, const char *cacheDir, jint flags, jboolean useCommandLineValues, jvmtiIterateSharedCachesCallback callback, void *user_data); Information about the caches is returned in a structure that is populated by a user-specified callback function. You can specify the search directory in two ways: Set the value of useCommandLineValues to true and specify the directory on the command line. If the directory is not specified on the command line, the default location for the platform is used. Set the value of useCommandLineValues to false and use the cacheDir parameter. To accept the default location for the platform, specify cacheDir with a null value. Parameters env : A pointer to the JVMTI environment. version : Version information for IterateSharedCaches , which describes the jvmtiSharedCacheInfo structure passed to the jvmtiIterateSharedCachesCallback function. The values allowed are: COM_IBM_ITERATE_SHARED_CACHES_VERSION_1 COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. flags : Reserved for future use. The only value allowed is COM_IBM_ITERATE_SHARED_CACHES_NO_FLAGS . useCommandLineValues : Set this value to true when you want to specify the cache directory on the command line. Set this value to false when you want to use the cacheDir parameter. callback : A function pointer to a user provided callback routine jvmtiIterateSharedCachesCallback . user_data : User supplied data, passed as an argument to the callback function. jint (JNICALL *jvmtiIterateSharedCachesCallback)(jvmtiEnv *env,jvmtiSharedCacheInfo *cache_info, void *user_data); Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_UNSUPPORTED_VERSION : The version parameter is not valid. JVMTI_ERROR_NULL_POINTER : The callback parameter is null. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The flags parameter is not valid. JVMTI_ERROR_INTERNAL : This error is returned when the jvmtiIterateSharedCachesCallback returns JNI_ERR . Identifiers JVMTI Extension Function identifier: com.ibm.IterateSharedCaches Macro declaration in the ibmjvmti.h file: COM_IBM_ITERATE_SHARED_CACHES jvmtiIterateSharedCachesCallback function Callback function parameters env : A pointer to the JVMTI environment when calling COM_IBM_ITERATE_SHARED_CACHES . cache_info : A jvmtiSharedCacheInfo structure containing information about a shared cache. user_data : User-supplied data, passed as an argument to IterateSharedCaches . Callback function returns JNI_OK : Continue iterating. JNI_ERR : Stop iterating, which causes IterateSharedCaches to return JVMTI_ERROR_INTERNAL jvmtiSharedCacheInfo structure The structure of jvmtiSharedCacheInfo typedef struct jvmtiSharedCacheInfo { const char *name; // the name of the shared cache jboolean isCompatible; // if the shared cache is compatible with this VM jboolean isPersistent; // true if the shared cache is persistent, false if its non-persistent jint os_shmid; // the OS shared memory ID associated with a non-persistent cache, -1 otherwise jint os_semid; // the OS shared semaphore ID associated with a non-persistent cache, -1 otherwise jint modLevel; // one of: // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA5 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA6 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA7 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA8 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA9 // from Java 10: the version number of the Java level on which the shared cache is created jint addrMode; // the address mode of the VM creating the shared cache: includes additional // information on whether it is a 64-bit compressedRefs cache when // COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. jboolean isCorrupt; // if the cache is corrupted jlong cacheSize; // the total usable shared classes cache size, or -1 when isCompatible is false jlong freeBytes; // the number of free bytes in the shared classes cache, or -1 when isCompatible is false jlong lastDetach; // the last detach time specified in milliseconds since 00:00:00 on 1 January 1970 UTC, // or -1 when the last detach time is not available jint cacheType; // the type of the cache jlong softMaxBytes; // the soft limit for the available space in the cache jint layer; // the shared cache layer number } jvmtiSharedCacheInfo; Notes: The field cacheType is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 or later is specified. jvmtiSharedCacheInfo.addrMode encodes both address mode and the compressed reference mode when COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. In this case, use the following set of macros to access the address mode and compressed reference mode: To get the address mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_ADDR_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_SHARED_CACHE_ADDRMODE_32 COM_IBM_SHARED_CACHE_ADDRMODE_64 To get the compressed references mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_CMPRSSREF_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_ITERATE_SHARED_CACHES_UNKNOWN_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_NON_COMPRESSED_POINTERS_MODE The field softMaxBytes is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 or later is specified. The field layer is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 or later is specified. If the shared cache does not have a layer number, the value for layer is -1 . DestroySharedCache You can remove a shared classes cache by using the DestroySharedCache() API: jvmtiError DestroySharedCache(jvmtiEnv *env, const char *cacheDir, const char *name, jint persistence, jboolean useCommandLineValues, jint *internalErrorCode); This extension removes a named shared classes cache of a given persistence type, in a given directory. You can specify the cache name, persistence type, and directory in one of these ways: Set useCommandLineValues to true and specify the values on the command line. If a value is not available, the default values for the platform are used. Set useCommandLineValues to false and use the cacheDir , persistence and cacheName parameters to identify the cache to be removed. To accept the default value for cacheDir or cacheName , specify the parameter with a null value. Parameters env : A pointer to the JVMTI environment. cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. cacheName : When the value of useCommandLineValues is false , specify the name of the cache to be removed. If the value is null , the platform-dependent default is used. persistence : When the value of useCommandLineValues is false, specify the type of cache to remove. This parameter must have one of the following values: PERSISTENCE_DEFAULT (The default value for the platform). PERSISTENT NONPERSISTENT useCommandLineValues : Set this value to true when you want to specify the shared classes cache name, persistence type, and directory on the command line. Set this value to false when you want to use the cacheDir , persistence , and cacheName parameters instead. internalErrorCode : If not null , this value is set to one of the following constants when JVMTI_ERROR_INTERNAL is returned: COM_IBM_DESTROYED_ALL_CACHE : Set when JVMTI_ERROR_NONE is returned. COM_IBM_DESTROYED_NONE : Set when the function fails to remove any caches. COM_IBM_DESTROY_FAILED_CURRENT_GEN_CACHE : Set when the function fails to remove the existing current generation cache, irrespective of the state of older generation caches. COM_IBM_DESTROY_FAILED_OLDER_GEN_CACHE : Set when the function fails to remove any older generation caches. The current generation cache does not exist or is successfully removed. Returns JVMTI_ERROR_NONE : Success. No cache exists or all existing caches of all generations are removed. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The persistence parameter is not valid. JVMTI_ERROR_INTERNAL : Failed to remove any existing cache with the given name. See the value of the internalErrorCode parameter for more information about the failure. Identifiers JVMTI Extension Function identifier: com.ibm.DestroySharedCache Macro declaration in the ibmjvmti.h file: COM_IBM_DESTROY_SHARED_CACHE RegisterVerboseGCSubscriber You can subscribe to verbose garbage collection (GC) data logging by using the RegisterVerboseGCSubscriber() API: jvmtiError RegisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiVerboseGCSubscriber subscriber, jvmtiVerboseGCAlarm alarm, void *user_data, void **subscription_id) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiVerboseGCSubscriber . alarm : A function pointer of type jvmtiVerboseGCAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterVerboseGCSubscriber call if successful. The value must be supplied to a future call to DeregisterVerboseGCSubscriber API, which is used to unsubscribe from verbose GC data logging. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : GC verbose logging is not available. JVMTI_ERROR_INTERNAL : An internal error has occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_VERBOSEGC_SUBSCRIBER jvmtiVerboseGCSubscriber function The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCSubscriber)(jvmtiEnv *jvmti_env, const char *record, jlong length, void *user_data); The subscriber function must be of type jvmtiVerboseGCSubscriber , which is declared in ibmjvmti.h . This function is called with each record of verbose logging data produced by the VM. The verbose logging record supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, and the subscription is deregistered. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : An ASCII string that contains a verbose log record. length : The number of ASCII characters in the verbose log record. user_data : User data supplied when the subscriber is registered. jvmtiVerboseGCAlarm function The alarm function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiVerboseGCAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. user_data : User data supplied when the subscriber is registered. subscription_id : The subscription identifier. DeregisterVerboseGCSubscriber You can unsubscribe from verbose Garbage Collection (GC) data logging by using the DeregisterVerboseGCSubscriber() API: jvmtiError DeregisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterVerboseGCSubscriber() API is called, no further calls are made to the previously registered subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterVerboseGCSubscriber() API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_VERBOSEGC_SUBSCRIBER","title":"JVMTI"},{"location":"interface_jvmti/#java-virtual-machine-tool-interface","text":"The Java\u2122 Virtual Machine Tool Interface (JVMTI) is a two-way interface that allows communication between the VM and a native agent. It replaces both the Java Virtual Machine Debug Interface (JVMDI) and Java Virtual Machine Profiler Interface (JVMPI).","title":"Java Virtual Machine Tool Interface"},{"location":"interface_jvmti/#overview","text":"The JVMTI allows third parties to develop debugging, profiling, and monitoring tools for the VM. The interface contains mechanisms for the agent to notify the VM about the kinds of information it requires, and also provides a means of receiving relevant notifications. Several agents can be attached to a VM at any one time. JVMTI agents can be loaded at startup using short or long forms of the command-line option: -agentlib:<agent-lib-name>=<options> or -agentpath:<path-to-agent>=<options> In the example that follows (see Sample JVMTI agent ), the directory containing the jdwp library is assumed to be on the library path. If you require a specific library, such as jdwp , with your JVMTI agent, you can specify the path at startup, for example: -agentlib:jdwp=<options> For more information about JVMTI, see https://docs.oracle.com/javase/8/docs/technotes/guides/management/index.html . For a guide about writing a JVMTI agent, see http://www.oracle.com/technetwork/articles/javase/jvmti-136367.html .","title":"Overview"},{"location":"interface_jvmti/#openj9-extensions","text":"OpenJ9 extensions to the JVMTI allow a JVMTI agent to query or automatically trigger operations in the VM, including the following tasks: Task OpenJ9 extensions Get the OS thread ID GetOSThreadID Query, set, and reset the VM dump options QueryVmDump , SetVmDump , ResetVmDump Trigger a VM dump, and monitor JVMTI event functions when VM dumps start and end TriggerVmDump , VMDumpStart , VMDumpEnd Set VM trace options SetVmTrace Subscribe to and unsubscribe from VM tracepoints RegisterTracePointSubscriber , DeregisterTracePointSubscriber Query runtime environment native memory categories GetMemoryCategories Query and set VM log options QueryVmLogOptions , SetVmLogOptions Search for and remove a shared classes cache IterateSharedCaches , DestroySharedCache Subscribe to and unsubscribe from verbose garbage collection (GC) data logging RegisterVerboseGCSubscriber , DeregisterVerboseGCSubscriber The definitions that you need when you write a JVMTI agent are provided in the header files jvmti.h and ibmjvmti.h , in the include directory.","title":"OpenJ9 extensions"},{"location":"interface_jvmti/#sample-jvmti-agent","text":"The following sample shows you how to write a simple JVMTI agent that uses OpenJ9 extensions to the JVMTI. Sample JVMTI agent written in C/C++, which uses the OpenJ9 extensions /* * tiSample.c * * Sample JVMTI agent to demonstrate the OpenJ9 JVMTI dump extensions */ #include \"jvmti.h\" #include \"ibmjvmti.h\" /* Forward declarations for JVMTI callback functions */ void JNICALL VMInitCallback(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread); void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...); /* * Agent_Onload() * * JVMTI agent initialisation function, invoked as agent is loaded by the VM */ JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) { jvmtiEnv *jvmti = NULL; jvmtiError rc; jint extensionEventCount = 0; jvmtiExtensionEventInfo *extensionEvents = NULL; jint extensionFunctionCount = 0; jvmtiExtensionFunctionInfo *extensionFunctions = NULL; int i = 0, j = 0; printf(\"tiSample: Loading JVMTI sample agent\\n\"); /* Get access to JVMTI */ (*jvm)->GetEnv(jvm, (void **)&jvmti, JVMTI_VERSION_1_0); /* Look up all the JVMTI extension events and functions */ (*jvmti)->GetExtensionEvents(jvmti, &extensionEventCount, &extensionEvents); (*jvmti)->GetExtensionFunctions(jvmti, &extensionFunctionCount, &extensionFunctions); printf(\"tiSample: Found %i JVMTI extension events, %i extension functions\\n\", extensionEventCount, extensionFunctionCount); /* Find the JVMTI extension event we want */ while (i++ < extensionEventCount) { if (strcmp(extensionEvents->id, COM_IBM_VM_DUMP_START) == 0) { /* Found the dump start extension event, now set up a callback for it */ rc = (*jvmti)->SetExtensionEventCallback(jvmti, extensionEvents->extension_event_index, &DumpStartCallback); printf(\"tiSample: Setting JVMTI event callback %s, rc=%i\\n\", COM_IBM_VM_DUMP_START, rc); break; } extensionEvents++; /* move on to the next extension event */ } /* Find the JVMTI extension function we want */ while (j++ < extensionFunctionCount) { jvmtiExtensionFunction function = extensionFunctions->func; if (strcmp(extensionFunctions->id, COM_IBM_SET_VM_DUMP) == 0) { /* Found the set dump extension function, now set a dump option to generate javadumps on thread starts */ rc = function(jvmti, \"java:events=thrstart\"); printf(\"tiSample: Calling JVMTI extension %s, rc=%i\\n\", COM_IBM_SET_VM_DUMP, rc); break; } extensionFunctions++; /* move on to the next extension function */ } return JNI_OK; } /* * DumpStartCallback() * JVMTI callback for dump start event (IBM JVMTI extension) */ void JNICALL DumpStartCallback(jvmtiEnv *jvmti_env, char* label, char* event, char* detail, ...) { printf(\"tiSample: Received JVMTI event callback, for event %s\\n\", event); } The sample JVMTI agent consists of two functions, Agent_OnLoad() and DumpStartCallback() :","title":"Sample JVMTI agent"},{"location":"interface_jvmti/#agent_onload","text":"This function is called by the VM when the agent is loaded at VM startup, which allows the JVMTI agent to modify VM behavior before initialization is complete. The sample agent obtains access to the JVMTI interface by using the JNI Invocation API function GetEnv() . The agent calls the APIs GetExtensionEvents() and GetExtensionFunctions() to find the JVMTI extensions that are supported by the VM. These APIs provide access to the list of extensions available in the jvmtiExtensionEventInfo and jvmtiExtensionFunctionInfo structures. The sample uses an extension event and an extension function in the following way: Extension event: The sample JVMTI agent searches for the extension event VmDumpStart in the list of jvmtiExtensionEventInfo structures, by using the identifier COM_IBM_VM_DUMP_START provided in ibmjvmti.h . When the event is found, the JVMTI agent calls the JVMTI interface SetExtensionEventCallback() to enable the event, providing a function DumpStartCallback() that is called when the event is triggered. Extension function: Next, the sample JVMTI agent searches for the extension function SetVMDump in the list of jvmtiExtensionFunctionInfo structures, by using the identifier COM_IBM_SET_VM_DUMP provided in ibmjvmti.h . The JVMTI agent calls the function by using the jvmtiExtensionFunction pointer to set a VM dump option java:events=thrstart . This option requests the VM to trigger a Java dump every time a VM thread is started.","title":"Agent_OnLoad()"},{"location":"interface_jvmti/#dumpstartcallback","text":"This callback function issues a message when the associated extension event is called. In the sample code, DumpStartCallback() is used when the VmDumpStart event is triggered.","title":"DumpStartCallback()"},{"location":"interface_jvmti/#using-the-sample-jvmti-agent","text":"Build the sample JVMTI agent: Windows: cl /I<jre_path>\\include /MD /FetiSample.dll tiSample.c /link /DLL Linux, AIX\u00ae, and z/OS\u00ae: gcc -I<jre_path>/include -o libtiSample.so -shared tiSample.c where <jre_path> is the path to your Java runtime environment installation. To run the sample JVMTI agent, use the command: java -agentlib:tiSample -version When the sample JVMTI agent loads, messages are generated. When the JVMTI agent initiates a Java dump, the message JVMDUMP010 is issued.","title":"Using the sample JVMTI agent"},{"location":"interface_jvmti/#api-reference","text":"The following sections provide reference information for the OpenJ9 extensions to the JVMTI.","title":"API reference"},{"location":"interface_jvmti/#getosthreadid","text":"You can get the OS thread ID by using the GetOSThreadID() API: jvmtiError GetOSThreadID(jvmtiEnv* jvmti_env, jthread thread, jlong * threadid_ptr); Parameters jvmti_env : A pointer to the JVMTI environment. thread : The thread for which the ID is required. threadid_ptr : A pointer to a variable, used to return the thread ID that corresponds to the thread specified by the thread parameter. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The threadid_ptr parameter is null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_INVALID_THREAD : The thread is not valid. JVMTI_ERROR_THREAD_NOT_ALIVE : The VM state of the thread is not started or has died. JVMTI_ERROR_UNATTACHED_THREAD : The current thread is not attached to the VM. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI start or live phase. Identifiers JVMTI Extension Function identifier: com.ibm.GetOSThreadID Macro declaration in the ibmjvmti.h file: COM_IBM_GET_OS_THREAD_ID","title":"GetOSThreadID"},{"location":"interface_jvmti/#queryvmdump","text":"You can query the VM dump options that are set for a VM by using the QueryVmDump() API: jvmtiError QueryVmDump(jvmtiEnv* jvmti_env, jint buffer_size, void* options_buffer, jint* data_size_ptr) This extension returns a set of dump option specifications as ASCII strings. The syntax of the option string is the same as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . The option strings are separated by newline characters. If the memory buffer is too small to contain the current VM dump option strings, you can expect the following results: The error message JVMTI_ERROR_ILLEGAL_ARGUMENT is returned. The variable for data_size_ptr is set to the required buffer size. Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option strings. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options_buffer or data_size_ptr parameters are null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer in options_buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_DUMP","title":"QueryVmDump"},{"location":"interface_jvmti/#setvmdump","text":"You can set VM dump options by using the SetVmDump() API: jvmtiError SetVmDump(jvmtiEnv* jvmti_env, char* option) The dump option is passed in as an ASCII character string. Use the same syntax as the -Xdump command-line option, with the initial -Xdump: omitted. See -Xdump . When dumps are in progress, the dump configuration is locked, and calls to SetVmDump() fail with a return value of JVMTI_ERROR_NOT_AVAILABLE . Parameters jvmti_env : A pointer to the JVMTI environment. option : The VM dump option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xdump string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_DUMP","title":"SetVmDump"},{"location":"interface_jvmti/#triggervmdump","text":"You can trigger a VM dump and specify the type of dump you want by using the TriggerVmDump() API: jvmtiError TriggerVmDump(jvmtiEnv* jvmti_env, char* option) Choose the type of dump required by specifying an ASCII string that contains one of the supported dump agent types. See -Xdump . JVMTI events are provided at the start and end of the dump. Parameters jvmti_env : A pointer to the JVMTI environment. option : A pointer to the dump type string, which can be one of the following types: stack java system console tool heap snap ceedump (z/OS only) Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.TriggerVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_TRIGGER_VM_DUMP","title":"TriggerVmDump"},{"location":"interface_jvmti/#resetvmdump","text":"You can reset VM dump options to the values at VM initialization by using the ResetVmDump() API: jvmtiError ResetVmDump(jvmtiEnv* jvmti_env) Parameters jvmti_env : The JVMTI environment pointer. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The dump configuration is locked because a dump is in progress. Identifiers JVMTI Extension Function identifier: com.ibm.ResetVmDump Macro declaration in the ibmjvmti.h file: COM_IBM_RESET_VM_DUMP","title":"ResetVmDump"},{"location":"interface_jvmti/#vmdumpstart","text":"The following JVMTI event function is called when a VM dump starts: void JNICALL VMDumpStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait.\" Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name, such as com.ibm.VmDumpStart . detail : The dump event detail string. The string can be empty. Returns None","title":"VMDumpStart"},{"location":"interface_jvmti/#vmdumpend","text":"The following JVMTI event function is called when a VM dump ends: void JNICALL VMDumpEnd(jvmtiEnv *jvmti_env, JNIEnv* jni_env, char* label, char* event, char* detail) The event function provides the dump file name, the name of the JVMTI event, and the detail string from the dump event. The detail string provides additional information about the event that triggered the dump. This information is the same as the information detailed in the JVMDUMP039I message. For example: JVMDUMP039I Processing dump event \"systhrow\", detail \"java/lang/OutOfMemoryError\" at 2014/10/17 13:31:03 - please wait. Parameters jvmti_env : JVMTI environment pointer. jni_env : JNI environment pointer for the thread on which the event occurred. label : The dump file name, including directory path. event : The extension event name com.ibm.VmDumpEnd . detail : The dump event detail string. The string can be empty. Returns None","title":"VMDumpEnd"},{"location":"interface_jvmti/#setvmtrace","text":"You can set VM trace options by using the SetVmTrace() API: jvmtiError SetVmTrace(jvmtiEnv* jvmti_env, char* option) The trace option is passed in as an ASCII character string. Use the same syntax as the -Xtrace command-line option, with the initial -Xtrace: omitted. See -Xtrace . Parameters jvmti_env : JVMTI environment pointer. option : Enter the VM trace option string. Note: On z/OS, you might need to convert the option string from EBCDIC to ASCII before using this JVMTI extension function. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The option parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The option parameter contains an invalid -Xtrace string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmTrace Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_TRACE","title":"SetVmTrace"},{"location":"interface_jvmti/#registertracepointsubscriber","text":"You can subscribe to VM tracepoints by using the RegisterTracePointSubscriber() API: jvmtiError RegisterTracePointSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiTraceSubscriber subscriber, jvmtiTraceAlarm alarm, void *userData, void **subscriptionID) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiTraceSubscriber . alarm : A function pointer of type jvmtiTraceAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterTracePointSubscriber call if successful. The value must be supplied to a future call to the DeregisterTracePointSubscriber API, which is used to unsubscribe from the VM tracepoint. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : VM trace is not available. JVMTI_ERROR_INTERNAL : An internal error occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_TRACEPOINT_SUBSCRIBER","title":"RegisterTracePointSubscriber"},{"location":"interface_jvmti/#jvmtitracesubscriber-function","text":"The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiTraceSubscriber)(jvmtiEnv *jvmti_env, void *record, jlong length, void *user_data); The subscriber function must be of type jvmtiTraceSubscriber , which is declared in ibmjvmti.h . This function is called with each tracepoint record that is selected through the -Xtrace:external option. The tracepoint record that is supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, the subscription is disconnected, and no further tracepoints are sent to the subscriber. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : A UTF-8 string that contains a tracepoint record. length : The number of UTF-8 characters in the tracepoint record. user_data : User data that is supplied when the subscriber is registered.","title":"jvmtiTraceSubscriber function"},{"location":"interface_jvmti/#jvmtitracealarm-function","text":"The alarm function type is defined as follows: typedef jvmtiError (*jvmtiTraceAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiTraceAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier. user_data : User data that is supplied when the subscriber is registered.","title":"jvmtiTraceAlarm function"},{"location":"interface_jvmti/#deregistertracepointsubscriber","text":"You can unsubscribe from VM tracepoints by using the DeregisterTracePointSubscriber() API: jvmtiError DeregisterTracePointSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterTracePointSubscriber() API is called, no further calls are made to the subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterTracePointSubscriber API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterTracePointSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_TRACEPOINT_SUBSCRIBER","title":"DeregisterTracePointSubscriber"},{"location":"interface_jvmti/#getmemorycategories","text":"You can query runtime environment native memory categories by using the GetMemoryCategories() API: jvmtiError GetMemoryCategories(jvmtiEnv* env, jint version, jint max_categories, jvmtiMemoryCategory * categories_buffer, jint * written_count_ptr, jint * total_categories_ptr); You can query the total native memory consumption of the runtime environment for each memory category by using this API. Native memory is memory requested from the operating system using library functions such as malloc() and mmap() . Runtime environment native memory use is grouped under high-level memory categories, as described in the NATIVEMEMINFO section of the Java dump topic. The data returned by the GetMemoryCategories() API is consistent with this format. See Java dump: NATIVEMEMINFO . The extension writes native memory information to a memory buffer specified by the user. Each memory category is recorded as a jvmtiMemoryCategory structure, whose format is defined in ibmjvmti.h . You can use the GetMemoryCategories() API to work out the buffer size you must allocate to hold all memory categories defined inside the VM. To calculate the size, call the API with a null categories_buffer argument and a non-null total_categories_ptr argument. Parameters env : A pointer to the JVMTI environment. version : The version of the jvmtiMemoryCategory structure that you are using. Use COM_IBM_GET_MEMORY_CATEGORIES_VERSION_1 for this argument, unless you must work with an obsolete version of the jvmtiMemoryCategory structure. max_categories : The number of jvmtiMemoryCategory structures that can fit in the categories_buffer memory buffer. categories_buffer : A pointer to the memory buffer for holding the result of the GetMemoryCategories() call. The number of jvmtiMemoryCategory slots available in the categories_buffer memory buffer must be accurately specified with max_categories , otherwise GetMemoryCategories() can overflow the memory buffer. The value can be null. written_count_ptr : A pointer to jint to store the number of jvmtiMemoryCategory structures to be written to the categories_buffer memory buffer. The value can be null. total_categories_ptr : A pointer to jint to store the total number of memory categories declared in the VM. The value can be null. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_UNSUPPORTED_VERSION : Unrecognized value passed for version. JVMTI_ERROR_ILLEGAL_ARGUMENT : Illegal argument; categories_buffer , count_ptr , and total_categories_ptr all have null values. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is invalid. JVMTI_ERROR_OUT_OF_MEMORY : Memory category data is truncated because max_categories is not large enough. Identifiers JVMTI Extension Function identifier: com.ibm.GetMemoryCategories Macro declaration in the ibmjvmti.h file: COM_IBM_GET_MEMORY_CATEGORIES","title":"GetMemoryCategories"},{"location":"interface_jvmti/#queryvmlogoptions","text":"You can query VM log options by using the QueryVmLogOptions() API: jvmtiError QueryVmLogOptions(jvmtiEnv* jvmti_env, jint buffer_size, void* options, jint* data_size_ptr) This extension returns the current log options as an ASCII string. The syntax of the string is the same as the -Xlog command-line option, with the initial -Xlog: omitted. For example, the string \"error,warn\" indicates that the VM is set to log error and warning messages only. For more information, see -Xlog . Parameters jvmti_env : A pointer to the JVMTI environment. buffer_size : The size of the supplied memory buffer in bytes. If the memory buffer is too small to contain the current VM log option string, the JVMTI_ERROR_ILLEGAL_ARGUMENT error message is returned. options_buffer : A pointer to the supplied memory buffer. data_size_ptr : A pointer to a variable, used to return the total size of the option string. Returns JVMTI_ERROR_NONE : Success JVMTI_ERROR_NULL_POINTER : The options or data_size_ptr parameters are null. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The supplied memory buffer is too small. Identifiers JVMTI Extension Function identifier: com.ibm.QueryVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_QUERY_VM_LOG_OPTIONS","title":"QueryVmLogOptions"},{"location":"interface_jvmti/#setvmlogoptions","text":"You can set VM log options by using the SetVmLogOptions() API: jvmtiError SetVmLogOptions(jvmtiEnv* jvmti_env, char* options_buffer) The log option is passed in as an ASCII character string. Use the same syntax as the -Xlog command-line option, with the initial -Xlog: omitted. For example, to set the VM to log error and warning messages, pass in a string containing \"error,warn\". For more information, see -Xlog . Parameters jvmti_env : A pointer to the JVMTI environment. options_buffer : A pointer to memory containing the log option. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The parameter option is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is invalid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_ILLEGAL_ARGUMENT : The parameter option contains an invalid -Xlog string. Identifiers JVMTI Extension Function identifier: com.ibm.SetVmLogOptions Macro declaration in the ibmjvmti.h file: COM_IBM_SET_VM_LOG_OPTIONS","title":"SetVmLogOptions"},{"location":"interface_jvmti/#iteratesharedcaches","text":"You can search for shared classes caches that exist in a specified cache directory by using the IterateSharedCaches() API: jvmtiError IterateSharedCaches(jvmtiEnv* env, jint version, const char *cacheDir, jint flags, jboolean useCommandLineValues, jvmtiIterateSharedCachesCallback callback, void *user_data); Information about the caches is returned in a structure that is populated by a user-specified callback function. You can specify the search directory in two ways: Set the value of useCommandLineValues to true and specify the directory on the command line. If the directory is not specified on the command line, the default location for the platform is used. Set the value of useCommandLineValues to false and use the cacheDir parameter. To accept the default location for the platform, specify cacheDir with a null value. Parameters env : A pointer to the JVMTI environment. version : Version information for IterateSharedCaches , which describes the jvmtiSharedCacheInfo structure passed to the jvmtiIterateSharedCachesCallback function. The values allowed are: COM_IBM_ITERATE_SHARED_CACHES_VERSION_1 COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. flags : Reserved for future use. The only value allowed is COM_IBM_ITERATE_SHARED_CACHES_NO_FLAGS . useCommandLineValues : Set this value to true when you want to specify the cache directory on the command line. Set this value to false when you want to use the cacheDir parameter. callback : A function pointer to a user provided callback routine jvmtiIterateSharedCachesCallback . user_data : User supplied data, passed as an argument to the callback function. jint (JNICALL *jvmtiIterateSharedCachesCallback)(jvmtiEnv *env,jvmtiSharedCacheInfo *cache_info, void *user_data); Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_UNSUPPORTED_VERSION : The version parameter is not valid. JVMTI_ERROR_NULL_POINTER : The callback parameter is null. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The flags parameter is not valid. JVMTI_ERROR_INTERNAL : This error is returned when the jvmtiIterateSharedCachesCallback returns JNI_ERR . Identifiers JVMTI Extension Function identifier: com.ibm.IterateSharedCaches Macro declaration in the ibmjvmti.h file: COM_IBM_ITERATE_SHARED_CACHES","title":"IterateSharedCaches"},{"location":"interface_jvmti/#jvmtiiteratesharedcachescallback-function","text":"Callback function parameters env : A pointer to the JVMTI environment when calling COM_IBM_ITERATE_SHARED_CACHES . cache_info : A jvmtiSharedCacheInfo structure containing information about a shared cache. user_data : User-supplied data, passed as an argument to IterateSharedCaches . Callback function returns JNI_OK : Continue iterating. JNI_ERR : Stop iterating, which causes IterateSharedCaches to return JVMTI_ERROR_INTERNAL","title":"jvmtiIterateSharedCachesCallback function"},{"location":"interface_jvmti/#jvmtisharedcacheinfo-structure","text":"The structure of jvmtiSharedCacheInfo typedef struct jvmtiSharedCacheInfo { const char *name; // the name of the shared cache jboolean isCompatible; // if the shared cache is compatible with this VM jboolean isPersistent; // true if the shared cache is persistent, false if its non-persistent jint os_shmid; // the OS shared memory ID associated with a non-persistent cache, -1 otherwise jint os_semid; // the OS shared semaphore ID associated with a non-persistent cache, -1 otherwise jint modLevel; // one of: // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA5 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA6 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA7 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA8 // COM_IBM_SHARED_CACHE_MODLEVEL_JAVA9 // from Java 10: the version number of the Java level on which the shared cache is created jint addrMode; // the address mode of the VM creating the shared cache: includes additional // information on whether it is a 64-bit compressedRefs cache when // COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. jboolean isCorrupt; // if the cache is corrupted jlong cacheSize; // the total usable shared classes cache size, or -1 when isCompatible is false jlong freeBytes; // the number of free bytes in the shared classes cache, or -1 when isCompatible is false jlong lastDetach; // the last detach time specified in milliseconds since 00:00:00 on 1 January 1970 UTC, // or -1 when the last detach time is not available jint cacheType; // the type of the cache jlong softMaxBytes; // the soft limit for the available space in the cache jint layer; // the shared cache layer number } jvmtiSharedCacheInfo; Notes: The field cacheType is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_2 or later is specified. jvmtiSharedCacheInfo.addrMode encodes both address mode and the compressed reference mode when COM_IBM_ITERATE_SHARED_CACHES_VERSION_3 or later is specified. In this case, use the following set of macros to access the address mode and compressed reference mode: To get the address mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_ADDR_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_SHARED_CACHE_ADDRMODE_32 COM_IBM_SHARED_CACHE_ADDRMODE_64 To get the compressed references mode, use: COM_IBM_ITERATE_SHARED_CACHES_GET_CMPRSSREF_MODE(jvmtiSharedCacheInfo.addrMode) This macro returns one of the following values: COM_IBM_ITERATE_SHARED_CACHES_UNKNOWN_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_COMPRESSED_POINTERS_MODE COM_IBM_ITERATE_SHARED_CACHES_NON_COMPRESSED_POINTERS_MODE The field softMaxBytes is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_4 or later is specified. The field layer is included when COM_IBM_ITERATE_SHARED_CACHES_VERSION_5 or later is specified. If the shared cache does not have a layer number, the value for layer is -1 .","title":"jvmtiSharedCacheInfo structure"},{"location":"interface_jvmti/#destroysharedcache","text":"You can remove a shared classes cache by using the DestroySharedCache() API: jvmtiError DestroySharedCache(jvmtiEnv *env, const char *cacheDir, const char *name, jint persistence, jboolean useCommandLineValues, jint *internalErrorCode); This extension removes a named shared classes cache of a given persistence type, in a given directory. You can specify the cache name, persistence type, and directory in one of these ways: Set useCommandLineValues to true and specify the values on the command line. If a value is not available, the default values for the platform are used. Set useCommandLineValues to false and use the cacheDir , persistence and cacheName parameters to identify the cache to be removed. To accept the default value for cacheDir or cacheName , specify the parameter with a null value. Parameters env : A pointer to the JVMTI environment. cacheDir : When the value of useCommandLineValues is false , specify the absolute path of the directory for the shared classes cache. If the value is null , the platform-dependent default is used. cacheName : When the value of useCommandLineValues is false , specify the name of the cache to be removed. If the value is null , the platform-dependent default is used. persistence : When the value of useCommandLineValues is false, specify the type of cache to remove. This parameter must have one of the following values: PERSISTENCE_DEFAULT (The default value for the platform). PERSISTENT NONPERSISTENT useCommandLineValues : Set this value to true when you want to specify the shared classes cache name, persistence type, and directory on the command line. Set this value to false when you want to use the cacheDir , persistence , and cacheName parameters instead. internalErrorCode : If not null , this value is set to one of the following constants when JVMTI_ERROR_INTERNAL is returned: COM_IBM_DESTROYED_ALL_CACHE : Set when JVMTI_ERROR_NONE is returned. COM_IBM_DESTROYED_NONE : Set when the function fails to remove any caches. COM_IBM_DESTROY_FAILED_CURRENT_GEN_CACHE : Set when the function fails to remove the existing current generation cache, irrespective of the state of older generation caches. COM_IBM_DESTROY_FAILED_OLDER_GEN_CACHE : Set when the function fails to remove any older generation caches. The current generation cache does not exist or is successfully removed. Returns JVMTI_ERROR_NONE : Success. No cache exists or all existing caches of all generations are removed. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : The shared classes feature is not enabled in the VM. JVMTI_ERROR_ILLEGAL_ARGUMENT : The persistence parameter is not valid. JVMTI_ERROR_INTERNAL : Failed to remove any existing cache with the given name. See the value of the internalErrorCode parameter for more information about the failure. Identifiers JVMTI Extension Function identifier: com.ibm.DestroySharedCache Macro declaration in the ibmjvmti.h file: COM_IBM_DESTROY_SHARED_CACHE","title":"DestroySharedCache"},{"location":"interface_jvmti/#registerverbosegcsubscriber","text":"You can subscribe to verbose garbage collection (GC) data logging by using the RegisterVerboseGCSubscriber() API: jvmtiError RegisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, char *description, jvmtiVerboseGCSubscriber subscriber, jvmtiVerboseGCAlarm alarm, void *user_data, void **subscription_id) Parameters jvmti_env : A pointer to the JVMTI environment. description : An ASCII character string that describes the subscriber. subscriber : A function of type jvmtiVerboseGCSubscriber . alarm : A function pointer of type jvmtiVerboseGCAlarm . user_data : A pointer to user data. This pointer is passed to the subscriber and alarm functions each time these functions are called. This pointer can be a null value. subscription_id : A pointer to a subscription identifier. This pointer is returned by the RegisterVerboseGCSubscriber call if successful. The value must be supplied to a future call to DeregisterVerboseGCSubscriber API, which is used to unsubscribe from verbose GC data logging. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : One of the supplied parameters is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. JVMTI_ERROR_NOT_AVAILABLE : GC verbose logging is not available. JVMTI_ERROR_INTERNAL : An internal error has occurred. Identifiers JVMTI Extension Function identifier: com.ibm.RegisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_REGISTER_VERBOSEGC_SUBSCRIBER","title":"RegisterVerboseGCSubscriber"},{"location":"interface_jvmti/#jvmtiverbosegcsubscriber-function","text":"The subscriber function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCSubscriber)(jvmtiEnv *jvmti_env, const char *record, jlong length, void *user_data); The subscriber function must be of type jvmtiVerboseGCSubscriber , which is declared in ibmjvmti.h . This function is called with each record of verbose logging data produced by the VM. The verbose logging record supplied to the subscriber function is valid only for the duration of the function. If the subscriber wants to save the data, the data must be copied elsewhere. If the subscriber function returns an error, the alarm function is called, and the subscription is deregistered. Subscriber function parameters jvmti_env : A pointer to the JVMTI environment. record : An ASCII string that contains a verbose log record. length : The number of ASCII characters in the verbose log record. user_data : User data supplied when the subscriber is registered.","title":"jvmtiVerboseGCSubscriber function"},{"location":"interface_jvmti/#jvmtiverbosegcalarm-function","text":"The alarm function type is defined as follows: typedef jvmtiError (*jvmtiVerboseGCAlarm)(jvmtiEnv *jvmti_env, void *subscription_id, void *user_data); The alarm function must be of type jvmtiVerboseGCAlarm , which is declared in ibmjvmti.h . This function is called if the subscriber function returns an error. Alarm function parameters jvmti_env : A pointer to the JVMTI environment. user_data : User data supplied when the subscriber is registered. subscription_id : The subscription identifier.","title":"jvmtiVerboseGCAlarm function"},{"location":"interface_jvmti/#deregisterverbosegcsubscriber","text":"You can unsubscribe from verbose Garbage Collection (GC) data logging by using the DeregisterVerboseGCSubscriber() API: jvmtiError DeregisterVerboseGCSubscriber(jvmtiEnv* jvmti_env, void *userData, void *subscription_id) After the DeregisterVerboseGCSubscriber() API is called, no further calls are made to the previously registered subscriber function. Parameters jvmti_env : A pointer to the JVMTI environment. subscription_id : The subscription identifier that is returned by the call to the RegisterVerboseGCSubscriber() API. Returns JVMTI_ERROR_NONE : Success. JVMTI_ERROR_NULL_POINTER : The subscription_id parameter is null. JVMTI_ERROR_OUT_OF_MEMORY : There is insufficient system memory to process the request. JVMTI_ERROR_INVALID_ENVIRONMENT : The jvmti_env parameter is not valid. JVMTI_ERROR_WRONG_PHASE : The extension has been called outside the JVMTI live phase. Identifiers JVMTI Extension Function identifier: com.ibm.DeregisterVerboseGCSubscriber Macro declaration in the ibmjvmti.h file: COM_IBM_DEREGISTER_VERBOSEGC_SUBSCRIBER","title":"DeregisterVerboseGCSubscriber"},{"location":"interface_lang_management/","text":"Language management interface Eclipse OpenJ9 provides MXBean extensions to the standard java.lang.management API, which can be used to monitor and manage the Java\u2122 virtual machine. These extensions provide access to information about the state of the OpenJ9 VM and the environment in which it is running. The following tables list the MXBeans by package and describe the monitoring or management capabilities. Package: com.ibm.lang.management MXBean Description GarbageCollectorMXBean Discovers Garbage Collection (GC) operations (collection times, compactions, heap memory usage, and freed memory). JvmCpuMonitorMXBean Discovers CPU consumption by category (GC, JIT, or other threads). MemoryMXBean Discovers memory usage (minimum and maximum heap sizes, and shared classes cache sizes). MemoryPoolMXBean Discovers memory pool usage for specific GC policies. OperatingSystemMXBean Discovers information about the operating system (memory, CPU capacity/utilization). RuntimeMXBean Discovers information about the runtime environment (CPU load, Java process ID, and VM state) ThreadMXBean Discovers information about native thread IDs. UnixOperatingSystemMXBean Discovers information for Unix operating systems (memory, file descriptors, processors, processor usage, and hardware) Package: com.ibm.virtualization.management MXBean Description GuestOSMXBean Discovers CPU and memory statistics of a virtual machine or logical partition as seen by the Hypervisor. HypervisorMXBean Discovers whether the operating system is running on a hypervisor and provides information about the hypervisor. Package: openj9.lang.management MXBean Description OpenJ9DiagnosticsMXBean Configures and dynamically triggers dump agents. For more information about using these MXBeans, read the API documentation. For Java 8, see the OpenJ9 Language Management API documentation .","title":"Language Management"},{"location":"interface_lang_management/#language-management-interface","text":"Eclipse OpenJ9 provides MXBean extensions to the standard java.lang.management API, which can be used to monitor and manage the Java\u2122 virtual machine. These extensions provide access to information about the state of the OpenJ9 VM and the environment in which it is running. The following tables list the MXBeans by package and describe the monitoring or management capabilities. Package: com.ibm.lang.management MXBean Description GarbageCollectorMXBean Discovers Garbage Collection (GC) operations (collection times, compactions, heap memory usage, and freed memory). JvmCpuMonitorMXBean Discovers CPU consumption by category (GC, JIT, or other threads). MemoryMXBean Discovers memory usage (minimum and maximum heap sizes, and shared classes cache sizes). MemoryPoolMXBean Discovers memory pool usage for specific GC policies. OperatingSystemMXBean Discovers information about the operating system (memory, CPU capacity/utilization). RuntimeMXBean Discovers information about the runtime environment (CPU load, Java process ID, and VM state) ThreadMXBean Discovers information about native thread IDs. UnixOperatingSystemMXBean Discovers information for Unix operating systems (memory, file descriptors, processors, processor usage, and hardware) Package: com.ibm.virtualization.management MXBean Description GuestOSMXBean Discovers CPU and memory statistics of a virtual machine or logical partition as seen by the Hypervisor. HypervisorMXBean Discovers whether the operating system is running on a hypervisor and provides information about the hypervisor. Package: openj9.lang.management MXBean Description OpenJ9DiagnosticsMXBean Configures and dynamically triggers dump agents. For more information about using these MXBeans, read the API documentation. For Java 8, see the OpenJ9 Language Management API documentation .","title":"Language management interface"},{"location":"introduction/","text":"Getting started with OpenJ9 OpenJ9 is a high performance, scalable, Java\u2122 virtual machine (VM) implementation that is fully compliant with the Java Virtual Machine Specification . At run time, the VM interprets the Java bytecode that is compiled by the Java compiler. The VM acts as a translator between the language and the underlying operating system and hardware. A Java program requires a specific VM to run on a particular platform, such as Linux\u00ae, z/OS\u00ae, or Windows\u2122. This reference material provides information about the VM configuration and tuning options, together with the default settings. Configuring your system For normal operation, certain environment variables must be set at the operating system level. Depending on your system environment, you might also want to set other configuration options that allow the VM to exploit hardware and operating system features. Read Customizing your system to learn more about the following options: Setting the PATH and CLASSPATH environment variable. Setting the LIBPATH or LD_LIBRARY_PATH environment variable (AIX\u00ae and Linux) to indicate where to find shared libraries. Setting ulimits on AIX and Linux systems to ensure that the operating system allocates sufficient resources for your application. Setting region size, BPXPRM parameters, and Language Environment\u00ae runtime options on z/OS systems. If your application allocates a large amount of memory and frequently accesses that memory, you might want to enable large page support on your system. See Configuring large page memory allocation . Configuring Dynamic LPAR support on AIX systems. Notes: On macOS\u00ae systems, you must set the DYLD_LIBRARY_PATH environment variable to indicate where to find shared libraries. In addition, to ensure there are sufficient resources for your application, you might need to increase system limits by using launchctl , ulimit , or kern.<VARIABLES> . For further instructions, refer to the documentation for your macOS release. On AIX systems, the XL C++ Runtime is required to run JDK 14 or later. Performance tuning OpenJ9 is configured to start with a set of default options that provide the optimal runtime environment for Java applications with typical workloads. However, if your application is atypical, you can improve performance by tuning the OpenJ9 VM. You can also improve performance by enabling hardware features or using specific APIs in your application code. Garbage collection policies OpenJ9 includes several garbage collection policies. To learn more about these policies and the types of application workload that can benefit from them, see Garbage Collection . Class data sharing You can share class data between running VMs, which can reduce the startup time for a VM once the cache has been created. For more information, see Class Data Sharing . Native data operations If your Java application manipulates native data, consider writing your application to take advantage of methods in the Data Access Accelerator API. Cloud optimizations To improve the performance of applications that run in containers, try setting the following tuning options: Use a shared classes cache ( -Xshareclasses -XX:SharedCacheHardLimit=200m -Xscmx60m ) with Ahead-Of-Time (AOT) compilation to improve your startup time. For more information, see Class Data Sharing and AOT Compiler . Use the -Xtune:virtualized option, which configures OpenJ9 for typical cloud deployments where VM guests are provisioned with a small number of virtual CPUs to maximize the number of applications that can be run. When enabled, OpenJ9 adapts its internal processes to reduce the amount of CPU consumed and trim down the memory footprint. These changes come at the expense of only a small loss in throughput. The OpenJ9 VM automatically detects when it is running in a docker container and uses a mechanism to detect when the VM is idle. When an idle state is detected, OpenJ9 runs a garbage collection cycle and releases free memory pages back to the operating system. The object heap is also compacted to make best use of the available memory for further application processing. For cloud services that charge based on memory usage, maintaining a small footprint can generate cost savings. For more information about tuning options that control this process, see -XX:IdleTuningMinIdleWaitTime . Cryptographic operations OpenJDK uses the in-built Java cryptographic implementation by default. However, native cryptographic implementations typically provide better performance. OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which is well established and used with many enterprise applications. The OpenSSL V1.0.x and V1.1.x implementations are currently supported for the Digest, CBC, GCM, and RSA algorithms. The OpenSSL V1.1.x implementation is also supported for the ChaCha20 and ChaCha20-Poly1305 algorithms. On Linux and AIX platforms, the OpenSSL 1.0.x or 1.1.x library is expected to be found on the system path. If you use a package manager to install OpenSSL, the system path will be updated automatically. On other platforms, the OpenSSL 1.1.x library is currently bundled with the binaries from AdoptOpenJDK. OpenSSL support is enabled by default for all supported algorithms. If you want to limit support to specific algorithms, a number of system properties are available for tuning the implementation. Each algorithm can be disabled individually by setting the following system properties on the command line: To turn off Digest , set -Djdk.nativeDigest=false To turn off ChaCha20 and ChaCha20-Poly1305 , set -Djdk.nativeChaCha20=false . Note: These algorithms are not supported on Java 8 To turn off CBC , set -Djdk.nativeCBC=false To turn off GCM , set -Djdk.nativeGCM=false To turn off RSA , set -Djdk.nativeRSA=false You can turn off all the algorithms by setting the following system property on the command line: -Djdk.nativeCrypto=false To build a version of OpenJDK with OpenJ9 that includes OpenSSL support, follow the steps in our detailed build instructions: OpenJDK 8 with OpenJ9 . OpenJDK 11 with OpenJ9 . OpenJDK 14 with OpenJ9 . Note: If you obtain an OpenJDK with OpenJ9 build from AdoptOpenJDK that includes OpenSSL or build a version yourself that includes OpenSSL support, the following acknowledgements apply in accordance with the license terms: This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/). This product includes cryptographic software written by Eric Young (eay@cryptsoft.com). Exploiting GPUs OpenJ9 provides both the CUDA4J API and the GPU API , which enables you to develop applications that can take advantage of graphics processing unit (GPU) processing for suitable functions, such as code page conversion. You can also enable the JIT compiler to offload certain processing tasks to a GPU by specifying the -Xjit:enableGPU option on the command line. When enabled, the JIT compiler determines when to offload tasks based on performance heuristics. GPU processing is supported only on Windows (x86-64) and Linux (x86-64 and IBM Power LE) systems. For more information about enabling GPU processing, see Exploiting graphics processing units . Special consideration is needed when using the WDDM driver model for GPUs on Windows. Using the WDDM driver model means the GPU is also used as a display device and as such is subject to the Timeout Detection and Recovery (TDR) mechanism of Windows. If you are running demanding GPU workloads, you should increase the timeout from the default 2 seconds. More detail may be found in NVIDIA's Installation Guide for Windows . Runtime options Runtime options are specified on the command line and include system properties, standard options, nonstandard ( -X ) options, and -XX options. For a detailed list of runtime options, see OpenJ9 command-line options Default settings If you do not specify any options on the command line at run time, the OpenJ9 VM starts with default settings that define how it operates. For more information about these settings, see Default settings for the OpenJ9 VM . Using Jlink On Java 11 and later, you can use the jlink utility to create a custom OpenJ9 runtime image, which allows you to optimize image size. If you do not require translations from the English language, the translation files can be removed to further optimize the size. You can achieve this by specifying the --exclude-files=**java_**.properties option when you run jlink . The default English java.properties file is unaffected. Troubleshooting The OpenJ9 diagnostic component contains extensive features to assist with problem determination. Diagnostic data is produced under default conditions, but can also be controlled by starting the VM with the -Xdump option or using the com.ibm.jvm.Dump API. You can also trace Java applications, methods, and VM operations by using the -Xtrace option . To get started, read Diagnostic tools and data .","title":"Getting started"},{"location":"introduction/#getting-started-with-openj9","text":"OpenJ9 is a high performance, scalable, Java\u2122 virtual machine (VM) implementation that is fully compliant with the Java Virtual Machine Specification . At run time, the VM interprets the Java bytecode that is compiled by the Java compiler. The VM acts as a translator between the language and the underlying operating system and hardware. A Java program requires a specific VM to run on a particular platform, such as Linux\u00ae, z/OS\u00ae, or Windows\u2122. This reference material provides information about the VM configuration and tuning options, together with the default settings.","title":"Getting started with OpenJ9"},{"location":"introduction/#configuring-your-system","text":"For normal operation, certain environment variables must be set at the operating system level. Depending on your system environment, you might also want to set other configuration options that allow the VM to exploit hardware and operating system features. Read Customizing your system to learn more about the following options: Setting the PATH and CLASSPATH environment variable. Setting the LIBPATH or LD_LIBRARY_PATH environment variable (AIX\u00ae and Linux) to indicate where to find shared libraries. Setting ulimits on AIX and Linux systems to ensure that the operating system allocates sufficient resources for your application. Setting region size, BPXPRM parameters, and Language Environment\u00ae runtime options on z/OS systems. If your application allocates a large amount of memory and frequently accesses that memory, you might want to enable large page support on your system. See Configuring large page memory allocation . Configuring Dynamic LPAR support on AIX systems. Notes: On macOS\u00ae systems, you must set the DYLD_LIBRARY_PATH environment variable to indicate where to find shared libraries. In addition, to ensure there are sufficient resources for your application, you might need to increase system limits by using launchctl , ulimit , or kern.<VARIABLES> . For further instructions, refer to the documentation for your macOS release. On AIX systems, the XL C++ Runtime is required to run JDK 14 or later.","title":"Configuring your system"},{"location":"introduction/#performance-tuning","text":"OpenJ9 is configured to start with a set of default options that provide the optimal runtime environment for Java applications with typical workloads. However, if your application is atypical, you can improve performance by tuning the OpenJ9 VM. You can also improve performance by enabling hardware features or using specific APIs in your application code.","title":"Performance tuning"},{"location":"introduction/#garbage-collection-policies","text":"OpenJ9 includes several garbage collection policies. To learn more about these policies and the types of application workload that can benefit from them, see Garbage Collection .","title":"Garbage collection policies"},{"location":"introduction/#class-data-sharing","text":"You can share class data between running VMs, which can reduce the startup time for a VM once the cache has been created. For more information, see Class Data Sharing .","title":"Class data sharing"},{"location":"introduction/#native-data-operations","text":"If your Java application manipulates native data, consider writing your application to take advantage of methods in the Data Access Accelerator API.","title":"Native data operations"},{"location":"introduction/#cloud-optimizations","text":"To improve the performance of applications that run in containers, try setting the following tuning options: Use a shared classes cache ( -Xshareclasses -XX:SharedCacheHardLimit=200m -Xscmx60m ) with Ahead-Of-Time (AOT) compilation to improve your startup time. For more information, see Class Data Sharing and AOT Compiler . Use the -Xtune:virtualized option, which configures OpenJ9 for typical cloud deployments where VM guests are provisioned with a small number of virtual CPUs to maximize the number of applications that can be run. When enabled, OpenJ9 adapts its internal processes to reduce the amount of CPU consumed and trim down the memory footprint. These changes come at the expense of only a small loss in throughput. The OpenJ9 VM automatically detects when it is running in a docker container and uses a mechanism to detect when the VM is idle. When an idle state is detected, OpenJ9 runs a garbage collection cycle and releases free memory pages back to the operating system. The object heap is also compacted to make best use of the available memory for further application processing. For cloud services that charge based on memory usage, maintaining a small footprint can generate cost savings. For more information about tuning options that control this process, see -XX:IdleTuningMinIdleWaitTime .","title":"Cloud optimizations"},{"location":"introduction/#cryptographic-operations","text":"OpenJDK uses the in-built Java cryptographic implementation by default. However, native cryptographic implementations typically provide better performance. OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which is well established and used with many enterprise applications. The OpenSSL V1.0.x and V1.1.x implementations are currently supported for the Digest, CBC, GCM, and RSA algorithms. The OpenSSL V1.1.x implementation is also supported for the ChaCha20 and ChaCha20-Poly1305 algorithms. On Linux and AIX platforms, the OpenSSL 1.0.x or 1.1.x library is expected to be found on the system path. If you use a package manager to install OpenSSL, the system path will be updated automatically. On other platforms, the OpenSSL 1.1.x library is currently bundled with the binaries from AdoptOpenJDK. OpenSSL support is enabled by default for all supported algorithms. If you want to limit support to specific algorithms, a number of system properties are available for tuning the implementation. Each algorithm can be disabled individually by setting the following system properties on the command line: To turn off Digest , set -Djdk.nativeDigest=false To turn off ChaCha20 and ChaCha20-Poly1305 , set -Djdk.nativeChaCha20=false . Note: These algorithms are not supported on Java 8 To turn off CBC , set -Djdk.nativeCBC=false To turn off GCM , set -Djdk.nativeGCM=false To turn off RSA , set -Djdk.nativeRSA=false You can turn off all the algorithms by setting the following system property on the command line: -Djdk.nativeCrypto=false To build a version of OpenJDK with OpenJ9 that includes OpenSSL support, follow the steps in our detailed build instructions: OpenJDK 8 with OpenJ9 . OpenJDK 11 with OpenJ9 . OpenJDK 14 with OpenJ9 . Note: If you obtain an OpenJDK with OpenJ9 build from AdoptOpenJDK that includes OpenSSL or build a version yourself that includes OpenSSL support, the following acknowledgements apply in accordance with the license terms: This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit. (http://www.openssl.org/). This product includes cryptographic software written by Eric Young (eay@cryptsoft.com).","title":"Cryptographic operations"},{"location":"introduction/#exploiting-gpus","text":"OpenJ9 provides both the CUDA4J API and the GPU API , which enables you to develop applications that can take advantage of graphics processing unit (GPU) processing for suitable functions, such as code page conversion. You can also enable the JIT compiler to offload certain processing tasks to a GPU by specifying the -Xjit:enableGPU option on the command line. When enabled, the JIT compiler determines when to offload tasks based on performance heuristics. GPU processing is supported only on Windows (x86-64) and Linux (x86-64 and IBM Power LE) systems. For more information about enabling GPU processing, see Exploiting graphics processing units . Special consideration is needed when using the WDDM driver model for GPUs on Windows. Using the WDDM driver model means the GPU is also used as a display device and as such is subject to the Timeout Detection and Recovery (TDR) mechanism of Windows. If you are running demanding GPU workloads, you should increase the timeout from the default 2 seconds. More detail may be found in NVIDIA's Installation Guide for Windows .","title":"Exploiting GPUs"},{"location":"introduction/#runtime-options","text":"Runtime options are specified on the command line and include system properties, standard options, nonstandard ( -X ) options, and -XX options. For a detailed list of runtime options, see OpenJ9 command-line options","title":"Runtime options"},{"location":"introduction/#default-settings","text":"If you do not specify any options on the command line at run time, the OpenJ9 VM starts with default settings that define how it operates. For more information about these settings, see Default settings for the OpenJ9 VM .","title":"Default settings"},{"location":"introduction/#using-jlink","text":"On Java 11 and later, you can use the jlink utility to create a custom OpenJ9 runtime image, which allows you to optimize image size. If you do not require translations from the English language, the translation files can be removed to further optimize the size. You can achieve this by specifying the --exclude-files=**java_**.properties option when you run jlink . The default English java.properties file is unaffected.","title":"Using Jlink"},{"location":"introduction/#troubleshooting","text":"The OpenJ9 diagnostic component contains extensive features to assist with problem determination. Diagnostic data is produced under default conditions, but can also be controlled by starting the VM with the -Xdump option or using the com.ibm.jvm.Dump API. You can also trace Java applications, methods, and VM operations by using the -Xtrace option . To get started, read Diagnostic tools and data .","title":"Troubleshooting"},{"location":"jit/","text":"The JIT compiler The Just-In-Time (JIT) compiler is a key component of the OpenJ9 VM that improves the performance of Java applications by compiling platform-neutral Java bytecode into native machine code at run time. Without the JIT, the VM has to interpret the bytecodes itself - a process that requires extra CPU and memory. The JIT compiler doesn't compile every method that gets called because thousands of methods can be called at startup. Instead, OpenJ9 records the number of times a method is called. When the count reaches a pre-defined invocation threshold , JIT compilation is triggered. Once a method has been compiled by the JIT, the VM can call the compiled method rather than interpreting it. Optimization levels The JIT compiler can compile a method at different optimization levels: cold , warm , hot , very hot (with profiling) , or scorching . The hotter the optimization level, the better the expected performance, but the higher the cost in terms of CPU and memory. cold is used during startup processing for large applications where the goal is to achieve the best compiled code speed for as many methods as possible. warm is the workhorse; after start-up, most methods are compiled when they reach the invocation threshold. For higher optimization levels, the VM uses a sampling thread to identify methods that continue to take a lot of time. Methods that consume more than 1% are compiled at hot. Methods that consume more than 12.5% are scheduled for a scorching compilation. However, before that happens the methods are compiled at very hot with profiling to collect detailed profile data that is used by the scorching compilation. The higher optimization levels use special techniques such as escape analysis and partial redundancy elimination, or loop through certain optimization sequences more times. Although these techniques use more CPU and memory, the improved performance that is delivered by the optimizations can make the tradeoff worthwhile. Troubleshooting The JIT compiler is enabled by default to optimize performance. However, if you experience a problem running your application, temporarily turning off the JIT will tell you whether the JIT is at fault. Because JIT starts at the same time as the VM, you can only modify JIT behavior at startup. There are a number of ways to disable the JIT: Specify -Djava.compiler=NONE on the command line. Specify -Xint on the command line, which turns off the JIT and AOT compiler. To eliminate problems with one or the other you can turn these compilers off selectively with the -Xnojit and -Xnoaot options. Call the java.lang.Compiler API programmatically. Note: java.lang.Compiler is deprecated for removal in Java SE 9. If turning off the JIT solves your problem, you can investigate JIT operations in more detail by using a number of options to control behavior. Turning on verbose logging with the verbose suboption causes the JIT to record all compiler operations. However, the log file can be difficult to read because there are so many complex operations occuring in rapid succession. Follow these steps to simplify operations, which helps you pinpoint the root cause: Turn off multiple compilation threads The JIT compiler can use more than one compilation thread, which typically improves startup performance. The number of threads is determined by the VM, depending on the system configuration. You can turn off multiple threads by using the -XcompilationThreads option, which simplifies the output in the verbose log. Lower the invocation threshold When the invocation count is set to 0 , the JIT compiles every method and your application will fail immediately when the method causing the problem is reached. You can alter the threshold with the count suboption. Turn off inlining Inlining is a complex process that generates larger and more complex code. To eliminate errors caused by these operations, use the disableInlining suboption. Decrease the optimization levels Use the optlevel suboption to gradually decrease the compiler optimization levels to see whether you can isolate the level at which your problem occurs. More information about these suboptions and the command line syntax is covered in -Xjit . Understanding JIT verbose logs At first glance, a JIT verbose log can look very complex. To help you understand the log we'll look at JIT compiler operations when you run the java -version command. The following option turns on verbose logging and directs output to a log file called vlogfile : java -Xjit:verbose,vlog=vlogfile -version The first section of the log includes lines that start with #INFO: , which provides information about the environment that the JIT is operating in. You can determine the version of the JIT and VM that you are using, and the type and number of processors that the JIT has access to. #INFO: _______________________________________ #INFO: Version Information: #INFO: JIT Level - e24e8aa9 #INFO: JVM Level - 20180315_120 #INFO: GC Level - e24e8aa9 #INFO: #INFO: Processor Information: #INFO: Platform Info:X86 Intel P6 #INFO: Vendor:GenuineIntel #INFO: numProc=1 #INFO: #INFO: _______________________________________ #INFO: AOT #INFO: options specified: #INFO: samplingFrequency=2 #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: _______________________________________ #INFO: JIT #INFO: options specified: #INFO: verbose,vlog=vlogfile #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: StartTime: Apr 23 09:49:10 2018 #INFO: Free Physical Memory: 996188 KB #INFO: CPU entitlement = 100.00 This section also shows the AOT and JIT options that are in force. The last few lines detail the start time of the compilation activity, how much free physical memory is available to the process, and the CPU entitlement. The information section is followed by a sequence of lines that describe the methods that are being compiled, as well as other events significant to the operation of the JIT compiler. Here is a typical line from the verbose log: + (cold) sun/reflect/Reflection.getCallerClass()Ljava/lang/Class; @ 00007FCACED1303C-00007FCACED13182 OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=00000000011E7EA8 bcsz=2 JNI compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% In this example: The method compiled is sun/reflect/Reflection.getCallerClass()Ljava/lang/Class . The + indicates that this method is successfully compiled. Failed compilations are marked by a ! . (cold) tells you the optimization level that was applied. Other examples might be (warm) or (scorching) . 00007FCACED1303C-00007FCACED13182 is the code range where the compiled code was generated. Q values provide information about the state of the compilation queues when the compilation occurred. bcsz shows the bytecode size. In this case it is small because this is a native method, so the JIT is simply providing an accelerated JNI transition into the native getCallerClass method. Each line of output represents a method that is compiled. The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the values time and mem into each line, as shown in the following example: + (cold) java/lang/System.getEncoding(I)Ljava/lang/String; @ 00007F29183A921C-00007F29183A936D OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=0000000000F13A70 bcsz=3 JNI time=311us mem=[region=704 system=16384]KB compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% time=311us reflects the amount of time taken to do the compilation. mem=[region=704 system=16384]KB reflects the amount of memory that was allocated during the compilation. The following example can be used to create verbose output that includes lines to show when compilation for a method starts and ends, and any methods that are inlined during the compilation. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version Note: The suboptions count and -XcompilationThreads1 are included only to simplify the output for this example and are not recommended for production. The following section is taken from the output and describes the compilation and inlining of one method java/lang/String.equals : (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB #INL: 7 methods inlined into 4dce72bd java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40 #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The first line is included as a result of setting the compileStart suboption and shows the start of the warm method compilation: (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB Similarly, the last line shows the successful compilation of this method, as denoted by the + : + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The lines inbetween that start with #INL describe the inlining operations that took place. A total of 7 methods were inlined into java/lang/String.equals : The first three methods ( #0 , #1 , #2 ) are inlined into the top level method, denoted as #-1 : #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z The next four methods ( #3 , #4 , #5 , #6 ) are inlined into the method denoted by #2 . #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C Here's how to interpret the line for #INL: #0: : The method is inlined into 4dce72bd , where 4dce72bd is an internal pointer that corresponds to this method (in this case, java/lang/String.equals(Ljava/lang/Object;)Z ). The value @22 at the end of the pointer is a bytecode index, which describes the bytecode index of the call that is being inlined. The call is 81670d20 bcsz=37 java/lang/String.lengthInternal()I , which shows the corresponding internal pointer, bytecode size (bcsz) and the name of the method that got inlined. Going through the #INL output line by line then: java/lang/String.lengthInternal()I got inlined into its caller 4dce72bd at bytecode index @22. java/lang/String.lengthInternal()I also got inlined into its caller 4dce72bd at bytecode index @28. java/lang/String.regionMatchesInternal(...) got inlined at call reference 4dce72bd at bytecode index @104. Then 4 distinct calls to java/lang/String.charAtInternal(I[C)C were also inlined into java/lang/String.regionMatchesInternal(...) : #3 at bytecode index @121 of regionMatchesInternal #4 at bytecode index @131 of regionMatchesInternal #5 at bytecode index @156 of regionMatchesInternal #6 at bytecode index @166 of regionMatchesInternal These were all the calls that the inliner decided to inline into the method being compiled. There is some additional output that describes calls to methods that weren't inlined: #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z While the output does not specifically say why these methods were not inlined, the relatively larger bytecode size ( bcsz=233 ) probably prevented the first method from being inlined. It's possible that, at a higher optimization level than cold, this deduplicateStrings method may get inlined. The coldCalled label on the last two lines, however, indicate that these calls are located in a part of the method that has not ever been executed, so the JIT decided that inlining those last two methods will probably increase compile time without much promise that it will improve performance. By reading the log in this way you can reconstruct the tree of inlines that are taking place as the compilation proceeds. You can see which methods are being inlined and which methods are not being inlined. See also Diagnosing a JIT or AOT problem","title":"JIT Compiler"},{"location":"jit/#the-jit-compiler","text":"The Just-In-Time (JIT) compiler is a key component of the OpenJ9 VM that improves the performance of Java applications by compiling platform-neutral Java bytecode into native machine code at run time. Without the JIT, the VM has to interpret the bytecodes itself - a process that requires extra CPU and memory. The JIT compiler doesn't compile every method that gets called because thousands of methods can be called at startup. Instead, OpenJ9 records the number of times a method is called. When the count reaches a pre-defined invocation threshold , JIT compilation is triggered. Once a method has been compiled by the JIT, the VM can call the compiled method rather than interpreting it.","title":"The JIT compiler"},{"location":"jit/#optimization-levels","text":"The JIT compiler can compile a method at different optimization levels: cold , warm , hot , very hot (with profiling) , or scorching . The hotter the optimization level, the better the expected performance, but the higher the cost in terms of CPU and memory. cold is used during startup processing for large applications where the goal is to achieve the best compiled code speed for as many methods as possible. warm is the workhorse; after start-up, most methods are compiled when they reach the invocation threshold. For higher optimization levels, the VM uses a sampling thread to identify methods that continue to take a lot of time. Methods that consume more than 1% are compiled at hot. Methods that consume more than 12.5% are scheduled for a scorching compilation. However, before that happens the methods are compiled at very hot with profiling to collect detailed profile data that is used by the scorching compilation. The higher optimization levels use special techniques such as escape analysis and partial redundancy elimination, or loop through certain optimization sequences more times. Although these techniques use more CPU and memory, the improved performance that is delivered by the optimizations can make the tradeoff worthwhile.","title":"Optimization levels"},{"location":"jit/#troubleshooting","text":"The JIT compiler is enabled by default to optimize performance. However, if you experience a problem running your application, temporarily turning off the JIT will tell you whether the JIT is at fault. Because JIT starts at the same time as the VM, you can only modify JIT behavior at startup. There are a number of ways to disable the JIT: Specify -Djava.compiler=NONE on the command line. Specify -Xint on the command line, which turns off the JIT and AOT compiler. To eliminate problems with one or the other you can turn these compilers off selectively with the -Xnojit and -Xnoaot options. Call the java.lang.Compiler API programmatically. Note: java.lang.Compiler is deprecated for removal in Java SE 9. If turning off the JIT solves your problem, you can investigate JIT operations in more detail by using a number of options to control behavior. Turning on verbose logging with the verbose suboption causes the JIT to record all compiler operations. However, the log file can be difficult to read because there are so many complex operations occuring in rapid succession. Follow these steps to simplify operations, which helps you pinpoint the root cause: Turn off multiple compilation threads The JIT compiler can use more than one compilation thread, which typically improves startup performance. The number of threads is determined by the VM, depending on the system configuration. You can turn off multiple threads by using the -XcompilationThreads option, which simplifies the output in the verbose log. Lower the invocation threshold When the invocation count is set to 0 , the JIT compiles every method and your application will fail immediately when the method causing the problem is reached. You can alter the threshold with the count suboption. Turn off inlining Inlining is a complex process that generates larger and more complex code. To eliminate errors caused by these operations, use the disableInlining suboption. Decrease the optimization levels Use the optlevel suboption to gradually decrease the compiler optimization levels to see whether you can isolate the level at which your problem occurs. More information about these suboptions and the command line syntax is covered in -Xjit .","title":"Troubleshooting"},{"location":"jit/#understanding-jit-verbose-logs","text":"At first glance, a JIT verbose log can look very complex. To help you understand the log we'll look at JIT compiler operations when you run the java -version command. The following option turns on verbose logging and directs output to a log file called vlogfile : java -Xjit:verbose,vlog=vlogfile -version The first section of the log includes lines that start with #INFO: , which provides information about the environment that the JIT is operating in. You can determine the version of the JIT and VM that you are using, and the type and number of processors that the JIT has access to. #INFO: _______________________________________ #INFO: Version Information: #INFO: JIT Level - e24e8aa9 #INFO: JVM Level - 20180315_120 #INFO: GC Level - e24e8aa9 #INFO: #INFO: Processor Information: #INFO: Platform Info:X86 Intel P6 #INFO: Vendor:GenuineIntel #INFO: numProc=1 #INFO: #INFO: _______________________________________ #INFO: AOT #INFO: options specified: #INFO: samplingFrequency=2 #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: _______________________________________ #INFO: JIT #INFO: options specified: #INFO: verbose,vlog=vlogfile #INFO: #INFO: options in effect: #INFO: verbose=1 #INFO: vlog=vlogfile #INFO: compressedRefs shiftAmount=0 #INFO: compressedRefs isLowMemHeap=1 #INFO: StartTime: Apr 23 09:49:10 2018 #INFO: Free Physical Memory: 996188 KB #INFO: CPU entitlement = 100.00 This section also shows the AOT and JIT options that are in force. The last few lines detail the start time of the compilation activity, how much free physical memory is available to the process, and the CPU entitlement. The information section is followed by a sequence of lines that describe the methods that are being compiled, as well as other events significant to the operation of the JIT compiler. Here is a typical line from the verbose log: + (cold) sun/reflect/Reflection.getCallerClass()Ljava/lang/Class; @ 00007FCACED1303C-00007FCACED13182 OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=00000000011E7EA8 bcsz=2 JNI compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% In this example: The method compiled is sun/reflect/Reflection.getCallerClass()Ljava/lang/Class . The + indicates that this method is successfully compiled. Failed compilations are marked by a ! . (cold) tells you the optimization level that was applied. Other examples might be (warm) or (scorching) . 00007FCACED1303C-00007FCACED13182 is the code range where the compiled code was generated. Q values provide information about the state of the compilation queues when the compilation occurred. bcsz shows the bytecode size. In this case it is small because this is a native method, so the JIT is simply providing an accelerated JNI transition into the native getCallerClass method. Each line of output represents a method that is compiled. The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the values time and mem into each line, as shown in the following example: + (cold) java/lang/System.getEncoding(I)Ljava/lang/String; @ 00007F29183A921C-00007F29183A936D OrdinaryMethod - Q_SZ=0 Q_SZI=0 QW=1 j9m=0000000000F13A70 bcsz=3 JNI time=311us mem=[region=704 system=16384]KB compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% time=311us reflects the amount of time taken to do the compilation. mem=[region=704 system=16384]KB reflects the amount of memory that was allocated during the compilation. The following example can be used to create verbose output that includes lines to show when compilation for a method starts and ends, and any methods that are inlined during the compilation. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version Note: The suboptions count and -XcompilationThreads1 are included only to simplify the output for this example and are not recommended for production. The following section is taken from the output and describes the compilation and inlining of one method java/lang/String.equals : (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB #INL: 7 methods inlined into 4dce72bd java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40 #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The first line is included as a result of setting the compileStart suboption and shows the start of the warm method compilation: (warm) Compiling java/lang/String.equals(Ljava/lang/Object;)Z OrdinaryMethod j9m=0000000001300B30 t=90 compThread=0 memLimit=262144 KB freePhysicalMemory=969 MB Similarly, the last line shows the successful compilation of this method, as denoted by the + : + (warm) java/lang/String.equals(Ljava/lang/Object;)Z @ 00007F53190A3E40-00007F53190A40D0 OrdinaryMethod - Q_SZ=277 Q_SZI=277 QW=1667 j9m=0000000001300B30 bcsz=127 GCR compThread=0 CpuLoad=2%(2%avg) JvmCpu=0% The lines inbetween that start with #INL describe the inlining operations that took place. A total of 7 methods were inlined into java/lang/String.equals : The first three methods ( #0 , #1 , #2 ) are inlined into the top level method, denoted as #-1 : #INL: #0: 4dce72bd #-1 inlined 4dce72bd@22 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #1: 4dce72bd #-1 inlined 4dce72bd@28 -> 81670d20 bcsz=37 java/lang/String.lengthInternal()I #INL: #2: 4dce72bd #-1 inlined 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z The next four methods ( #3 , #4 , #5 , #6 ) are inlined into the method denoted by #2 . #INL: #3: 4dce72bd #2 inlined bf62dcaf@121 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #4: 4dce72bd #2 inlined bf62dcaf@131 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #5: 4dce72bd #2 inlined bf62dcaf@156 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C #INL: #6: 4dce72bd #2 inlined bf62dcaf@166 -> bbb5af92 bcsz=39 java/lang/String.charAtInternal(I[C)C Here's how to interpret the line for #INL: #0: : The method is inlined into 4dce72bd , where 4dce72bd is an internal pointer that corresponds to this method (in this case, java/lang/String.equals(Ljava/lang/Object;)Z ). The value @22 at the end of the pointer is a bytecode index, which describes the bytecode index of the call that is being inlined. The call is 81670d20 bcsz=37 java/lang/String.lengthInternal()I , which shows the corresponding internal pointer, bytecode size (bcsz) and the name of the method that got inlined. Going through the #INL output line by line then: java/lang/String.lengthInternal()I got inlined into its caller 4dce72bd at bytecode index @22. java/lang/String.lengthInternal()I also got inlined into its caller 4dce72bd at bytecode index @28. java/lang/String.regionMatchesInternal(...) got inlined at call reference 4dce72bd at bytecode index @104. Then 4 distinct calls to java/lang/String.charAtInternal(I[C)C were also inlined into java/lang/String.regionMatchesInternal(...) : #3 at bytecode index @121 of regionMatchesInternal #4 at bytecode index @131 of regionMatchesInternal #5 at bytecode index @156 of regionMatchesInternal #6 at bytecode index @166 of regionMatchesInternal These were all the calls that the inliner decided to inline into the method being compiled. There is some additional output that describes calls to methods that weren't inlined: #INL: 4dce72bd called 4dce72bd@120 -> f734b49c bcsz=233 java/lang/String.deduplicateStrings(Ljava/lang/String;Ljava/lang/String;)V #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z #INL: 4dce72bd coldCalled 4dce72bd@104 -> bf62dcaf bcsz=182 java/lang/String.regionMatchesInternal(Ljava/lang/String;Ljava/lang/String;[C[CIII)Z While the output does not specifically say why these methods were not inlined, the relatively larger bytecode size ( bcsz=233 ) probably prevented the first method from being inlined. It's possible that, at a higher optimization level than cold, this deduplicateStrings method may get inlined. The coldCalled label on the last two lines, however, indicate that these calls are located in a part of the method that has not ever been executed, so the JIT decided that inlining those last two methods will probably increase compile time without much promise that it will improve performance. By reading the log in this way you can reconstruct the tree of inlines that are taking place as the compilation proceeds. You can see which methods are being inlined and which methods are not being inlined.","title":"Understanding JIT verbose logs"},{"location":"jit/#see-also","text":"Diagnosing a JIT or AOT problem","title":"See also"},{"location":"jitserver/","text":"JITServer technology (technical preview) Linux\u00ae on x86-64 only JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java\u2122 application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and even performance of Java applications. We recommend trying this technology if the following criteria are met: Your Java application is required to compile many methods using JIT in a relatively short time. The application is running in an enviroment with limited CPU or memory, which can worsen interference from the JIT compiler. The network latency between JITServer and client VM is relatively low. For more details about JITServer technology, its pros and cons, and when best to use it, see the blog Free your JVM from the JIT with JITServer Technology . Using JITServer technology JITServer technology is not enabled by default: you must explicitly invoke it. Running OpenJ9 without either of the following options launches it as a regular VM with embedded JIT compilation. Launch OpenJ9 in client mode Use the following command-line option to launch OpenJ9 in client mode. In this mode, the VM sends compilation requests to an available JITServer. The client operates as a regular VM with its own JIT compiler if a server is not available. -XX:+UseJITServer Launch OpenJ9 in server mode Use the following command to start a JITServer process that listens for incoming compilation requests: jitserver Configuring JITServer technology You can use the following command line options to further configure the JITServer and the client VM processes: Setting Effect Default -XX:JITServerPort=<port> Specifies the port the server listens to for compilation requests 38400 -XX:JITServerAddress=<address> Specifies the name or IP of the server localhost -XX:JITServerTimeout=<timeout> Specifies a timeout value in milliseconds for socket operations ( Note 1 ) Note 1: The timeout default is 30000 ms for the JITServer process, and 2000 ms when OpenJ9 is launched as a client VM. You might need to increase the latter value if network latency is large. Security issues You can encrypt network communication between the client VM and JITServer by using OpenSSL 1.0.x or 1.1.x. To enable encryption, specify the private key ( <key>.pem ) and the certificate ( <cert>.pem ) at the server: -XX:JITServerSSLKey=<key>.pem -XX:JITServerSSLCert=<cert>.pem and use the certificate at the client: -XX:JITServerSSLRootCerts=<cert>.pem For more details and further discussion about security considerations, see Free your JVM from the JIT with JITServer Technology . Building an SDK with JITServer technology If you want to build a JDK with JITServer technology for yourself, see Appendix A of Free your JVM from the JIT with JITServer Technology . See also The JIT compiler","title":"JITServer (tech. preview)"},{"location":"jitserver/#jitserver-technology-technical-preview","text":"Linux\u00ae on x86-64 only JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java\u2122 application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and even performance of Java applications. We recommend trying this technology if the following criteria are met: Your Java application is required to compile many methods using JIT in a relatively short time. The application is running in an enviroment with limited CPU or memory, which can worsen interference from the JIT compiler. The network latency between JITServer and client VM is relatively low. For more details about JITServer technology, its pros and cons, and when best to use it, see the blog Free your JVM from the JIT with JITServer Technology .","title":"JITServer technology (technical preview)"},{"location":"jitserver/#using-jitserver-technology","text":"JITServer technology is not enabled by default: you must explicitly invoke it. Running OpenJ9 without either of the following options launches it as a regular VM with embedded JIT compilation.","title":"Using JITServer technology"},{"location":"jitserver/#launch-openj9-in-client-mode","text":"Use the following command-line option to launch OpenJ9 in client mode. In this mode, the VM sends compilation requests to an available JITServer. The client operates as a regular VM with its own JIT compiler if a server is not available. -XX:+UseJITServer","title":"Launch OpenJ9 in client mode"},{"location":"jitserver/#launch-openj9-in-server-mode","text":"Use the following command to start a JITServer process that listens for incoming compilation requests: jitserver","title":"Launch OpenJ9 in server mode"},{"location":"jitserver/#configuring-jitserver-technology","text":"You can use the following command line options to further configure the JITServer and the client VM processes: Setting Effect Default -XX:JITServerPort=<port> Specifies the port the server listens to for compilation requests 38400 -XX:JITServerAddress=<address> Specifies the name or IP of the server localhost -XX:JITServerTimeout=<timeout> Specifies a timeout value in milliseconds for socket operations ( Note 1 ) Note 1: The timeout default is 30000 ms for the JITServer process, and 2000 ms when OpenJ9 is launched as a client VM. You might need to increase the latter value if network latency is large.","title":"Configuring JITServer technology"},{"location":"jitserver/#security-issues","text":"You can encrypt network communication between the client VM and JITServer by using OpenSSL 1.0.x or 1.1.x. To enable encryption, specify the private key ( <key>.pem ) and the certificate ( <cert>.pem ) at the server: -XX:JITServerSSLKey=<key>.pem -XX:JITServerSSLCert=<cert>.pem and use the certificate at the client: -XX:JITServerSSLRootCerts=<cert>.pem For more details and further discussion about security considerations, see Free your JVM from the JIT with JITServer Technology .","title":"Security issues"},{"location":"jitserver/#building-an-sdk-with-jitserver-technology","text":"If you want to build a JDK with JITServer technology for yourself, see Appendix A of Free your JVM from the JIT with JITServer Technology .","title":"Building an SDK with JITServer technology"},{"location":"jitserver/#see-also","text":"The JIT compiler","title":"See also"},{"location":"legal/","text":"Legal License agreement, notices, copyright, and trademark information for the user documentation. License agreement See License Notices See Notices Copyright information Eclipse OpenJ9 documentation is subject to the following copyright: Copyright (c) 2017, 2020 IBM Corp. Trademarks IBM, the IBM logo, and ibm.com are trademarks or registered trademarks of International Business Machines Corp., registered in many jurisdictions worldwide. Other product and service names might be trademarks of IBM or other companies. A current list of IBM trademarks is available on the Web at \"Copyright and trademark information\" here . Java and all Java-based trademarks and logos are trademarks or registered trademarks of Oracle and/or its affiliates. Linux is a registered trademark of Linus Torvalds in the United States, other countries, or both. Microsoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or both.","title":"Legal"},{"location":"legal/#legal","text":"License agreement, notices, copyright, and trademark information for the user documentation.","title":"Legal"},{"location":"legal/#license-agreement","text":"See License","title":"License agreement"},{"location":"legal/#notices","text":"See Notices","title":"Notices"},{"location":"legal/#copyright-information","text":"Eclipse OpenJ9 documentation is subject to the following copyright: Copyright (c) 2017, 2020 IBM Corp.","title":"Copyright information"},{"location":"legal/#trademarks","text":"IBM, the IBM logo, and ibm.com are trademarks or registered trademarks of International Business Machines Corp., registered in many jurisdictions worldwide. Other product and service names might be trademarks of IBM or other companies. A current list of IBM trademarks is available on the Web at \"Copyright and trademark information\" here . Java and all Java-based trademarks and logos are trademarks or registered trademarks of Oracle and/or its affiliates. Linux is a registered trademark of Linus Torvalds in the United States, other countries, or both. Microsoft and Windows are trademarks of Microsoft Corporation in the United States, other countries, or both.","title":"Trademarks"},{"location":"messages_intro/","text":"OpenJ9 VM messages Messages are issued by the OpenJ9 virtual machine (VM) in response to certain conditions. Understanding what the messages mean can help you with problem determination. Message categories There are three main categories of message: Information Information messages provide information about VM processing. For example, a dump information message is typically issued when a dump agent requests a dump. Warning Warning messages are issued by the VM to indicate conditions that might need user intervention. Error Error messages are issued by the VM when normal processing cannot proceed, because of unexpected conditions. OpenJ9 virtual machine messages have the following format: JVM<type><number><code> where: JVM is a standard prefix. <type> refers to the VM subcomponent that issued the message. <number> is a unique numerical number. <code> is one of the following codes: I - Information message W - Warning message E - Error message These messages can help you with problem determination. By default, all error and some information messages are routed to the system log and also written to stderr or stdout . The specific information messages are JVMDUMP039I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the VM. To route additional message types to the system log, or turn off message logging to the system log, use the -Xlog option. The -Xlog option does not affect messages written to the standard error stream (stderr). See OpenJ9 command-line options . Finding logged messages Logged messages can be found in different locations, according to platform. Finding AIX messages On AIX\u00ae, messages are logged by the syslog daemon ( /usr/sbin/syslogd ). Logged messages are written to the syslog file that is configured in /etc/syslog.conf . If the syslog daemon is not running, logged messages are lost. You can redirect messages from the syslog daemon to the AIX error log facility by performing the following configuration steps: Set up a redirect in the file syslog.conf so that syslog messages are sent to the error log, by adding the following line: user.debug errlog If syslogd is already running, reload the updated configuration by running the following command: refresh -s syslogd The updated configuration is used each time syslogd starts. 4. Use the AIX errpt command or the System Management Interface Tool (SMIT) to read the messages sent to the error log. For more information about AIX logging, see: Error-logging overview . Finding Linux messages On Linux\u00ae, messages are logged by the syslog daemon. To find where messages are logged, check the syslog configuration file. Finding macOS messages On macOS\u00ae, messages are logged by the syslog daemon. However, on Sierra and High Sierra, syslog does not work. If /var/log/system.log is not available, Console.app can be used instead. Finding Windows messages On Windows\u2122, messages are logged in the application events section of the event viewer. Finding z/OS messages On z/OS\u00ae, messages are sent to the operator console. To see the messages, go from the ispf panel to the sdsf panel, then open the log panel. Obtaining detailed message descriptions Detailed message information is available to help with problem diagnosis. Understanding the warning or error message issued by the VM can help you diagnose problems. All warning and error messages issued by the VM are listed by type in the messages guide: IBM\u00ae VM messages . The messages, error codes, and exit codes in this guide apply to multiple versions of the VM. Note: If the VM fills all available memory, the message number might be produced without a description for the error that caused the problem. Look for the message number in the relevant section of the J9 VM Messages guide to see the message description and the additional information provided.","title":"OpenJ9 messages"},{"location":"messages_intro/#openj9-vm-messages","text":"Messages are issued by the OpenJ9 virtual machine (VM) in response to certain conditions. Understanding what the messages mean can help you with problem determination.","title":"OpenJ9 VM messages"},{"location":"messages_intro/#message-categories","text":"There are three main categories of message: Information Information messages provide information about VM processing. For example, a dump information message is typically issued when a dump agent requests a dump. Warning Warning messages are issued by the VM to indicate conditions that might need user intervention. Error Error messages are issued by the VM when normal processing cannot proceed, because of unexpected conditions. OpenJ9 virtual machine messages have the following format: JVM<type><number><code> where: JVM is a standard prefix. <type> refers to the VM subcomponent that issued the message. <number> is a unique numerical number. <code> is one of the following codes: I - Information message W - Warning message E - Error message These messages can help you with problem determination. By default, all error and some information messages are routed to the system log and also written to stderr or stdout . The specific information messages are JVMDUMP039I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the VM. To route additional message types to the system log, or turn off message logging to the system log, use the -Xlog option. The -Xlog option does not affect messages written to the standard error stream (stderr). See OpenJ9 command-line options .","title":"Message categories"},{"location":"messages_intro/#finding-logged-messages","text":"Logged messages can be found in different locations, according to platform.","title":"Finding logged messages"},{"location":"messages_intro/#finding-aix-messages","text":"On AIX\u00ae, messages are logged by the syslog daemon ( /usr/sbin/syslogd ). Logged messages are written to the syslog file that is configured in /etc/syslog.conf . If the syslog daemon is not running, logged messages are lost. You can redirect messages from the syslog daemon to the AIX error log facility by performing the following configuration steps: Set up a redirect in the file syslog.conf so that syslog messages are sent to the error log, by adding the following line: user.debug errlog If syslogd is already running, reload the updated configuration by running the following command: refresh -s syslogd The updated configuration is used each time syslogd starts. 4. Use the AIX errpt command or the System Management Interface Tool (SMIT) to read the messages sent to the error log. For more information about AIX logging, see: Error-logging overview .","title":"Finding AIX messages"},{"location":"messages_intro/#finding-linux-messages","text":"On Linux\u00ae, messages are logged by the syslog daemon. To find where messages are logged, check the syslog configuration file.","title":"Finding Linux messages"},{"location":"messages_intro/#finding-macos-messages","text":"On macOS\u00ae, messages are logged by the syslog daemon. However, on Sierra and High Sierra, syslog does not work. If /var/log/system.log is not available, Console.app can be used instead.","title":"Finding macOS messages"},{"location":"messages_intro/#finding-windows-messages","text":"On Windows\u2122, messages are logged in the application events section of the event viewer.","title":"Finding Windows messages"},{"location":"messages_intro/#finding-zos-messages","text":"On z/OS\u00ae, messages are sent to the operator console. To see the messages, go from the ispf panel to the sdsf panel, then open the log panel.","title":"Finding z/OS messages"},{"location":"messages_intro/#obtaining-detailed-message-descriptions","text":"Detailed message information is available to help with problem diagnosis. Understanding the warning or error message issued by the VM can help you diagnose problems. All warning and error messages issued by the VM are listed by type in the messages guide: IBM\u00ae VM messages . The messages, error codes, and exit codes in this guide apply to multiple versions of the VM. Note: If the VM fills all available memory, the message number might be produced without a description for the error that caused the problem. Look for the message number in the relevant section of the J9 VM Messages guide to see the message description and the additional information provided.","title":"Obtaining detailed message descriptions"},{"location":"openj9_defaults/","text":"Default settings for the OpenJ9 VM The following tables provide a quick reference to the default settings for the VM when it is first installed. The last 2 columns show whether the default setting can be changed by a command-line parameter or an environment variable. Note that if both are set, the command-line parameter always takes precedence. VM setting Default Command line Env. variable Javadump Enabled yes yes Heapdump Disabled yes yes System dump Enabled yes yes Snap traces Enabled yes yes JIT dump Enabled yes yes Verbose output Disabled yes no Compressed references (See Note 1 ) yes yes Boot classpath search Disabled yes no JNI checks Disabled yes no Remote debugging Disabled yes no Strict conformance checks Disabled yes no Quickstart Disabled yes no Remote debug info server Disabled yes no Reduced signaling Disabled yes no Signal handler chaining Enabled yes no Classpath Not set yes yes Class data sharing Disabled yes no Accessibility support Enabled no yes JIT compiler Enabled yes yes AOT compiler (See Note 2 ) Enabled yes no JIT debug options Disabled yes no Java2D max size of fonts with algorithmic bold 14 point no yes Java2D use rendered bitmaps in scalable fonts Enabled no yes Java2D freetype font rasterizing Enabled no yes Java2D use AWT fonts Disabled no yes Notes: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: Enabled for -Xmx values \u2264 57 GB, otherwise disabled. On z/OS\u00ae: Enabled for -Xmx values \u2264 25 GB, otherwise disabled. With APAR OA49416 , enabled for -Xmx values \u2264 57 GB. AOT is not used by the VM unless shared classes are also enabled. VM setting AIX Linux macOS Windows z/OS Command line Env. variable Default locale None None None N/A None no yes Time to wait before starting plug-in N/A Zero N/A N/A N/A no yes Temporary directory /tmp /tmp /tmp c:\\temp /tmp no yes Plug-in redirection None None None N/A None no yes IM switching Disabled Disabled Disabled N/A Disabled no yes IM modifiers Disabled Disabled Disabled N/A Disabled no yes Thread model N/A N/A N/A N/A Native no yes Initial stack size for Java Threads (32/64-bit) . Use -Xiss<size> 2 KB 2 KB 2 KB 2 KB 2 KB yes no Maximum stack size for Java Threads (32-bit) . Use -Xss<size> 320 KB 320 KB N/A 320 KB 320 KB yes no Maximum stack size for Java Threads (64-bit) . Use -Xss<size> 1024 KB 1024 KB 1024 KB 1024 KB 1024 KB yes no Stack size for OS Threads (32-bit) . Use -Xmso<size> 256 KB 256 KB N/A 32 KB 256 KB yes no Stack size for OS Threads (64-bit) . Use -Xmso<size> 256 KB 256 KB 256 KB 256 KB 1 MB yes no Initial heap size. Use -Xms<size> 8 MB 8 MB 8 MB 8 MB 8 MB yes no Maximum Java heap size. Use -Xmx<size> See Notes See Notes See Notes See Notes See Notes yes no Page size for the Java object heap and code cache (For restrictions, see the -Xlp:codecache and -Xlp:objectheap options). Operating system default Architecture: x86: 2MB, IBM Z\u00ae: 1MB, Other architectures: Operating system default 4 KB Operating system default 1M pageable yes no Notes: The default value of -Xmx : The value is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. If you have set the -XX:+OriginalJDK8HeapSizeCompatibilityMode option for compatibility with earlier releases, the value is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Available memory is defined as being the smallest of two values: The real or physical memory or the RLIMIT_AS value.","title":"Default settings"},{"location":"openj9_defaults/#default-settings-for-the-openj9-vm","text":"The following tables provide a quick reference to the default settings for the VM when it is first installed. The last 2 columns show whether the default setting can be changed by a command-line parameter or an environment variable. Note that if both are set, the command-line parameter always takes precedence. VM setting Default Command line Env. variable Javadump Enabled yes yes Heapdump Disabled yes yes System dump Enabled yes yes Snap traces Enabled yes yes JIT dump Enabled yes yes Verbose output Disabled yes no Compressed references (See Note 1 ) yes yes Boot classpath search Disabled yes no JNI checks Disabled yes no Remote debugging Disabled yes no Strict conformance checks Disabled yes no Quickstart Disabled yes no Remote debug info server Disabled yes no Reduced signaling Disabled yes no Signal handler chaining Enabled yes no Classpath Not set yes yes Class data sharing Disabled yes no Accessibility support Enabled no yes JIT compiler Enabled yes yes AOT compiler (See Note 2 ) Enabled yes no JIT debug options Disabled yes no Java2D max size of fonts with algorithmic bold 14 point no yes Java2D use rendered bitmaps in scalable fonts Enabled no yes Java2D freetype font rasterizing Enabled no yes Java2D use AWT fonts Disabled no yes Notes: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: Enabled for -Xmx values \u2264 57 GB, otherwise disabled. On z/OS\u00ae: Enabled for -Xmx values \u2264 25 GB, otherwise disabled. With APAR OA49416 , enabled for -Xmx values \u2264 57 GB. AOT is not used by the VM unless shared classes are also enabled. VM setting AIX Linux macOS Windows z/OS Command line Env. variable Default locale None None None N/A None no yes Time to wait before starting plug-in N/A Zero N/A N/A N/A no yes Temporary directory /tmp /tmp /tmp c:\\temp /tmp no yes Plug-in redirection None None None N/A None no yes IM switching Disabled Disabled Disabled N/A Disabled no yes IM modifiers Disabled Disabled Disabled N/A Disabled no yes Thread model N/A N/A N/A N/A Native no yes Initial stack size for Java Threads (32/64-bit) . Use -Xiss<size> 2 KB 2 KB 2 KB 2 KB 2 KB yes no Maximum stack size for Java Threads (32-bit) . Use -Xss<size> 320 KB 320 KB N/A 320 KB 320 KB yes no Maximum stack size for Java Threads (64-bit) . Use -Xss<size> 1024 KB 1024 KB 1024 KB 1024 KB 1024 KB yes no Stack size for OS Threads (32-bit) . Use -Xmso<size> 256 KB 256 KB N/A 32 KB 256 KB yes no Stack size for OS Threads (64-bit) . Use -Xmso<size> 256 KB 256 KB 256 KB 256 KB 1 MB yes no Initial heap size. Use -Xms<size> 8 MB 8 MB 8 MB 8 MB 8 MB yes no Maximum Java heap size. Use -Xmx<size> See Notes See Notes See Notes See Notes See Notes yes no Page size for the Java object heap and code cache (For restrictions, see the -Xlp:codecache and -Xlp:objectheap options). Operating system default Architecture: x86: 2MB, IBM Z\u00ae: 1MB, Other architectures: Operating system default 4 KB Operating system default 1M pageable yes no Notes: The default value of -Xmx : The value is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. If you have set the -XX:+OriginalJDK8HeapSizeCompatibilityMode option for compatibility with earlier releases, the value is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Available memory is defined as being the smallest of two values: The real or physical memory or the RLIMIT_AS value.","title":"Default settings for the OpenJ9 VM"},{"location":"openj9_directories/","text":"Directory conventions The following tables provide a quick reference to the OpenJ9 VM directory location on different Java\u2122 versions and different platform architectures. Some pages refer to the VM directory location as <vm_dir> . Operating system Java 8 Java 11 and later AIX\u00ae <install_dir>/jre/lib/ppc[64]/default <install_dir>/ Linux\u00ae <install_dir>/jre/lib/<arch>/default <install_dir>/ macOS\u00ae <install_dir>/jre/lib/default <install_dir>/ Windows\u2122 <install_dir>\\jre\\bin\\default <install_dir>\\ z/OS\u00ae <install_dir>/jre/lib/s390[x]/default <install_dir>/ Where: <install_dir> is your JDK installation directory. <arch> depends on the architecture your Linux distribution is running on. See the following table for possible values: Architecture Value of <arch> x86 32-bit i386 x86 64-bit x86-64 IBM POWER\u00ae 32-bit (Big Endian) ppc IBM POWER 64-bit (Big Endian) ppc64 IBM POWER 64-bit (Little Endian) ppc64le IBM Z\u00ae 31-bit s390 IBM Z 64-bit s390x","title":"Directory conventions"},{"location":"openj9_directories/#directory-conventions","text":"The following tables provide a quick reference to the OpenJ9 VM directory location on different Java\u2122 versions and different platform architectures. Some pages refer to the VM directory location as <vm_dir> . Operating system Java 8 Java 11 and later AIX\u00ae <install_dir>/jre/lib/ppc[64]/default <install_dir>/ Linux\u00ae <install_dir>/jre/lib/<arch>/default <install_dir>/ macOS\u00ae <install_dir>/jre/lib/default <install_dir>/ Windows\u2122 <install_dir>\\jre\\bin\\default <install_dir>\\ z/OS\u00ae <install_dir>/jre/lib/s390[x]/default <install_dir>/ Where: <install_dir> is your JDK installation directory. <arch> depends on the architecture your Linux distribution is running on. See the following table for possible values: Architecture Value of <arch> x86 32-bit i386 x86 64-bit x86-64 IBM POWER\u00ae 32-bit (Big Endian) ppc IBM POWER 64-bit (Big Endian) ppc64 IBM POWER 64-bit (Little Endian) ppc64le IBM Z\u00ae 31-bit s390 IBM Z 64-bit s390x","title":"Directory conventions"},{"location":"openj9_newuser/","text":"New to OpenJ9? The Eclipse OpenJ9 virtual machine (VM) implements the Java Virtual Machine Specification . Most Java applications should run on an OpenJDK that contains the OpenJ9 VM without changing anything. However, because it is an independent implementation there are some differences compared to the HotSpot VM, which is the default OpenJDK VM and is also included in an Oracle JDK. Command-line options Although OpenJ9 implements its own command-line interface, many HotSpot options are recognized and accepted by the VM for compatibility. Any -XX: options that are not recognized by the VM are ignored by default, which prevents an application failing to start. You can turn off this behavior with the -XX:-IgnoreUnrecognizedXXColonOptions option. For a list of compatible options, equivalent options, and options that need to be set for compatibility, see Switching to OpenJ9 . Garbage collection policies Eclipse OpenJ9 has a number of GC policies designed around different types of applications and workloads. By default, OpenJ9 uses the Generational Concurrent ( gencon ) GC policy, which is best suited for transactional applications that have many short-lived objects. The policy aims to minimize GC pause times without compromising throughput. If you are using Java 8, the gencon policy is similar to the ParallelGC policy, which is the default HotSpot policy. If you are using Java 11, the OpenJ9 balanced ( balanced ) policy is most similar to the default HotSpot policy. If you have a different type of workload, you might want to select a different GC policy. For a summary of available policies, see Garbage collection . For more information about the differences between OpenJ9 GC policies and how to choose the right one for your application, see Eclipse OpenJ9: Garbage collection tradeoffs and tuning with OpenJ9 . To start your application with a different policy, use the -Xgcpolicy option on the command line. Operational tooling If you are a Java application developer or you are responsible for managing large server or desktop deployments of a Java runtime environment, you probably use a number of tools for monitoring, management, and troubleshooting. Because OpenJ9 is an independent implementation, it has evolved with its own approach for these areas and, in some cases, its own unique tools. In other cases, tools have been added for compatibility with the reference implementation, but these tools might differ in behavior from equivalent tools in HotSpot. For a list of these tools, see Switching to OpenJ9 in the Tools section. Dumps, logs, and trace files OpenJ9 contains extensive trace and debugging capabilities to help identify, isolate, and solve run time problems. Dump files: Various types of dump are produced by default in response to certain events and can also be triggered for a whole range of events by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. Dumps include Java dumps , heap dumps , system dumps , JIT dumps, stack dumps, and snap dumps (tracepoint data). For more information, see the -Xdump option. Verbose log files: Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination, including class data sharing , garbage collection , and the JIT compiler . Trace files: The OpenJ9 implementation contains extensive tracepoints used to log information and exceptional conditions, with minimal impact on performance. Some tracepoints are enabled by default; others can be enabled on demand. For more information, see the -Xtrace option for tracing Java applications and the VM, and the -Xtgc option for tracing garbage collection. If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you probably make use of the monitoring and diagnostic tools that are provided with the VM. OpenJ9 has implemented a different approach to providing similar data; rather than running a number of different tools to obtain a different piece of information, the Java dump file provides a comprehensive set of information in one place. You can find the following information in an OpenJ9 Java dump: The system the VM is running on and the resources available. The Java execution environment, including the options set from the command line. The native memory used by the VM, broken down by VM component. Memory usage in the VM for the object heap and internal VM structures, such as the JIT code cache. Lock operations that protect shared resources during runtime. Java threads, native threads, and stack traces. Hook interfaces, for performance analysis. Details about the shared classes cache, if used. Detailed information about classloaders, together with a list of libraries and classes that are loaded. For more information, see Java dump . Tools OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Memory Analyzer: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . Interactive Diagnostic Data Explorer (IDDE): A GUI alternative to the OpenJ9 dump viewer , which can examine the contents of an OpenJ9 system dump. For more information, read the IDDE documentation . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center. Most of the other tools provided with HotSpot are not officially supported, but equivalent functionality is available in OpenJ9 through command-line options, dump agents, and AttachAPI. Interfaces OpenJ9 provides the following interfaces, which can be used for monitoring and diagnostic purposes: JVMTI : OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information about this interface, see Java Virtual Machine Tool Interface . DTFJ interface : The Diagnostic Tool Framework for Java (DTFJ) API allows custom applications to be written that can access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer Toolkit (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information about DTFJ, see Diagnostic Tool Framework for Java . java.lang.management API: OpenJ9 provides MXBean additions and extensions to this standard API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you might make use of certain com.sun.management interfaces. Although OpenJ9 implements some of these interfaces, a few are specific to the HotSpot VM. The following table indicates alternative classes or mechanisms that you can use for equivalent function in OpenJ9: HotSpot-specific classes Alternatives for OpenJ9 HotSpotDiagnosticMXBean OpenJ9DiagnosticsMXBean (for heap dumps) MissionControl Use Health Center MissionControlMXBean Use Health Center ThreadMXBean JvmCpuMonitorMXBean (for thread time) VMOption OpenJ9 Java dump (option -Xdump:java ) DiagnosticCommandMBean None Note: OpenJ9 implements the following com.sun.management interfaces: GarbageCollectorMXBean , GarbageCollectionNotificationInfo , GcInfo , OperatingSystemMXBean , UnixOperatingSystemMXBean . Other differences This topic describes the differences between the HotSpot VM and the Eclipse OpenJ9 VM. Therefore, if you are currently using an OpenJDK with the default HotSpot VM and you want to switch to using an OpenJDK with the OpenJ9 VM, these are the only differences you might be concerned about. If however, you are using an Oracle JDK, you might want to learn about differences between other components that make up an Oracle JDK or an OpenJDK from the AdoptOpenJDK community. For more information, read the Migration guide .","title":"New to OpenJ9?"},{"location":"openj9_newuser/#new-to-openj9","text":"The Eclipse OpenJ9 virtual machine (VM) implements the Java Virtual Machine Specification . Most Java applications should run on an OpenJDK that contains the OpenJ9 VM without changing anything. However, because it is an independent implementation there are some differences compared to the HotSpot VM, which is the default OpenJDK VM and is also included in an Oracle JDK.","title":"New to OpenJ9?"},{"location":"openj9_newuser/#command-line-options","text":"Although OpenJ9 implements its own command-line interface, many HotSpot options are recognized and accepted by the VM for compatibility. Any -XX: options that are not recognized by the VM are ignored by default, which prevents an application failing to start. You can turn off this behavior with the -XX:-IgnoreUnrecognizedXXColonOptions option. For a list of compatible options, equivalent options, and options that need to be set for compatibility, see Switching to OpenJ9 .","title":"Command-line options"},{"location":"openj9_newuser/#garbage-collection-policies","text":"Eclipse OpenJ9 has a number of GC policies designed around different types of applications and workloads. By default, OpenJ9 uses the Generational Concurrent ( gencon ) GC policy, which is best suited for transactional applications that have many short-lived objects. The policy aims to minimize GC pause times without compromising throughput. If you are using Java 8, the gencon policy is similar to the ParallelGC policy, which is the default HotSpot policy. If you are using Java 11, the OpenJ9 balanced ( balanced ) policy is most similar to the default HotSpot policy. If you have a different type of workload, you might want to select a different GC policy. For a summary of available policies, see Garbage collection . For more information about the differences between OpenJ9 GC policies and how to choose the right one for your application, see Eclipse OpenJ9: Garbage collection tradeoffs and tuning with OpenJ9 . To start your application with a different policy, use the -Xgcpolicy option on the command line.","title":"Garbage collection policies"},{"location":"openj9_newuser/#operational-tooling","text":"If you are a Java application developer or you are responsible for managing large server or desktop deployments of a Java runtime environment, you probably use a number of tools for monitoring, management, and troubleshooting. Because OpenJ9 is an independent implementation, it has evolved with its own approach for these areas and, in some cases, its own unique tools. In other cases, tools have been added for compatibility with the reference implementation, but these tools might differ in behavior from equivalent tools in HotSpot. For a list of these tools, see Switching to OpenJ9 in the Tools section.","title":"Operational tooling"},{"location":"openj9_newuser/#dumps-logs-and-trace-files","text":"OpenJ9 contains extensive trace and debugging capabilities to help identify, isolate, and solve run time problems. Dump files: Various types of dump are produced by default in response to certain events and can also be triggered for a whole range of events by using the com.ibm.jvm.Dump API or by specifying -Xdump options on the command line. Dumps include Java dumps , heap dumps , system dumps , JIT dumps, stack dumps, and snap dumps (tracepoint data). For more information, see the -Xdump option. Verbose log files: Some components of OpenJ9 can also produce verbose output or log files to assist with problem determination, including class data sharing , garbage collection , and the JIT compiler . Trace files: The OpenJ9 implementation contains extensive tracepoints used to log information and exceptional conditions, with minimal impact on performance. Some tracepoints are enabled by default; others can be enabled on demand. For more information, see the -Xtrace option for tracing Java applications and the VM, and the -Xtgc option for tracing garbage collection. If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you probably make use of the monitoring and diagnostic tools that are provided with the VM. OpenJ9 has implemented a different approach to providing similar data; rather than running a number of different tools to obtain a different piece of information, the Java dump file provides a comprehensive set of information in one place. You can find the following information in an OpenJ9 Java dump: The system the VM is running on and the resources available. The Java execution environment, including the options set from the command line. The native memory used by the VM, broken down by VM component. Memory usage in the VM for the object heap and internal VM structures, such as the JIT code cache. Lock operations that protect shared resources during runtime. Java threads, native threads, and stack traces. Hook interfaces, for performance analysis. Details about the shared classes cache, if used. Detailed information about classloaders, together with a list of libraries and classes that are loaded. For more information, see Java dump .","title":"Dumps, logs, and trace files"},{"location":"openj9_newuser/#tools","text":"OpenJ9 provides support for a number of monitoring and diagnostic tools that can be found in the Eclipse marketplace . Each tool provides a graphical user interface to help you visualize data and, in some cases, can provide tuning or debugging recommendations. Health Center: Provides real-time monitoring of running applications with minimal overhead over the network. You can monitor a whole range of operations including, class loading, CPU usage, GC heap and pause times, I/O activity, lock contention, method trace, native memory usage, profiling, and live threads. For more information, read the Health Center documentation . Garbage Collection Memory Vizualizer (GCMV): Plots GC and native memory data over time. You can view and save data as a report, raw log, tabulated data, or in graphical format. The tool helps to diagnose problems such as memory leaks with data presented in various visual formats for analysis. Tuning recommendations are also provided. For more information, read the GCMV documentation . Memory Analyzer: Examines the Java object heap to help find memory leaks or reduce memory consumption. Support is available for OpenJ9 via the DTFJ interface (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java). More information about Eclipse MAT can be found on the project website page . Interactive Diagnostic Data Explorer (IDDE): A GUI alternative to the OpenJ9 dump viewer , which can examine the contents of an OpenJ9 system dump. For more information, read the IDDE documentation . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, the Java VisualVM utility is functionally similar to Health Center. Most of the other tools provided with HotSpot are not officially supported, but equivalent functionality is available in OpenJ9 through command-line options, dump agents, and AttachAPI.","title":"Tools"},{"location":"openj9_newuser/#interfaces","text":"OpenJ9 provides the following interfaces, which can be used for monitoring and diagnostic purposes: JVMTI : OpenJ9 supports the Java Virtual Machine Tool Interface (JVMTI) and provides extensions that allow JVMTI tools to obtain diagnostic information or trigger diagnostic operations in the VM. For more information about this interface, see Java Virtual Machine Tool Interface . DTFJ interface : The Diagnostic Tool Framework for Java (DTFJ) API allows custom applications to be written that can access a wide range of information in a system dump or a Java dump. DTFJ can be used with the Eclipse Memory Analyzer Toolkit (MAT) to examine the Java object heap for memory leaks and to reduce memory consumption. For more information about DTFJ, see Diagnostic Tool Framework for Java . java.lang.management API: OpenJ9 provides MXBean additions and extensions to this standard API, which enables you to use tools such as JConsole to monitor and manage your Java applications. For more information, see Language management interface . If you are familiar with using HotSpot as part of an Oracle JDK or OpenJDK, you might make use of certain com.sun.management interfaces. Although OpenJ9 implements some of these interfaces, a few are specific to the HotSpot VM. The following table indicates alternative classes or mechanisms that you can use for equivalent function in OpenJ9: HotSpot-specific classes Alternatives for OpenJ9 HotSpotDiagnosticMXBean OpenJ9DiagnosticsMXBean (for heap dumps) MissionControl Use Health Center MissionControlMXBean Use Health Center ThreadMXBean JvmCpuMonitorMXBean (for thread time) VMOption OpenJ9 Java dump (option -Xdump:java ) DiagnosticCommandMBean None Note: OpenJ9 implements the following com.sun.management interfaces: GarbageCollectorMXBean , GarbageCollectionNotificationInfo , GcInfo , OperatingSystemMXBean , UnixOperatingSystemMXBean .","title":"Interfaces"},{"location":"openj9_newuser/#other-differences","text":"This topic describes the differences between the HotSpot VM and the Eclipse OpenJ9 VM. Therefore, if you are currently using an OpenJDK with the default HotSpot VM and you want to switch to using an OpenJDK with the OpenJ9 VM, these are the only differences you might be concerned about. If however, you are using an Oracle JDK, you might want to learn about differences between other components that make up an Oracle JDK or an OpenJDK from the AdoptOpenJDK community. For more information, read the Migration guide .","title":"Other differences"},{"location":"openj9_releases/","text":"Overview New releases of OpenJ9 are set to coincide with critical patch updates and new versions of the Java\u2122 SE class libraries. To learn more about when these releases take place, and the OpenJ9 support lifecycle, see Supported environments . If you are interested in the content of future releases, plans are published in the Eclipse OpenJ9 project page . High level information about the features and changes in final releases of OpenJ9 can be found in the topics that follow.","title":"Overview"},{"location":"openj9_releases/#overview","text":"New releases of OpenJ9 are set to coincide with critical patch updates and new versions of the Java\u2122 SE class libraries. To learn more about when these releases take place, and the OpenJ9 support lifecycle, see Supported environments . If you are interested in the content of future releases, plans are published in the Eclipse OpenJ9 project page . High level information about the features and changes in final releases of OpenJ9 can be found in the topics that follow.","title":"Overview"},{"location":"openj9_signals/","text":"Signal handling Signals used by the OpenJ9 VM include the following types: Exceptions (Exc): Raised synchronously by the operating system whenever an unrecoverable condition occurs (not applicable on Windows systems). Errors (Err): Raised by the OpenJ9 VM when an unrecoverable condition occurs. Interrupts (Int): Raised asynchronously from outside a VM process to request a VM exit. Controls (Con): Other signals that are used by the VM for control purposes. For exceptions and errors, if the VM cannot handle the condition and recover, dumps are produced and a controlled shut down sequence takes place. Interrupts also cause the VM to enter a controlled shut down sequence, but without generating dumps. The shutdown sequence is equivalent to calling System.exit() , which results in the following steps: The VM calls the equivalent application signal handler. The VM calls any hooks installed by the application (unexpected shutdown hooks for exceptions or errors, shutdown or exit hooks for interrupts). The VM does any final clean up. Control signals are used for internal control purposes and do not cause the VM to end. The VM takes control of any signals for Java threads. For non-Java threads, the VM passes control to an application handler, if one is installed. If the application does not install a signal handler, or signal chaining is turned off, the signal is either ignored or the default action is taken. Signal chaining is controlled by the -Xsigchain / -Xnosigchain command-line option. The signals relevant to each platform are detailed in the sections that follow. When reading each table, a number supplied after the signal name is the standard numerical value for that signal. Note that certain signals on VM threads cause OpenJ9 to shutdown. An application signal handler should not attempt to recover from these signals unless it no longer requires the VM. Signals on Linux Signal Type Description Option to disable signal SIGBUS (7) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (34) Con Used by the VM for thread introspection - SIGRTMIN +1 (35) Con Used by the VM for Runtime Instrumentation (Linux for IBM Z systems only) - SIGRTMAX -2 (62) Con Used by the java.net class library code - SIGCHLD (17) Con Used by the java.lang.Process implementation - Notes: The use of SIGRTMIN is configurable with the -Xdump:suspendwith=<num> option. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signals on macOS Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (30) Con Used by the VM for thread introspection - SIGIO (23) Con Used by the java.net class library code - Note: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signals on Windows Signal Type Description Option to disable signal SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGBREAK Con A break signal from a terminal. By default, this triggers a Java dump -Xrs Notes: The following mechanisms are used by OpenJ9 for signal handling: structured exception handling (32-bit VM only) AddVectoredExceptionHandler() API (64-bit JVM only) SetConsoleCtrlHandler() applicable All mechanisms can be disabled by using the -Xrs option. However, only structured exception handling and the use of the AddVectoredExceptionHandler() API can be disabled by using the -Xrs:sync option. The option -Xnosigchain , which turns off signal handler chaining, is ignored on Windows systems. Signals on z/OS Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (3) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (24) Con Quit signal from a terminal, triggers a Java dump by default -Xrs SIGTRAP (26) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (16) Con Used by the java.net class library code - Notes: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signals on AIX Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (3) Con Triggers a Java dump by default -Xrs No Name (40) Con Used by the VM for control purposes -Xrs SIGRECONFIG (58) Con Reserved to detect changes to resources (CPUs, processing capacity, or physical memory) -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (50) Con Used by the VM for thread introspection - SIGRTMAX -1 (56) Con Used by the java.net class library code - SIGCHLD (20) Con Used by the java.lang.Process implementation - Notes: VM performance is affected if you install a signal handler for SIGTRAP (5) or SIGRECONFIG (58) because these signals are used for internal control purposes. If you want to generate floating point exceptions, use the following call in your code to generate a SIGFPE signal: fp_trap( P_TRAP_SYNC) . Although you can use the C compiler -qflttrap setting to generate SIGTRAP signals to trap floating point exceptions, this mechanism can affect the JIT compiler. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option. Signal chaining Signal chaining allows application code to interoperate with VM signal handling. By linking and loading a shared library, certain calls can be intercepted so that the application handlers do not replace the VM signal handlers. Instead, the application handlers are chained behind the VM handlers. If signals that are raised do not target the VM, the application handlers take over. Signals that can be chained include signal() , sigset() , and sigaction() . The following table shows the shared library that must be linked with the application that creates or embeds a VM, and the command line syntax to use with the compiler, where available: Operating system Shared library Method for linking Linux, macOS, and z/OS libjsig.so gcc -L$JAVA_HOME/bin -ljsig -L$JAVA_HOME/lib/j9vm -ljvm <java_application>.c Windows jsig.dll Link the DLL with the application that creates or embeds a VM AIX libjsig.so cc_r [-q64] <other_compile/link_parameter> -L<java_install_dir> -ljsig -L<java_install_dir>/lib/j9vm -ljvm <java_application>.c Note: On Linux, macOS, and z/OS systems, you can use the LD_PRELOAD environment variable as an alternative method to the command line for linking the shared library as shown in the following list: bash and ksh shells: export LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application> csh shell: setenv LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application> See also -Xrs -Xsigcatch -Xsigchain -Xsignal (z/OS only)","title":"Signal handling"},{"location":"openj9_signals/#signal-handling","text":"Signals used by the OpenJ9 VM include the following types: Exceptions (Exc): Raised synchronously by the operating system whenever an unrecoverable condition occurs (not applicable on Windows systems). Errors (Err): Raised by the OpenJ9 VM when an unrecoverable condition occurs. Interrupts (Int): Raised asynchronously from outside a VM process to request a VM exit. Controls (Con): Other signals that are used by the VM for control purposes. For exceptions and errors, if the VM cannot handle the condition and recover, dumps are produced and a controlled shut down sequence takes place. Interrupts also cause the VM to enter a controlled shut down sequence, but without generating dumps. The shutdown sequence is equivalent to calling System.exit() , which results in the following steps: The VM calls the equivalent application signal handler. The VM calls any hooks installed by the application (unexpected shutdown hooks for exceptions or errors, shutdown or exit hooks for interrupts). The VM does any final clean up. Control signals are used for internal control purposes and do not cause the VM to end. The VM takes control of any signals for Java threads. For non-Java threads, the VM passes control to an application handler, if one is installed. If the application does not install a signal handler, or signal chaining is turned off, the signal is either ignored or the default action is taken. Signal chaining is controlled by the -Xsigchain / -Xnosigchain command-line option. The signals relevant to each platform are detailed in the sections that follow. When reading each table, a number supplied after the signal name is the standard numerical value for that signal. Note that certain signals on VM threads cause OpenJ9 to shutdown. An application signal handler should not attempt to recover from these signals unless it no longer requires the VM.","title":"Signal handling"},{"location":"openj9_signals/#signals-on-linux","text":"Signal Type Description Option to disable signal SIGBUS (7) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (34) Con Used by the VM for thread introspection - SIGRTMIN +1 (35) Con Used by the VM for Runtime Instrumentation (Linux for IBM Z systems only) - SIGRTMAX -2 (62) Con Used by the java.net class library code - SIGCHLD (17) Con Used by the java.lang.Process implementation - Notes: The use of SIGRTMIN is configurable with the -Xdump:suspendwith=<num> option. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on Linux"},{"location":"openj9_signals/#signals-on-macos","text":"Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (3) Con Quit signal from a terminal, which triggers a Java dump by default -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (30) Con Used by the VM for thread introspection - SIGIO (23) Con Used by the java.net class library code - Note: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on macOS"},{"location":"openj9_signals/#signals-on-windows","text":"Signal Type Description Option to disable signal SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGBREAK Con A break signal from a terminal. By default, this triggers a Java dump -Xrs Notes: The following mechanisms are used by OpenJ9 for signal handling: structured exception handling (32-bit VM only) AddVectoredExceptionHandler() API (64-bit JVM only) SetConsoleCtrlHandler() applicable All mechanisms can be disabled by using the -Xrs option. However, only structured exception handling and the use of the AddVectoredExceptionHandler() API can be disabled by using the -Xrs:sync option. The option -Xnosigchain , which turns off signal handler chaining, is ignored on Windows systems.","title":"Signals on Windows"},{"location":"openj9_signals/#signals-on-zos","text":"Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (3) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (24) Con Quit signal from a terminal, triggers a Java dump by default -Xrs SIGTRAP (26) Con Used by the JIT -Xrs or -Xrs:sync SIGCHLD (20) Con Used by the java.lang.Process implementation - SIGUSR1 (16) Con Used by the java.net class library code - Notes: The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on z/OS"},{"location":"openj9_signals/#signals-on-aix","text":"Signal Type Description Option to disable signal SIGBUS (10) Exc Incorrect memory access (data misalignment) -Xrs or -Xrs:sync SIGSEV (11) Exc Incorrect memory access (write to inaccessible area) -Xrs or -Xrs:sync SIGILL (4) Exc Illegal instruction (attempt to call unknown machine instruction)) -Xrs or -Xrs:sync SIGFPE (8) Exc Floating point exception (divide by zero) -Xrs or -Xrs:sync SIGABRT (6) Err Abnormal termination, raised by the VM when a VM fault is detected -Xrs or -Xrs:sync SIGINT (2) Int Interactive attention (CTRL-C), VM exits normally -Xrs SIGTERM (15) Int Termination request, VM exits normally -Xrs SIGHUP (1) Int Hang up, VM exits normally -Xrs SIGQUIT (3) Con Triggers a Java dump by default -Xrs No Name (40) Con Used by the VM for control purposes -Xrs SIGRECONFIG (58) Con Reserved to detect changes to resources (CPUs, processing capacity, or physical memory) -Xrs SIGTRAP (5) Con Used by the JIT -Xrs or -Xrs:sync SIGRTMIN (50) Con Used by the VM for thread introspection - SIGRTMAX -1 (56) Con Used by the java.net class library code - SIGCHLD (20) Con Used by the java.lang.Process implementation - Notes: VM performance is affected if you install a signal handler for SIGTRAP (5) or SIGRECONFIG (58) because these signals are used for internal control purposes. If you want to generate floating point exceptions, use the following call in your code to generate a SIGFPE signal: fp_trap( P_TRAP_SYNC) . Although you can use the C compiler -qflttrap setting to generate SIGTRAP signals to trap floating point exceptions, this mechanism can affect the JIT compiler. The handling of SIGABRT is configurable with the -XX[+|-]HandleSIGABRT option.","title":"Signals on AIX"},{"location":"openj9_signals/#signal-chaining","text":"Signal chaining allows application code to interoperate with VM signal handling. By linking and loading a shared library, certain calls can be intercepted so that the application handlers do not replace the VM signal handlers. Instead, the application handlers are chained behind the VM handlers. If signals that are raised do not target the VM, the application handlers take over. Signals that can be chained include signal() , sigset() , and sigaction() . The following table shows the shared library that must be linked with the application that creates or embeds a VM, and the command line syntax to use with the compiler, where available: Operating system Shared library Method for linking Linux, macOS, and z/OS libjsig.so gcc -L$JAVA_HOME/bin -ljsig -L$JAVA_HOME/lib/j9vm -ljvm <java_application>.c Windows jsig.dll Link the DLL with the application that creates or embeds a VM AIX libjsig.so cc_r [-q64] <other_compile/link_parameter> -L<java_install_dir> -ljsig -L<java_install_dir>/lib/j9vm -ljvm <java_application>.c Note: On Linux, macOS, and z/OS systems, you can use the LD_PRELOAD environment variable as an alternative method to the command line for linking the shared library as shown in the following list: bash and ksh shells: export LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application> csh shell: setenv LD_PRELOAD=$JAVA_HOME/lib/libjsig.so; <java_application>","title":"Signal chaining"},{"location":"openj9_signals/#see-also","text":"-Xrs -Xsigcatch -Xsigchain -Xsignal (z/OS only)","title":"See also"},{"location":"openj9_support/","text":"Supported environments The Eclipse OpenJ9 project source code can be built against multiple JDK levels starting with JDK8, so the question of support has a more complicated answer than at OpenJDK. Our community is committed to supporting JDK levels as long as they are supported at the OpenJDK open source project with a significant user base. Currently, Eclipse OpenJ9 produces a new release every quarter that can build against all JDK levels currently supported by the OpenJDK community. We are committed to accepting problem reports when using Eclipse OpenJ9 against a supported OpenJDK level, with fixes being delivered in each release of Eclipse OpenJ9. In order to track the OpenJDK 6 month release cadence, OpenJ9 also produces two releases a year that support only a single JDK level. These releases will occur in March and September with the intention of supporting only the corresponding new OpenJDK feature release (ie: 11, 13, ...). The following table summarizes which JDK levels are expected to be supported by which Eclipse OpenJ9 releases, along with projected release dates. All future dates and support expectations are predictions that might change depending on how the OpenJDK and OpenJ9 projects evolve over time. To keep this table concise, some rows and columns will be removed over time. Eclipse OpenJ9 releases OpenJ9 release Release date JDK8 (LTS) JDK11 (LTS) JDK14 JDK15 v 0.19.0 March 2020 No No Yes (*2) v 0.20.0 April 2020 Yes Yes Yes v 0.21.0 July 2020 Yes Yes Yes v 0.22.0 September 2020 (*1) No No No Yes (*2) v 0.23.0 October 2020 (*1) Yes Yes No Yes v 0.24.0 January 2021 (*1) Yes Yes No Yes Notes: (*1): These OpenJ9 releases are expected, in line with our support statement. (*2): These OpenJ9 releases are the feature releases that support only the new OpenJDK release. For any issues or limitations of an Eclipse OpenJ9 release, read the release notes . Platform support The Eclipse OpenJ9 project is open to supporting any hardware/operating system platforms provided that we have community members available to maintain them. For practical reasons the Eclipse OpenJ9 JVM does not currently run on every platform. OpenJDK 8 Important: If you obtain pre-built binaries from AdoptOpenJDK.net , platform support might vary, depending on their build environment. Check the AdoptOpenJDK Platform support matrix . OpenJDK 8 binaries are supported on the minimum operating system levels shown in the following tables: Linux\u00ae x32 x64 ppc64le Z31 Z64 CentOS 6.9 Y Y N N N CentOS 7.4 Y Y Y N N Red Hat Enterprise Linux (RHEL) 6.9 Y Y N Y Y RHEL 7.4 Y Y Y Y Y SUSE Linux Enterprise Server (SLES) 12 Y Y Y Y Y Ubuntu 16.04 Y Y Y N Y Ubuntu 18.04 Y Y Y N Y Note: Not all of these distributions are tested, but Linux distributions that have a minimum glibc version 2.12 are expected to function without problems. Windows\u00ae x32 x64 Windows 10 Y Y Windows Server 2012 R2 Y Y Windows Server 2016 Y Y Windows Server 2019 Y Y macOS\u00ae x64 OS X\u00ae 10.9.0+ Y AIX\u00ae ppc32 ppc64 AIX 7.1 TL4 Y Y AIX 7.2 Y Y When public support for an operating system version ends, OpenJ9 can no longer be supported on that level. OpenJDK 11 Important: If you obtain pre-built binaries from AdoptOpenJDK.net , platform support might vary, depending on their build environment. Check the AdoptOpenJDK Platform support matrix . OpenJDK 11 binaries are supported on the minimum operating system levels shown in the following tables: Linux ( Note 1 ) AArch64 ( Note 2 ) x64 ppc64le Z64 CentOS 6.9 N Y N N CentOS 7.4 Y Y Y N Red Hat Enterprise Linux (RHEL) 6.9 N Y N Y RHEL 7.4 Y Y Y Y SUSE Linux Enterprise Server (SLES) 12 N Y Y Y Ubuntu 16.04 Y Y Y Y Ubuntu 18.04 Y Y Y Y Notes: Not all of these distributions are tested, but Linux distributions that have a minimum glibc version 2.12 are expected to function without problems. Only limited support for the 64-bit ARM architecture is currently available. For a list of known issues, see the Release notes for the latest version of Eclipse OpenJ9. Windows x64 Windows 10 Y Windows Server 2012 R2 Y Windows Server 2016 Y Windows Server 2019 Y macOS x64 OS X 10.9.0+ Y AIX ppc64 AIX 7.1 TL4 Y AIX 7.2 Y When public support for an operating system version ends, OpenJ9 can no longer be supported on that level. OpenJDK 14 Important: If you obtain pre-built binaries from AdoptOpenJDK.net , platform support might vary, depending on their build environment. Check the AdoptOpenJDK Platform support matrix . OpenJDK 14 binaries are supported on the minimum operating system levels shown in the following tables: Linux x64 ppc64le Z64 CentOS 6.9 Y N N CentOS 7.4 Y Y N Red Hat Enterprise Linux (RHEL) 6.9 Y N Y RHEL 7.4 Y Y Y SUSE Linux Enterprise Server (SLES) 12 Y Y Y Ubuntu 16.04 Y Y Y Ubuntu 18.04 Y Y Y Note: Not all of these distributions are tested, but Linux distributions that have a minimum glibc version 2.12 are expected to function without problems. Windows x64 Windows 10 Y Windows Server 2012 R2 Y Windows Server 2016 Y Windows Server 2019 Y macOS x64 OS X 10.9.0+ Y AIX ppc64 AIX 7.1 TL4 Y AIX 7.2 Y Important: AIX OpenJ9 builds require the XL C++ Runtime . When public support for an operating system version ends, OpenJ9 can no longer be supported on that level. Build environments The project build and test OpenJDK with OpenJ9 on a number of platforms. The operating system and compiler levels for the build systems are shown in the following tables. OpenJDK 8 Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER\u00ae LE 64-bit Ubuntu 16.04 gcc 7.5 Linux on IBM Z\u00ae 64-bit RHEL 7.7 gcc 7.5 Windows x86 32-bit Windows Server 2012 R2 Microsoft Visual Studio 2010 SP1 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2010 SP1 macOS x86 64-bit OSX 10.11 xcode/clang 4.6.3 and 7.2.1 AIX POWER BE 64-bit AIX 7.1 TL04 xlc/C++ 13.1.3 OpenJDK 11 Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on ARM 64-bit CentOS 7 gcc 7.5 Linux on POWER LE 64-bit Ubuntu 16.04 gcc 7.5 Linux on IBM Z 64-bit RHEL 7.7 gcc 7.5 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 macOS x86 64-bit macOS 10.13.5 xcode/clang 9.4 AIX POWER BE 64-bit AIX 7.1 TL04 xlc/C++ 13.1.3 OpenJDK 14 Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER LE 64-bit Ubuntu 16.04 gcc 7.5 Linux on IBM Z 64-bit RHEL 7.7 gcc 7.5 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 macOS x86 64-bit macOS 10.13.5 xcode/clang 9.4 AIX POWER BE 64-bit AIX 7.1 TL04 xlc/C++ 16.1.0","title":"Supported environments"},{"location":"openj9_support/#supported-environments","text":"The Eclipse OpenJ9 project source code can be built against multiple JDK levels starting with JDK8, so the question of support has a more complicated answer than at OpenJDK. Our community is committed to supporting JDK levels as long as they are supported at the OpenJDK open source project with a significant user base. Currently, Eclipse OpenJ9 produces a new release every quarter that can build against all JDK levels currently supported by the OpenJDK community. We are committed to accepting problem reports when using Eclipse OpenJ9 against a supported OpenJDK level, with fixes being delivered in each release of Eclipse OpenJ9. In order to track the OpenJDK 6 month release cadence, OpenJ9 also produces two releases a year that support only a single JDK level. These releases will occur in March and September with the intention of supporting only the corresponding new OpenJDK feature release (ie: 11, 13, ...). The following table summarizes which JDK levels are expected to be supported by which Eclipse OpenJ9 releases, along with projected release dates. All future dates and support expectations are predictions that might change depending on how the OpenJDK and OpenJ9 projects evolve over time. To keep this table concise, some rows and columns will be removed over time.","title":"Supported environments"},{"location":"openj9_support/#eclipse-openj9-releases","text":"OpenJ9 release Release date JDK8 (LTS) JDK11 (LTS) JDK14 JDK15 v 0.19.0 March 2020 No No Yes (*2) v 0.20.0 April 2020 Yes Yes Yes v 0.21.0 July 2020 Yes Yes Yes v 0.22.0 September 2020 (*1) No No No Yes (*2) v 0.23.0 October 2020 (*1) Yes Yes No Yes v 0.24.0 January 2021 (*1) Yes Yes No Yes Notes: (*1): These OpenJ9 releases are expected, in line with our support statement. (*2): These OpenJ9 releases are the feature releases that support only the new OpenJDK release. For any issues or limitations of an Eclipse OpenJ9 release, read the release notes .","title":"Eclipse OpenJ9 releases"},{"location":"openj9_support/#platform-support","text":"The Eclipse OpenJ9 project is open to supporting any hardware/operating system platforms provided that we have community members available to maintain them. For practical reasons the Eclipse OpenJ9 JVM does not currently run on every platform.","title":"Platform support"},{"location":"openj9_support/#openjdk-8","text":"Important: If you obtain pre-built binaries from AdoptOpenJDK.net , platform support might vary, depending on their build environment. Check the AdoptOpenJDK Platform support matrix . OpenJDK 8 binaries are supported on the minimum operating system levels shown in the following tables: Linux\u00ae x32 x64 ppc64le Z31 Z64 CentOS 6.9 Y Y N N N CentOS 7.4 Y Y Y N N Red Hat Enterprise Linux (RHEL) 6.9 Y Y N Y Y RHEL 7.4 Y Y Y Y Y SUSE Linux Enterprise Server (SLES) 12 Y Y Y Y Y Ubuntu 16.04 Y Y Y N Y Ubuntu 18.04 Y Y Y N Y Note: Not all of these distributions are tested, but Linux distributions that have a minimum glibc version 2.12 are expected to function without problems. Windows\u00ae x32 x64 Windows 10 Y Y Windows Server 2012 R2 Y Y Windows Server 2016 Y Y Windows Server 2019 Y Y macOS\u00ae x64 OS X\u00ae 10.9.0+ Y AIX\u00ae ppc32 ppc64 AIX 7.1 TL4 Y Y AIX 7.2 Y Y When public support for an operating system version ends, OpenJ9 can no longer be supported on that level.","title":"OpenJDK 8"},{"location":"openj9_support/#openjdk-11","text":"Important: If you obtain pre-built binaries from AdoptOpenJDK.net , platform support might vary, depending on their build environment. Check the AdoptOpenJDK Platform support matrix . OpenJDK 11 binaries are supported on the minimum operating system levels shown in the following tables: Linux ( Note 1 ) AArch64 ( Note 2 ) x64 ppc64le Z64 CentOS 6.9 N Y N N CentOS 7.4 Y Y Y N Red Hat Enterprise Linux (RHEL) 6.9 N Y N Y RHEL 7.4 Y Y Y Y SUSE Linux Enterprise Server (SLES) 12 N Y Y Y Ubuntu 16.04 Y Y Y Y Ubuntu 18.04 Y Y Y Y Notes: Not all of these distributions are tested, but Linux distributions that have a minimum glibc version 2.12 are expected to function without problems. Only limited support for the 64-bit ARM architecture is currently available. For a list of known issues, see the Release notes for the latest version of Eclipse OpenJ9. Windows x64 Windows 10 Y Windows Server 2012 R2 Y Windows Server 2016 Y Windows Server 2019 Y macOS x64 OS X 10.9.0+ Y AIX ppc64 AIX 7.1 TL4 Y AIX 7.2 Y When public support for an operating system version ends, OpenJ9 can no longer be supported on that level.","title":"OpenJDK 11"},{"location":"openj9_support/#openjdk-14","text":"Important: If you obtain pre-built binaries from AdoptOpenJDK.net , platform support might vary, depending on their build environment. Check the AdoptOpenJDK Platform support matrix . OpenJDK 14 binaries are supported on the minimum operating system levels shown in the following tables: Linux x64 ppc64le Z64 CentOS 6.9 Y N N CentOS 7.4 Y Y N Red Hat Enterprise Linux (RHEL) 6.9 Y N Y RHEL 7.4 Y Y Y SUSE Linux Enterprise Server (SLES) 12 Y Y Y Ubuntu 16.04 Y Y Y Ubuntu 18.04 Y Y Y Note: Not all of these distributions are tested, but Linux distributions that have a minimum glibc version 2.12 are expected to function without problems. Windows x64 Windows 10 Y Windows Server 2012 R2 Y Windows Server 2016 Y Windows Server 2019 Y macOS x64 OS X 10.9.0+ Y AIX ppc64 AIX 7.1 TL4 Y AIX 7.2 Y Important: AIX OpenJ9 builds require the XL C++ Runtime . When public support for an operating system version ends, OpenJ9 can no longer be supported on that level.","title":"OpenJDK 14"},{"location":"openj9_support/#build-environments","text":"The project build and test OpenJDK with OpenJ9 on a number of platforms. The operating system and compiler levels for the build systems are shown in the following tables.","title":"Build environments"},{"location":"openj9_support/#openjdk-8_1","text":"Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER\u00ae LE 64-bit Ubuntu 16.04 gcc 7.5 Linux on IBM Z\u00ae 64-bit RHEL 7.7 gcc 7.5 Windows x86 32-bit Windows Server 2012 R2 Microsoft Visual Studio 2010 SP1 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2010 SP1 macOS x86 64-bit OSX 10.11 xcode/clang 4.6.3 and 7.2.1 AIX POWER BE 64-bit AIX 7.1 TL04 xlc/C++ 13.1.3","title":"OpenJDK 8"},{"location":"openj9_support/#openjdk-11_1","text":"Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on ARM 64-bit CentOS 7 gcc 7.5 Linux on POWER LE 64-bit Ubuntu 16.04 gcc 7.5 Linux on IBM Z 64-bit RHEL 7.7 gcc 7.5 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 macOS x86 64-bit macOS 10.13.5 xcode/clang 9.4 AIX POWER BE 64-bit AIX 7.1 TL04 xlc/C++ 13.1.3","title":"OpenJDK 11"},{"location":"openj9_support/#openjdk-14_1","text":"Platform Operating system Compiler Linux x86 64-bit CentOS 6.10 gcc 7.5 Linux on POWER LE 64-bit Ubuntu 16.04 gcc 7.5 Linux on IBM Z 64-bit RHEL 7.7 gcc 7.5 Windows x86 64-bit Windows Server 2012 R2 Microsoft Visual Studio 2017 macOS x86 64-bit macOS 10.13.5 xcode/clang 9.4 AIX POWER BE 64-bit AIX 7.1 TL04 xlc/C++ 16.1.0","title":"OpenJDK 14"},{"location":"shrc/","text":"Class data sharing Sharing class data between JVMs improves start up performance and reduces memory footprint. Start up performance is improved by placing classes that an application needs when initializing into a shared classes cache. The next time the application runs, it takes much less time to start because the classes are already available. When you enable class data sharing, AOT compilation is also enabled by default, which dynamically compiles certain methods into AOT code at runtime. By using these features in combination, startup performance can be improved even further because the cached AOT code can be used to quickly enable native code performance for subsequent runs of your application. When class data sharing is enabled, OpenJ9 automatically creates a memory mapped file that stores and shares the classes in memory. The shared classes cache is updated dynamically; When an application loads new classes, the JVM automatically stores them in the cache without any user intervention. Memory footprint is reduced by sharing common classes between applications that run in separate Java VMs. Enabling class data sharing Class data sharing is enabled by default for bootstrap classes only (the equivalent of specifying -Xshareclasses:bootClassesOnly,nonFatal,silent ), unless your application is running in a container. If you want to change the default behaviour, use the -Xshareclasses option on the command line. For example: You can change the name and location of the default shared classes cache. You can enable messages about the default shared classes cache by using the default command line option without the silent suboption: -Xshareclasses:bootClassesOnly,nonFatal . Note: If you have multiple VMs and you do not change the default shared classes behavior, the VMs will share a single default cache, assuming that the VMs are from a single Java installation. If the VMs are from different Java installations, the cache might be deleted and recreated; for more information, see the following section about best practices. You can treat the default cache like any other shared classes cache, for example you can print statistics for it, change the soft maximum limit size, or delete it. You can enable class data sharing for non-bootstrap classes as well, by using -Xshareclasses without the bootClassesOnly suboption. You can also disable all class data sharing by using the none suboption. Best practices for using -Xshareclasses The -Xshareclasses option is highly configurable, allowing you to specify where to create the cache, how much space to allocate for AOT code and more. You can also set the cache size by using the -Xscmx option. When shared classes is enabled, it is good practice to specify some of the cache behavior: Set an application-specific cache name ( -Xshareclasses:name=<name> ). If a cache with the specified name doesn't already exist, a new cache is created. This avoids sharing your application cache with a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note: You cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. Set a specific cache directory ( -Xshareclasses:cacheDir=<directory> ). Set a cache directory that is specific to your application, to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory. Your application will be unaffected by a user running java -Xshareclasses:destroyAll . In addition, if you have VMs from different Java installations, of the same Java release and installed by the same user, each VM checks whether the existing default shared cache in the cache directory is from the same Java installation as the VM. If not, the VM deletes that shared cache, then creates a new one. Specifying a different cache directory for each Java installation avoids this situation. Ensure that the cache directory permissions are set appropriately ( -Xshareclasses:cacheDirPerm ). It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. Set the -Xshareclasses:nonfatal option. This option means that your application can start even if there is a problem opening or creating the shared cache, in which case, the VM might be able to start without class data sharing. Support for custom class loaders Classes are shared by the bootstrap class loader internally in the OpenJ9 VM. If you are using a custom class loader, you can use the Java Helper API to find and store classes in the shared classes cache. For more information, see Using the Java Helper API . Cache utilities Several utilities are provided for managing active caches, which are invoked by specifying -Xshareclasses suboptions. These utilities control the following types of operations: Adjust the minimum and maximum amount of cache space reserved for AOT or JIT data. Adjust the soft maximum size of the cache. Create snapshots of a cache. Create a cache from a snapshot. Remove caches and cache snapshots. List all the compatible and incompatible caches and snapshots. For problem determination, invalidate and revalidate AOT methods that cause a failure in an application. For problem determination, provide information to analyze the contents of a shared classes cache. For more information, see -Xshareclasses . See also AOT compiler Class Sharing Diagnosing class data sharing problems","title":"Overview"},{"location":"shrc/#class-data-sharing","text":"Sharing class data between JVMs improves start up performance and reduces memory footprint. Start up performance is improved by placing classes that an application needs when initializing into a shared classes cache. The next time the application runs, it takes much less time to start because the classes are already available. When you enable class data sharing, AOT compilation is also enabled by default, which dynamically compiles certain methods into AOT code at runtime. By using these features in combination, startup performance can be improved even further because the cached AOT code can be used to quickly enable native code performance for subsequent runs of your application. When class data sharing is enabled, OpenJ9 automatically creates a memory mapped file that stores and shares the classes in memory. The shared classes cache is updated dynamically; When an application loads new classes, the JVM automatically stores them in the cache without any user intervention. Memory footprint is reduced by sharing common classes between applications that run in separate Java VMs.","title":"Class data sharing"},{"location":"shrc/#enabling-class-data-sharing","text":"Class data sharing is enabled by default for bootstrap classes only (the equivalent of specifying -Xshareclasses:bootClassesOnly,nonFatal,silent ), unless your application is running in a container. If you want to change the default behaviour, use the -Xshareclasses option on the command line. For example: You can change the name and location of the default shared classes cache. You can enable messages about the default shared classes cache by using the default command line option without the silent suboption: -Xshareclasses:bootClassesOnly,nonFatal . Note: If you have multiple VMs and you do not change the default shared classes behavior, the VMs will share a single default cache, assuming that the VMs are from a single Java installation. If the VMs are from different Java installations, the cache might be deleted and recreated; for more information, see the following section about best practices. You can treat the default cache like any other shared classes cache, for example you can print statistics for it, change the soft maximum limit size, or delete it. You can enable class data sharing for non-bootstrap classes as well, by using -Xshareclasses without the bootClassesOnly suboption. You can also disable all class data sharing by using the none suboption.","title":"Enabling class data sharing"},{"location":"shrc/#best-practices-for-using-xshareclasses","text":"The -Xshareclasses option is highly configurable, allowing you to specify where to create the cache, how much space to allocate for AOT code and more. You can also set the cache size by using the -Xscmx option. When shared classes is enabled, it is good practice to specify some of the cache behavior: Set an application-specific cache name ( -Xshareclasses:name=<name> ). If a cache with the specified name doesn't already exist, a new cache is created. This avoids sharing your application cache with a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note: You cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. Set a specific cache directory ( -Xshareclasses:cacheDir=<directory> ). Set a cache directory that is specific to your application, to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory. Your application will be unaffected by a user running java -Xshareclasses:destroyAll . In addition, if you have VMs from different Java installations, of the same Java release and installed by the same user, each VM checks whether the existing default shared cache in the cache directory is from the same Java installation as the VM. If not, the VM deletes that shared cache, then creates a new one. Specifying a different cache directory for each Java installation avoids this situation. Ensure that the cache directory permissions are set appropriately ( -Xshareclasses:cacheDirPerm ). It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. Set the -Xshareclasses:nonfatal option. This option means that your application can start even if there is a problem opening or creating the shared cache, in which case, the VM might be able to start without class data sharing.","title":"Best practices for using -Xshareclasses"},{"location":"shrc/#support-for-custom-class-loaders","text":"Classes are shared by the bootstrap class loader internally in the OpenJ9 VM. If you are using a custom class loader, you can use the Java Helper API to find and store classes in the shared classes cache. For more information, see Using the Java Helper API .","title":"Support for custom class loaders"},{"location":"shrc/#cache-utilities","text":"Several utilities are provided for managing active caches, which are invoked by specifying -Xshareclasses suboptions. These utilities control the following types of operations: Adjust the minimum and maximum amount of cache space reserved for AOT or JIT data. Adjust the soft maximum size of the cache. Create snapshots of a cache. Create a cache from a snapshot. Remove caches and cache snapshots. List all the compatible and incompatible caches and snapshots. For problem determination, invalidate and revalidate AOT methods that cause a failure in an application. For problem determination, provide information to analyze the contents of a shared classes cache. For more information, see -Xshareclasses .","title":"Cache utilities"},{"location":"shrc/#see-also","text":"AOT compiler Class Sharing Diagnosing class data sharing problems","title":"See also"},{"location":"shrc_diag_util/","text":"Shared classes cache diagnostic utilities These utilities display information about the contents of a shared classes cache. Run the utilities by specifying them as suboptions of -Xshareclasses . The utilities run on the default cache unless you specify a cache by adding the name=<cache_name> suboption. printAllStats -Xshareclasses:printAllStats -Xshareclasses:printAllStats,name=<cache_name> Displays the contents of the cache in chronological order. You can use this output to see the history of updates that were made to the cache. For layered caches, some information is shown for the top layer cache only, and some is shown for all layers combined. To see information for the top layer cache only, use printTopLayerStats=all . Each entry in the output starts with a VM ID, so you can see which VM wrote the associated data. Here are example entries for various types of cache data, with explanations: Class paths This example shows one class path with 4 entries: 1: 0x2234FA6C CLASSPATH /myVM/Apps/application1.jar /myVM/Apps/application2.jar /myVM/Apps/application3.jar /myVM/Apps/application4.jar 1 : the ID of the VM that wrote this data. 0x2234FA6C : the address where this data is stored. CLASSPATH : the type of data that was written. ROMClasses This example shows an entry for a single ROMClass : 1: 0x2234F7DC ROMCLASS: java/lang/Runnable at 0x213684A8 Index 1 in class path 0x2234FA6C 1 : the ID of the VM that wrote this data. 0x2234F7DC : the address where the metadata about the class is stored. ROMCLASS : the type of data that was stored. java/lang/Runnable : the name of the class. 0x213684A8 : the address where the class was stored. Index 1 : the index in the class path where the class was loaded from. 0x2234FA6C : the address of the class path against which this class is stored. Stale classes are marked with !STALE! . Any partition or modification context that is used when the class is stored is also shown. AOT methods This example shows an entry for one AOT-compiled method: 1: 0x540FBA6A AOT: loadConvert for ROMClass java/util/Properties at 0x52345174 1 : the ID of the VM that wrote this data. 0x540FBA6A : the address where the data is stored. AOT : the type of data that was stored. loadConvert : the method for which AOT-compiled code is stored. java/util/Properties : the class that contains the method. 0x52345174 : the address of the class that contains the method. Stale methods are marked with !STALE! . URLs and tokens A Token is a string that is passed to the Java\u2122 SharedClassHelper API. The output for these data types has the same format as that for class paths, but with a single entry. Zip entry caches This example shows 4 separate entries for zip entry caches: 1: 0x042FE07C ZIPCACHE: luni-kernel.jar_347075_1272300300_1 Address: 0x042FE094 Size: 7898 1: 0x042FA878 ZIPCACHE: luni.jar_598904_1272300546_1 Address: 0x042FA890 Size: 14195 1: 0x042F71F8 ZIPCACHE: nio.jar_405359_1272300546_1 Address: 0x042F7210 Size: 13808 1: 0x042F6D58 ZIPCACHE: annotation.jar_13417_1272300554_1 Address: 0x042F6D70 Size: 1023 1 : the ID of the VM that wrote this data. 0x042FE07C : the address where the metadata for the zip entry cache is stored. ZIPCACHE : the type of data that was stored. luni-kernel.jar_347075_1272300300_1 : the name of the zip entry cache. 0x042FE094 : the address where the data is stored. 7898 : the size of the stored data, in bytes. JIT data Information about JIT data is shown in JITPROFILE and JITHINT entries. For example: 1: 0xD6290368 JITPROFILE: getKeyHash Signature: ()I Address: 0xD55118C0 for ROMClass java/util/Hashtable$Entry at 0xD5511640. 2: 0xD6283848 JITHINT: loadClass Signature: (Ljava/lang/String;)Ljava/lang/Class; Address: 0xD5558F98 for ROMClass com/ibm/oti/vm/BootstrapClassLoader at 0xD5558AE0. Startup hints Information about startup hints is shown in STARTUP HINTS KEY and STARTUP HINTS DETAIL . For example: 1: 0x000000002237C6E0 STARTUP HINTS KEY: -Xoptionsfile=jre\\bin\\compressedrefs\\options.default -Xlockword:mode=default -Xjcl:jclse29 -Dcom.ibm.oti.vm.bootstrap.library.path=jre\\bin\\compressedrefs;jre\\bin -Djava.home=jre -Djava.ext.dirs=jre\\lib\\ext -Duser.dir=bin -Djava.class.path=. -Dsun.java.launcher=SUN_STANDARD Address: 0x000000002237C700 Size: 96 STARTUP HINTS DETAIL Flags: 1 DATA1: 1677721 DATA2: 5033165 printStats -Xshareclasses:printStats -Xshareclasses:printStats,name=<cache_name> -Xshareclasses:printStats=<data_type1>[+<data_type2>][...],name=<cache_name> Displays summary information about the cache. For layered caches, -Xshareclasses:printStats shows some information for the top layer cache, and summary information (bytes and counts only) for all layers combined. To see information for the top layer cache only, use printTopLayerStats . You can request more detail about items of a specific data type that are stored in the shared cache by using printStats=<data_type> . Use the plus symbol (+) to separate the data types. For example, use printStats=romclass+url,name=myCache to see information about ROMClass and URL items in all the layer caches of the cache called Cache1 . The valid data types are as follows (case insensitive): help (displays the list of valid data types) all (equivalent to printAllStats ) classpath url token romclass rommethod aot jitprofile jithint zipcache stale startuphint Example output for a traditional cache (no cache layers: cache layer = 0 ), with summary information only: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr Cache contains only classes with line numbers base address = 0x00007F60B807A000 end address = 0x00007F60B905E000 allocation pointer = 0x00007F60B81BE3A8 cache layer = 0 cache size = 16776608 softmx bytes = 16776608 free bytes = 12740572 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 30440 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 189358 Class debug area % used = 14% ROMClass bytes = 1328040 AOT bytes = 98404 JIT data bytes = 168 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 2 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 24% full Cache is accessible to current user = true Example output for a cache with 2 layers ( cache layer = 1 ), with summary information only: Current statistics for top layer of cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007FCAB2766000 end address = 0x00007FCAB374A000 allocation pointer = 0x00007FCAB2766000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% Cache is 8% full Cache is accessible to current user = true --------------------------------------------------------- Current statistics for all layers of cache \"Cache1\": ROMClass bytes = 1328040 AOT bytes = 128924 JIT data bytes = 812 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 20 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% The Cache created with section indicates the options that were used when the cache was created. BCI Enabled relates to the -Xshareclasses:enableBCI option (enabled by default) and Restrict Classpaths relates to the -Xshareclasses:restrictClasspaths option. Feature = cr indicates that the cache is a 64-bit compressed references cache, as described in Creating, populating, monitoring, and deleting a cache . Line number information for classes in the cache is then shown with one of the following messages: Cache contains only classes with line numbers : VM line number processing was enabled for all the classes that were stored in this shared cache (the -Xlinenumbers option is enabled by default). All classes in the cache contain line numbers if the original classes contained line number data. Cache contains only classes without line numbers : The -Xnolinenumbers option was used to disable VM line number processing for all the classes that were stored in this shared cache, so none of the classes contain line numbers. Cache contains classes with line numbers and classes without line numbers : VM line number processing was enabled for some classes and disabled for others (the -Xnolinenumbers option was specified when some of the classes were added to the cache). The following summary data is displayed: baseAddress and endAddress The boundary addresses of the shared memory area that contains the classes. allocation pointer The address where ROMClass data is currently being allocated in the cache. cache layer The layer number that the cache stats relate to. cache size and free bytes cache size shows the total size of the shared memory area in bytes, and free bytes shows the free bytes that remain. softmx bytes The soft maximum size for the cache. For more information, see -Xscmx . ROMClass bytes The number of bytes of class data in the cache. AOT bytes The number of bytes of AOT-compiled code in the cache. Reserved space for AOT bytes The number of bytes reserved for AOT-compiled code in the cache. Maximum space for AOT bytes The maximum number of bytes of AOT-compiled code that can be stored in the cache. JIT data bytes The number of bytes of JIT-related data stored in the cache. Reserved space for JIT data bytes The number of bytes reserved for JIT-related data in the cache. Maximum space for JIT data bytes The maximum number of bytes of JIT-related data that can be stored in the cache. Zip cache bytes The number of zip entry cache bytes stored in the cache. Startup hint bytes The number of bytes of data stored to describe startup hints. Data bytes The number of bytes of non-class data stored by the VM. Metadata bytes The number of bytes of data stored to describe the cached classes. Note: This field is available only in the top layer cache output or when a cache is not layered. Metadata % used The proportion of metadata bytes to class bytes, which indicates how efficiently cache space is being used. The value shown does consider the Class debug area size . Class debug area size The size in bytes of the Class Debug Area. This area is reserved to store LineNumberTable and LocalVariableTable class attribute information. Class debug area bytes used The size in bytes of the Class Debug Area that contains data. Class debug area % used The percentage of the Class Debug Area that contains data. ROMClasses The number of classes in the cache. The cache stores ROMClasses (the class data itself, which is read-only) and information about the location from which the classes were loaded. This information is stored in different ways, depending on the Java SharedClassHelper API that was used to store the classes. For more information, see Using the Java Helper API . AOT methods Optionally, ROMClass methods can be compiled and the AOT code stored in the cache. The AOT methods information shows the total number of methods in the cache that have AOT code compiled for them. This number includes AOT code for stale classes. Classpaths , URLs , and Tokens The number of class paths, URLs, and tokens in the cache. Classes stored from a SharedClassURLClasspathHelper are stored with a Classpath. Classes stored using a SharedClassURLHelper are stored with a URL. Classes stored using a SharedClassTokenHelper are stored with a Token. Most class loaders, including the bootstrap and application class loaders, use a SharedClassURLClasspathHelper . The result is that it is most common to see class paths in the cache. The number of Classpaths, URLs, and Tokens stored is determined by a number of factors. For example, every time an element of a Classpath is updated, such as when a .jar file is rebuilt, a new Classpath is added to the cache. Additionally, if partitions or modification contexts are used, they are associated with the Classpath, URL, or Token. A Classpath, URL, or Token is stored for each unique combination of partition and modification context. For more information, see SharedClassHelper partitions and Modification contexts . Zip caches The number of .zip files that have entry caches stored in the shared cache. Startup hints The number of startup hints stored in the cache. There can be a startup hint for each unique set of command line options used to start the JVM. Stale classes The number of classes that have been marked as \"potentially stale\" by the cache code, because of a VM or Java application update. See Understanding dynamic updates . % Stale classes The percentage of classes in the cache that are stale. Cache is XXX% full The percentage of the cache that is currently used. This line is displayed only if the soft maximum size is not set. This value is calculated as follows: % Full = (('Cache Size' - 'Free Bytes') * 100) / ('Cache Size') Cache is XXX% soft full The percentage of the soft maximum size that is currently used. This line is displayed only if the soft maximum size is set. The free bytes in the cache statistics means the free bytes within the soft maximum limit. This value is calculated as follows: % soft Full = (('Soft max bytes' - 'Free Bytes') * 100) / ('Soft max bytes') For more information about the soft maximum size, see -Xscmx . Cache is accessible to current user Whether the current user can access the cache. printTopLayerStats Use this utility with a layered cache. This utility works in the same way as printStats . By default, this utility shows information for the top layer cache. To view statistics for a specific layer, use the layer=<number> option. For example, to show statistics for the second layer in a 2-layer cache, run printTopLayerStats,layer=1 . Example output: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007F234C054000 end address = 0x00007F234D038000 allocation pointer = 0x00007F234C054000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 792 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% ROMClass bytes = 0 AOT bytes = 30520 JIT data bytes = 644 Zip cache bytes = 0 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 0 # AOT Methods = 18 # Classpaths = 0 # URLs = 0 # Tokens = 0 # Zip caches = 0 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 8% full Cache is accessible to current user = true","title":"Diagnostic cache utilities"},{"location":"shrc_diag_util/#shared-classes-cache-diagnostic-utilities","text":"These utilities display information about the contents of a shared classes cache. Run the utilities by specifying them as suboptions of -Xshareclasses . The utilities run on the default cache unless you specify a cache by adding the name=<cache_name> suboption.","title":"Shared classes cache diagnostic utilities"},{"location":"shrc_diag_util/#printallstats","text":"-Xshareclasses:printAllStats -Xshareclasses:printAllStats,name=<cache_name> Displays the contents of the cache in chronological order. You can use this output to see the history of updates that were made to the cache. For layered caches, some information is shown for the top layer cache only, and some is shown for all layers combined. To see information for the top layer cache only, use printTopLayerStats=all . Each entry in the output starts with a VM ID, so you can see which VM wrote the associated data. Here are example entries for various types of cache data, with explanations:","title":"printAllStats"},{"location":"shrc_diag_util/#class-paths","text":"This example shows one class path with 4 entries: 1: 0x2234FA6C CLASSPATH /myVM/Apps/application1.jar /myVM/Apps/application2.jar /myVM/Apps/application3.jar /myVM/Apps/application4.jar 1 : the ID of the VM that wrote this data. 0x2234FA6C : the address where this data is stored. CLASSPATH : the type of data that was written.","title":"Class paths"},{"location":"shrc_diag_util/#romclasses","text":"This example shows an entry for a single ROMClass : 1: 0x2234F7DC ROMCLASS: java/lang/Runnable at 0x213684A8 Index 1 in class path 0x2234FA6C 1 : the ID of the VM that wrote this data. 0x2234F7DC : the address where the metadata about the class is stored. ROMCLASS : the type of data that was stored. java/lang/Runnable : the name of the class. 0x213684A8 : the address where the class was stored. Index 1 : the index in the class path where the class was loaded from. 0x2234FA6C : the address of the class path against which this class is stored. Stale classes are marked with !STALE! . Any partition or modification context that is used when the class is stored is also shown.","title":"ROMClasses"},{"location":"shrc_diag_util/#aot-methods","text":"This example shows an entry for one AOT-compiled method: 1: 0x540FBA6A AOT: loadConvert for ROMClass java/util/Properties at 0x52345174 1 : the ID of the VM that wrote this data. 0x540FBA6A : the address where the data is stored. AOT : the type of data that was stored. loadConvert : the method for which AOT-compiled code is stored. java/util/Properties : the class that contains the method. 0x52345174 : the address of the class that contains the method. Stale methods are marked with !STALE! .","title":"AOT methods"},{"location":"shrc_diag_util/#urls-and-tokens","text":"A Token is a string that is passed to the Java\u2122 SharedClassHelper API. The output for these data types has the same format as that for class paths, but with a single entry.","title":"URLs and tokens"},{"location":"shrc_diag_util/#zip-entry-caches","text":"This example shows 4 separate entries for zip entry caches: 1: 0x042FE07C ZIPCACHE: luni-kernel.jar_347075_1272300300_1 Address: 0x042FE094 Size: 7898 1: 0x042FA878 ZIPCACHE: luni.jar_598904_1272300546_1 Address: 0x042FA890 Size: 14195 1: 0x042F71F8 ZIPCACHE: nio.jar_405359_1272300546_1 Address: 0x042F7210 Size: 13808 1: 0x042F6D58 ZIPCACHE: annotation.jar_13417_1272300554_1 Address: 0x042F6D70 Size: 1023 1 : the ID of the VM that wrote this data. 0x042FE07C : the address where the metadata for the zip entry cache is stored. ZIPCACHE : the type of data that was stored. luni-kernel.jar_347075_1272300300_1 : the name of the zip entry cache. 0x042FE094 : the address where the data is stored. 7898 : the size of the stored data, in bytes.","title":"Zip entry caches"},{"location":"shrc_diag_util/#jit-data","text":"Information about JIT data is shown in JITPROFILE and JITHINT entries. For example: 1: 0xD6290368 JITPROFILE: getKeyHash Signature: ()I Address: 0xD55118C0 for ROMClass java/util/Hashtable$Entry at 0xD5511640. 2: 0xD6283848 JITHINT: loadClass Signature: (Ljava/lang/String;)Ljava/lang/Class; Address: 0xD5558F98 for ROMClass com/ibm/oti/vm/BootstrapClassLoader at 0xD5558AE0.","title":"JIT data"},{"location":"shrc_diag_util/#startup-hints","text":"Information about startup hints is shown in STARTUP HINTS KEY and STARTUP HINTS DETAIL . For example: 1: 0x000000002237C6E0 STARTUP HINTS KEY: -Xoptionsfile=jre\\bin\\compressedrefs\\options.default -Xlockword:mode=default -Xjcl:jclse29 -Dcom.ibm.oti.vm.bootstrap.library.path=jre\\bin\\compressedrefs;jre\\bin -Djava.home=jre -Djava.ext.dirs=jre\\lib\\ext -Duser.dir=bin -Djava.class.path=. -Dsun.java.launcher=SUN_STANDARD Address: 0x000000002237C700 Size: 96 STARTUP HINTS DETAIL Flags: 1 DATA1: 1677721 DATA2: 5033165","title":"Startup hints"},{"location":"shrc_diag_util/#printstats","text":"-Xshareclasses:printStats -Xshareclasses:printStats,name=<cache_name> -Xshareclasses:printStats=<data_type1>[+<data_type2>][...],name=<cache_name> Displays summary information about the cache. For layered caches, -Xshareclasses:printStats shows some information for the top layer cache, and summary information (bytes and counts only) for all layers combined. To see information for the top layer cache only, use printTopLayerStats . You can request more detail about items of a specific data type that are stored in the shared cache by using printStats=<data_type> . Use the plus symbol (+) to separate the data types. For example, use printStats=romclass+url,name=myCache to see information about ROMClass and URL items in all the layer caches of the cache called Cache1 . The valid data types are as follows (case insensitive): help (displays the list of valid data types) all (equivalent to printAllStats ) classpath url token romclass rommethod aot jitprofile jithint zipcache stale startuphint Example output for a traditional cache (no cache layers: cache layer = 0 ), with summary information only: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr Cache contains only classes with line numbers base address = 0x00007F60B807A000 end address = 0x00007F60B905E000 allocation pointer = 0x00007F60B81BE3A8 cache layer = 0 cache size = 16776608 softmx bytes = 16776608 free bytes = 12740572 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 30440 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 189358 Class debug area % used = 14% ROMClass bytes = 1328040 AOT bytes = 98404 JIT data bytes = 168 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 2 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 24% full Cache is accessible to current user = true Example output for a cache with 2 layers ( cache layer = 1 ), with summary information only: Current statistics for top layer of cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007FCAB2766000 end address = 0x00007FCAB374A000 allocation pointer = 0x00007FCAB2766000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% Cache is 8% full Cache is accessible to current user = true --------------------------------------------------------- Current statistics for all layers of cache \"Cache1\": ROMClass bytes = 1328040 AOT bytes = 128924 JIT data bytes = 812 Zip cache bytes = 1133704 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 452 # AOT Methods = 20 # Classpaths = 1 # URLs = 0 # Tokens = 0 # Zip caches = 21 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% The Cache created with section indicates the options that were used when the cache was created. BCI Enabled relates to the -Xshareclasses:enableBCI option (enabled by default) and Restrict Classpaths relates to the -Xshareclasses:restrictClasspaths option. Feature = cr indicates that the cache is a 64-bit compressed references cache, as described in Creating, populating, monitoring, and deleting a cache . Line number information for classes in the cache is then shown with one of the following messages: Cache contains only classes with line numbers : VM line number processing was enabled for all the classes that were stored in this shared cache (the -Xlinenumbers option is enabled by default). All classes in the cache contain line numbers if the original classes contained line number data. Cache contains only classes without line numbers : The -Xnolinenumbers option was used to disable VM line number processing for all the classes that were stored in this shared cache, so none of the classes contain line numbers. Cache contains classes with line numbers and classes without line numbers : VM line number processing was enabled for some classes and disabled for others (the -Xnolinenumbers option was specified when some of the classes were added to the cache). The following summary data is displayed:","title":"printStats"},{"location":"shrc_diag_util/#baseaddress-and-endaddress","text":"The boundary addresses of the shared memory area that contains the classes.","title":"baseAddress and endAddress"},{"location":"shrc_diag_util/#allocation-pointer","text":"The address where ROMClass data is currently being allocated in the cache.","title":"allocation pointer"},{"location":"shrc_diag_util/#cache-layer","text":"The layer number that the cache stats relate to.","title":"cache layer"},{"location":"shrc_diag_util/#cache-size-and-free-bytes","text":"cache size shows the total size of the shared memory area in bytes, and free bytes shows the free bytes that remain.","title":"cache size and free bytes"},{"location":"shrc_diag_util/#softmx-bytes","text":"The soft maximum size for the cache. For more information, see -Xscmx .","title":"softmx bytes"},{"location":"shrc_diag_util/#romclass-bytes","text":"The number of bytes of class data in the cache.","title":"ROMClass bytes"},{"location":"shrc_diag_util/#aot-bytes","text":"The number of bytes of AOT-compiled code in the cache.","title":"AOT bytes"},{"location":"shrc_diag_util/#reserved-space-for-aot-bytes","text":"The number of bytes reserved for AOT-compiled code in the cache.","title":"Reserved space for AOT bytes"},{"location":"shrc_diag_util/#maximum-space-for-aot-bytes","text":"The maximum number of bytes of AOT-compiled code that can be stored in the cache.","title":"Maximum space for AOT bytes"},{"location":"shrc_diag_util/#jit-data-bytes","text":"The number of bytes of JIT-related data stored in the cache.","title":"JIT data bytes"},{"location":"shrc_diag_util/#reserved-space-for-jit-data-bytes","text":"The number of bytes reserved for JIT-related data in the cache.","title":"Reserved space for JIT data bytes"},{"location":"shrc_diag_util/#maximum-space-for-jit-data-bytes","text":"The maximum number of bytes of JIT-related data that can be stored in the cache.","title":"Maximum space for JIT data bytes"},{"location":"shrc_diag_util/#zip-cache-bytes","text":"The number of zip entry cache bytes stored in the cache.","title":"Zip cache bytes"},{"location":"shrc_diag_util/#startup-hint-bytes","text":"The number of bytes of data stored to describe startup hints.","title":"Startup hint bytes"},{"location":"shrc_diag_util/#data-bytes","text":"The number of bytes of non-class data stored by the VM.","title":"Data bytes"},{"location":"shrc_diag_util/#metadata-bytes","text":"The number of bytes of data stored to describe the cached classes. Note: This field is available only in the top layer cache output or when a cache is not layered.","title":"Metadata bytes"},{"location":"shrc_diag_util/#metadata-used","text":"The proportion of metadata bytes to class bytes, which indicates how efficiently cache space is being used. The value shown does consider the Class debug area size .","title":"Metadata % used"},{"location":"shrc_diag_util/#class-debug-area-size","text":"The size in bytes of the Class Debug Area. This area is reserved to store LineNumberTable and LocalVariableTable class attribute information.","title":"Class debug area size"},{"location":"shrc_diag_util/#class-debug-area-bytes-used","text":"The size in bytes of the Class Debug Area that contains data.","title":"Class debug area bytes used"},{"location":"shrc_diag_util/#class-debug-area-used","text":"The percentage of the Class Debug Area that contains data.","title":"Class debug area % used"},{"location":"shrc_diag_util/#romclasses_1","text":"The number of classes in the cache. The cache stores ROMClasses (the class data itself, which is read-only) and information about the location from which the classes were loaded. This information is stored in different ways, depending on the Java SharedClassHelper API that was used to store the classes. For more information, see Using the Java Helper API .","title":"ROMClasses"},{"location":"shrc_diag_util/#aot-methods_1","text":"Optionally, ROMClass methods can be compiled and the AOT code stored in the cache. The AOT methods information shows the total number of methods in the cache that have AOT code compiled for them. This number includes AOT code for stale classes.","title":"AOT methods"},{"location":"shrc_diag_util/#classpaths-urls-and-tokens","text":"The number of class paths, URLs, and tokens in the cache. Classes stored from a SharedClassURLClasspathHelper are stored with a Classpath. Classes stored using a SharedClassURLHelper are stored with a URL. Classes stored using a SharedClassTokenHelper are stored with a Token. Most class loaders, including the bootstrap and application class loaders, use a SharedClassURLClasspathHelper . The result is that it is most common to see class paths in the cache. The number of Classpaths, URLs, and Tokens stored is determined by a number of factors. For example, every time an element of a Classpath is updated, such as when a .jar file is rebuilt, a new Classpath is added to the cache. Additionally, if partitions or modification contexts are used, they are associated with the Classpath, URL, or Token. A Classpath, URL, or Token is stored for each unique combination of partition and modification context. For more information, see SharedClassHelper partitions and Modification contexts .","title":"Classpaths, URLs, and Tokens"},{"location":"shrc_diag_util/#zip-caches","text":"The number of .zip files that have entry caches stored in the shared cache.","title":"Zip caches"},{"location":"shrc_diag_util/#startup-hints_1","text":"The number of startup hints stored in the cache. There can be a startup hint for each unique set of command line options used to start the JVM.","title":"Startup hints"},{"location":"shrc_diag_util/#stale-classes","text":"The number of classes that have been marked as \"potentially stale\" by the cache code, because of a VM or Java application update. See Understanding dynamic updates .","title":"Stale classes"},{"location":"shrc_diag_util/#stale-classes_1","text":"The percentage of classes in the cache that are stale.","title":"% Stale classes"},{"location":"shrc_diag_util/#cache-is-xxx-full","text":"The percentage of the cache that is currently used. This line is displayed only if the soft maximum size is not set. This value is calculated as follows: % Full = (('Cache Size' - 'Free Bytes') * 100) / ('Cache Size')","title":"Cache is XXX% full"},{"location":"shrc_diag_util/#cache-is-xxx-soft-full","text":"The percentage of the soft maximum size that is currently used. This line is displayed only if the soft maximum size is set. The free bytes in the cache statistics means the free bytes within the soft maximum limit. This value is calculated as follows: % soft Full = (('Soft max bytes' - 'Free Bytes') * 100) / ('Soft max bytes') For more information about the soft maximum size, see -Xscmx .","title":"Cache is XXX% soft full"},{"location":"shrc_diag_util/#cache-is-accessible-to-current-user","text":"Whether the current user can access the cache.","title":"Cache is accessible to current user"},{"location":"shrc_diag_util/#printtoplayerstats","text":"Use this utility with a layered cache. This utility works in the same way as printStats . By default, this utility shows information for the top layer cache. To view statistics for a specific layer, use the layer=<number> option. For example, to show statistics for the second layer in a 2-layer cache, run printTopLayerStats,layer=1 . Example output: Current statistics for cache \"Cache1\": Cache created with: -Xnolinenumbers = false BCI Enabled = true Restrict Classpaths = false Feature = cr base address = 0x00007F234C054000 end address = 0x00007F234D038000 allocation pointer = 0x00007F234C054000 cache layer = 1 cache size = 16776608 softmx bytes = 16776608 free bytes = 15299372 Reserved space for AOT bytes = -1 Maximum space for AOT bytes = -1 Reserved space for JIT data bytes = -1 Maximum space for JIT data bytes = -1 Metadata bytes = 792 Metadata % used = 0% Class debug area size = 1331200 Class debug area used bytes = 0 Class debug area % used = 0% ROMClass bytes = 0 AOT bytes = 30520 JIT data bytes = 644 Zip cache bytes = 0 Startup hint bytes = 0 Data bytes = 114080 # ROMClasses = 0 # AOT Methods = 18 # Classpaths = 0 # URLs = 0 # Tokens = 0 # Zip caches = 0 # Startup hints = 0 # Stale classes = 0 % Stale classes = 0% Cache is 8% full Cache is accessible to current user = true","title":"printTopLayerStats"},{"location":"tool_builder/","text":"Option builder tools You can modify many of the command-line options by specifying a number of parameters. Several of the options have many available parameters that you can combine in numerous ways to achieve the effect you want. Tools are available for the following options to help you select these parameters correctly, achieve the correct combinations, and avoid conflicts: -Xdump -Xtrace","title":"Option builder"},{"location":"tool_builder/#option-builder-tools","text":"You can modify many of the command-line options by specifying a number of parameters. Several of the options have many available parameters that you can combine in numerous ways to achieve the effect you want. Tools are available for the following options to help you select these parameters correctly, achieve the correct combinations, and avoid conflicts: -Xdump -Xtrace","title":"Option builder tools"},{"location":"tool_jcmd/","text":"Java diagnostic command ( jcmd ) tool Use the jcmd tool to run diagnostic commands on a specified VM. Note: Running diagnostic commands can significantly affect the performance of the target VM. The command syntax is as follows: jcmd [<options>] [<vmid> <arguments>] Where: The available <options> are: -J : supplies arguments to the Java VM that is running the jcmd command. You can use multiple -J options, for example: jcmd -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints the jcmd help <vmid> is the Attach API virtual machine identifier for the Java\u2122 VM process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. You can use the jps command to find the VMID. The available arguments are: help : shows the diagnostic commands that are available for this VM. This list of commands can vary between VMs. help <command> : shows help information for the specified diagnostic command <command> [<command_arguments>] : runs the specified diagnostic command, with optional command arguments Examples: jcmd 31452 Thread.print jcmd 31452 help Dump.heap jcmd 31452 Dump.heap myHeapDump Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For information about the differences between these two implementations, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Support for the Java Attach API .","title":"Java command (jcmd) tool"},{"location":"tool_jcmd/#java-diagnostic-command-jcmd-tool","text":"Use the jcmd tool to run diagnostic commands on a specified VM. Note: Running diagnostic commands can significantly affect the performance of the target VM. The command syntax is as follows: jcmd [<options>] [<vmid> <arguments>] Where: The available <options> are: -J : supplies arguments to the Java VM that is running the jcmd command. You can use multiple -J options, for example: jcmd -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints the jcmd help <vmid> is the Attach API virtual machine identifier for the Java\u2122 VM process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. You can use the jps command to find the VMID. The available arguments are: help : shows the diagnostic commands that are available for this VM. This list of commands can vary between VMs. help <command> : shows help information for the specified diagnostic command <command> [<command_arguments>] : runs the specified diagnostic command, with optional command arguments Examples: jcmd 31452 Thread.print jcmd 31452 help Dump.heap jcmd 31452 Dump.heap myHeapDump Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For information about the differences between these two implementations, see Switching to OpenJ9 . The tool uses the Attach API, and has the following limitations: Displays information only for local processes that are owned by the current user, due to security considerations. Displays information for OpenJ9 Java processes only Does not show information for processes whose Attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Support for the Java Attach API .","title":"Java diagnostic command (jcmd) tool"},{"location":"tool_jdmpview/","text":"Dump viewer ( jdmpview ) The dump viewer is a command-line tool that allows you to examine the contents of system dumps produced from the OpenJ9 VM. The dump viewer allows you to view both Java\u2122 and native information from the time the dump was produced. For long running tasks, the dump viewer can also be run in batch mode. The dump viewer is useful for diagnosing OutOfMemoryError exceptions in Java\u2122 applications. For problems like general protection faults (GPF), system abends, and SIGSEVs, a system debugger such as gdb (Linux) provides more information. Syntax Starting the dump viewer jdmpview [-J<vm option>] (-core <core file> | -zip <zip file>) [-notemp] Input option Explanation -core <core file> Specifies a dump file. -zip <zip file> Specifies a compressed file containing the core file (produced by the dump extractor ( jextract ) tool on AIX\u00ae, Linux\u00ae, and macOS\u00ae systems). -notemp By default, when you specify a file by using the -zip option, the contents are extracted to a temporary directory before processing. Use the -notemp option to prevent this extraction step, and run all subsequent commands in memory. -J-Dcom.ibm.j9ddr.path.mapping=<mappings> The variable <mappings> is a list of native library mappings of the form old-path=new-path , using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). -J-Dcom.ibm.j9ddr.library.path=<path> The variable <path> is a list of paths to search for native libraries, using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). Note: The -core option can be used with the -zip option to specify the core file in the compressed file. Without these options, jdmpview shows multiple contexts, one for each source file that it identified in the compressed file. Note: On AIX and Linux, some jdmpview commands need to locate the native libraries that are referenced by the core. For example, commands that relate to callsites. First, check the list of native libraries by running jdmpview on a core with the info mod parameter. If the libraries are not in the original locations, ensure that jdmpview can locate them by specifying the path mapping ( -J-Dcom.ibm.j9ddr.path.mapping=<mappings> ) and library path ( -J-Dcom.ibm.j9ddr.library.path=<path> ) options specified on the jdmpview command line. On z/OS\u00ae, you can copy the dump to an HFS file and supply that as input to jdmpview , or you can supply a fully qualified MVS\u2122 data set name. For example: > jdmpview -core USER1.JVM.TDUMP.SSHD6.D070430.T092211 DTFJView version 4.28.3, using DTFJ version 1.11.28004 Loading image from DTFJ... MVS data set names may contain the dollar sign ($). Names that contain a dollar sign must be enclosed by single quotation marks ('). For example: > jdmpview -core 'USER1.JVM.$TDUMP.SSH$D7.D141211.T045506' After jdmpview processes the dump files, a session starts, showing this message: For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" > If you run the jdmpview tool on a compressed file that contains multiple dumps, the tool detects and shows all the dump files, whether these are system dumps, Java dumps, or heap dumps. Because of this behavior, more than one context might be displayed when you start jdmpview . To switch context, type context <n> , where <n> is the context value for the dump you want to investigate. On z/OS, a system dump can contain multiple address spaces and an address space can contain multiple VM instances. In this case, the context allows you to select the address space and VM instance within the dump file. The following z/OS example shows address spaces ( ASID ), with two JVMs occupying address space 0x73 (context 5 and 6). The current context is 5 ( CTX:5> ), shown with an asterisk. To view the JVM in context 6, you can switch by specifying context 6 . CTX:5> context Available contexts (* = currently selected context) : 0 : ASID: 0x1 : No JRE : No JRE 1 : ASID: 0x3 : No JRE : No JRE 2 : ASID: 0x4 : No JRE : No JRE 3 : ASID: 0x6 : No JRE : No JRE 4 : ASID: 0x7 : No JRE : No JRE *5 : ASID: 0x73 EDB: 0x83d2053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 6 : ASID: 0x73 EDB: 0x8004053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 7 : ASID: 0x73 EDB: 0x4a7bd9e8 : No JRE 8 : ASID: 0xffff : No JRE : No JRE If you are using jdmpview to view Java dumps and heap dumps, some options do not produce any output. For example, a heap dump doesn't contain the information requested by the info system command, but does contain information requested by the info class command. If you are viewing a dump where there are a large number of objects on the heap, you can speed up the performance of jdmpview by ensuring that your system has enough memory available and does not need to page memory to disk. To achieve this, start jdmpview with a larger heap size by specifying the -Xmx option. Use the -J option to pass the -Xmx command line option to the JVM. For example: jdmpview -J-Xmx<n> -core <core file> The options available to the dump viewer session are shown under Session parameters Starting in batch mode For long running or routine jobs, jdmpview can be used in batch mode. You can run a single command without specifying a command file by appending the command to the end of the jdmpview command line. For example: jdmpview -core mycore.dmp info class When specifying jdmpview commands that accept a wildcard parameter, you must replace the wildcard symbol with ALL to prevent the shell interpreting the wildcard symbol. For example, in interactive mode, the command info thread * must be specified in the following way: jdmpview -core mycore.dmp info thread ALL Batch mode is controlled with the following command line options: Option Explanation -cmdfile <path to command file> A file that contains a series of jdmpview commands, which are read and run sequentially. -charset <character set name> The character set for the commands specified in -cmdfile (name must be a supported charset as defined in java.nio.charset.Charset. For example, US-ASCII) -outfile <path to output file> The file to record any output generated by commands. -overwrite If the file specified in -outfile exists, this option overwrites the file. -append If the file specified in -outfile exists, new output messages are appended to the end of that file. The -append and -overwrite options cannot be used at the same time. The command file can have empty lines that contain spaces, or comment lines that start with // or #. These lines are ignored by jdmpview. Example command file: // commands.txt info system info proc To run jdmpview in batch mode, using this command file, specify: jdmpview -outfile out.txt [-overwrite|-append] -cmdfile commands.txt -core <path to core file> When the output file exists, you need to specify either the -overwrite option or the -append option. If you do not, an error message is generated. Processing output You can redirect command output to a file, or pipe the command output to another command. To redirect jdmpview command output to a file, use one of the following formats: command > <target_file> If the target file exists, this redirection overwrites the content within it. command >> <target_file> If the target file exists, this redirection appends the output to it. Where <target_file> is the file name, which can include the full path to the file. To pipe jdmpview command output to another command, use the vertical bar (|) character. For example: command | grep string You can chain more than two commands together by using multiple vertical bar characters. The following commands can be used to interrogate the output: charsFrom charsTo grep tokens Using CharsFrom Use the charsFrom command after the vertical bar character to exclude all characters that come before a specified pattern in a resulting line. charsFrom <options> pattern Where <options> : -e or -exclude : Exclude the matched pattern from the resulting line. By default, the matched pattern is included in the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays resulting lines that contain the pattern jre , and trims each line to exclude all characters that come before this pattern: > info mod | charsFrom jre jre/lib/ppc64/libzip.so @ 0x0, sections: jre/lib/ppc64/libdbgwrapper80.so @ 0x0, sections: jre/lib/ppc64/libverify.so @ 0x0, sections: jre/lib/ppc64/libjava.so @ 0x0, sections: jre/lib/ppc64/compressedrefs/libjclse7b_28.so @ 0x0, sections: Using CharsTo Use the CharsTo command after the vertical bar character to include the characters in a resulting line until a specific pattern is found. charsTo <options> pattern Where <options> : -include : Include the matched pattern in the resulting line. By default, the matched pattern is excluded from the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays lines that contain the pattern \"@\", and trims each line to exclude all characters from \"@\" onwards: > info mod | charsTo @ bin/java /usr/lib64/gconv/UTF-16.so /test/sdk/lib/ppc64le/libnet.so /test/sdk/lib/ppc64le/libnio.so /test/sdk/lib/ppc64le/libzip.so /test/sdk/lib/ppc64le/libjsig.so libjsig.so You can also use charsFrom and charsTo together, separated by a vertical bar character. For example, the following command displays lines that contain the pattern \"lib\", and trims each line to exclude all characters that come before this pattern, as well as all characters from the pattern @ : > info mod | charsFrom lib | charsTo @ lib/ppc64le/libzip.so lib/ppc64le/libjsig.so lib/ppc64le/libverify.so lib/ppc64le/libjava.so lib/ppc64le/compressedrefs/libj9jit29.so Note: The line will not be displayed if the charsFrom and charsTo are used together, but only one of the patterns are matched in a line. Furthermore, the line will not be displayed if both patterns are matched in a line, but the charsTo pattern appears before, and not after, the charsFrom pattern. Using grep Use the grep command after the vertical bar character to show which lines match a specified pattern. grep <options> pattern Where <options> : -i : Ignore case. -r , -G , or --regex : Use a regular expression as defined in the Java documentation of the java.utils.regex.Pattern class. -b or --block : Show blocks of lines where at least one of the lines matches the pattern. Blocks of lines are separated by empty lines. -A <NUM> or +<NUM> : Show at most <NUM> lines after the matching line. For example grep -A 2 pattern or grep +2 pattern. -B <NUM> or -<NUM> : Show at most <NUM> lines before the matching line. -C <NUM> or +-<NUM> : Show at most <NUM> lines before and after the matching line. -v or --invert-match : Use with the grep command to show lines that do not match the pattern. These options are equivalent to the grep- command. -F or --fixed-strings : Do not treat the asterisk (*) as a wildcard character. Use these options with the -r , -G , or --regex options. Pattern rules: An asterisk (*) in a pattern is treated as a wildcard character unless you specify the -F or --fixed-strings options. If a pattern contains spaces, enclose the pattern in a pair of double quotation marks (\"). If a pattern contains double quotation marks, enclose the pattern in a pair of single quotation marks ('). You can specify multiple sub-patterns to match by using the following format, but only if you do not use the -r , -G , or --regex options: \"[pattern1|pattern2|...|patternN]\" The initial and trailing double quotation marks and brackets ([ ]) are required. Use a vertical bar character to separate the sub-patterns. Quotation marks and the vertical bar are not allowed in a sub-pattern. Spaces are allowed in the middle of a sub-pattern, but leading and trailing spaces will be trimmed. Use the grep command to show lines that do not match the pattern. For example, the following command displays the number of instances and total heap size for the java/lang/String class: > info class | grep java/lang/String 94 7688 [Ljava/lang/String; 1822 58304 java/lang/String 1 16 java/lang/String$CaseInsensitiveComparator 0 0 java/lang/String$UnsafeHelpers The following command uses two pipes in combination to display the number of instances and total heap size for the java/lang/StringCoding.StringDecoder class: > info class | grep java/lang/String | grep -i decoder 1 48 java/lang/StringCoding$StringDecoder Using tokens Use the tokens command after the vertical bar character to isolate specified tokens in the resulting lines. tokens [options] range[,range][..range] You can define range in the following formats: x x,y x..y A set of rules applies to these formats: x or y can be prefixed with \"-\". This means that x or y are counting backwards from the end of a list. For example, a y value of -1 represents the last token in a list, while -2 represents the penultimate token in a list. x must represent a token that either precedes or is at the same position as y. In this format, if x is omitted, it is assumed to be '1'. If y is omitted, it is assumed to be '-1'. For example, the following command displays the first and second token for each resulting line: > info mmap | grep -r ^0x | tokens 1,2 0x0000000000012fff 0x000000000000d000 0x0000000000017fff 0x0000000000004000 0x00000000009dafff 0x0000000000018000 0x00000000009fffff 0x000000000001f000 0x0000000000cbefff 0x0000000000002000 0x0000000000d76fff 0x0000000000001000 0x0000000003145fff 0x0000000000071000 0x0000000003b93fff 0x0000000000003000 Session parameters When jdmpview is started, many parameters can be used during the session to interrogate the system dump data, which are divided into general and expert parameters. The general parameters are documented in this section. To see a list of expert parameters, use the !j9help option. !j9help !j9help Lists all expert parameters that can be used in a session, with a brief description. cd cd <directory_name> Changes the working directory to <directory_name> . The working directory is used for log files. Logging is controlled by the set logging command. Use the pwd command to query the current working directory. cmdfile cmdfile <directory_name> Runs all of the commands in a file. The commands are read line by line and run sequentially. Empty lines, and lines that start with // or # , are ignored. Use the option charset to identify the character set that is used in the chosen file. The character set must be supported, as defined in java.nio.charset.Charset , such as US-ASCII . deadlock This command detects deadlock situations in the Java application that was running when the system dump was produced. Example output: deadlock loop: thread: Thread-2 (monitor object: 0x9e32c8) waiting for => thread: Thread-3 (monitor object: 0x9e3300) waiting for => thread: Thread-2 (monitor object: 0x9e32c8) In this example, the deadlock analysis shows that Thread-2 is waiting for a lock held by Thread-3 , which is in turn waiting for a lock held earlier by Thread-2 . Threads are identified by their Java thread name, whereas object monitors are identified by the address of the object in the Java heap. You can obtain further information about the threads using the info thread * command. You can obtain further information about the monitors using the x/J <0xaddr> command. find find <pattern>,<start_address>,<end_address>,<memory_boundary>, <bytes_to_print>,<matches_to_display> This command searches for <pattern> in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the find command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes. findnext findptr <pattern>,<start_address>,<end_address>,<memory_boundary>,<bytes_to_print>,<matches_to_display> Finds the next instance of the last string passed to find or findptr . It repeats the previous find or findptr command, depending on which one was issued last, starting from the last match. Searches memory for the given pointer. findptr searches for <pattern> as a pointer in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the findptr command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes. help help [<command_name>] Shows information for a specific command. If you supply no parameters, help shows the complete list of supported commands. history history|his [-r][<N>] Recalls and displays the history of commands that you have run. The default behavior is to display the 20 most recent commands. If you use the argument <N> , then N commands are displayed. For example, if you run history 35, then the 35 most recent commands are displayed. You can also use the -r option with <N> to run the Nth most recent command in your history. Using the -r option alone runs the most recent command in your history. info thread info thread [*|all|<native_thread_ID>|<zos_TCB_address>] Displays information about Java and native threads. The following information is displayed for all threads (\"*\"), or the specified thread: Thread id Registers Stack sections Thread frames: procedure name and base pointer Thread properties: list of native thread properties and their values. For example: thread priority. Associated Java thread, if applicable: Name of Java thread Address of associated java.lang.Thread object State (shown in JVMTI and java.lang.Thread.State formats) The monitor the thread is waiting for Thread frames: base pointer, method, and filename:line If you supply no parameters, the command shows information about the current thread. info system Displays the following information about the system that produced the core dump: Amount of memory Operating system Virtual machine or virtual machines present info class info class [<class_name>] [-sort:<name>|<count>|<size>] Displays the inheritance chain and other data for a given class. If a class name is passed to info class, the following information is shown about that class: - Name - ID - Superclass ID - Class loader ID - Modifiers - Number of instances and total size of instances - Inheritance chain - Fields with modifiers (and values for static fields) - Methods with modifiers If no parameters are passed to `info class`, the following information is shown: - The number of instances of each class. - The total size of all instances of each class. - The class name - The total number of instances of all classes. - The total size of all objects. The `sort` option allows the list of classes to be sorted by name (default), by number of instances of each class, or by the total size of instances of each class. info proc Displays threads, command-line arguments, environment variables, and shared modules of the current process. To view the shared modules used by a process, use the info sym command. info jitm Displays JIT compiled methods and their addresses: Method name and signature Method start address Method end address info lock Displays a list of available monitors and locked objects. info sym Displays a list of available modules. For each process in the address spaces, this command shows a list of module sections for each module, their start and end addresses, names, and sizes. info mmap info mmap [<address>] [-verbose] [-sort:<size>|<address>] Displays a summary list of memory sections in the process address space, with start and end address, size, and properties. If an address parameter is specified, the results show details of only the memory section containing the address. If -verbose is specified, full details of the properties of each memory section are displayed. The -sort option allows the list of memory sections to be sorted by size or by start address (default). info mod Displays a list of native library modules in the process address space, which includes file paths and other information about each module. info heap info heap [*|<heap_name>*] If no parameters are passed to this command, the heap names and heap sections are shown. Using either \"*\" or a heap name shows the following information about all heaps or the specified heap: Heap name (Heap size and occupancy) Heap sections Section name Section size Whether the section is shared Whether the section is executable Whether the section is read only heapdump heapdump [<heaps>] Generates a Java heap dump to a file. You can select which Java heaps to dump by listing the heap names, separated by spaces. To see which heaps are available, use the info heap command. By default, all Java heaps are dumped. hexdump hexdump <hex_address> <bytes_to_print> Displays a section of memory in a hexdump-like format. Displays <bytes_to_print> bytes of memory contents starting from <hex_address> . + Displays the next section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling forwards through memory. The previous hexdump command is repeated, starting from the end of the previous one. - Displays the previous section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling backwards through memory. The previous hexdump command is repeated, starting from a position before the previous one. pwd Displays the current working directory, which is the directory where log files are stored. quit Exits the core file viewing tool; any log files that are currently open are closed before exit. set heapdump Configures Heapdump generation settings. set heapdump <options> where <options> are: phd : Set the Heapdump format to Portable Heapdump, which is the default. txt : Set the Heapdump format to classic. file <file> : Set the destination of the Heapdump. multiplefiles [on|off] : If multiplefiles is set to on, each Java heap in the system dump is written to a separate file. If multiplefiles is set to off, all Java heaps are written to the same file. The default is off. set logging set logging <options> Configures logging settings, starts logging, or stops logging. This parameter enables the results of commands to be logged to a file, where <options> are: [on|off] : Turns logging on or off. (Default: off) file <filename> : Sets the file to log to. The path is relative to the directory returned by the pwd command, unless an absolute path is specified. If the file is set while logging is on, the change takes effect the next time logging is started. Not set by default. overwrite [on|off] : Turns overwriting of the specified log file on or off. When overwrite is off, log messages are appended to the log file. When overwrite is on, the log file is overwritten after the set logging command. (Default: off) redirect [on|off] : Turns redirecting to file on or off, with off being the default. When logging is set to on: A value of on for redirect sends non-error output only to the log file. A value of off for redirect sends non-error output to the console and log file. Redirect must be turned off before logging can be turned off. (Default: off) show heapdump Displays the current Heapdump generation settings. show logging Displays the current logging settings: set_logging = [on|off] set_logging_file = set_logging_overwrite = [on|off] set_logging_redirect = [on|off] current_logging_file = The file that is currently being logged to might be different from set_logging_file, if that value was changed after logging was started. whatis <hex_address> Displays information about whatis stored at the given memory address, <hex_address> . This command examines the memory location at <hex_address> and tries to find out more information about this address. For example: > whatis 0x8e76a8 heap #1 - name: Default@19fce8 0x8e76a8 is within heap segment: 8b0000 -- cb0000 0x8e76a8 is start of an object of type java/lang/Thread x/ (examine) Passes the number of items to display and the unit size, as listed in the following table, to the sub-command. For example, x/12bd . Abbreviation Unit Size b Byte 8-bit h Half word 16-bit w Word 32-bit g Giant word 64-bit This command is similar to the use of the x/ command in gdb, including the use of defaults. x/J [ <class_name> | <0xaddr> ] Displays information about a particular object, or all objects of a class. If <class_name> is supplied, all static fields with their values are shown, followed by all objects of that class with their fields and values. If an object address (in hex) is supplied, static fields for that object's class are not shown; the other fields and values of that object are printed along with its address. Note: This command ignores the number of items and unit size passed to it by the x/ command. x/D < 0xaddr > Displays the integer at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big endian architecture. This command uses the number of items and unit size passed to it by the x/ command. x/X < 0xaddr > Displays the hex value of the bytes at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big endian architecture. Note: This command uses the number of items and unit size passed to it by the x/ command. x/K < 0xaddr > Where the size is defined by the pointer size of the architecture, this parameter shows the value of each section of memory. The output is adjusted for the hardware architecture this dump file is from, starting at the specified address. It also displays a module with a module section and an offset from the start of that module section in memory if the pointer points to that module section. If no symbol is found, it displays a \"*\" and an offset from the current address if the pointer points to an address in 4KB (4096 bytes) of the current address. Although this command can work on an arbitrary section of memory, it is probably more useful on a section of memory that refers to a stack frame. To find the memory section of a thread stack frame, use the info thread command. Note: This command uses the number of items and unit size passed to it by the x/ command. Example This example session illustrates a selection of the commands available and their use. In the example session, which is generated on a Linux system, some lines have been removed for clarity (and terseness). User input is prefaced by a greater than symbol (>). test@madras:~/test> sdk/bin/jdmpview -core core.20121116.154147.16838.0001.dmp DTFJView version 4.27.57, using DTFJ version 1.10.27022 Loading image from DTFJ... For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" Available contexts (* = currently selected context) : Source : file:///home/test/core.20121116.154147.16838.0001.dmp *0 : PID: 16867 : JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6480-20121116_01 ) > help + displays the next section of memory in hexdump-like format - displays the previous section of memory in hexdump-like format cd changes the current working directory, used for log files close [context id] closes the connection to a core file context [ID|asid ID] switch to the selected context deadlock displays information about deadlocks if there are any exit Exit the application find searches memory for a given string findnext finds the next instance of the last string passed to \"find\" findptr searches memory for the given pointer heapdump generates a PHD or classic format heapdump help [command name] displays list of commands or help for a specific command hexdump outputs a section of memory in a hexdump-like format info <component> Information about the specified component info class <Java class name> Provides information about the specified Java class info heap [*|heap name] Displays information about Java heaps info jitm Displays JIT'ed methods and their addresses info lock outputs a list of system monitors and locked objects info mmap Outputs a list of all memory segments in the address space info mod outputs module information info proc shortened form of info process info process displays threads, command line arguments, environment info sym an alias for 'mod' info sys shortened form of info system info system displays information about the system the core dump is from info thread displays information about Java and native threads log [name level] display and control instances of java.util.logging.Logger open [path to core or zip] opens the specified core or zip file plugins Plugin management commands list Show the list of loaded plugins for the current context reload Reload plugins for the current context showpath Show the DTFJ View plugin search path for the current context setpath Set the DTFJ View plugin search path for the current context pwd displays the current working directory quit Exit the application set [logging|heapdump] Sets options for the specified command set heapdump configures heapdump format, filename and multiple heap support set logging configures several logging-related parameters, starts/stops logging on turn on logging off turn off logging file turn on logging overwrite controls the overwriting of log files show [logging|heapdump] Displays the current set options for a command show heapdump displays heapdump settings show logging shows the current logging options whatis [hex address] gives information about what is stored at the given memory address x/d <hex address> displays the integer at the specified address x/j <object address> [class name] displays information about a particular object or all objects of a class x/k <hex address> displays the specified memory section as if it were a stack frame parameters x/x <hex address> displays the hex value of the bytes at the specified address > set logging file log.txt logging turned on; outputting to \"/home/test/log.txt\" > info system Machine OS: Linux Hypervisor: PowerVM Machine name: madras Machine IP address(es): 9.20.88.155 System memory: 8269201408 Dump creation time: 2015/08/10 14:44:36:019 Dump creation time (nanoseconds): 21314421467539 Java version: JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6490-20121116_01) JVM start time: 2015/08/10 14:44:05:690 JVM start time (nanoseconds): 21284086192267 > info thread * native threads for address space process id: 16838 thread id: 16839 registers: native stack sections: native stack frames: properties: associated Java thread: name: main Thread object: java/lang/Thread @ 0x2ffd1e08 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x0000000000085b28 method: void com/ibm/jvm/Dump.SystemDumpImpl() (Native Method) objects: <no objects in this frame> bp: 0x0000000000085b40 method: void com/ibm/jvm/Dump.SystemDump() source: Dump.java:41 objects: <no objects in this frame> bp: 0x0000000000085b68 method: void mySystemDump.main(String[]) source: mySystemDump.java:29 objects: <no objects in this frame> ===Lines Removed=== name: GC Slave id: 16860 Thread object: java/lang/Thread @ 0x3001b980 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::slaveThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: GC Slave id: 16861 Thread object: java/lang/Thread @ 0x3001c180 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::slaveThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: Signal Dispatcher id: 16847 Thread object: com/ibm/misc/SignalDispatcher @ 0x3000f268 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x00000000000df748 method: int com/ibm/misc/SignalDispatcher.waitForSignal() (Native Method) objects: <no objects in this frame> bp: 0x00000000000df788 method: void com/ibm/misc/SignalDispatcher.run() source: SignalDispatcher.java:54 objects: 0x30015828 0x30015828 ===Lines Removed=== > info heap * Heap #1: Generational@fff78303d30 Section #1: Heap extent at 0x100d0000 (0x300000 bytes) Size: 3145728 bytes Shared: false Executable: false Read Only: false Section #2: Heap extent at 0x2ffd0000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false Section #3: Heap extent at 0x30050000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false > info class java/lang/String name = java/lang/String ID = 0x37c00 superID = 0x30300 classLoader = 0x2ffe9b58 modifiers: public final number of instances: 2146 total size of instances: 51504 bytes Inheritance chain.... java/lang/Object java/lang/String Fields...... static fields for \"java/lang/String\" private static final long serialVersionUID = -6849794470754667710 (0xa0f0a4387a3bb342) public static final java.util.Comparator CASE_INSENSITIVE_ORDER = <object> @ 0x2ffd0278 private static final char[] ascii = <object> @ 0x2ffd02c8 private static String[] stringArray = <object> @ 0x2ffd0298 private static final int stringArraySize = 10 (0xa) static boolean enableCopy = false private static int seed = -126504465 (0xfffffffff875b1ef) private static char[] startCombiningAbove = <object> @ 0x100d0c40 private static char[] endCombiningAbove = <object> @ 0x100d0cc0 private static final char[] upperValues = <object> @ 0x100d0d40 private static final java.io.ObjectStreamField[] serialPersistentFields = <object> @ 0x2ffd0920 non-static fields for \"java/lang/String\" private final char[] value private final int offset private final int count private int hashCode private int hashCode32 Methods...... Bytecode range(s): : private static native int getSeed() Bytecode range(s): fff76d8ce48 -- fff76d8ce5e: public void <init>() Bytecode range(s): fff76d8ce88 -- fff76d8cecd: private void <init>(String, char) Bytecode range(s): fff76d8cf10 -- fff76d8cf19: public void <init>(byte[]) Bytecode range(s): fff76d8cf40 -- fff76d8cf4a: public void <init>(byte[], int) Bytecode range(s): fff76d8cf7c -- fff76d8cfb5: public void <init>(byte[], int, int) Bytecode range(s): fff76d8cff8 -- fff76d8d065: public void <init>(byte[], int, int, int) Bytecode range(s): fff76d8d0c4 -- fff76d8d10c: public void <init>(byte[], int, int, String) ===Lines Removed=== > whatis 0x2ffd0298 heap #1 - name: Generational@fff78303d30 0x2ffd0298 is within heap segment: 2ffd0000 -- 30050000 0x2ffd0298 is the start of an object of type [Ljava/lang/String;","title":"Dump viewer"},{"location":"tool_jdmpview/#dump-viewer-jdmpview","text":"The dump viewer is a command-line tool that allows you to examine the contents of system dumps produced from the OpenJ9 VM. The dump viewer allows you to view both Java\u2122 and native information from the time the dump was produced. For long running tasks, the dump viewer can also be run in batch mode. The dump viewer is useful for diagnosing OutOfMemoryError exceptions in Java\u2122 applications. For problems like general protection faults (GPF), system abends, and SIGSEVs, a system debugger such as gdb (Linux) provides more information.","title":"Dump viewer (jdmpview)"},{"location":"tool_jdmpview/#syntax","text":"","title":"Syntax"},{"location":"tool_jdmpview/#starting-the-dump-viewer","text":"jdmpview [-J<vm option>] (-core <core file> | -zip <zip file>) [-notemp] Input option Explanation -core <core file> Specifies a dump file. -zip <zip file> Specifies a compressed file containing the core file (produced by the dump extractor ( jextract ) tool on AIX\u00ae, Linux\u00ae, and macOS\u00ae systems). -notemp By default, when you specify a file by using the -zip option, the contents are extracted to a temporary directory before processing. Use the -notemp option to prevent this extraction step, and run all subsequent commands in memory. -J-Dcom.ibm.j9ddr.path.mapping=<mappings> The variable <mappings> is a list of native library mappings of the form old-path=new-path , using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). -J-Dcom.ibm.j9ddr.library.path=<path> The variable <path> is a list of paths to search for native libraries, using the usual path separator (a semi-colon (';') on Windows, and a colon (':') on other platforms). Note: The -core option can be used with the -zip option to specify the core file in the compressed file. Without these options, jdmpview shows multiple contexts, one for each source file that it identified in the compressed file. Note: On AIX and Linux, some jdmpview commands need to locate the native libraries that are referenced by the core. For example, commands that relate to callsites. First, check the list of native libraries by running jdmpview on a core with the info mod parameter. If the libraries are not in the original locations, ensure that jdmpview can locate them by specifying the path mapping ( -J-Dcom.ibm.j9ddr.path.mapping=<mappings> ) and library path ( -J-Dcom.ibm.j9ddr.library.path=<path> ) options specified on the jdmpview command line. On z/OS\u00ae, you can copy the dump to an HFS file and supply that as input to jdmpview , or you can supply a fully qualified MVS\u2122 data set name. For example: > jdmpview -core USER1.JVM.TDUMP.SSHD6.D070430.T092211 DTFJView version 4.28.3, using DTFJ version 1.11.28004 Loading image from DTFJ... MVS data set names may contain the dollar sign ($). Names that contain a dollar sign must be enclosed by single quotation marks ('). For example: > jdmpview -core 'USER1.JVM.$TDUMP.SSH$D7.D141211.T045506' After jdmpview processes the dump files, a session starts, showing this message: For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" > If you run the jdmpview tool on a compressed file that contains multiple dumps, the tool detects and shows all the dump files, whether these are system dumps, Java dumps, or heap dumps. Because of this behavior, more than one context might be displayed when you start jdmpview . To switch context, type context <n> , where <n> is the context value for the dump you want to investigate. On z/OS, a system dump can contain multiple address spaces and an address space can contain multiple VM instances. In this case, the context allows you to select the address space and VM instance within the dump file. The following z/OS example shows address spaces ( ASID ), with two JVMs occupying address space 0x73 (context 5 and 6). The current context is 5 ( CTX:5> ), shown with an asterisk. To view the JVM in context 6, you can switch by specifying context 6 . CTX:5> context Available contexts (* = currently selected context) : 0 : ASID: 0x1 : No JRE : No JRE 1 : ASID: 0x3 : No JRE : No JRE 2 : ASID: 0x4 : No JRE : No JRE 3 : ASID: 0x6 : No JRE : No JRE 4 : ASID: 0x7 : No JRE : No JRE *5 : ASID: 0x73 EDB: 0x83d2053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 6 : ASID: 0x73 EDB: 0x8004053a0 : JRE 1.8.0 z/OS s390x-64 build 20181117_128845 (pmz6480-20181120_01) 7 : ASID: 0x73 EDB: 0x4a7bd9e8 : No JRE 8 : ASID: 0xffff : No JRE : No JRE If you are using jdmpview to view Java dumps and heap dumps, some options do not produce any output. For example, a heap dump doesn't contain the information requested by the info system command, but does contain information requested by the info class command. If you are viewing a dump where there are a large number of objects on the heap, you can speed up the performance of jdmpview by ensuring that your system has enough memory available and does not need to page memory to disk. To achieve this, start jdmpview with a larger heap size by specifying the -Xmx option. Use the -J option to pass the -Xmx command line option to the JVM. For example: jdmpview -J-Xmx<n> -core <core file> The options available to the dump viewer session are shown under Session parameters","title":"Starting the dump viewer"},{"location":"tool_jdmpview/#starting-in-batch-mode","text":"For long running or routine jobs, jdmpview can be used in batch mode. You can run a single command without specifying a command file by appending the command to the end of the jdmpview command line. For example: jdmpview -core mycore.dmp info class When specifying jdmpview commands that accept a wildcard parameter, you must replace the wildcard symbol with ALL to prevent the shell interpreting the wildcard symbol. For example, in interactive mode, the command info thread * must be specified in the following way: jdmpview -core mycore.dmp info thread ALL Batch mode is controlled with the following command line options: Option Explanation -cmdfile <path to command file> A file that contains a series of jdmpview commands, which are read and run sequentially. -charset <character set name> The character set for the commands specified in -cmdfile (name must be a supported charset as defined in java.nio.charset.Charset. For example, US-ASCII) -outfile <path to output file> The file to record any output generated by commands. -overwrite If the file specified in -outfile exists, this option overwrites the file. -append If the file specified in -outfile exists, new output messages are appended to the end of that file. The -append and -overwrite options cannot be used at the same time. The command file can have empty lines that contain spaces, or comment lines that start with // or #. These lines are ignored by jdmpview. Example command file: // commands.txt info system info proc To run jdmpview in batch mode, using this command file, specify: jdmpview -outfile out.txt [-overwrite|-append] -cmdfile commands.txt -core <path to core file> When the output file exists, you need to specify either the -overwrite option or the -append option. If you do not, an error message is generated.","title":"Starting in batch mode"},{"location":"tool_jdmpview/#processing-output","text":"You can redirect command output to a file, or pipe the command output to another command. To redirect jdmpview command output to a file, use one of the following formats: command > <target_file> If the target file exists, this redirection overwrites the content within it. command >> <target_file> If the target file exists, this redirection appends the output to it. Where <target_file> is the file name, which can include the full path to the file. To pipe jdmpview command output to another command, use the vertical bar (|) character. For example: command | grep string You can chain more than two commands together by using multiple vertical bar characters. The following commands can be used to interrogate the output: charsFrom charsTo grep tokens","title":"Processing output"},{"location":"tool_jdmpview/#using-charsfrom","text":"Use the charsFrom command after the vertical bar character to exclude all characters that come before a specified pattern in a resulting line. charsFrom <options> pattern Where <options> : -e or -exclude : Exclude the matched pattern from the resulting line. By default, the matched pattern is included in the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays resulting lines that contain the pattern jre , and trims each line to exclude all characters that come before this pattern: > info mod | charsFrom jre jre/lib/ppc64/libzip.so @ 0x0, sections: jre/lib/ppc64/libdbgwrapper80.so @ 0x0, sections: jre/lib/ppc64/libverify.so @ 0x0, sections: jre/lib/ppc64/libjava.so @ 0x0, sections: jre/lib/ppc64/compressedrefs/libjclse7b_28.so @ 0x0, sections:","title":"Using CharsFrom"},{"location":"tool_jdmpview/#using-charsto","text":"Use the CharsTo command after the vertical bar character to include the characters in a resulting line until a specific pattern is found. charsTo <options> pattern Where <options> : -include : Include the matched pattern in the resulting line. By default, the matched pattern is excluded from the resulting line. -keep : Keep lines that do not contain a match to the pattern. By default, lines that do not contain a match are excluded from the results. -i or -ignoreCase : Ignore case. For example, the following command displays lines that contain the pattern \"@\", and trims each line to exclude all characters from \"@\" onwards: > info mod | charsTo @ bin/java /usr/lib64/gconv/UTF-16.so /test/sdk/lib/ppc64le/libnet.so /test/sdk/lib/ppc64le/libnio.so /test/sdk/lib/ppc64le/libzip.so /test/sdk/lib/ppc64le/libjsig.so libjsig.so You can also use charsFrom and charsTo together, separated by a vertical bar character. For example, the following command displays lines that contain the pattern \"lib\", and trims each line to exclude all characters that come before this pattern, as well as all characters from the pattern @ : > info mod | charsFrom lib | charsTo @ lib/ppc64le/libzip.so lib/ppc64le/libjsig.so lib/ppc64le/libverify.so lib/ppc64le/libjava.so lib/ppc64le/compressedrefs/libj9jit29.so Note: The line will not be displayed if the charsFrom and charsTo are used together, but only one of the patterns are matched in a line. Furthermore, the line will not be displayed if both patterns are matched in a line, but the charsTo pattern appears before, and not after, the charsFrom pattern.","title":"Using CharsTo"},{"location":"tool_jdmpview/#using-grep","text":"Use the grep command after the vertical bar character to show which lines match a specified pattern. grep <options> pattern Where <options> : -i : Ignore case. -r , -G , or --regex : Use a regular expression as defined in the Java documentation of the java.utils.regex.Pattern class. -b or --block : Show blocks of lines where at least one of the lines matches the pattern. Blocks of lines are separated by empty lines. -A <NUM> or +<NUM> : Show at most <NUM> lines after the matching line. For example grep -A 2 pattern or grep +2 pattern. -B <NUM> or -<NUM> : Show at most <NUM> lines before the matching line. -C <NUM> or +-<NUM> : Show at most <NUM> lines before and after the matching line. -v or --invert-match : Use with the grep command to show lines that do not match the pattern. These options are equivalent to the grep- command. -F or --fixed-strings : Do not treat the asterisk (*) as a wildcard character. Use these options with the -r , -G , or --regex options. Pattern rules: An asterisk (*) in a pattern is treated as a wildcard character unless you specify the -F or --fixed-strings options. If a pattern contains spaces, enclose the pattern in a pair of double quotation marks (\"). If a pattern contains double quotation marks, enclose the pattern in a pair of single quotation marks ('). You can specify multiple sub-patterns to match by using the following format, but only if you do not use the -r , -G , or --regex options: \"[pattern1|pattern2|...|patternN]\" The initial and trailing double quotation marks and brackets ([ ]) are required. Use a vertical bar character to separate the sub-patterns. Quotation marks and the vertical bar are not allowed in a sub-pattern. Spaces are allowed in the middle of a sub-pattern, but leading and trailing spaces will be trimmed. Use the grep command to show lines that do not match the pattern. For example, the following command displays the number of instances and total heap size for the java/lang/String class: > info class | grep java/lang/String 94 7688 [Ljava/lang/String; 1822 58304 java/lang/String 1 16 java/lang/String$CaseInsensitiveComparator 0 0 java/lang/String$UnsafeHelpers The following command uses two pipes in combination to display the number of instances and total heap size for the java/lang/StringCoding.StringDecoder class: > info class | grep java/lang/String | grep -i decoder 1 48 java/lang/StringCoding$StringDecoder","title":"Using grep"},{"location":"tool_jdmpview/#using-tokens","text":"Use the tokens command after the vertical bar character to isolate specified tokens in the resulting lines. tokens [options] range[,range][..range] You can define range in the following formats: x x,y x..y A set of rules applies to these formats: x or y can be prefixed with \"-\". This means that x or y are counting backwards from the end of a list. For example, a y value of -1 represents the last token in a list, while -2 represents the penultimate token in a list. x must represent a token that either precedes or is at the same position as y. In this format, if x is omitted, it is assumed to be '1'. If y is omitted, it is assumed to be '-1'. For example, the following command displays the first and second token for each resulting line: > info mmap | grep -r ^0x | tokens 1,2 0x0000000000012fff 0x000000000000d000 0x0000000000017fff 0x0000000000004000 0x00000000009dafff 0x0000000000018000 0x00000000009fffff 0x000000000001f000 0x0000000000cbefff 0x0000000000002000 0x0000000000d76fff 0x0000000000001000 0x0000000003145fff 0x0000000000071000 0x0000000003b93fff 0x0000000000003000","title":"Using tokens"},{"location":"tool_jdmpview/#session-parameters","text":"When jdmpview is started, many parameters can be used during the session to interrogate the system dump data, which are divided into general and expert parameters. The general parameters are documented in this section. To see a list of expert parameters, use the !j9help option.","title":"Session parameters"},{"location":"tool_jdmpview/#j9help","text":"!j9help Lists all expert parameters that can be used in a session, with a brief description.","title":"!j9help"},{"location":"tool_jdmpview/#cd","text":"cd <directory_name> Changes the working directory to <directory_name> . The working directory is used for log files. Logging is controlled by the set logging command. Use the pwd command to query the current working directory.","title":"cd"},{"location":"tool_jdmpview/#cmdfile","text":"cmdfile <directory_name> Runs all of the commands in a file. The commands are read line by line and run sequentially. Empty lines, and lines that start with // or # , are ignored. Use the option charset to identify the character set that is used in the chosen file. The character set must be supported, as defined in java.nio.charset.Charset , such as US-ASCII .","title":"cmdfile"},{"location":"tool_jdmpview/#deadlock","text":"This command detects deadlock situations in the Java application that was running when the system dump was produced. Example output: deadlock loop: thread: Thread-2 (monitor object: 0x9e32c8) waiting for => thread: Thread-3 (monitor object: 0x9e3300) waiting for => thread: Thread-2 (monitor object: 0x9e32c8) In this example, the deadlock analysis shows that Thread-2 is waiting for a lock held by Thread-3 , which is in turn waiting for a lock held earlier by Thread-2 . Threads are identified by their Java thread name, whereas object monitors are identified by the address of the object in the Java heap. You can obtain further information about the threads using the info thread * command. You can obtain further information about the monitors using the x/J <0xaddr> command.","title":"deadlock"},{"location":"tool_jdmpview/#find","text":"find <pattern>,<start_address>,<end_address>,<memory_boundary>, <bytes_to_print>,<matches_to_display> This command searches for <pattern> in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the find command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes.","title":"find"},{"location":"tool_jdmpview/#findnext","text":"findptr <pattern>,<start_address>,<end_address>,<memory_boundary>,<bytes_to_print>,<matches_to_display> Finds the next instance of the last string passed to find or findptr . It repeats the previous find or findptr command, depending on which one was issued last, starting from the last match. Searches memory for the given pointer. findptr searches for <pattern> as a pointer in the memory segment from <start_address> to <end_address> (both inclusive), and shows the number of matching addresses you specify with <matches_to_display> . You can also display the next <bytes_to_print> bytes for the last match. By default, the findptr command searches for the pattern at every byte in the range. If you know the pattern is aligned to a particular byte boundary, you can specify <memory_boundary> to search every <memory_boundary> bytes. For example, if you specify a <memory_boundary> of \"4\", the command searches for the pattern every 4 bytes.","title":"findnext"},{"location":"tool_jdmpview/#help","text":"help [<command_name>] Shows information for a specific command. If you supply no parameters, help shows the complete list of supported commands.","title":"help"},{"location":"tool_jdmpview/#history","text":"history|his [-r][<N>] Recalls and displays the history of commands that you have run. The default behavior is to display the 20 most recent commands. If you use the argument <N> , then N commands are displayed. For example, if you run history 35, then the 35 most recent commands are displayed. You can also use the -r option with <N> to run the Nth most recent command in your history. Using the -r option alone runs the most recent command in your history.","title":"history"},{"location":"tool_jdmpview/#info-thread","text":"info thread [*|all|<native_thread_ID>|<zos_TCB_address>] Displays information about Java and native threads. The following information is displayed for all threads (\"*\"), or the specified thread: Thread id Registers Stack sections Thread frames: procedure name and base pointer Thread properties: list of native thread properties and their values. For example: thread priority. Associated Java thread, if applicable: Name of Java thread Address of associated java.lang.Thread object State (shown in JVMTI and java.lang.Thread.State formats) The monitor the thread is waiting for Thread frames: base pointer, method, and filename:line If you supply no parameters, the command shows information about the current thread.","title":"info thread"},{"location":"tool_jdmpview/#info-system","text":"Displays the following information about the system that produced the core dump: Amount of memory Operating system Virtual machine or virtual machines present","title":"info system"},{"location":"tool_jdmpview/#info-class","text":"info class [<class_name>] [-sort:<name>|<count>|<size>] Displays the inheritance chain and other data for a given class. If a class name is passed to info class, the following information is shown about that class: - Name - ID - Superclass ID - Class loader ID - Modifiers - Number of instances and total size of instances - Inheritance chain - Fields with modifiers (and values for static fields) - Methods with modifiers If no parameters are passed to `info class`, the following information is shown: - The number of instances of each class. - The total size of all instances of each class. - The class name - The total number of instances of all classes. - The total size of all objects. The `sort` option allows the list of classes to be sorted by name (default), by number of instances of each class, or by the total size of instances of each class.","title":"info class"},{"location":"tool_jdmpview/#info-proc","text":"Displays threads, command-line arguments, environment variables, and shared modules of the current process. To view the shared modules used by a process, use the info sym command.","title":"info proc"},{"location":"tool_jdmpview/#info-jitm","text":"Displays JIT compiled methods and their addresses: Method name and signature Method start address Method end address","title":"info jitm"},{"location":"tool_jdmpview/#info-lock","text":"Displays a list of available monitors and locked objects.","title":"info lock"},{"location":"tool_jdmpview/#info-sym","text":"Displays a list of available modules. For each process in the address spaces, this command shows a list of module sections for each module, their start and end addresses, names, and sizes.","title":"info sym"},{"location":"tool_jdmpview/#info-mmap","text":"info mmap [<address>] [-verbose] [-sort:<size>|<address>] Displays a summary list of memory sections in the process address space, with start and end address, size, and properties. If an address parameter is specified, the results show details of only the memory section containing the address. If -verbose is specified, full details of the properties of each memory section are displayed. The -sort option allows the list of memory sections to be sorted by size or by start address (default).","title":"info mmap"},{"location":"tool_jdmpview/#info-mod","text":"Displays a list of native library modules in the process address space, which includes file paths and other information about each module.","title":"info mod"},{"location":"tool_jdmpview/#info-heap","text":"info heap [*|<heap_name>*] If no parameters are passed to this command, the heap names and heap sections are shown. Using either \"*\" or a heap name shows the following information about all heaps or the specified heap: Heap name (Heap size and occupancy) Heap sections Section name Section size Whether the section is shared Whether the section is executable Whether the section is read only","title":"info heap"},{"location":"tool_jdmpview/#heapdump","text":"heapdump [<heaps>] Generates a Java heap dump to a file. You can select which Java heaps to dump by listing the heap names, separated by spaces. To see which heaps are available, use the info heap command. By default, all Java heaps are dumped.","title":"heapdump"},{"location":"tool_jdmpview/#hexdump","text":"hexdump <hex_address> <bytes_to_print> Displays a section of memory in a hexdump-like format. Displays <bytes_to_print> bytes of memory contents starting from <hex_address> .","title":"hexdump"},{"location":"tool_jdmpview/#_1","text":"Displays the next section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling forwards through memory. The previous hexdump command is repeated, starting from the end of the previous one.","title":"+"},{"location":"tool_jdmpview/#-","text":"Displays the previous section of memory in hexdump-like format. This command is used with the hexdump command to enable easy scrolling backwards through memory. The previous hexdump command is repeated, starting from a position before the previous one.","title":"-"},{"location":"tool_jdmpview/#pwd","text":"Displays the current working directory, which is the directory where log files are stored.","title":"pwd"},{"location":"tool_jdmpview/#quit","text":"Exits the core file viewing tool; any log files that are currently open are closed before exit.","title":"quit"},{"location":"tool_jdmpview/#set-heapdump","text":"Configures Heapdump generation settings. set heapdump <options> where <options> are: phd : Set the Heapdump format to Portable Heapdump, which is the default. txt : Set the Heapdump format to classic. file <file> : Set the destination of the Heapdump. multiplefiles [on|off] : If multiplefiles is set to on, each Java heap in the system dump is written to a separate file. If multiplefiles is set to off, all Java heaps are written to the same file. The default is off.","title":"set heapdump"},{"location":"tool_jdmpview/#set-logging","text":"set logging <options> Configures logging settings, starts logging, or stops logging. This parameter enables the results of commands to be logged to a file, where <options> are: [on|off] : Turns logging on or off. (Default: off) file <filename> : Sets the file to log to. The path is relative to the directory returned by the pwd command, unless an absolute path is specified. If the file is set while logging is on, the change takes effect the next time logging is started. Not set by default. overwrite [on|off] : Turns overwriting of the specified log file on or off. When overwrite is off, log messages are appended to the log file. When overwrite is on, the log file is overwritten after the set logging command. (Default: off) redirect [on|off] : Turns redirecting to file on or off, with off being the default. When logging is set to on: A value of on for redirect sends non-error output only to the log file. A value of off for redirect sends non-error output to the console and log file. Redirect must be turned off before logging can be turned off. (Default: off)","title":"set logging"},{"location":"tool_jdmpview/#show-heapdump","text":"Displays the current Heapdump generation settings.","title":"show heapdump"},{"location":"tool_jdmpview/#show-logging","text":"Displays the current logging settings: set_logging = [on|off] set_logging_file = set_logging_overwrite = [on|off] set_logging_redirect = [on|off] current_logging_file = The file that is currently being logged to might be different from set_logging_file, if that value was changed after logging was started.","title":"show logging"},{"location":"tool_jdmpview/#whatis-lthex_addressgt","text":"Displays information about whatis stored at the given memory address, <hex_address> . This command examines the memory location at <hex_address> and tries to find out more information about this address. For example: > whatis 0x8e76a8 heap #1 - name: Default@19fce8 0x8e76a8 is within heap segment: 8b0000 -- cb0000 0x8e76a8 is start of an object of type java/lang/Thread","title":"whatis &lt;hex_address&gt;"},{"location":"tool_jdmpview/#x-examine","text":"Passes the number of items to display and the unit size, as listed in the following table, to the sub-command. For example, x/12bd . Abbreviation Unit Size b Byte 8-bit h Half word 16-bit w Word 32-bit g Giant word 64-bit This command is similar to the use of the x/ command in gdb, including the use of defaults.","title":"x/ (examine)"},{"location":"tool_jdmpview/#xj-ltclass_namegtlt0xaddrgt","text":"Displays information about a particular object, or all objects of a class. If <class_name> is supplied, all static fields with their values are shown, followed by all objects of that class with their fields and values. If an object address (in hex) is supplied, static fields for that object's class are not shown; the other fields and values of that object are printed along with its address. Note: This command ignores the number of items and unit size passed to it by the x/ command.","title":"x/J [&lt;class_name&gt;|&lt;0xaddr&gt;]"},{"location":"tool_jdmpview/#xd-0xaddr","text":"Displays the integer at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big endian architecture. This command uses the number of items and unit size passed to it by the x/ command.","title":"x/D &lt;0xaddr&gt;"},{"location":"tool_jdmpview/#xx-0xaddr","text":"Displays the hex value of the bytes at the specified address, adjusted for the hardware architecture this dump file is from. For example, the file might be from a big endian architecture. Note: This command uses the number of items and unit size passed to it by the x/ command.","title":"x/X &lt;0xaddr&gt;"},{"location":"tool_jdmpview/#xk-0xaddr","text":"Where the size is defined by the pointer size of the architecture, this parameter shows the value of each section of memory. The output is adjusted for the hardware architecture this dump file is from, starting at the specified address. It also displays a module with a module section and an offset from the start of that module section in memory if the pointer points to that module section. If no symbol is found, it displays a \"*\" and an offset from the current address if the pointer points to an address in 4KB (4096 bytes) of the current address. Although this command can work on an arbitrary section of memory, it is probably more useful on a section of memory that refers to a stack frame. To find the memory section of a thread stack frame, use the info thread command. Note: This command uses the number of items and unit size passed to it by the x/ command.","title":"x/K &lt;0xaddr&gt;"},{"location":"tool_jdmpview/#example","text":"This example session illustrates a selection of the commands available and their use. In the example session, which is generated on a Linux system, some lines have been removed for clarity (and terseness). User input is prefaced by a greater than symbol (>). test@madras:~/test> sdk/bin/jdmpview -core core.20121116.154147.16838.0001.dmp DTFJView version 4.27.57, using DTFJ version 1.10.27022 Loading image from DTFJ... For a list of commands, type \"help\"; for how to use \"help\", type \"help help\" Available contexts (* = currently selected context) : Source : file:///home/test/core.20121116.154147.16838.0001.dmp *0 : PID: 16867 : JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6480-20121116_01 ) > help + displays the next section of memory in hexdump-like format - displays the previous section of memory in hexdump-like format cd changes the current working directory, used for log files close [context id] closes the connection to a core file context [ID|asid ID] switch to the selected context deadlock displays information about deadlocks if there are any exit Exit the application find searches memory for a given string findnext finds the next instance of the last string passed to \"find\" findptr searches memory for the given pointer heapdump generates a PHD or classic format heapdump help [command name] displays list of commands or help for a specific command hexdump outputs a section of memory in a hexdump-like format info <component> Information about the specified component info class <Java class name> Provides information about the specified Java class info heap [*|heap name] Displays information about Java heaps info jitm Displays JIT'ed methods and their addresses info lock outputs a list of system monitors and locked objects info mmap Outputs a list of all memory segments in the address space info mod outputs module information info proc shortened form of info process info process displays threads, command line arguments, environment info sym an alias for 'mod' info sys shortened form of info system info system displays information about the system the core dump is from info thread displays information about Java and native threads log [name level] display and control instances of java.util.logging.Logger open [path to core or zip] opens the specified core or zip file plugins Plugin management commands list Show the list of loaded plugins for the current context reload Reload plugins for the current context showpath Show the DTFJ View plugin search path for the current context setpath Set the DTFJ View plugin search path for the current context pwd displays the current working directory quit Exit the application set [logging|heapdump] Sets options for the specified command set heapdump configures heapdump format, filename and multiple heap support set logging configures several logging-related parameters, starts/stops logging on turn on logging off turn off logging file turn on logging overwrite controls the overwriting of log files show [logging|heapdump] Displays the current set options for a command show heapdump displays heapdump settings show logging shows the current logging options whatis [hex address] gives information about what is stored at the given memory address x/d <hex address> displays the integer at the specified address x/j <object address> [class name] displays information about a particular object or all objects of a class x/k <hex address> displays the specified memory section as if it were a stack frame parameters x/x <hex address> displays the hex value of the bytes at the specified address > set logging file log.txt logging turned on; outputting to \"/home/test/log.txt\" > info system Machine OS: Linux Hypervisor: PowerVM Machine name: madras Machine IP address(es): 9.20.88.155 System memory: 8269201408 Dump creation time: 2015/08/10 14:44:36:019 Dump creation time (nanoseconds): 21314421467539 Java version: JRE 1.8.0 Linux ppc64-64 build 20121115_128521 (pxp6490-20121116_01) JVM start time: 2015/08/10 14:44:05:690 JVM start time (nanoseconds): 21284086192267 > info thread * native threads for address space process id: 16838 thread id: 16839 registers: native stack sections: native stack frames: properties: associated Java thread: name: main Thread object: java/lang/Thread @ 0x2ffd1e08 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x0000000000085b28 method: void com/ibm/jvm/Dump.SystemDumpImpl() (Native Method) objects: <no objects in this frame> bp: 0x0000000000085b40 method: void com/ibm/jvm/Dump.SystemDump() source: Dump.java:41 objects: <no objects in this frame> bp: 0x0000000000085b68 method: void mySystemDump.main(String[]) source: mySystemDump.java:29 objects: <no objects in this frame> ===Lines Removed=== name: GC Slave id: 16860 Thread object: java/lang/Thread @ 0x3001b980 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::slaveThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: GC Slave id: 16861 Thread object: java/lang/Thread @ 0x3001c180 Priority: 5 Thread.State: WAITING JVMTI state: ALIVE WAITING WAITING_INDEFINITELY IN_OBJECT_WAIT waiting to be notified on: \"MM_ParallelDispatcher::slaveThread\" with ID 0x1004cbc8 owner name: <unowned> Java stack frames: <no frames to print> name: Signal Dispatcher id: 16847 Thread object: com/ibm/misc/SignalDispatcher @ 0x3000f268 Priority: 5 Thread.State: RUNNABLE JVMTI state: ALIVE RUNNABLE Java stack frames: bp: 0x00000000000df748 method: int com/ibm/misc/SignalDispatcher.waitForSignal() (Native Method) objects: <no objects in this frame> bp: 0x00000000000df788 method: void com/ibm/misc/SignalDispatcher.run() source: SignalDispatcher.java:54 objects: 0x30015828 0x30015828 ===Lines Removed=== > info heap * Heap #1: Generational@fff78303d30 Section #1: Heap extent at 0x100d0000 (0x300000 bytes) Size: 3145728 bytes Shared: false Executable: false Read Only: false Section #2: Heap extent at 0x2ffd0000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false Section #3: Heap extent at 0x30050000 (0x80000 bytes) Size: 524288 bytes Shared: false Executable: false Read Only: false > info class java/lang/String name = java/lang/String ID = 0x37c00 superID = 0x30300 classLoader = 0x2ffe9b58 modifiers: public final number of instances: 2146 total size of instances: 51504 bytes Inheritance chain.... java/lang/Object java/lang/String Fields...... static fields for \"java/lang/String\" private static final long serialVersionUID = -6849794470754667710 (0xa0f0a4387a3bb342) public static final java.util.Comparator CASE_INSENSITIVE_ORDER = <object> @ 0x2ffd0278 private static final char[] ascii = <object> @ 0x2ffd02c8 private static String[] stringArray = <object> @ 0x2ffd0298 private static final int stringArraySize = 10 (0xa) static boolean enableCopy = false private static int seed = -126504465 (0xfffffffff875b1ef) private static char[] startCombiningAbove = <object> @ 0x100d0c40 private static char[] endCombiningAbove = <object> @ 0x100d0cc0 private static final char[] upperValues = <object> @ 0x100d0d40 private static final java.io.ObjectStreamField[] serialPersistentFields = <object> @ 0x2ffd0920 non-static fields for \"java/lang/String\" private final char[] value private final int offset private final int count private int hashCode private int hashCode32 Methods...... Bytecode range(s): : private static native int getSeed() Bytecode range(s): fff76d8ce48 -- fff76d8ce5e: public void <init>() Bytecode range(s): fff76d8ce88 -- fff76d8cecd: private void <init>(String, char) Bytecode range(s): fff76d8cf10 -- fff76d8cf19: public void <init>(byte[]) Bytecode range(s): fff76d8cf40 -- fff76d8cf4a: public void <init>(byte[], int) Bytecode range(s): fff76d8cf7c -- fff76d8cfb5: public void <init>(byte[], int, int) Bytecode range(s): fff76d8cff8 -- fff76d8d065: public void <init>(byte[], int, int, int) Bytecode range(s): fff76d8d0c4 -- fff76d8d10c: public void <init>(byte[], int, int, String) ===Lines Removed=== > whatis 0x2ffd0298 heap #1 - name: Generational@fff78303d30 0x2ffd0298 is within heap segment: 2ffd0000 -- 30050000 0x2ffd0298 is the start of an object of type [Ljava/lang/String;","title":"Example"},{"location":"tool_jextract/","text":"Dump extractor ( jextract ) (AIX\u00ae, Linux\u00ae, macOS\u00ae) On some operating systems, copies of executable files and libraries are required for a full analysis of a core dump (you can get some information from the dump without these files, but not as much). Run the jextract utility to collect these extra files and package them into an archive file along with the core dump. To analyze the output, use the dump viewer ( jdmpview ) . Syntax jextract <core file name> [<zip_file>] where: <core file name> is the name of the system dump. <zip_file> is the name you want to give to the processed file. If you do not specify a name, output is written to <core file name>.zip by default. The output is written to the same directory as the core file. Restriction: You must run jextract on the same system that produced the system dump in order to collect the correct executables and libraries referenced in the system dump. You should also run jextract using the same VM level, to avoid any problems. See also Dump viewer ( jdmpview )","title":"Dump extractor"},{"location":"tool_jextract/#dump-extractor-jextract","text":"(AIX\u00ae, Linux\u00ae, macOS\u00ae) On some operating systems, copies of executable files and libraries are required for a full analysis of a core dump (you can get some information from the dump without these files, but not as much). Run the jextract utility to collect these extra files and package them into an archive file along with the core dump. To analyze the output, use the dump viewer ( jdmpview ) .","title":"Dump extractor (jextract)"},{"location":"tool_jextract/#syntax","text":"jextract <core file name> [<zip_file>] where: <core file name> is the name of the system dump. <zip_file> is the name you want to give to the processed file. If you do not specify a name, output is written to <core file name>.zip by default. The output is written to the same directory as the core file. Restriction: You must run jextract on the same system that produced the system dump in order to collect the correct executables and libraries referenced in the system dump. You should also run jextract using the same VM level, to avoid any problems.","title":"Syntax"},{"location":"tool_jextract/#see-also","text":"Dump viewer ( jdmpview )","title":"See also"},{"location":"tool_jmap/","text":"Java memory map ( jmap ) tool Use the jmap tool to get memory information for a particular Java\u2122 process, or list of processes. The tool shows statistics about classes on the heap, including the number of objects and their aggregate size. The command syntax is as follows: jmap [<option>] [<vmid>] <vmid> is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in jps or other Attach API-based tools. Multiple VMIDs can be specified, separated by a space. If you do not specify a VMID, the command reads input from stdin . You can therefore get information for all processes by piping the output of the jps command to jmap : jps -q | jmap -histo IDs of dead processes are silently ignored. On its own, jmap prints help information. To obtain memory information, a -histo argument must be supplied, where the available <options> are as follows: -histo : Prints statistics about classes on the heap, including the number of objects and their aggregate size -histo:live : Prints statistics for live objects only -J : supplies arguments to the Java VM that is running the jmap command. You can use multiple -J options, for example: jmap -J-Xms2m -J-Xmx10m The output has the following format: num object count total size class name ------------------------------------------------- 1 3354 107328 [C 2 717 57360 java.lang.Class 3 2427 38832 java.lang.String 4 50 13200 [J 5 717 11472 java.lang.J9VMInternals$ClassInitializationLock 6 342 8208 java.lang.StringBuilder 7 151 7248 jdk.internal.org.objectweb.asm.Item 8 396 6336 [Ljava.lang.Object; Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. The following tool limitations apply: Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <options> <pid> . Displaying data from core dumps is not supported; use jdmpview instead. Other options , such as -F (force a dump of an unresponsive process) can be accomplished using kill -QUIT <pid> .","title":"Java memory map (jmap) tool"},{"location":"tool_jmap/#java-memory-map-jmap-tool","text":"Use the jmap tool to get memory information for a particular Java\u2122 process, or list of processes. The tool shows statistics about classes on the heap, including the number of objects and their aggregate size. The command syntax is as follows: jmap [<option>] [<vmid>] <vmid> is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in jps or other Attach API-based tools. Multiple VMIDs can be specified, separated by a space. If you do not specify a VMID, the command reads input from stdin . You can therefore get information for all processes by piping the output of the jps command to jmap : jps -q | jmap -histo IDs of dead processes are silently ignored. On its own, jmap prints help information. To obtain memory information, a -histo argument must be supplied, where the available <options> are as follows: -histo : Prints statistics about classes on the heap, including the number of objects and their aggregate size -histo:live : Prints statistics for live objects only -J : supplies arguments to the Java VM that is running the jmap command. You can use multiple -J options, for example: jmap -J-Xms2m -J-Xmx10m The output has the following format: num object count total size class name ------------------------------------------------- 1 3354 107328 [C 2 717 57360 java.lang.Class 3 2427 38832 java.lang.String 4 50 13200 [J 5 717 11472 java.lang.J9VMInternals$ClassInitializationLock 6 342 8208 java.lang.StringBuilder 7 151 7248 jdk.internal.org.objectweb.asm.Item 8 396 6336 [Ljava.lang.Object; Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. The following tool limitations apply: Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <options> <pid> . Displaying data from core dumps is not supported; use jdmpview instead. Other options , such as -F (force a dump of an unresponsive process) can be accomplished using kill -QUIT <pid> .","title":"Java memory map (jmap) tool"},{"location":"tool_jps/","text":"Java process status ( jps ) tool Use the jps tool to query running Java\u2122 processes. The tool shows information for every Java process that is owned by the current user ID on the current host. The command syntax is as follows: jps [<options>] where the available <options> are as follows: -J : supplies arguments to the Java VM that is running the jps command. You can use multiple -J options, for example: jps -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -l : prints the application package name -q : prints only the virtual machine identifiers -m : prints the application arguments -v : prints the Java VM arguments, including those that are produced automatically The output has the following format: <VMID> [[<class_name>|<jar_name>|\"Unknown\"] [<application_args>][<vm_args>]] where VMID is the Attach API virtual machine identifier for the Java process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. For example: $ jps -l 5462 org.foo.bar.MyApplication 14332 openj9.tools.attach.diagnostics.Jps $ jps -q 5462 14332 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. The tool uses the Attach API, and has the following limitations: Does not list Java processes on other hosts, to enhance security Does not list Java processes owned by other users Does not list non-OpenJ9 Java processes Does not list processes whose attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Support for the Java Attach API .","title":"Java process status (jps)"},{"location":"tool_jps/#java-process-status-jps-tool","text":"Use the jps tool to query running Java\u2122 processes. The tool shows information for every Java process that is owned by the current user ID on the current host. The command syntax is as follows: jps [<options>] where the available <options> are as follows: -J : supplies arguments to the Java VM that is running the jps command. You can use multiple -J options, for example: jps -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -l : prints the application package name -q : prints only the virtual machine identifiers -m : prints the application arguments -v : prints the Java VM arguments, including those that are produced automatically The output has the following format: <VMID> [[<class_name>|<jar_name>|\"Unknown\"] [<application_args>][<vm_args>]] where VMID is the Attach API virtual machine identifier for the Java process. This ID is often, but not always, the same as the operating system process ID . One example where the ID might be different is if you specified the system property -Dcom.ibm.tools.attach.id when you started the process. For example: $ jps -l 5462 org.foo.bar.MyApplication 14332 openj9.tools.attach.diagnostics.Jps $ jps -q 5462 14332 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. The tool uses the Attach API, and has the following limitations: Does not list Java processes on other hosts, to enhance security Does not list Java processes owned by other users Does not list non-OpenJ9 Java processes Does not list processes whose attach API is disabled. Note: The Attach API is disabled by default on z/OS. For more information about the Attach API, including how to enable and secure it, see Support for the Java Attach API .","title":"Java process status (jps) tool"},{"location":"tool_jstack/","text":"Java stack ( jstack ) tool Use the jstack tool to obtain Java stack traces and thread information for processes. The tool is similar to the HotSpot tool of the same name; the OpenJ9 version of jstack is an independent implementation, added for compatibility. The command syntax is as follows: jstack <options>* <pid>* Where <pid>* is a list of process IDs. If none are supplied, the process IDs are read from stdin , which allows a user running a Bourne or equivalent shell to query all processes via jps -q | jstack . IDs of inactive processes are silently ignored. The output contains Java stacks and thread information of the specified processes (equivalent to the information provided in java.lang.management.ThreadInfo ). The values for <options>* are as follows: -J : supplies arguments to the Java VM that is running the jstack command. You can use multiple -J options, for example: jstack -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -p : prints the system and agent properties of the process -l : prints more verbose output, including information about locks -h : prints help information Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 .","title":"Java stack (jstack) tool"},{"location":"tool_jstack/#java-stack-jstack-tool","text":"Use the jstack tool to obtain Java stack traces and thread information for processes. The tool is similar to the HotSpot tool of the same name; the OpenJ9 version of jstack is an independent implementation, added for compatibility. The command syntax is as follows: jstack <options>* <pid>* Where <pid>* is a list of process IDs. If none are supplied, the process IDs are read from stdin , which allows a user running a Bourne or equivalent shell to query all processes via jps -q | jstack . IDs of inactive processes are silently ignored. The output contains Java stacks and thread information of the specified processes (equivalent to the information provided in java.lang.management.ThreadInfo ). The values for <options>* are as follows: -J : supplies arguments to the Java VM that is running the jstack command. You can use multiple -J options, for example: jstack -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -p : prints the system and agent properties of the process -l : prints more verbose output, including information about locks -h : prints help information Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 .","title":"Java stack (jstack) tool"},{"location":"tool_jstat/","text":"Java statistics monitoring ( jstat ) tool Use the jstat tool to obtain Java Virtual Machine (JVM) statistics. The tool is similar to the HotSpot tool of the same name; the OpenJ9 version of jstat is an independent implementation, added for compatibility. The command syntax is as follows: jstat [<option>] [<vmid>] where vmid is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in Java process status (jps) tool or other Attach API-based tools. On its own, jstat prints help information. The values for <option> are as follows: -J : supplies arguments to the JVM that is running the jstat command. You can use multiple -J options, for example: jstat -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints help information -options : lists the available command options -class : displays classloading statistics The output has the following format: Class Loaded Class Unloaded 860 0 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 .","title":"Java statistics monitoring (jstat) tool"},{"location":"tool_jstat/#java-statistics-monitoring-jstat-tool","text":"Use the jstat tool to obtain Java Virtual Machine (JVM) statistics. The tool is similar to the HotSpot tool of the same name; the OpenJ9 version of jstat is an independent implementation, added for compatibility. The command syntax is as follows: jstat [<option>] [<vmid>] where vmid is the Attach API virtual machine identifier for the Java process. This ID is typically the same as the operating system process ID , unless you specified the -Dcom.ibm.tools.attach.id system property when you started the process. VMID is shown in Java process status (jps) tool or other Attach API-based tools. On its own, jstat prints help information. The values for <option> are as follows: -J : supplies arguments to the JVM that is running the jstat command. You can use multiple -J options, for example: jstat -J-Xmx10m -J-Dcom.ibm.tools.attach.enable=yes -h : prints help information -options : lists the available command options -class : displays classloading statistics The output has the following format: Class Loaded Class Unloaded 860 0 Restrictions: This tool is not supported and is subject to change or removal in future releases. Although similar in usage and output to the HotSpot tool of the same name, this tool is a different implementation that is specific to OpenJ9. For more information about differences, see Switching to OpenJ9 .","title":"Java statistics monitoring (jstat) tool"},{"location":"tool_migration/","text":"Switching to OpenJ9 OpenJ9 provides the following tools, which might differ in behavior from the HotSpot equivalent. Note: For information about HotSpot equivalences and differences for items other than tools, see New to OpenJ9? Java diagnostic command tool ( jcmd ) Runs diagnostic commands on a specified VM. The main difference from the HotSpot jcmd tool is that the following options are not currently supported: The -f option to read commands from a file. The Perfcounter.print option for displaying performance counters for the target VM. Selecting VMs by main class instead of VMID. Specifying 0 as a VMID to target all VMs. Java memory map tool ( jmap ) Displays information about classes on the heap, including the number of objects and their aggregate size. The main differences from the HotSpot jmap tool are as follows: Uses the Attach API. Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <option> <vmid> , where <vmid> is the Attach API virtual machine identifier for the Java\u2122 process. Does not support displaying data from core dumps; use Dump viewer instead. Does not include a -F option to force a dump of an unresponsive process. User kill -QUIT <pid> instead, where <pid> is the process identifier. For more information, see jmap . Java process status ( jps ) Displays information about running Java processes. The main differences from the HotSpot jps tool are as follows: Runs on Windows\u00ae, AIX\u00ae, and z/OS\u00ae, as well as Linux\u00ae. Uses the Attach API. Shows processes on the current host only. There is no -V option. For more information, see Java process status . Java stack ( jstack ) tool Displays information about Java stack traces and thread information for processes. The main differences from the HotSpot jstack tool are as follows: In the interests of security, the OpenJ9 implementation of jstack prints only information about local processes that are owned by the current user. Printing data for core dumps is not supported. Use the Dump viewer instead. There is no -m option. Printing data for native stack frames is not supported. There is no -F option to force a dump, although this might be accomplished using kill -QUIT <pid> on some platforms. For more information, see jstack . Java statistics monitoring ( jstat ) tool Displays information about Java statistics for processes. The main difference from the HotSpot jstat tool is that this tool only provides the number of classes loaded and the number of class unloaded. For more information, see jstat .","title":"Switching to OpenJ9"},{"location":"tool_migration/#switching-to-openj9","text":"OpenJ9 provides the following tools, which might differ in behavior from the HotSpot equivalent. Note: For information about HotSpot equivalences and differences for items other than tools, see New to OpenJ9?","title":"Switching to OpenJ9"},{"location":"tool_migration/#java-diagnostic-command-tool-jcmd","text":"Runs diagnostic commands on a specified VM. The main difference from the HotSpot jcmd tool is that the following options are not currently supported: The -f option to read commands from a file. The Perfcounter.print option for displaying performance counters for the target VM. Selecting VMs by main class instead of VMID. Specifying 0 as a VMID to target all VMs.","title":"Java diagnostic command tool (jcmd)"},{"location":"tool_migration/#java-memory-map-tool-jmap","text":"Displays information about classes on the heap, including the number of objects and their aggregate size. The main differences from the HotSpot jmap tool are as follows: Uses the Attach API. Displays information only for local processes that are owned by the current user, due to security considerations. You can display information for remote processes by using ssh user@host jmap <option> <vmid> , where <vmid> is the Attach API virtual machine identifier for the Java\u2122 process. Does not support displaying data from core dumps; use Dump viewer instead. Does not include a -F option to force a dump of an unresponsive process. User kill -QUIT <pid> instead, where <pid> is the process identifier. For more information, see jmap .","title":"Java memory map tool (jmap)"},{"location":"tool_migration/#java-process-status-jps","text":"Displays information about running Java processes. The main differences from the HotSpot jps tool are as follows: Runs on Windows\u00ae, AIX\u00ae, and z/OS\u00ae, as well as Linux\u00ae. Uses the Attach API. Shows processes on the current host only. There is no -V option. For more information, see Java process status .","title":"Java process status (jps)"},{"location":"tool_migration/#java-stack-jstack-tool","text":"Displays information about Java stack traces and thread information for processes. The main differences from the HotSpot jstack tool are as follows: In the interests of security, the OpenJ9 implementation of jstack prints only information about local processes that are owned by the current user. Printing data for core dumps is not supported. Use the Dump viewer instead. There is no -m option. Printing data for native stack frames is not supported. There is no -F option to force a dump, although this might be accomplished using kill -QUIT <pid> on some platforms. For more information, see jstack .","title":"Java stack (jstack) tool"},{"location":"tool_migration/#java-statistics-monitoring-jstat-tool","text":"Displays information about Java statistics for processes. The main difference from the HotSpot jstat tool is that this tool only provides the number of classes loaded and the number of class unloaded. For more information, see jstat .","title":"Java statistics monitoring (jstat) tool"},{"location":"tool_traceformat/","text":"Trace formatter ( traceformat ) The trace formatter is a Java\u2122 program that converts binary trace point data in a trace file to a readable form. The formatter requires the TraceFormat.dat and J9TraceFormat.dat files, which contain the formatting templates. The formatter produces a file that contains header information about the VM that produced the binary trace file, a list of threads for which trace points were produced, and the formatted trace points with their time stamp, thread ID, trace point ID, and trace point data. Syntax To use the trace formatter on a binary trace file type: traceformat <input_file> [<output_file>] <parameters> Where <input_file> is the name of the binary trace file to be formatted, and <output_file> is the name of the output file. If you do not specify an output file, the output file is called input_file.fmt . The size of the heap that is needed to format the trace is directly proportional to the number of threads present in the trace file. For large numbers of threads the formatter might run out of memory, generating the error OutOfMemoryError . In this case, increase the heap size by using the -Xmx option. Parameters The following <parameters> are available with the trace formatter: Option Explanation -datfile=<file1.dat>[,<file2.dat>] A comma-separated list of trace formatting data files. By default, the following files are used:$JAVA_HOME/lib/J9TraceFormat.dat and $JAVA_HOME/lib/TraceFormat.dat -format_time=yes|no Specifies whether to format the time stamps into human readable form. The default is yes . -help Displays usage information. -indent Indents trace messages at each Entry trace point and outdents trace messages at each Exit trace point. The default is not to indent the messages. -summary Prints summary information to the screen without generating an output file. -threads=<thread id>[,<thread id>]... Filters the output for the given thread IDs only. thread id is the ID of the thread, which can be specified in decimal or hex (0x) format. Any number of thread IDs can be specified, separated by commas. -timezone=+|-HH:MM Specifies the offset from UTC, as positive or negative hours and minutes, to apply when formatting time stamps. -verbose Output detailed warning and error messages, and performance statistics. Examples The following example shows output from running the trace formatter command: C:\\test>traceformat sample.trc Writing formatted trace output to file sample.trc.fmt Processing 0.4921875Mb of binary trace data Completed processing of 6983 tracepoints with 0 warnings and 0 errors The formatted trace output looks similar to the following extract, which is truncated to show the key areas of information: Trace Summary Service level: JRE 1.8.0 Windows 7 amd64-64 build (pwa6480sr2-20150624_06(SR2)) JVM startup options: -Xoptionsfile=c:\\build\\pwa6480sr2-20150624\\sdk\\lib\\compressedrefs\\options.default .... Processor information: Arch family: AMD64 Processor Sub-type: Opteron Num Processors: 8 Word size: 64 Trace activation information:: FORMAT=c:\\build\\pwa6480sr2-20150624\\sdk\\lib;. MAXIMAL=all{level1} EXCEPTION=j9mm{gclogger} MAXIMAL=all{level2} output=sample Trace file header: JVM start time: 08:58:35.527000000 Generations: 1 Pointer size: 8 Active threads .... 0x000000000f155f00 Attach API wait loop 0x000000000f18b200 Thread-1 0x000000000f190200 Thread-3 Trace Formatted Data Time (UTC) Thread ID Tracepoint ID Type Tracepoint Data 08:58:35.527291919 *0x000000000f010500 j9trc.0 Event Trace engine initialized for VM = 0x3ad4d0 08:58:35.527349836 0x000000000f010500 j9prt.0 Event Trace engine initialized for module j9port 08:58:35.527354040 0x000000000f010500 j9thr.0 Event Trace engine initialized for module j9thr 08:58:35.529409621 *0x000000000f01eb00 j9trc.5 Event Thread started VMthread = 0xf01eb00, name = (unnamed thread), nativeID = 0x24a798 .... 08:58:35.536134516 0x000000000f010500 j9vm.1 Entry >Create RAM class from ROM class 0x3cab680 in class loader 0x3042338 08:58:35.536136384 0x000000000f010500 j9vm.80 Event ROM class 0x3cab680 is named java/lang/Object 08:58:35.536200373 0x000000000f010500 j9vm.2 Exit <Created RAM class 0xf03ef00 from ROM class 0x3cab680","title":"Trace formatter"},{"location":"tool_traceformat/#trace-formatter-traceformat","text":"The trace formatter is a Java\u2122 program that converts binary trace point data in a trace file to a readable form. The formatter requires the TraceFormat.dat and J9TraceFormat.dat files, which contain the formatting templates. The formatter produces a file that contains header information about the VM that produced the binary trace file, a list of threads for which trace points were produced, and the formatted trace points with their time stamp, thread ID, trace point ID, and trace point data.","title":"Trace formatter (traceformat)"},{"location":"tool_traceformat/#syntax","text":"To use the trace formatter on a binary trace file type: traceformat <input_file> [<output_file>] <parameters> Where <input_file> is the name of the binary trace file to be formatted, and <output_file> is the name of the output file. If you do not specify an output file, the output file is called input_file.fmt . The size of the heap that is needed to format the trace is directly proportional to the number of threads present in the trace file. For large numbers of threads the formatter might run out of memory, generating the error OutOfMemoryError . In this case, increase the heap size by using the -Xmx option.","title":"Syntax"},{"location":"tool_traceformat/#parameters","text":"The following <parameters> are available with the trace formatter: Option Explanation -datfile=<file1.dat>[,<file2.dat>] A comma-separated list of trace formatting data files. By default, the following files are used:$JAVA_HOME/lib/J9TraceFormat.dat and $JAVA_HOME/lib/TraceFormat.dat -format_time=yes|no Specifies whether to format the time stamps into human readable form. The default is yes . -help Displays usage information. -indent Indents trace messages at each Entry trace point and outdents trace messages at each Exit trace point. The default is not to indent the messages. -summary Prints summary information to the screen without generating an output file. -threads=<thread id>[,<thread id>]... Filters the output for the given thread IDs only. thread id is the ID of the thread, which can be specified in decimal or hex (0x) format. Any number of thread IDs can be specified, separated by commas. -timezone=+|-HH:MM Specifies the offset from UTC, as positive or negative hours and minutes, to apply when formatting time stamps. -verbose Output detailed warning and error messages, and performance statistics.","title":"Parameters"},{"location":"tool_traceformat/#examples","text":"The following example shows output from running the trace formatter command: C:\\test>traceformat sample.trc Writing formatted trace output to file sample.trc.fmt Processing 0.4921875Mb of binary trace data Completed processing of 6983 tracepoints with 0 warnings and 0 errors The formatted trace output looks similar to the following extract, which is truncated to show the key areas of information: Trace Summary Service level: JRE 1.8.0 Windows 7 amd64-64 build (pwa6480sr2-20150624_06(SR2)) JVM startup options: -Xoptionsfile=c:\\build\\pwa6480sr2-20150624\\sdk\\lib\\compressedrefs\\options.default .... Processor information: Arch family: AMD64 Processor Sub-type: Opteron Num Processors: 8 Word size: 64 Trace activation information:: FORMAT=c:\\build\\pwa6480sr2-20150624\\sdk\\lib;. MAXIMAL=all{level1} EXCEPTION=j9mm{gclogger} MAXIMAL=all{level2} output=sample Trace file header: JVM start time: 08:58:35.527000000 Generations: 1 Pointer size: 8 Active threads .... 0x000000000f155f00 Attach API wait loop 0x000000000f18b200 Thread-1 0x000000000f190200 Thread-3 Trace Formatted Data Time (UTC) Thread ID Tracepoint ID Type Tracepoint Data 08:58:35.527291919 *0x000000000f010500 j9trc.0 Event Trace engine initialized for VM = 0x3ad4d0 08:58:35.527349836 0x000000000f010500 j9prt.0 Event Trace engine initialized for module j9port 08:58:35.527354040 0x000000000f010500 j9thr.0 Event Trace engine initialized for module j9thr 08:58:35.529409621 *0x000000000f01eb00 j9trc.5 Event Thread started VMthread = 0xf01eb00, name = (unnamed thread), nativeID = 0x24a798 .... 08:58:35.536134516 0x000000000f010500 j9vm.1 Entry >Create RAM class from ROM class 0x3cab680 in class loader 0x3042338 08:58:35.536136384 0x000000000f010500 j9vm.80 Event ROM class 0x3cab680 is named java/lang/Object 08:58:35.536200373 0x000000000f010500 j9vm.2 Exit <Created RAM class 0xf03ef00 from ROM class 0x3cab680","title":"Examples"},{"location":"version0.10/","text":"What's new in version 0.10.0 The following new features and notable changes since v.0.9.0 are included in this release: New binaries and changes to supported environments. Change to the default shared classes cache size for OpenJDK 8 builds New information for the SHARED CLASSES section of a Javadump file Support for OpenJDK HotSpot options Features and changes Binaries and supported environments OpenJ9 release 0.10.0 supports OpenJDK 11, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 11 OpenJDK 11 with Eclipse OpenJ9 is a long term support (LTS) release and supersedes OpenJDK 10 with Eclipse OpenJ9. Although it is possible to build an OpenJDK v8 with the OpenJ9 0.10.0 release level, testing at the project is not complete and therefore support is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments Change to the default shared classes cache size For OpenJDK 8 builds, the default shared classes cache size is increased from 16 MB to 300 MB, with a \"soft\" maximum limit for the initial size of the cache set to 64 MB. Certain exceptions apply. For more information, see -Xshareclasses . The new default also applies to OpenJDK 11 builds. New information for the SHARED CLASSES section of a Java dump file The value of the soft maximum size ( -Xscmx ) of the shared classes cache is now recorded in the SHARED CLASSES section of a Java dump file against the string 2SCLTEXTSMB . For example output, see Java dump . Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:HeapDumpPath -XX:[+|-]HeapDumpOnOutOfMemory -XX:ActiveProcessorCount Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.9.0 and v 0.10.0 releases, see the Release notes .","title":"Version 0.10.0"},{"location":"version0.10/#whats-new-in-version-0100","text":"The following new features and notable changes since v.0.9.0 are included in this release: New binaries and changes to supported environments. Change to the default shared classes cache size for OpenJDK 8 builds New information for the SHARED CLASSES section of a Javadump file Support for OpenJDK HotSpot options","title":"What's new in version 0.10.0"},{"location":"version0.10/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.10/#binaries-and-supported-environments","text":"OpenJ9 release 0.10.0 supports OpenJDK 11, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 11 OpenJDK 11 with Eclipse OpenJ9 is a long term support (LTS) release and supersedes OpenJDK 10 with Eclipse OpenJ9. Although it is possible to build an OpenJDK v8 with the OpenJ9 0.10.0 release level, testing at the project is not complete and therefore support is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments","title":"Binaries and supported environments"},{"location":"version0.10/#change-to-the-default-shared-classes-cache-size","text":"For OpenJDK 8 builds, the default shared classes cache size is increased from 16 MB to 300 MB, with a \"soft\" maximum limit for the initial size of the cache set to 64 MB. Certain exceptions apply. For more information, see -Xshareclasses . The new default also applies to OpenJDK 11 builds.","title":"Change to the default shared classes cache size"},{"location":"version0.10/#new-information-for-the-shared-classes-section-of-a-java-dump-file","text":"The value of the soft maximum size ( -Xscmx ) of the shared classes cache is now recorded in the SHARED CLASSES section of a Java dump file against the string 2SCLTEXTSMB . For example output, see Java dump .","title":"New information for the SHARED CLASSES section of a Java dump file"},{"location":"version0.10/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:HeapDumpPath -XX:[+|-]HeapDumpOnOutOfMemory -XX:ActiveProcessorCount","title":"Support for OpenJDK HotSpot options"},{"location":"version0.10/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.9.0 and v 0.10.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.11/","text":"What's new in version 0.11.0 The following new features and notable changes since v 0.10.0 are included in this release: New binaries and changes to supported environments. OpenSSL is now supported for improved native cryptographic performance Changes to the location of the default shared cache and cache snapshot directory New class data sharing suboptions Container awareness in the OpenJ9 VM is now enabled by default Pause-less garbage collection mode is now available on Linux x86 platforms You can now restrict identity hash codes to non-negative values Support for OpenJDK HotSpot options Features and changes Binaries and supported environments OpenJ9 release 0.11.0 provides limited support for the macOS\u00ae platform on OpenJDK 11. Early builds of OpenJDK 11 with OpenJ9 on macOS are available at the AdoptOpenJDK project at the following link: OpenJDK version 11 Support for macOS on OpenJDK 8 is coming soon. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments OpenSSL is now supported for improved native cryptographic performance OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binary due to an unresolved problem. Changes to the location of the default shared cache and cache snapshot directory To increase security, the default shared classes cache directory is changed on non-Windows platforms from /tmp/javasharedresources/ to the user's home directory, unless you specify -Xshareclasses:groupAccess . If you use the groupAccess suboption, the default directory is unchanged because some members of the group might not have access to the user home directory. Note: For persistent caches, the shared classes cache directory cannot be on an NFS mount. If your user home directory is on an NFS mount, either move it or use the -Xshareclasses:cacheDir=<directory> suboption to specify a different directory for the cache. In general, caches cannot be shared across different Java releases, so you cannot re-use a cache that was created by a previous level of Java 11; if you use the name and cacheDir suboptions to specify an existing cache, the VM attempts to delete the cache and create a new one. However, on Windows, the cache cannot be deleted if it is in use, in which case the VM continues to use the existing cache. You can find and remove old caches or snapshots by using the following command-line options: For persistent caches: - -Xshareclasses:cacheDir=/tmp/javasharedresources/,listAllCaches to find the cache - -Xshareclasses:cacheDir=/tmp/javasharedresources/,name=<cacheName>,destroy to remove the cache For nonpersistent caches or snapshots: - -Xshareclasses:cacheDir=/tmp,listAllCaches to find the item - -Xshareclasses:cacheDir=/tmp,name=<snapshotName>,destroySnapshot to remove the item New class data sharing suboptions -Xshareclasses:bootClassesOnly : disables caching of classes that are loaded by non-bootstrap class loaders. This suboption also enables the nonfatal suboption, which allows the VM to start even if there was an error creating the shared classes cache. -Xshareclasses:fatal : prevents the VM from starting if there was an error creating the shared classes cache. You might want to enable this suboption when using the -Xshareclasses:bootClassesOnly suboption, to troubleshoot problems when creating the cache. Container awareness in the OpenJ9 VM is now enabled by default When using container technology, applications are typically run on their own and do not need to compete for memory. If the VM detects that it is running in a container environment, and a memory limit for the container is set, the VM automatically adjusts the maximum default Java heap size. In earlier releases, this behavior was enabled by setting the -XX:+UseContainerSupport option. This setting is now the default. For more information about the Java heap size set for a container, see -XX:[+|-]UseContainerSupport . Pause-less garbage collection mode is now available on Linux x86 platforms Pause-less garbage collection mode is aimed at large heap, response-time sensitive applications. When enabled, the VM attempts to reduce GC pause times. In earlier releases, pause-less garbage collection mode ( -Xgc:concurrentScavenge ) was available only on IBM z14 hardware. This mode is now available on 64-bit x86 Linux platforms. Restrictions: The Generational Concurrent ( gencon ) garbage collection policy must be used. (This is the default policy.) Compressed references must be used. See -Xcompressedrefs . Compressed references are enabled by default when the maximum heap size ( -Xmx ) \u2264 57 GB. The concurrent scavenge option is ignored if the maximum heap size is > 57 GB. You can now restrict identity hash codes to non-negative values OpenJ9 allows both positive and negative identity hashcodes, which can be problematic if your program (incorrectly) assumes hashcodes can only be positive. However, you can now use the -XX:[+|-]PositiveIdentityHash option to limit identity hash codes to non-negative values. Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:MaxHeapSize -XX:InitialHeapSize Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.10.0 and v 0.11.0 releases, see the Release notes .","title":"Version 0.11.0"},{"location":"version0.11/#whats-new-in-version-0110","text":"The following new features and notable changes since v 0.10.0 are included in this release: New binaries and changes to supported environments. OpenSSL is now supported for improved native cryptographic performance Changes to the location of the default shared cache and cache snapshot directory New class data sharing suboptions Container awareness in the OpenJ9 VM is now enabled by default Pause-less garbage collection mode is now available on Linux x86 platforms You can now restrict identity hash codes to non-negative values Support for OpenJDK HotSpot options","title":"What's new in version 0.11.0"},{"location":"version0.11/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.11/#binaries-and-supported-environments","text":"OpenJ9 release 0.11.0 provides limited support for the macOS\u00ae platform on OpenJDK 11. Early builds of OpenJDK 11 with OpenJ9 on macOS are available at the AdoptOpenJDK project at the following link: OpenJDK version 11 Support for macOS on OpenJDK 8 is coming soon. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments","title":"Binaries and supported environments"},{"location":"version0.11/#openssl-is-now-supported-for-improved-native-cryptographic-performance","text":"OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binary due to an unresolved problem.","title":"OpenSSL is now supported for improved native cryptographic performance"},{"location":"version0.11/#changes-to-the-location-of-the-default-shared-cache-and-cache-snapshot-directory","text":"To increase security, the default shared classes cache directory is changed on non-Windows platforms from /tmp/javasharedresources/ to the user's home directory, unless you specify -Xshareclasses:groupAccess . If you use the groupAccess suboption, the default directory is unchanged because some members of the group might not have access to the user home directory. Note: For persistent caches, the shared classes cache directory cannot be on an NFS mount. If your user home directory is on an NFS mount, either move it or use the -Xshareclasses:cacheDir=<directory> suboption to specify a different directory for the cache. In general, caches cannot be shared across different Java releases, so you cannot re-use a cache that was created by a previous level of Java 11; if you use the name and cacheDir suboptions to specify an existing cache, the VM attempts to delete the cache and create a new one. However, on Windows, the cache cannot be deleted if it is in use, in which case the VM continues to use the existing cache. You can find and remove old caches or snapshots by using the following command-line options: For persistent caches: - -Xshareclasses:cacheDir=/tmp/javasharedresources/,listAllCaches to find the cache - -Xshareclasses:cacheDir=/tmp/javasharedresources/,name=<cacheName>,destroy to remove the cache For nonpersistent caches or snapshots: - -Xshareclasses:cacheDir=/tmp,listAllCaches to find the item - -Xshareclasses:cacheDir=/tmp,name=<snapshotName>,destroySnapshot to remove the item","title":"Changes to the location of the default shared cache and cache snapshot directory"},{"location":"version0.11/#new-class-data-sharing-suboptions","text":"-Xshareclasses:bootClassesOnly : disables caching of classes that are loaded by non-bootstrap class loaders. This suboption also enables the nonfatal suboption, which allows the VM to start even if there was an error creating the shared classes cache. -Xshareclasses:fatal : prevents the VM from starting if there was an error creating the shared classes cache. You might want to enable this suboption when using the -Xshareclasses:bootClassesOnly suboption, to troubleshoot problems when creating the cache.","title":"New class data sharing suboptions"},{"location":"version0.11/#container-awareness-in-the-openj9-vm-is-now-enabled-by-default","text":"When using container technology, applications are typically run on their own and do not need to compete for memory. If the VM detects that it is running in a container environment, and a memory limit for the container is set, the VM automatically adjusts the maximum default Java heap size. In earlier releases, this behavior was enabled by setting the -XX:+UseContainerSupport option. This setting is now the default. For more information about the Java heap size set for a container, see -XX:[+|-]UseContainerSupport .","title":"Container awareness in the OpenJ9 VM is now enabled by default"},{"location":"version0.11/#pause-less-garbage-collection-mode-is-now-available-on-linux-x86-platforms","text":"Pause-less garbage collection mode is aimed at large heap, response-time sensitive applications. When enabled, the VM attempts to reduce GC pause times. In earlier releases, pause-less garbage collection mode ( -Xgc:concurrentScavenge ) was available only on IBM z14 hardware. This mode is now available on 64-bit x86 Linux platforms. Restrictions: The Generational Concurrent ( gencon ) garbage collection policy must be used. (This is the default policy.) Compressed references must be used. See -Xcompressedrefs . Compressed references are enabled by default when the maximum heap size ( -Xmx ) \u2264 57 GB. The concurrent scavenge option is ignored if the maximum heap size is > 57 GB.","title":"Pause-less garbage collection mode is now available on Linux x86 platforms"},{"location":"version0.11/#you-can-now-restrict-identity-hash-codes-to-non-negative-values","text":"OpenJ9 allows both positive and negative identity hashcodes, which can be problematic if your program (incorrectly) assumes hashcodes can only be positive. However, you can now use the -XX:[+|-]PositiveIdentityHash option to limit identity hash codes to non-negative values.","title":"You can now restrict identity hash codes to non-negative values"},{"location":"version0.11/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:MaxHeapSize -XX:InitialHeapSize","title":"Support for OpenJDK HotSpot options"},{"location":"version0.11/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.10.0 and v 0.11.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.12/","text":"What's new in version 0.12.x Version 0.12.0 The following new features and notable changes since v 0.11.0 are included in this release: Improved flexibility for managing the size of the JIT code cache Idle-tuning is enabled by default when OpenJ9 runs in a docker container Changes to default shared classes cache directory permissions (not Windows) OpenSSL is now supported for improved native cryptographic performance Improved support for pause-less garbage collection RSA algorithm support for OpenSSL IBM_JAVA_OPTIONS is deprecated Warning: Following the release of OpenJ9 0.12.0, an intermittent problem was identified with OpenSSL V1.1.x acceleration of the cryptographic Digest algorithm. For more information about the issue, see #4530 . You can turn off the Digest algorithm by setting the -Djdk.nativeDigest system property to false . A new release of OpenJ9 (0.12.1) is available that disables the Digest algorithm by default. Features and changes Binaries and supported environments OpenJ9 release 0.12.0 provides support for OpenJDK 8 with OpenJ9 and OpenJDK 11 with OpenJ9 . In this release support is extended to the 64-bit macOS\u00ae platform on OpenJDK with OpenJ9. Builds for all platforms are available from the AdoptOpenJDK project at the following links: OpenJDK 8 with OpenJ9 OpenJDK 11 with OpenJ9 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Improved flexibility for managing the size of the JIT code cache The JIT code cache stores the native code of compiled Java\u2122 methods. By default, the size of the code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. In earlier releases the size of the code cache could be increased from the default value by using the -Xcodecachetotal command line option. In this release the size can also be decreased by using this option, with a minimum size of 2 MB. The size of the JIT code cache also affects the size of the JIT data cache, which holds metadata about compiled methods. If you use the -Xcodecachetotal option to manage the size of the code cache, the size of the data cache is adjusted by the same proportion. For more information, see -Xcodecachetotal . Idle-tuning is enabled by default when OpenJ9 runs in a docker container In an earlier release, a set of idle-tuning options were introduced to manage the footprint of the Java heap when the OpenJ9 VM is in an idle state. These options could be set manually on the command line. In this release, the following two options are enabled by default when OpenJ9 is running in a container: -XX:[+|-]IdleTuningGcOnIdle , which runs a garbage collection cycle and releases free memory pages back to the operating system when the VM state is set to idle. -XX:[+|-]IdleTuningCompactOnIdle , which compacts the object heap to reduce fragmentation when the VM state is set to idle. By default, the VM must be idle for 180 seconds before the status is set to idle. To control the wait time before an idle state is set, use the -XX:IdleTuningMinIdleWaitTime option. To turn off idle detection, set the value to 0 . Changes to default shared classes cache directory permissions (not Windows) If you do not use the cachDirPerm suboption to specify permissions for a shared classes cache directory, and the cache directory is not the /tmp/javasharedresources default, the following changes apply: When creating a new cache directory, the default permissions are now stricter. If the cache directory already exists, permissions are now unchanged (previously, when a cache was opened using this directory, the permissions would be set to 0777). For more information, see -Xshareclasses . OpenSSL is now supported for improved native cryptographic performance OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: OpenJDK 8 with OpenJ9 includes OpenSSL support since v 0.11.0. Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binaries due to an unresolved problem. Improved support for pause-less garbage collection Concurrent scavenge mode is now supported on 64-bit Windows operating systems. In Eclipse OpenJ9 v 0.11.0, support was added for -Xgc:concurrentScavenge on Linux x86-64 virtual machines that use compressed references. In this release, support is now available for Linux x86-64 large-heap virtual machines (non-compressed references). For more information, see the -Xgc:concurrentScavenge option. RSA algorithm support for OpenSSL OpenSSL v1.1 support for the RSA algorithm is added in this release, providing improved cryptographic performance. OpenSSL support is enabled by default. If you want to turn off support for the RSA algorithm, set the -Djdk.nativeRSA system property to false . IBM_JAVA_OPTIONS is deprecated The VM environment variable IBM_JAVA_OPTIONS is deprecated and is replaced by OPENJ9_JAVA_OPTIONS . IBM_JAVA_OPTIONS will be removed in a future release. For more information about the use of this variable, see the general options in Environment variables . Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.11.0 and v 0.12.0 releases, see the Release notes . Version 0.12.1 The following change is implemented since v 0.12.0: By default, OpenJ9 provides native cryptographic acceleration using OpenSSL v 1.1.x for the Digest, CBC, GCM, and RSA algorithms. Under certain circumstances acceleration of the Digest algorithm was found to cause a segmentation error. Cryptographic acceleration of the Digest algorithm is now turned off by default. The system property -Djdk.nativeDigest cannot be used to turn on support. This property is ignored by the VM. Full release information Release notes to describe the changes between Eclipse OpenJ9 v 0.12.0 and v 0.12.1 releases, can be found in the OpenJ9 GitHub repository .","title":"Version 0.12.0"},{"location":"version0.12/#whats-new-in-version-012x","text":"","title":"What's new in version 0.12.x"},{"location":"version0.12/#version-0120","text":"The following new features and notable changes since v 0.11.0 are included in this release: Improved flexibility for managing the size of the JIT code cache Idle-tuning is enabled by default when OpenJ9 runs in a docker container Changes to default shared classes cache directory permissions (not Windows) OpenSSL is now supported for improved native cryptographic performance Improved support for pause-less garbage collection RSA algorithm support for OpenSSL IBM_JAVA_OPTIONS is deprecated Warning: Following the release of OpenJ9 0.12.0, an intermittent problem was identified with OpenSSL V1.1.x acceleration of the cryptographic Digest algorithm. For more information about the issue, see #4530 . You can turn off the Digest algorithm by setting the -Djdk.nativeDigest system property to false . A new release of OpenJ9 (0.12.1) is available that disables the Digest algorithm by default.","title":"Version 0.12.0"},{"location":"version0.12/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.12/#binaries-and-supported-environments","text":"OpenJ9 release 0.12.0 provides support for OpenJDK 8 with OpenJ9 and OpenJDK 11 with OpenJ9 . In this release support is extended to the 64-bit macOS\u00ae platform on OpenJDK with OpenJ9. Builds for all platforms are available from the AdoptOpenJDK project at the following links: OpenJDK 8 with OpenJ9 OpenJDK 11 with OpenJ9 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.12/#improved-flexibility-for-managing-the-size-of-the-jit-code-cache","text":"The JIT code cache stores the native code of compiled Java\u2122 methods. By default, the size of the code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. In earlier releases the size of the code cache could be increased from the default value by using the -Xcodecachetotal command line option. In this release the size can also be decreased by using this option, with a minimum size of 2 MB. The size of the JIT code cache also affects the size of the JIT data cache, which holds metadata about compiled methods. If you use the -Xcodecachetotal option to manage the size of the code cache, the size of the data cache is adjusted by the same proportion. For more information, see -Xcodecachetotal .","title":"Improved flexibility for managing the size of the JIT code cache"},{"location":"version0.12/#idle-tuning-is-enabled-by-default-when-openj9-runs-in-a-docker-container","text":"In an earlier release, a set of idle-tuning options were introduced to manage the footprint of the Java heap when the OpenJ9 VM is in an idle state. These options could be set manually on the command line. In this release, the following two options are enabled by default when OpenJ9 is running in a container: -XX:[+|-]IdleTuningGcOnIdle , which runs a garbage collection cycle and releases free memory pages back to the operating system when the VM state is set to idle. -XX:[+|-]IdleTuningCompactOnIdle , which compacts the object heap to reduce fragmentation when the VM state is set to idle. By default, the VM must be idle for 180 seconds before the status is set to idle. To control the wait time before an idle state is set, use the -XX:IdleTuningMinIdleWaitTime option. To turn off idle detection, set the value to 0 .","title":"Idle-tuning is enabled by default when OpenJ9 runs in a docker container"},{"location":"version0.12/#changes-to-default-shared-classes-cache-directory-permissions-not-windows","text":"If you do not use the cachDirPerm suboption to specify permissions for a shared classes cache directory, and the cache directory is not the /tmp/javasharedresources default, the following changes apply: When creating a new cache directory, the default permissions are now stricter. If the cache directory already exists, permissions are now unchanged (previously, when a cache was opened using this directory, the permissions would be set to 0777). For more information, see -Xshareclasses .","title":"Changes to default shared classes cache directory permissions (not Windows)"},{"location":"version0.12/#openssl-is-now-supported-for-improved-native-cryptographic-performance","text":"OpenSSL is a native open source cryptographic toolkit for Transport Layer Security (TLS) and Secure Sockets Layer (SSL) protocols, which provides improved cryptographic performance compared to the in-built OpenJDK Java cryptographic implementation. The OpenSSL V1.1.x implementation is enabled by default and supported for the Digest, CBC, and GCM algorithms. Binaries obtained from AdoptOpenJDK include OpenSSL v1.1.x (see Note). For more information about tuning the OpenSSL implementation, see Performance tuning . Note: OpenJDK 8 with OpenJ9 includes OpenSSL support since v 0.11.0. Currently, OpenSSL is not bundled as part of the AdoptOpenJDK AIX binaries due to an unresolved problem.","title":"OpenSSL is now supported for improved native cryptographic performance"},{"location":"version0.12/#improved-support-for-pause-less-garbage-collection","text":"Concurrent scavenge mode is now supported on 64-bit Windows operating systems. In Eclipse OpenJ9 v 0.11.0, support was added for -Xgc:concurrentScavenge on Linux x86-64 virtual machines that use compressed references. In this release, support is now available for Linux x86-64 large-heap virtual machines (non-compressed references). For more information, see the -Xgc:concurrentScavenge option.","title":"Improved support for pause-less garbage collection"},{"location":"version0.12/#rsa-algorithm-support-for-openssl","text":"OpenSSL v1.1 support for the RSA algorithm is added in this release, providing improved cryptographic performance. OpenSSL support is enabled by default. If you want to turn off support for the RSA algorithm, set the -Djdk.nativeRSA system property to false .","title":"RSA algorithm support for OpenSSL"},{"location":"version0.12/#ibm_java_options-is-deprecated","text":"The VM environment variable IBM_JAVA_OPTIONS is deprecated and is replaced by OPENJ9_JAVA_OPTIONS . IBM_JAVA_OPTIONS will be removed in a future release. For more information about the use of this variable, see the general options in Environment variables .","title":"IBM_JAVA_OPTIONS is deprecated"},{"location":"version0.12/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.11.0 and v 0.12.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.12/#version-0121","text":"The following change is implemented since v 0.12.0: By default, OpenJ9 provides native cryptographic acceleration using OpenSSL v 1.1.x for the Digest, CBC, GCM, and RSA algorithms. Under certain circumstances acceleration of the Digest algorithm was found to cause a segmentation error. Cryptographic acceleration of the Digest algorithm is now turned off by default. The system property -Djdk.nativeDigest cannot be used to turn on support. This property is ignored by the VM.","title":"Version 0.12.1"},{"location":"version0.12/#full-release-information_1","text":"Release notes to describe the changes between Eclipse OpenJ9 v 0.12.0 and v 0.12.1 releases, can be found in the OpenJ9 GitHub repository .","title":"Full release information"},{"location":"version0.13/","text":"What's new in version 0.13.0 The following new features and notable changes since v 0.12.1 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New Java\u2122 process status tool Writing a Java dump to STDOUT or STDERR Better diagnostic information for Linux systems that implement control groups Improved support for pause-less garbage collection Features and changes Binaries and supported environments OpenJ9 release 0.13.0 supports OpenJDK 12, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 12 OpenJDK 12 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.12.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.13.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Support for OpenSSL 1.0.2 OpenSSL cryptographic support is extended to include OpenSSL 1.0.2 for the Digest, CBC, GCM, and RSA algorithms. Support is enabled by default. On Linux and AIX platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . In addition, support for the OpenSSL Digest algorithm is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path. New Java process status tool A Java process status tool ( jps ) is available for querying running Java processes. For more information, see Java process status . Writing a Java dump to STDOUT or STDERR You can now write a Java dump file to STDOUT or STDERR by using the -Xdump command-line option. See Writing to STDOUT / STDERR for details. Better diagnostic information for Linux systems that implement control groups If you use control groups (cgroups) to manage resources on Linux systems, information about CPU and memory limits is now recorded in a Java dump file. This information is particularly important for applications that run in Docker containers, because when resource limits are set inside a container, the Docker Engine relies on cgroups to enforce the settings. If you are getting a Java OutOfMemoryError error because a container limit has been set on the amount of memory available to an application and this allocation is not sufficient, you can diagnose this problem from the Java dump file. You can find the cgroup information in the ENVINFO section. For sample output, see Java dump (ENVINFO) . Improved support for pause-less garbage collection Concurrent scavenge mode is now supported on the following platforms: Linux on POWER LE AIX For more information, see the -Xgc:concurrentScavenge option. Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.12.1 and v 0.13.0 releases, see the Release notes .","title":"Version 0.13.0"},{"location":"version0.13/#whats-new-in-version-0130","text":"The following new features and notable changes since v 0.12.1 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New Java\u2122 process status tool Writing a Java dump to STDOUT or STDERR Better diagnostic information for Linux systems that implement control groups Improved support for pause-less garbage collection","title":"What's new in version 0.13.0"},{"location":"version0.13/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.13/#binaries-and-supported-environments","text":"OpenJ9 release 0.13.0 supports OpenJDK 12, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 12 OpenJDK 12 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.12.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.13.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.13/#support-for-openssl-102","text":"OpenSSL cryptographic support is extended to include OpenSSL 1.0.2 for the Digest, CBC, GCM, and RSA algorithms. Support is enabled by default. On Linux and AIX platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . In addition, support for the OpenSSL Digest algorithm is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path.","title":"Support for OpenSSL 1.0.2"},{"location":"version0.13/#new-java-process-status-tool","text":"A Java process status tool ( jps ) is available for querying running Java processes. For more information, see Java process status .","title":"New Java process status tool"},{"location":"version0.13/#writing-a-java-dump-to-stdout-or-stderr","text":"You can now write a Java dump file to STDOUT or STDERR by using the -Xdump command-line option. See Writing to STDOUT / STDERR for details.","title":"Writing a Java dump to STDOUT or STDERR"},{"location":"version0.13/#better-diagnostic-information-for-linux-systems-that-implement-control-groups","text":"If you use control groups (cgroups) to manage resources on Linux systems, information about CPU and memory limits is now recorded in a Java dump file. This information is particularly important for applications that run in Docker containers, because when resource limits are set inside a container, the Docker Engine relies on cgroups to enforce the settings. If you are getting a Java OutOfMemoryError error because a container limit has been set on the amount of memory available to an application and this allocation is not sufficient, you can diagnose this problem from the Java dump file. You can find the cgroup information in the ENVINFO section. For sample output, see Java dump (ENVINFO) .","title":"Better diagnostic information for Linux systems that implement control groups"},{"location":"version0.13/#improved-support-for-pause-less-garbage-collection","text":"Concurrent scavenge mode is now supported on the following platforms: Linux on POWER LE AIX For more information, see the -Xgc:concurrentScavenge option.","title":"Improved support for pause-less garbage collection"},{"location":"version0.13/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.12.1 and v 0.13.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.14/","text":"What's new in version 0.14.x Version 0.14.0 The following new features and notable changes since v 0.13.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New option for ignoring or reporting unrecognized -XX: options Improved support for pause-less garbage collection New Java stack ( jstack ) tool for obtaining stack traces and thread information New Java process status ( jps ) tool New experimental option to improve the performance of JVMTI watched fields New option to prevent a network query being used to determine host name and IP address Changes to the shared classes cache generation number Change to the default native stack size on 64-bit z/OS\u00ae Features and changes Binaries and supported environments OpenJ9 release 0.14.0 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Support for OpenSSL 1.0.2 OpenJ9 release 0.13.0 introduced support for OpenSSL 1.0.2 for Java 12. In this release, support is extended to Java 8 and Java 11. OpenSSL is enabled by default for the CBC, Digest, GCM, and RSA cryptographic algorithms. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . Note: Support for the OpenSSL Digest algorithm on Java 8 and 11 is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path. New option for ignoring or reporting unrecognized -XX: options By default, unrecognized -XX: command-line options are ignored, which prevents an application failing to start. You can now use -XX:-IgnoreUnrecognizedXXColonOptions to turn off this behavior, so that unrecognized -XX: options are reported instead. For more information, see -XX:[+|-]IgnoreUnrecognizedXXColonOptions . Improved support for pause-less garbage collection Support for Concurrent scavenge mode is now extended to Linux on POWER\u00ae BE architectures. For more information, see -Xgc:concurrentScavenge . New jstack tool for obtaining stack traces and thread information For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jstack tool. To learn how to use the tool and about any differences compared to the HotSpot tool of the same name, see Java stack tool . New jps tool OpenJ9 release 0.13.0 introduced support for the jps tool for Java 12. In this release, support is added for Java 8 and 11. The jps tool can be used to query running Java processes. For more information, see Java process status . New experimental option to improve the performance of JVMTI watched fields The -XX:[+|-]JITInlineWatches option is introduced in this release. When enabled, the option turns on experimental JIT operations that are intended to improve the performance of JVMTI watched fields. This option is currently supported only on x86 platforms (Windows\u00ae, macOS\u00ae, and Linux). New option to prevent a network query being used to determine host name and IP address By default, a network query is used to determine the host name and IP address for troubleshooting purposes. To avoid your program waiting to time out if a nameserver cannot be contacted, you can now prevent the query from being performed. For more information, see -XX:[+|-]ReadIPInfoForRAS . Changes to the shared classes cache generation number On all platforms, the format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache, rather than re-creating or reusing an existing cache. To save space, all existing shared caches can be removed unless they are in use by an earlier release. For more information about destroying a shared classes cache, see -Xshareclasses . Change to the default native stack size on 64-bit z/OS The default stack size for operating system threads on 64-bit z/OS is changed from 384 KB to the operating system minimum of 1 MB. For more information about this setting, see -Xmso . Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.13.0 and v 0.14.0 releases, see the Release notes . Version 0.14.2 The following new features and notable changes since v 0.14.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.1 OpenSSL Digest algorithm disabled Features and changes Binaries and supported environments OpenJ9 release 0.14.2 supports OpenJDK 8 and 11. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 The Windows (MSI) installer for OpenJDK v8 (64-bit) can now be used to optionally install the IcedTea-Web package, which provides equivalent functionality to Java Web Start. For more information about the installer, see the AdoptOpenJDK Installation page . For more information about migrating to IcedTea-Web, read the AdoptOpenJDK Migration Guide . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Support for OpenSSL 1.0.1 OpenSSL version 1.0.1 support is now enabled; Earlier releases supported only OpenSSL 1.0.2 and 1.1.x. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . OpenSSL Digest algorithm disabled Due to issue #5611 , the Digest algorithm is disabled.","title":"Version 0.14.0"},{"location":"version0.14/#whats-new-in-version-014x","text":"","title":"What's new in version 0.14.x"},{"location":"version0.14/#version-0140","text":"The following new features and notable changes since v 0.13.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.2 New option for ignoring or reporting unrecognized -XX: options Improved support for pause-less garbage collection New Java stack ( jstack ) tool for obtaining stack traces and thread information New Java process status ( jps ) tool New experimental option to improve the performance of JVMTI watched fields New option to prevent a network query being used to determine host name and IP address Changes to the shared classes cache generation number Change to the default native stack size on 64-bit z/OS\u00ae","title":"Version 0.14.0"},{"location":"version0.14/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.14/#binaries-and-supported-environments","text":"OpenJ9 release 0.14.0 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.14/#support-for-openssl-102","text":"OpenJ9 release 0.13.0 introduced support for OpenSSL 1.0.2 for Java 12. In this release, support is extended to Java 8 and Java 11. OpenSSL is enabled by default for the CBC, Digest, GCM, and RSA cryptographic algorithms. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations . Note: Support for the OpenSSL Digest algorithm on Java 8 and 11 is re-enabled in this release following the resolution of issue #4530 . Warning: Earlier versions of OpenJDK with OpenJ9 from the AdoptOpenJDK project bundle OpenSSL as part of the binary package. On Linux and AIX systems, OpenSSL is no longer bundled and the libraries are expected to be available on the system path.","title":"Support for OpenSSL 1.0.2"},{"location":"version0.14/#new-option-for-ignoring-or-reporting-unrecognized-xx-options","text":"By default, unrecognized -XX: command-line options are ignored, which prevents an application failing to start. You can now use -XX:-IgnoreUnrecognizedXXColonOptions to turn off this behavior, so that unrecognized -XX: options are reported instead. For more information, see -XX:[+|-]IgnoreUnrecognizedXXColonOptions .","title":"New option for ignoring or reporting unrecognized -XX: options"},{"location":"version0.14/#improved-support-for-pause-less-garbage-collection","text":"Support for Concurrent scavenge mode is now extended to Linux on POWER\u00ae BE architectures. For more information, see -Xgc:concurrentScavenge .","title":"Improved support for pause-less garbage collection"},{"location":"version0.14/#new-jstack-tool-for-obtaining-stack-traces-and-thread-information","text":"For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jstack tool. To learn how to use the tool and about any differences compared to the HotSpot tool of the same name, see Java stack tool .","title":"New jstack tool for obtaining stack traces and thread information"},{"location":"version0.14/#new-jps-tool","text":"OpenJ9 release 0.13.0 introduced support for the jps tool for Java 12. In this release, support is added for Java 8 and 11. The jps tool can be used to query running Java processes. For more information, see Java process status .","title":"New jps tool"},{"location":"version0.14/#new-experimental-option-to-improve-the-performance-of-jvmti-watched-fields","text":"The -XX:[+|-]JITInlineWatches option is introduced in this release. When enabled, the option turns on experimental JIT operations that are intended to improve the performance of JVMTI watched fields. This option is currently supported only on x86 platforms (Windows\u00ae, macOS\u00ae, and Linux).","title":"New experimental option to improve the performance of JVMTI watched fields"},{"location":"version0.14/#new-option-to-prevent-a-network-query-being-used-to-determine-host-name-and-ip-address","text":"By default, a network query is used to determine the host name and IP address for troubleshooting purposes. To avoid your program waiting to time out if a nameserver cannot be contacted, you can now prevent the query from being performed. For more information, see -XX:[+|-]ReadIPInfoForRAS .","title":"New option to prevent a network query being used to determine host name and IP address"},{"location":"version0.14/#changes-to-the-shared-classes-cache-generation-number","text":"On all platforms, the format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache, rather than re-creating or reusing an existing cache. To save space, all existing shared caches can be removed unless they are in use by an earlier release. For more information about destroying a shared classes cache, see -Xshareclasses .","title":"Changes to the shared classes cache generation number"},{"location":"version0.14/#change-to-the-default-native-stack-size-on-64-bit-zos","text":"The default stack size for operating system threads on 64-bit z/OS is changed from 384 KB to the operating system minimum of 1 MB. For more information about this setting, see -Xmso .","title":"Change to the default native stack size on 64-bit z/OS"},{"location":"version0.14/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.13.0 and v 0.14.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.14/#version-0142","text":"The following new features and notable changes since v 0.14.0 are included in this release: New binaries and changes to supported environments Support for OpenSSL 1.0.1 OpenSSL Digest algorithm disabled","title":"Version 0.14.2"},{"location":"version0.14/#features-and-changes_1","text":"","title":"Features and changes"},{"location":"version0.14/#binaries-and-supported-environments_1","text":"OpenJ9 release 0.14.2 supports OpenJDK 8 and 11. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 The Windows (MSI) installer for OpenJDK v8 (64-bit) can now be used to optionally install the IcedTea-Web package, which provides equivalent functionality to Java Web Start. For more information about the installer, see the AdoptOpenJDK Installation page . For more information about migrating to IcedTea-Web, read the AdoptOpenJDK Migration Guide . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.14/#support-for-openssl-101","text":"OpenSSL version 1.0.1 support is now enabled; Earlier releases supported only OpenSSL 1.0.2 and 1.1.x. On Linux\u00ae and AIX\u00ae platforms, the OpenSSL libraries are expected to be available on the system path. For more information about cryptographic acceleration with OpenSSL, see Cryptographic operations .","title":"Support for OpenSSL 1.0.1"},{"location":"version0.14/#openssl-digest-algorithm-disabled","text":"Due to issue #5611 , the Digest algorithm is disabled.","title":"OpenSSL Digest algorithm disabled"},{"location":"version0.15/","text":"What's new in version 0.15.1 The following new features and notable changes since v 0.14.0 are included in this release: New binaries and changes to supported environments Performance improvements for JVMTI watched fields Support for pause-less garbage collection on IBM Z systems ChaCha20 algorithm support for OpenSSL OpenSSL Digest algorithm disabled Support for OpenJDK HotSpot options Support for Transparent Huge Pages (THP) Support for low-overhead heap profiling (JEP 331) New Java memory map (jmap) tool Automatically setting an initial heap size Removal of -Xdiagnosticscollector option Change in behaviour of -XX:[+|-]IdleTuningCompactOnIdle Addition of heuristics for compaction during idle GC Change in shared classes behavior for checking timestamps of jar or zip files Features and changes Binaries and supported environments OpenJ9 release 0.15.0 and 0.15.1 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 Note: The binaries at AdoptOpenJDK are labeled 0.15.1 due to a missing change. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Performance improvements for JVMTI watched fields OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which, when enabled, turned on experimental JIT operations to improve the performance of JVMTI watched fields. Following successful results, this option is now enabled by default. This option is now also supported on z/OS\u00ae and Linux for IBM Z\u00ae, in addition to x86 platforms (Windows\u00ae, macOS\u00ae, and Linux). Support for pause-less garbage collection on IBM Z systems Support for Concurrent scavenge mode is now extended to Linux on IBM Z\u00ae systems and z/OS\u00ae. For more information, see -Xgc:concurrentScavenge . ChaCha20 algorithm support for OpenSSL The ChaCha20 and ChaCha20-Poly1305 algorithms can now use OpenSSL on Java 11. For more information, see -Djdk.nativeChaCha20 . OpenSSL Digest algorithm disabled Due to issue #5611 , the Digest algorithm is disabled. This algorithm was disabled for Java 8 and 11 in release 0.14.2, which did not support Java 12. Support for OpenJDK HotSpot options For compatibility, the -XX:OnOutOfMemoryError OpenJDK HotSpot option is now supported by OpenJ9. Support for Transparent Huge Pages (THP) The VM now supports the allocation of huge pages on Linux when you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting. To enable this feature, set -XX:+TransparentHugePage on the command line when you start your application. This option is currently not enabled by default. Support for low-overhead heap profiling JEP 331 provides a mechanism for sampling Java heap allocations with a low overhead via the JVM Tool Interface (JVMTI). Restrictions: JEP 331 is implemented for OpenJ9 with the following limitations: The balanced and metronome garbage collection policies are not supported. The JEP331 JVMTI agent and the Health Center agent both set a sampling interval, which by default is different. If both agents are used at the same time the Health Center agent will get incorrect results, unless the sampling intervals are adjusted to use the same value. New Java memory map tool The Java memory map (jmap) tool is similar to the HotSpot tool of the same name, and can be used to print statistics about classes on the heap, including the number of objects and their aggregate size. For usage information, see Java memory map (jmap) tool . Automatically setting an initial heap size OpenJ9 can now learn and set an appropriate initial heap size for an application as an alternative to a user manually sizing and setting an -Xms value. The VM records the size of the heap when startup processing ends, writing this data to the shared classes cache. An average value is set over a few restarts, helping to ensure that the value used for the initial heap size is as accurate as possible. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. To turn on this behavior, set the -XX:+UseGCStartupHints option on the command line when you start your application. Removal of -Xdiagnosticscollector option This option was redundant and has now been removed. If you try to use this option on the command line, the VM outputs this error message: JVMJ9VM007E Command-line option unrecognised: -Xdiagnosticscollector Change in behaviour of -XX:IdleTuningCompactOnIdle -XX:[+|-]IdleTuningCompactOnIdle is now no longer effective when -XX:+IdleTuningGcOnIdle is not specified. Heuristics for compaction during idle GC OpenJ9 now automatically compacts the heap when certain triggers are met during idle garbage collection (GC). As a result of this change, -XX:[+|-]IdleTuningCompactOnIdle is deprecated. Change in shared classes behavior for checking timestamps of jar or zip files In earlier releases, the shared classes cache checks timestamps of jar or zip files every time a class is loaded and reloads a class if the timestamp has changed. This behavior is now changed; timestamps are checked only when zip or jar files are added to class loaders and used for the first time to look for a class, which can improve class-loading performance. If jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. To revert to the behavior of earlier releases, set the -Xshareclasses:checkURLTimestamps option on the command line when you start your application. Note: Multiple -Xshareclasses: options are not combined, only the last one is used. Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.14.0 and v 0.15.1 releases, see the Release notes .","title":"Version 0.15.1"},{"location":"version0.15/#whats-new-in-version-0151","text":"The following new features and notable changes since v 0.14.0 are included in this release: New binaries and changes to supported environments Performance improvements for JVMTI watched fields Support for pause-less garbage collection on IBM Z systems ChaCha20 algorithm support for OpenSSL OpenSSL Digest algorithm disabled Support for OpenJDK HotSpot options Support for Transparent Huge Pages (THP) Support for low-overhead heap profiling (JEP 331) New Java memory map (jmap) tool Automatically setting an initial heap size Removal of -Xdiagnosticscollector option Change in behaviour of -XX:[+|-]IdleTuningCompactOnIdle Addition of heuristics for compaction during idle GC Change in shared classes behavior for checking timestamps of jar or zip files","title":"What's new in version 0.15.1"},{"location":"version0.15/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.15/#binaries-and-supported-environments","text":"OpenJ9 release 0.15.0 and 0.15.1 supports OpenJDK 8, 11, and 12. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 12 Note: The binaries at AdoptOpenJDK are labeled 0.15.1 due to a missing change. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.15/#performance-improvements-for-jvmti-watched-fields","text":"OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which, when enabled, turned on experimental JIT operations to improve the performance of JVMTI watched fields. Following successful results, this option is now enabled by default. This option is now also supported on z/OS\u00ae and Linux for IBM Z\u00ae, in addition to x86 platforms (Windows\u00ae, macOS\u00ae, and Linux).","title":"Performance improvements for JVMTI watched fields"},{"location":"version0.15/#support-for-pause-less-garbage-collection-on-ibm-z-systems","text":"Support for Concurrent scavenge mode is now extended to Linux on IBM Z\u00ae systems and z/OS\u00ae. For more information, see -Xgc:concurrentScavenge .","title":"Support for pause-less garbage collection on IBM Z systems"},{"location":"version0.15/#chacha20-algorithm-support-for-openssl","text":"The ChaCha20 and ChaCha20-Poly1305 algorithms can now use OpenSSL on Java 11. For more information, see -Djdk.nativeChaCha20 .","title":"ChaCha20 algorithm support for OpenSSL"},{"location":"version0.15/#openssl-digest-algorithm-disabled","text":"Due to issue #5611 , the Digest algorithm is disabled. This algorithm was disabled for Java 8 and 11 in release 0.14.2, which did not support Java 12.","title":"OpenSSL Digest algorithm disabled"},{"location":"version0.15/#support-for-openjdk-hotspot-options","text":"For compatibility, the -XX:OnOutOfMemoryError OpenJDK HotSpot option is now supported by OpenJ9.","title":"Support for OpenJDK HotSpot options"},{"location":"version0.15/#support-for-transparent-huge-pages-thp","text":"The VM now supports the allocation of huge pages on Linux when you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting. To enable this feature, set -XX:+TransparentHugePage on the command line when you start your application. This option is currently not enabled by default.","title":"Support for Transparent Huge Pages (THP)"},{"location":"version0.15/#support-for-low-overhead-heap-profiling","text":"JEP 331 provides a mechanism for sampling Java heap allocations with a low overhead via the JVM Tool Interface (JVMTI). Restrictions: JEP 331 is implemented for OpenJ9 with the following limitations: The balanced and metronome garbage collection policies are not supported. The JEP331 JVMTI agent and the Health Center agent both set a sampling interval, which by default is different. If both agents are used at the same time the Health Center agent will get incorrect results, unless the sampling intervals are adjusted to use the same value.","title":"Support for low-overhead heap profiling"},{"location":"version0.15/#new-java-memory-map-tool","text":"The Java memory map (jmap) tool is similar to the HotSpot tool of the same name, and can be used to print statistics about classes on the heap, including the number of objects and their aggregate size. For usage information, see Java memory map (jmap) tool .","title":"New Java memory map tool"},{"location":"version0.15/#automatically-setting-an-initial-heap-size","text":"OpenJ9 can now learn and set an appropriate initial heap size for an application as an alternative to a user manually sizing and setting an -Xms value. The VM records the size of the heap when startup processing ends, writing this data to the shared classes cache. An average value is set over a few restarts, helping to ensure that the value used for the initial heap size is as accurate as possible. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. To turn on this behavior, set the -XX:+UseGCStartupHints option on the command line when you start your application.","title":"Automatically setting an initial heap size"},{"location":"version0.15/#removal-of-xdiagnosticscollector-option","text":"This option was redundant and has now been removed. If you try to use this option on the command line, the VM outputs this error message: JVMJ9VM007E Command-line option unrecognised: -Xdiagnosticscollector","title":"Removal of -Xdiagnosticscollector option"},{"location":"version0.15/#change-in-behaviour-of-xxidletuningcompactonidle","text":"-XX:[+|-]IdleTuningCompactOnIdle is now no longer effective when -XX:+IdleTuningGcOnIdle is not specified.","title":"Change in behaviour of -XX:IdleTuningCompactOnIdle"},{"location":"version0.15/#heuristics-for-compaction-during-idle-gc","text":"OpenJ9 now automatically compacts the heap when certain triggers are met during idle garbage collection (GC). As a result of this change, -XX:[+|-]IdleTuningCompactOnIdle is deprecated.","title":"Heuristics for compaction during idle GC"},{"location":"version0.15/#change-in-shared-classes-behavior-for-checking-timestamps-of-jar-or-zip-files","text":"In earlier releases, the shared classes cache checks timestamps of jar or zip files every time a class is loaded and reloads a class if the timestamp has changed. This behavior is now changed; timestamps are checked only when zip or jar files are added to class loaders and used for the first time to look for a class, which can improve class-loading performance. If jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. To revert to the behavior of earlier releases, set the -Xshareclasses:checkURLTimestamps option on the command line when you start your application. Note: Multiple -Xshareclasses: options are not combined, only the last one is used.","title":"Change in shared classes behavior for checking timestamps of jar or zip files"},{"location":"version0.15/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.14.0 and v 0.15.1 releases, see the Release notes .","title":"Full release information"},{"location":"version0.16/","text":"What's new in version 0.16.0 The following new features and notable changes since v 0.15.1 are included in this release: New binaries and changes to supported environments Some class data sharing is enabled by default Automatic setting of initial heap size is enabled by default Option to share VM anonymous classes Performance improvements for JVMTI watched fields on Power Systems Linux on x86: Support for Transparent Huge Pages (THP) New Java\u2122 diagnostic command ( jcmd ) tool Changes to the shared classes cache generation number The -Xverify:none and -noverify options are deprecated Features and changes Binaries and supported environments OpenJ9 release 0.16.0 supports OpenJDK 13, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 13 OpenJDK 13 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.15.2. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.16.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Some class data sharing is enabled by default Class data sharing is enabled by default for bootstrap classes, unless your application is running in a container. You can use the -Xshareclasses option to change the default behavior, including using -Xshareclasses:none to disable all class data sharing. For more information, see Class data sharing . Automatic setting of initial heap size is enabled by default OpenJ9 version 0.15.1 introduced the -XX:[+|-]UseGCStartupHints option, which, when enabled, turned on the automatic learning and setting of an appropriate heap size for an application. This option is now enabled by default. Option to share VM anonymous classes Prior to version 0.16.0, anonymous classes, those created by Unsafe.defineAnonymousClass , were not stored in the shared classes cache. They are now stored there by default, which means they are available for ahead-of-time (AOT) compilation, potentially improving startup performance. A new command, -XX:[+|-]ShareAnonymousClasses , is introduced that enables you to stop anonymous classes being stored in the shared classes cache. Performance improvements for JVMTI watched fields on Power Systems OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which turns on JIT operations to improve the performance of JVMTI watched fields. This option, which was enabled by default in version 0.15.1, is now also supported on AIX\u00ae and Linux on Power Systems\u2122. Linux\u00ae on x86: Support for Transparent Huge Pages (THP) When you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting on Linux on x86 systems, THP is now enabled by default. To disable this feature, set -XX:-TransparentHugePage on the command line when you start your application. The THP setting on other systems remains disabled by default when you use madvise , but can be enabled by setting -XX:+TransparentHugePage . New jcmd tool For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jcmd tool for running diagnostic commands on a VM. For more information, see Java diagnostic command tool . Changes to the shared classes cache generation number The format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache rather than re-creating or reusing an existing cache. To save space, you can remove all existing shared caches unless they are in use by an earlier release. As a result of the format change, a layer column now appears in the output of the -Xshareclasses:listAllCaches option. This change is to support a future enhancement. For more information about the -Xshareclasses option, including the destroy options that you can use to remove caches, see -Xshareclasses . The -Xverify:none and -noverify options are deprecated The option -Xverify:none (and its equivalent -noverify ) is deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions. Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.15.1 and v 0.16.0 releases, see the Release notes .","title":"Version 0.16.0"},{"location":"version0.16/#whats-new-in-version-0160","text":"The following new features and notable changes since v 0.15.1 are included in this release: New binaries and changes to supported environments Some class data sharing is enabled by default Automatic setting of initial heap size is enabled by default Option to share VM anonymous classes Performance improvements for JVMTI watched fields on Power Systems Linux on x86: Support for Transparent Huge Pages (THP) New Java\u2122 diagnostic command ( jcmd ) tool Changes to the shared classes cache generation number The -Xverify:none and -noverify options are deprecated","title":"What's new in version 0.16.0"},{"location":"version0.16/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.16/#binaries-and-supported-environments","text":"OpenJ9 release 0.16.0 supports OpenJDK 13, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 13 OpenJDK 13 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.15.2. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.16.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.16/#some-class-data-sharing-is-enabled-by-default","text":"Class data sharing is enabled by default for bootstrap classes, unless your application is running in a container. You can use the -Xshareclasses option to change the default behavior, including using -Xshareclasses:none to disable all class data sharing. For more information, see Class data sharing .","title":"Some class data sharing is enabled by default"},{"location":"version0.16/#automatic-setting-of-initial-heap-size-is-enabled-by-default","text":"OpenJ9 version 0.15.1 introduced the -XX:[+|-]UseGCStartupHints option, which, when enabled, turned on the automatic learning and setting of an appropriate heap size for an application. This option is now enabled by default.","title":"Automatic setting of initial heap size is enabled by default"},{"location":"version0.16/#option-to-share-vm-anonymous-classes","text":"Prior to version 0.16.0, anonymous classes, those created by Unsafe.defineAnonymousClass , were not stored in the shared classes cache. They are now stored there by default, which means they are available for ahead-of-time (AOT) compilation, potentially improving startup performance. A new command, -XX:[+|-]ShareAnonymousClasses , is introduced that enables you to stop anonymous classes being stored in the shared classes cache.","title":"Option to share VM anonymous classes"},{"location":"version0.16/#performance-improvements-for-jvmti-watched-fields-on-power-systems","text":"OpenJ9 version 0.14.0 introduced the -XX:[+|-]JITInlineWatches option, which turns on JIT operations to improve the performance of JVMTI watched fields. This option, which was enabled by default in version 0.15.1, is now also supported on AIX\u00ae and Linux on Power Systems\u2122.","title":"Performance improvements for JVMTI watched fields on Power Systems"},{"location":"version0.16/#linux-on-x86-support-for-transparent-huge-pages-thp","text":"When you use the madvise ( /sys/kernel/mm/transparent_hugepage/enabled ) setting on Linux on x86 systems, THP is now enabled by default. To disable this feature, set -XX:-TransparentHugePage on the command line when you start your application. The THP setting on other systems remains disabled by default when you use madvise , but can be enabled by setting -XX:+TransparentHugePage .","title":"Linux&reg; on x86: Support for Transparent Huge Pages (THP)"},{"location":"version0.16/#new-jcmd-tool","text":"For compatibility with the reference implementation, OpenJ9 now includes an independent implementation of the jcmd tool for running diagnostic commands on a VM. For more information, see Java diagnostic command tool .","title":"New jcmd tool"},{"location":"version0.16/#changes-to-the-shared-classes-cache-generation-number","text":"The format of classes that are stored in the shared classes cache is changed, which causes the JVM to create a new shared classes cache rather than re-creating or reusing an existing cache. To save space, you can remove all existing shared caches unless they are in use by an earlier release. As a result of the format change, a layer column now appears in the output of the -Xshareclasses:listAllCaches option. This change is to support a future enhancement. For more information about the -Xshareclasses option, including the destroy options that you can use to remove caches, see -Xshareclasses .","title":"Changes to the shared classes cache generation number"},{"location":"version0.16/#the-xverifynone-and-noverify-options-are-deprecated","text":"The option -Xverify:none (and its equivalent -noverify ) is deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions.","title":"The -Xverify:none and -noverify options are deprecated"},{"location":"version0.16/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.15.1 and v 0.16.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.17/","text":"What's new in version 0.17.0 The following new features and notable changes since v 0.16.0 are included in this release: New binaries and changes to supported environments New shared classes cache suboptions for layered caches New shared classes cache suboption to skip disk space check Option to share 'Unsafe' classes Option to record class relationships in the verifier Support for the IBM z15\u00ae processor Digest algorithm is re-enabled Direct Dump Reader (DDR) VM restriction removed The format of the HOOKS section of a Java dump has changed LUDCL caching disabled by default Features and changes Binaries and supported environments OpenJ9 release 0.17.0 supports OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: The Windows\u00ae and macOS\u00ae binaries from the AdoptOpenJDK community for OpenJDK 8, 11, and 13 have been updated to OpenSSL v1.1.1d. Look for the following release names to identify these packages: OpenJDK 8: jdk8u232-b09.1_openj9-0.17.0 OpenJDK 11: jdk-11.0.5+10.1_openj9-0.17.0 OpenjDK 13: jdk-13.0.1+9.1_openj9-0.17.0) Note: The last release of OpenJDK 8 and 11 from AdoptOpenJDK is Eclipse OpenJ9 0.15.1. To read about other features and changes in the VM since 0.15.1, check the Version 0.16.0 release notes too. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . New shared classes cache suboptions for layered caches (Experimental, 64-bit only) New suboptions are available for creating layered caches, where a cache builds on another cache with the same name. You can use these suboptions to save space when building a Docker container, for example. Note: Because these suboptions are experimental, do not use them in a production environment. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers New shared classes cache suboption to skip disk space check When creating a persistent shared classes cache, the OpenJ9 VM checks that there is sufficient disk space available on the file system. For file systems that do not support the checking of free space, you can set the -Xshareclasses:noPersistentDiskSpaceCheck option, which causes the VM to skip the space checking operation. If there isn't enough disk space available when the cache is written, a SIGBUS or SIGSEGV signal occurs and the VM ends. For more information, see the -Xshareclasses:noPersistentDiskSpaceCheck option. Option to share 'Unsafe' classes Classes created through Unsafe.defineClass are now stored by default in the shared classes cache. You can use the -XX:-ShareUnsafeClasses option to change the default behavior. For more information, see -XX:[+|-]ShareUnsafeClasses . Option to record class relationships in the verifier A new command line option -XX:+ClassRelationshipVerifier allows you to record class relationships in the verifier, which avoids unnecessary class loading and reduces VM startup time. This is a new approach to bytecode verification that delays validating the relationships between classes until the classes are required to be loaded for a program's execution thus loading only those classes that are needed. For more information, see -XX:[+|-]ClassRelationshipVerifier . Support for the IBM z15 processor This release adds JIT compiler support for exploiting z15 instructions. Digest algorithm is re-enabled Issue #5611 is fixed, so support for the Digest algorithm is re-enabled. For more information about this support, see Cryptographic operations . Direct Dump Reader (DDR) VM restriction removed Prior to this version, you had to use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core when using DDR. This restriction has now been removed. The format of the HOOKS section of a Java dump has changed The format of the HOOKS section of a Java dump, which shows internal VM event callbacks, has changed: Recorded times have been changed from milliseconds to microseconds to provide increased precision. A new field, 3HKTOTALTIME , is included, which gives the total duration of previous events. The hook data is now reset after each Java dump. For more information and an example of the new format, see Java dump: HOOKS LUDCL caching disabled by default By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now disabled by default due to issue #7332 . Note: Versions of the documentation before 0.17.0 incorrectly identified this property as disabled by default when it was actually enabled by default in the VM. Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.16 and v 0.17.0 releases, see the Release notes .","title":"Version 0.17.0"},{"location":"version0.17/#whats-new-in-version-0170","text":"The following new features and notable changes since v 0.16.0 are included in this release: New binaries and changes to supported environments New shared classes cache suboptions for layered caches New shared classes cache suboption to skip disk space check Option to share 'Unsafe' classes Option to record class relationships in the verifier Support for the IBM z15\u00ae processor Digest algorithm is re-enabled Direct Dump Reader (DDR) VM restriction removed The format of the HOOKS section of a Java dump has changed LUDCL caching disabled by default","title":"What's new in version 0.17.0"},{"location":"version0.17/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.17/#binaries-and-supported-environments","text":"OpenJ9 release 0.17.0 supports OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: The Windows\u00ae and macOS\u00ae binaries from the AdoptOpenJDK community for OpenJDK 8, 11, and 13 have been updated to OpenSSL v1.1.1d. Look for the following release names to identify these packages: OpenJDK 8: jdk8u232-b09.1_openj9-0.17.0 OpenJDK 11: jdk-11.0.5+10.1_openj9-0.17.0 OpenjDK 13: jdk-13.0.1+9.1_openj9-0.17.0) Note: The last release of OpenJDK 8 and 11 from AdoptOpenJDK is Eclipse OpenJ9 0.15.1. To read about other features and changes in the VM since 0.15.1, check the Version 0.16.0 release notes too. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.17/#new-shared-classes-cache-suboptions-for-layered-caches","text":"(Experimental, 64-bit only) New suboptions are available for creating layered caches, where a cache builds on another cache with the same name. You can use these suboptions to save space when building a Docker container, for example. Note: Because these suboptions are experimental, do not use them in a production environment. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers","title":"New shared classes cache suboptions for layered caches"},{"location":"version0.17/#new-shared-classes-cache-suboption-to-skip-disk-space-check","text":"When creating a persistent shared classes cache, the OpenJ9 VM checks that there is sufficient disk space available on the file system. For file systems that do not support the checking of free space, you can set the -Xshareclasses:noPersistentDiskSpaceCheck option, which causes the VM to skip the space checking operation. If there isn't enough disk space available when the cache is written, a SIGBUS or SIGSEGV signal occurs and the VM ends. For more information, see the -Xshareclasses:noPersistentDiskSpaceCheck option.","title":"New shared classes cache suboption to skip disk space check"},{"location":"version0.17/#option-to-share-unsafe-classes","text":"Classes created through Unsafe.defineClass are now stored by default in the shared classes cache. You can use the -XX:-ShareUnsafeClasses option to change the default behavior. For more information, see -XX:[+|-]ShareUnsafeClasses .","title":"Option to share 'Unsafe' classes"},{"location":"version0.17/#option-to-record-class-relationships-in-the-verifier","text":"A new command line option -XX:+ClassRelationshipVerifier allows you to record class relationships in the verifier, which avoids unnecessary class loading and reduces VM startup time. This is a new approach to bytecode verification that delays validating the relationships between classes until the classes are required to be loaded for a program's execution thus loading only those classes that are needed. For more information, see -XX:[+|-]ClassRelationshipVerifier .","title":"Option to record class relationships in the verifier"},{"location":"version0.17/#support-for-the-ibm-z15-processor","text":"This release adds JIT compiler support for exploiting z15 instructions.","title":"Support for the IBM z15 processor"},{"location":"version0.17/#digest-algorithm-is-re-enabled","text":"Issue #5611 is fixed, so support for the Digest algorithm is re-enabled. For more information about this support, see Cryptographic operations .","title":"Digest algorithm is re-enabled"},{"location":"version0.17/#direct-dump-reader-ddr-vm-restriction-removed","text":"Prior to this version, you had to use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core when using DDR. This restriction has now been removed.","title":"Direct Dump Reader (DDR) VM restriction removed"},{"location":"version0.17/#the-format-of-the-hooks-section-of-a-java-dump-has-changed","text":"The format of the HOOKS section of a Java dump, which shows internal VM event callbacks, has changed: Recorded times have been changed from milliseconds to microseconds to provide increased precision. A new field, 3HKTOTALTIME , is included, which gives the total duration of previous events. The hook data is now reset after each Java dump. For more information and an example of the new format, see Java dump: HOOKS","title":"The format of the HOOKS section of a Java dump has changed"},{"location":"version0.17/#ludcl-caching-disabled-by-default","text":"By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now disabled by default due to issue #7332 . Note: Versions of the documentation before 0.17.0 incorrectly identified this property as disabled by default when it was actually enabled by default in the VM.","title":"LUDCL caching disabled by default"},{"location":"version0.17/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.16 and v 0.17.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.18/","text":"What's new in version 0.18.1 The following new features and notable changes since v 0.17.0 are included in this release: Binaries and supported environments Technical preview of JITServer technology jextract now available on macOS\u00ae for OpenJDK version 8 New shared-classes cache suboption to turn off timestamp checking Removal of restriction on layered shared cache -Xmso 1 MB minimum value on z/OS\u00ae 64-bit jstat : new Java\u2122 statistics monitoring tool -XX:+TransparentHugePage is enabled by default on more Linux\u00ae systems New exit dump agent and ExitOnOutOfMemoryError option LUDCL caching enabled by default Terabytes suffix support for -X and -XX options that take a size Improved support for pause-less garbage collection -Xgc:noConcurrentScavenge option Support for OpenJDK HotSpot options Shared classes cache suboptions for layered caches no longer experimental -Djava.lang.string.substring.nocopy option Features and changes Binaries and supported environments OpenJ9 releases 0.18.0 and 0.18.1 support OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: Binaries at AdoptOpenJDK that are labeled 0.18.1 include additional bug fixes. For more information, see the release notes . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Technical preview of JITServer technology A technical preview of JITServer technology is included in this release. It's currently available for OpenJDK 8 and OpenJDK 11 running on Linux on x86-64. JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and even performance of Java applications. For more information, see JITServer technology . jextract now available on macOS for OpenJDK version 8 The jextract tool is now available on macOS platforms (as well as AIX\u00ae and Linux) for all current versions of OpenJDK: 8, 11, and 13. New shared-classes cache suboption to turn off timestamp checking You can set the -Xshareclasses:noTimestampChecks option to turn off timestamp checking in shared classes. For more information, see the -Xshareclasses:noTimestampChecks option. Removal of restriction on layered shared cache In the previous release, there is a restriction that the jvmtiSharedCacheInfo.isCorrupt field and the SharedClassCacheInfo.isCacheCorrupt() method cannot detect a corrupted cache that has a layer number other than 0 . This restriction is now removed. See the Shared classes API documentation . -Xmso 1 MB minimum value on z/OS 64-bit On z/OS 64-bit, -Xmso has a 1 MB minimum value, to match the minimum stack space provided by the operating system. If you set a value smaller than 1 MB, the value is ignored. jstat : new Java statistics monitoring tool For compatibility with the HotSpot implementation, OpenJ9 now includes an independent implementation of the jstat tool for retrieving statistics on a VM. For more information, see Java statistics monitoring tool . -XX:+TransparentHugePage is enabled by default on more Linux systems -XX:+TransparentHugePage is enabled by default on Linux systems for POWER\u00ae and IBM Z\u00ae as well as x86 systems. This option takes affect only when Transparent Huge Pages (THP) is set to madvise on your system. When Transparent Huge Pages are used, your application footprint might increase. New exit dump agent and ExitOnOutOfMemoryError option The new exit dump agent shuts down the VM when the specified event occurs. The exit agent is at priority level 0 and the tool agent has been moved to priority level 1 to aid in mimicking the behavior of HotSpot options. For more information about dump agents, see -Xdump . OpenJ9 now supports the HotSpot option -XX:[+|-]ExitOnOutOfMemoryError . You can set this option to have the VM shut down when a java.lang.OutOfMemory error is thrown by the VM or in Java code. The exit dump agent is used in the implementation of -XX:[+|-]ExitOnOutOfMemoryError . LUDCL caching enabled by default By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now enabled by default. This feature was disabled for the 0.17.0 release due to issue #7332 which has now been resolved. Terabytes suffix support for -X and -XX options that take a size OpenJ9 now supports 't' and 'T' suffixes (indicating terabytes) for -X and -XX options that take a <size> parameter. Improved support for pause-less garbage collection Support for Concurrent scavenge mode is now extended to macOS. For more information, see -Xgc:concurrentScavenge . -Xgc:noConcurrentScavenge option The previously undocumented option -Xgc:noConcurrentScavenge disables pause-less garbage collection. Support for OpenJDK HotSpot options For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:ParallelGCThreads -XX:ConcGCThreads -XX:ParallelCMSThreads Shared classes cache suboptions for layered caches no longer experimental The suboptions for creating layered caches are no longer marked experimental. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers -Djava.lang.string.substring.nocopy option The previously undocumented Java 8 option -Djava.lang.string.substring.nocopy=true avoids String sharing by String.substring(), which is the same behavior as the Oracle HotSpot VM. Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.17.0 and v 0.18.0 releases, see the Release notes .","title":"Version 0.18.1"},{"location":"version0.18/#whats-new-in-version-0181","text":"The following new features and notable changes since v 0.17.0 are included in this release: Binaries and supported environments Technical preview of JITServer technology jextract now available on macOS\u00ae for OpenJDK version 8 New shared-classes cache suboption to turn off timestamp checking Removal of restriction on layered shared cache -Xmso 1 MB minimum value on z/OS\u00ae 64-bit jstat : new Java\u2122 statistics monitoring tool -XX:+TransparentHugePage is enabled by default on more Linux\u00ae systems New exit dump agent and ExitOnOutOfMemoryError option LUDCL caching enabled by default Terabytes suffix support for -X and -XX options that take a size Improved support for pause-less garbage collection -Xgc:noConcurrentScavenge option Support for OpenJDK HotSpot options Shared classes cache suboptions for layered caches no longer experimental -Djava.lang.string.substring.nocopy option","title":"What's new in version 0.18.1"},{"location":"version0.18/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.18/#binaries-and-supported-environments","text":"OpenJ9 releases 0.18.0 and 0.18.1 support OpenJDK 8, 11, and 13. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 13 Note: Binaries at AdoptOpenJDK that are labeled 0.18.1 include additional bug fixes. For more information, see the release notes . To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.18/#technical-preview-of-jitserver-technology","text":"A technical preview of JITServer technology is included in this release. It's currently available for OpenJDK 8 and OpenJDK 11 running on Linux on x86-64. JITServer technology decouples the JIT compiler from the VM and lets the JIT compiler run remotely in its own process. This mechanism prevents your Java application suffering possible negative effects due to CPU and memory consumption caused by JIT compilation. This technology can improve quality of service, robustness, and even performance of Java applications. For more information, see JITServer technology .","title":"Technical preview of JITServer technology"},{"location":"version0.18/#jextract-now-available-on-macos-for-openjdk-version-8","text":"The jextract tool is now available on macOS platforms (as well as AIX\u00ae and Linux) for all current versions of OpenJDK: 8, 11, and 13.","title":"jextract now available on macOS for OpenJDK version 8"},{"location":"version0.18/#new-shared-classes-cache-suboption-to-turn-off-timestamp-checking","text":"You can set the -Xshareclasses:noTimestampChecks option to turn off timestamp checking in shared classes. For more information, see the -Xshareclasses:noTimestampChecks option.","title":"New shared-classes cache suboption to turn off timestamp checking"},{"location":"version0.18/#removal-of-restriction-on-layered-shared-cache","text":"In the previous release, there is a restriction that the jvmtiSharedCacheInfo.isCorrupt field and the SharedClassCacheInfo.isCacheCorrupt() method cannot detect a corrupted cache that has a layer number other than 0 . This restriction is now removed. See the Shared classes API documentation .","title":"Removal of restriction on layered shared cache"},{"location":"version0.18/#-xmso-1-mb-minimum-value-on-zos-64-bit","text":"On z/OS 64-bit, -Xmso has a 1 MB minimum value, to match the minimum stack space provided by the operating system. If you set a value smaller than 1 MB, the value is ignored.","title":"-Xmso 1 MB minimum value on z/OS 64-bit"},{"location":"version0.18/#jstat-new-java-statistics-monitoring-tool","text":"For compatibility with the HotSpot implementation, OpenJ9 now includes an independent implementation of the jstat tool for retrieving statistics on a VM. For more information, see Java statistics monitoring tool .","title":"jstat: new Java statistics monitoring tool"},{"location":"version0.18/#-xxtransparenthugepage-is-enabled-by-default-on-more-linux-systems","text":"-XX:+TransparentHugePage is enabled by default on Linux systems for POWER\u00ae and IBM Z\u00ae as well as x86 systems. This option takes affect only when Transparent Huge Pages (THP) is set to madvise on your system. When Transparent Huge Pages are used, your application footprint might increase.","title":"-XX:+TransparentHugePage is enabled by default on more Linux systems"},{"location":"version0.18/#new-exit-dump-agent-and-exitonoutofmemoryerror-option","text":"The new exit dump agent shuts down the VM when the specified event occurs. The exit agent is at priority level 0 and the tool agent has been moved to priority level 1 to aid in mimicking the behavior of HotSpot options. For more information about dump agents, see -Xdump . OpenJ9 now supports the HotSpot option -XX:[+|-]ExitOnOutOfMemoryError . You can set this option to have the VM shut down when a java.lang.OutOfMemory error is thrown by the VM or in Java code. The exit dump agent is used in the implementation of -XX:[+|-]ExitOnOutOfMemoryError .","title":"New exit dump agent and ExitOnOutOfMemoryError option"},{"location":"version0.18/#ludcl-caching-enabled-by-default","text":"By caching the Latest User Defined Class Loader (LUDCL), Java applications that use deserialization extensively can see a performance improvement. This capability is controlled by the -Dcom.ibm.enableClassCaching system property and is now enabled by default. This feature was disabled for the 0.17.0 release due to issue #7332 which has now been resolved.","title":"LUDCL caching enabled by default"},{"location":"version0.18/#terabytes-suffix-support-for-x-and-xx-options-that-take-a-size","text":"OpenJ9 now supports 't' and 'T' suffixes (indicating terabytes) for -X and -XX options that take a <size> parameter.","title":"Terabytes suffix support for -X and -XX options that take a size"},{"location":"version0.18/#improved-support-for-pause-less-garbage-collection","text":"Support for Concurrent scavenge mode is now extended to macOS. For more information, see -Xgc:concurrentScavenge .","title":"Improved support for pause-less garbage collection"},{"location":"version0.18/#-xgcnoconcurrentscavenge-option","text":"The previously undocumented option -Xgc:noConcurrentScavenge disables pause-less garbage collection.","title":"-Xgc:noConcurrentScavenge option"},{"location":"version0.18/#support-for-openjdk-hotspot-options","text":"For compatibility, the following OpenJDK HotSpot options are now supported by OpenJ9: -XX:ParallelGCThreads -XX:ConcGCThreads -XX:ParallelCMSThreads","title":"Support for OpenJDK HotSpot options"},{"location":"version0.18/#shared-classes-cache-suboptions-for-layered-caches-no-longer-experimental","text":"The suboptions for creating layered caches are no longer marked experimental. The new options are: createLayer layer=<number> (see this section for more information about layered caches) printTopLayerStats destroyAllLayers","title":"Shared classes cache suboptions for layered caches no longer experimental"},{"location":"version0.18/#-djavalangstringsubstringnocopy-option","text":"The previously undocumented Java 8 option -Djava.lang.string.substring.nocopy=true avoids String sharing by String.substring(), which is the same behavior as the Oracle HotSpot VM.","title":"-Djava.lang.string.substring.nocopy option"},{"location":"version0.18/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.17.0 and v 0.18.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.19/","text":"What's new in version 0.19.0 The following new features and notable changes since v 0.18.0 are included in this release: New binaries and changes to supported environments Option to print code cache usage to stderr at VM shutdown StringBuffer and StringBuilder above 1 G grow to the maximum size jpackage packaging tool platform support Extended messages for NullPointerException not yet implemented Compiler changes for Linux Features and changes Binaries and supported environments OpenJ9 release 0.19.0 supports OpenJDK 14, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 14 OpenJDK 14 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.18.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.19.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Option to print code cache usage to stderr at VM shutdown A new command line option -XX:+PrintCodeCache allows you to print the code cache memory usage to stderr when the VM shuts down. StringBuffer and StringBuilder above 1 G grow to the maximum size A 1 G char[] or larger StringBuffer and StringBuilder now immediately grows to the maximum possible size for all current versions of Java, including Java 8. For Java 8 only, you can revert to the previous behavior of growing only as much as necessary to accommodate the String being added, by using the option, -Djava.lang.stringBuffer.growAggressively=false . jpackage packaging tool platform support The jpackage utility is described in JEP 343 as a tool that \"packages a Java application into a platform-specific package that includes all of the necessary dependencies.\" Full details of the tool are available at JEP 343: Packaging Tool . Be aware that jpackage is supported on only the following OpenJ9 platforms: Linux\u00ae, macOS\u00ae, and Windows\u2122. It is not supported on AIX\u00ae or z/OS\u00ae platforms. Extended messages for NullPointerException not yet implemented JEP 358: Helpful NullPointerExceptions provides extended messages when a NullPointerException is generated by the Java 14 VM and you have enabled the feature. However, be aware that this is not implemented in OpenJ9 at this time. Compiler changes for Linux Linux x86 64-bit, Linux on POWER\u00ae LE 64-bit, and Linux on IBM Z\u00ae 64-bit have all moved to the gcc 7.5 compiler. See Supported environments . Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.18.0 and v 0.19.0 releases, see the Release notes .","title":"Version 0.19.0"},{"location":"version0.19/#whats-new-in-version-0190","text":"The following new features and notable changes since v 0.18.0 are included in this release: New binaries and changes to supported environments Option to print code cache usage to stderr at VM shutdown StringBuffer and StringBuilder above 1 G grow to the maximum size jpackage packaging tool platform support Extended messages for NullPointerException not yet implemented Compiler changes for Linux","title":"What's new in version 0.19.0"},{"location":"version0.19/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.19/#binaries-and-supported-environments","text":"OpenJ9 release 0.19.0 supports OpenJDK 14, which is available from the AdoptOpenJDK community at the following link: OpenJDK version 14 OpenJDK 14 with Eclipse OpenJ9 is not a long term support (LTS) release. The latest builds of OpenJDK with OpenJ9 for Java 8 and 11 at the AdoptOpenJDK community are for Eclipse OpenJ9 release 0.18.0. Features mentioned in these release notes are not available in these builds. Although it might be possible to build an OpenJDK 8 or OpenJDK 11 with OpenJ9 0.19.0, testing at the project is not complete and therefore support for any of these features is not available. To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.19/#option-to-print-code-cache-usage-to-stderr-at-vm-shutdown","text":"A new command line option -XX:+PrintCodeCache allows you to print the code cache memory usage to stderr when the VM shuts down.","title":"Option to print code cache usage to stderr at VM shutdown"},{"location":"version0.19/#stringbuffer-and-stringbuilder-above-1-g-grow-to-the-maximum-size","text":"A 1 G char[] or larger StringBuffer and StringBuilder now immediately grows to the maximum possible size for all current versions of Java, including Java 8. For Java 8 only, you can revert to the previous behavior of growing only as much as necessary to accommodate the String being added, by using the option, -Djava.lang.stringBuffer.growAggressively=false .","title":"StringBuffer and StringBuilder above 1 G grow to the maximum size"},{"location":"version0.19/#jpackage-packaging-tool-platform-support","text":"The jpackage utility is described in JEP 343 as a tool that \"packages a Java application into a platform-specific package that includes all of the necessary dependencies.\" Full details of the tool are available at JEP 343: Packaging Tool . Be aware that jpackage is supported on only the following OpenJ9 platforms: Linux\u00ae, macOS\u00ae, and Windows\u2122. It is not supported on AIX\u00ae or z/OS\u00ae platforms.","title":"jpackage packaging tool platform support"},{"location":"version0.19/#extended-messages-for-nullpointerexception-not-yet-implemented","text":"JEP 358: Helpful NullPointerExceptions provides extended messages when a NullPointerException is generated by the Java 14 VM and you have enabled the feature. However, be aware that this is not implemented in OpenJ9 at this time.","title":"Extended messages for NullPointerException not yet implemented"},{"location":"version0.19/#compiler-changes-for-linux","text":"Linux x86 64-bit, Linux on POWER\u00ae LE 64-bit, and Linux on IBM Z\u00ae 64-bit have all moved to the gcc 7.5 compiler. See Supported environments .","title":"Compiler changes for Linux"},{"location":"version0.19/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.18.0 and v 0.19.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.20/","text":"What's new in version 0.20.0 The following new features and notable changes since v 0.19.0 are included in this release: Binaries and supported environments Limited support for 64-bit Linux on ARM -XX:[+|-]ExitOnOutOfMemoryError option behavior update New -XX:[+|-]GlobalLockReservation option added Change to default maximum heap size for Java 8 Change to jcmd default options Features and changes Binaries and supported environments OpenJ9 release 0.20.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Limited support for 64-bit Linux on ARM Limited support is available in this release for the 64-bit ARM (AArch64) architecture. An early access build on OpenJDK 11 is available from the AdoptOpenJDK community . See the OpenJ9 release notes for any known issues that are still being worked on before this platform is fully supported. -XX:[+|-]ExitOnOutOfMemoryError option behavior update The -XX:[+|-]ExitOnOutOfMemoryError option is updated to exit only on VM OutOfMemoryErrors instead of both VM and Java\u2122 thrown errors to match the HotSpot option. See -XX:[+|-]ExitOnOutOfMemoryError for more details about this option. New -XX:[+|-]GlobalLockReservation option added (AIX and Linux on Power systems only) Option -XX:[+|-]GlobalLockReservation enables a new optimization targeted towards more efficient handling of locking and unlocking Java objects. See -XX:[+|-]GlobalLockReservation for more details about this option. Change to default maximum heap size for Java 8 For consistency with Java 11, the default maximum heap size ( -Xmx ) is changed to be 25% of the available memory with a maximum of 25 GB. Where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. If you want to revert to the default setting in earlier releases of OpenJ9, use the -XX:+OriginalJDK8HeapSizeCompatibilityMode option. Change to jcmd default options The Java diagnostic command ( jcmd ) tool no longer requires a filename when used with the Dump.java , Dump.snap , or Dump.system options. See jcmd for more information about the tool. Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.19.0 and v 0.20.0 releases, see the Release notes .","title":"Version 0.20.0"},{"location":"version0.20/#whats-new-in-version-0200","text":"The following new features and notable changes since v 0.19.0 are included in this release: Binaries and supported environments Limited support for 64-bit Linux on ARM -XX:[+|-]ExitOnOutOfMemoryError option behavior update New -XX:[+|-]GlobalLockReservation option added Change to default maximum heap size for Java 8 Change to jcmd default options","title":"What's new in version 0.20.0"},{"location":"version0.20/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.20/#binaries-and-supported-environments","text":"OpenJ9 release 0.20.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.20/#limited-support-for-64-bit-linux-on-arm","text":"Limited support is available in this release for the 64-bit ARM (AArch64) architecture. An early access build on OpenJDK 11 is available from the AdoptOpenJDK community . See the OpenJ9 release notes for any known issues that are still being worked on before this platform is fully supported.","title":"Limited support for 64-bit Linux on ARM"},{"location":"version0.20/#-xx-exitonoutofmemoryerror-option-behavior-update","text":"The -XX:[+|-]ExitOnOutOfMemoryError option is updated to exit only on VM OutOfMemoryErrors instead of both VM and Java\u2122 thrown errors to match the HotSpot option. See -XX:[+|-]ExitOnOutOfMemoryError for more details about this option.","title":"-XX:[+|-]ExitOnOutOfMemoryError option behavior update"},{"location":"version0.20/#new-xx-globallockreservation-option-added","text":"(AIX and Linux on Power systems only) Option -XX:[+|-]GlobalLockReservation enables a new optimization targeted towards more efficient handling of locking and unlocking Java objects. See -XX:[+|-]GlobalLockReservation for more details about this option.","title":"New -XX:[+|-]GlobalLockReservation option added"},{"location":"version0.20/#change-to-default-maximum-heap-size-for-java-8","text":"For consistency with Java 11, the default maximum heap size ( -Xmx ) is changed to be 25% of the available memory with a maximum of 25 GB. Where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. If you want to revert to the default setting in earlier releases of OpenJ9, use the -XX:+OriginalJDK8HeapSizeCompatibilityMode option.","title":"Change to default maximum heap size for Java 8"},{"location":"version0.20/#change-to-jcmd-default-options","text":"The Java diagnostic command ( jcmd ) tool no longer requires a filename when used with the Dump.java , Dump.snap , or Dump.system options. See jcmd for more information about the tool.","title":"Change to jcmd default options"},{"location":"version0.20/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.19.0 and v 0.20.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.21/","text":"What's new in version 0.21.0 The following new features and notable changes since v 0.20.0 are included in this release: New binaries and changes to supported environments Application Programming Interface (API) documentation Performance improvements New -XX:[+|-]HandleSIGABRT option added New -XX:[+|-]PrintFlagsFinal option added Update to NoClassDefFoundError exception message macOS\u00ae shared libraries version updated Features and changes Binaries and supported environments OpenJ9 release 0.21.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments . Application Programming Interface (API) documentation API documentation that applies to OpenJ9 can now be found in this user documentation for both JDK 8 and JDK 11. The documentation includes links to Oracle API documentation for information that is not specific to OpenJ9. See API overview . Performance improvements If the -Xtune:virtualized command line option is used, the default JIT scratch memory limit is now reduced from 256 MB to 16 MB. This reduces the peak from JIT compilation activity, allowing you to size containers more easily, based on the particular application's memory usage. If the JIT is running in a container and no swap space is defined, the JIT dynamically adjusts its scratch memory consumption based on the amount of free physical memory available, to avoid out-of-memory (OOM) occurrences. Several performance features were added to the AArch64 JIT compiler implementation that led to a throughput improvement on multiple applications of at least 20%. The most notable improvements were seen in global register allocation, recompilation (without profiling), CUDA support, concurrent scavenge GC policy, and the inlined code sequence for object allocations. New -XX:[+|-]HandleSIGABRT option added This option affects the handling of the operating system signal SIGABRT . For compatibility with the reference implementation, set -XX:-HandleSIGABRT . For more information, see -XX:[+|-]HandleSIGABRT . New -XX:[+|-]PrintFlagsFinal option added This release provides an initial implementation of the -XX:[+|-]PrintFlagsFinal option. It is currently incomplete and outputs only a subset of parameters. Over time, we expect more options to be added to the output. See -XX:[+|-]PrintFlagsFinal for more details about this option. Update to NoClassDefFoundError exception message The order in which class names are printed in a NoClassDefFoundError exception message now matches the output reported by HotSpot. For example, in the following exception message: java.lang.NoClassDefFoundError: mypackage/Main (wrong name: Main) mypackage/Main is the class name encountered by the VM in the .class file, but \"wrong name\" Main was the provided class name. Prior to this update to the exception message, the encountered class name and the provided class name were swapped in the NoClassDefFoundError exception message. macOS shared libraries version updated The version information for shared libraries on macOS has been updated from 0.0.0 to 1.0.0. If an application has linked against a shared library from a previous OpenJ9 release, it needs to be re-linked against the new release. Failure to re-link causes an error Incompatible library version , requires version 0.0.0 . Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.20.0 and v 0.21.0 releases, see the Release notes .","title":"Version 0.21.0"},{"location":"version0.21/#whats-new-in-version-0210","text":"The following new features and notable changes since v 0.20.0 are included in this release: New binaries and changes to supported environments Application Programming Interface (API) documentation Performance improvements New -XX:[+|-]HandleSIGABRT option added New -XX:[+|-]PrintFlagsFinal option added Update to NoClassDefFoundError exception message macOS\u00ae shared libraries version updated","title":"What's new in version 0.21.0"},{"location":"version0.21/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.21/#binaries-and-supported-environments","text":"OpenJ9 release 0.21.0 supports OpenJDK 8, 11, and 14. Binaries are available from the AdoptOpenJDK community at the following links: OpenJDK version 8 OpenJDK version 11 OpenJDK version 14 To learn more about support for OpenJ9 releases, including OpenJDK levels and platform support, see Supported environments .","title":"Binaries and supported environments"},{"location":"version0.21/#application-programming-interface-api-documentation","text":"API documentation that applies to OpenJ9 can now be found in this user documentation for both JDK 8 and JDK 11. The documentation includes links to Oracle API documentation for information that is not specific to OpenJ9. See API overview .","title":"Application Programming Interface (API) documentation"},{"location":"version0.21/#performance-improvements","text":"If the -Xtune:virtualized command line option is used, the default JIT scratch memory limit is now reduced from 256 MB to 16 MB. This reduces the peak from JIT compilation activity, allowing you to size containers more easily, based on the particular application's memory usage. If the JIT is running in a container and no swap space is defined, the JIT dynamically adjusts its scratch memory consumption based on the amount of free physical memory available, to avoid out-of-memory (OOM) occurrences. Several performance features were added to the AArch64 JIT compiler implementation that led to a throughput improvement on multiple applications of at least 20%. The most notable improvements were seen in global register allocation, recompilation (without profiling), CUDA support, concurrent scavenge GC policy, and the inlined code sequence for object allocations.","title":"Performance improvements"},{"location":"version0.21/#new-xx-handlesigabrt-option-added","text":"This option affects the handling of the operating system signal SIGABRT . For compatibility with the reference implementation, set -XX:-HandleSIGABRT . For more information, see -XX:[+|-]HandleSIGABRT .","title":"New -XX:[+|-]HandleSIGABRT option added"},{"location":"version0.21/#new-xx-printflagsfinal-option-added","text":"This release provides an initial implementation of the -XX:[+|-]PrintFlagsFinal option. It is currently incomplete and outputs only a subset of parameters. Over time, we expect more options to be added to the output. See -XX:[+|-]PrintFlagsFinal for more details about this option.","title":"New -XX:[+|-]PrintFlagsFinal option added"},{"location":"version0.21/#update-to-noclassdeffounderror-exception-message","text":"The order in which class names are printed in a NoClassDefFoundError exception message now matches the output reported by HotSpot. For example, in the following exception message: java.lang.NoClassDefFoundError: mypackage/Main (wrong name: Main) mypackage/Main is the class name encountered by the VM in the .class file, but \"wrong name\" Main was the provided class name. Prior to this update to the exception message, the encountered class name and the provided class name were swapped in the NoClassDefFoundError exception message.","title":"Update to NoClassDefFoundError exception message"},{"location":"version0.21/#macos-shared-libraries-version-updated","text":"The version information for shared libraries on macOS has been updated from 0.0.0 to 1.0.0. If an application has linked against a shared library from a previous OpenJ9 release, it needs to be re-linked against the new release. Failure to re-link causes an error Incompatible library version , requires version 0.0.0 .","title":"macOS shared libraries version updated"},{"location":"version0.21/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.20.0 and v 0.21.0 releases, see the Release notes .","title":"Full release information"},{"location":"version0.8/","text":"Release notes - version 0.8.0 Version 0.8.0 is the first release of Eclipse OpenJ9, as defined in the release plan . This release supports OpenJDK Version 8 binaries at AdoptOpenJDK.net that contain the Eclipse OpenJ9 virtual machine. For more information about supported platforms, and any issues and limitations, read the OpenJ9 GitHub release notes .","title":"Version 0.8.0"},{"location":"version0.8/#release-notes-version-080","text":"Version 0.8.0 is the first release of Eclipse OpenJ9, as defined in the release plan . This release supports OpenJDK Version 8 binaries at AdoptOpenJDK.net that contain the Eclipse OpenJ9 virtual machine. For more information about supported platforms, and any issues and limitations, read the OpenJ9 GitHub release notes .","title":"Release notes - version 0.8.0"},{"location":"version0.9/","text":"What's new in version 0.9.0 The following new features and notable changes from v.0.8.0 are included in this release: New binaries and supported environments. The idle tuning feature is now supported on Linux running on Power\u00ae Systems and IBM Z\u00ae Systems. A new Garbage Collection (GC) policy is available that performs no housekeeping. A command line option is provided to automatically set a larger Java heap size for applications that run in containers. You can now specify the maximum Java heap size as a percentage value. The shared classes feature now supports nested jar files. System dump data can now be read to help diagnose problems on Linux and Windows platforms. There are notable changes to the java.lang.String class. There are notable changes to the com.ibm.oti.shared.SharedClassCacheInfo class. Features and changes Binaries and supported platforms The following additional OpenJDK binaries that contain the OpenJ9 VM are now available from the AdoptOpenJDK community: OpenJDK version 10 OpenJDK version 8 for 32-bit Windows OpenJDK version 8 for x86 64-bit Linux (Large Heap) for Java heaps >57 GB. Complete platform support information for OpenJ9 can be found in Supported environments Idle tuning feature The idle tuning feature in OpenJ9 keeps your memory footprint small by releasing unused memory back to the operating system. Prior to Eclipse v 0.9.0 this feature was available only on Linux x86 architectures with the gencon garbage collection policy. From v 0.9.0, this feature is now available on Linux for IBM POWER\u00ae and IBM Z\u00ae architectures. For more information about this feature, see the following command line options, which control this behavior: -XX:[+|-]IdleTuningCompactOnIdle -XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle The following blog post describes the benefits of using this feature: Are you still paying for unused memory when your Java app is idle? New GC policy A new GC policy is introduced for JEP 318: Epsilon: A No-Op Garbage Collector . When this policy is enabled, the Java object heap is expanded in the normal way until the limit is reached, but memory is not reclaimed through garbage collection. When the limit is reached the VM shuts down. This JEP has a number of use cases including short-lived applications and certain test scenarios. To enable this policy you can use one of the following options: -Xgcpolicy:nogc -XX:+UseNoGC Modifying the default Java heap size for applications that run in containers When using container technology, applications are typically run on their own and do not need to compete for memory. In this release, changes are introduced to detect when OpenJ9 is running inside a container. If your application is running in a container and you want the VM to allocate a larger fraction of memory to the Java heap, set the -XX:+UseContainerSupport option on the command line. The following table shows the maximum Java heap size that gets set, depending on the memory available: Physical memory <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512M Greater than 2 GB 75% <size> The default heap size for containers only takes affect when running in a container environment and when -XX:+UseContainerSupport is specified, which is expected to be the default in a future release. Specifying the maximum Java heap size as a percentage value OpenJ9 now supports setting the heap size as a percentage of the physical memory. The following OpenJDK options are recognized and can be set for the VM: -XX:MaxRAMPercentage -XX:InitialRAMPercentage To understand how to set these options, see -XX:InitialRAMPercentage / -XX:MaxRAMPercentage . If your application is running in a container and you have specified -XX:+UseContainerSupport , as described in Modifying the default Java heap size for applications that run in containers , both the default heap size for containers and the -XX:MaxRAMPercentage and -XX:InitialRAMPercentage options are based on the available container memory. Shared classes support for nested jar files Changes are made to the com.ibm.oti.shared API to support nested jar files. Direct Dump Reader enabled on Linux and Windows Direct Dump Reader (DDR) support is now enabled for the OpenJ9 VM on all Linux architectures and on Windows. The DDR code enables the VM to read system dump data by using the OpenJ9 Diagnostic Tool Framework for Java (DTFJ) API or the jdmpview tool. If you use the Eclipse Memory Analyzer Tool (MAT) , you can also analyze OpenJ9 or IBM VMs by installing the DTFJ plugin. (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java) You must use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core. This restriction will be fixed in a later version of OpenJ9. Changes to the java.lang.String class To match the behavior of OpenJDK, java.lang.String no longer has a count field, which changes the way that String.subString() works compared to Java 8. String.subString() now copies the value array. Similarly, StringBuffer and StringBuilder do not share the value array with any String created by toString() . For performance and compatibility with the new String object layout, the OpenJ9 implementations of StringBuffer and StringBuilder have been deprecated in favor of the OpenJDK implementations. Changes to the SharedClassCacheInfo class SharedClassCacheInfo.getCacheJVMLevel() used to return the JVMLEVEL constant that maps to a Java version number, for example JVMLEVEL_JAVA8 . This call now returns only the Java version number, for example 10 for Java 10. Full release information To see a complete list of changes between Eclipse OpenJ9 v 0.8.0 and v 0.9.0 releases, see the Release notes .","title":"Version 0.9.0"},{"location":"version0.9/#whats-new-in-version-090","text":"The following new features and notable changes from v.0.8.0 are included in this release: New binaries and supported environments. The idle tuning feature is now supported on Linux running on Power\u00ae Systems and IBM Z\u00ae Systems. A new Garbage Collection (GC) policy is available that performs no housekeeping. A command line option is provided to automatically set a larger Java heap size for applications that run in containers. You can now specify the maximum Java heap size as a percentage value. The shared classes feature now supports nested jar files. System dump data can now be read to help diagnose problems on Linux and Windows platforms. There are notable changes to the java.lang.String class. There are notable changes to the com.ibm.oti.shared.SharedClassCacheInfo class.","title":"What's new in version 0.9.0"},{"location":"version0.9/#features-and-changes","text":"","title":"Features and changes"},{"location":"version0.9/#binaries-and-supported-platforms","text":"The following additional OpenJDK binaries that contain the OpenJ9 VM are now available from the AdoptOpenJDK community: OpenJDK version 10 OpenJDK version 8 for 32-bit Windows OpenJDK version 8 for x86 64-bit Linux (Large Heap) for Java heaps >57 GB. Complete platform support information for OpenJ9 can be found in Supported environments","title":"Binaries and supported platforms"},{"location":"version0.9/#idle-tuning-feature","text":"The idle tuning feature in OpenJ9 keeps your memory footprint small by releasing unused memory back to the operating system. Prior to Eclipse v 0.9.0 this feature was available only on Linux x86 architectures with the gencon garbage collection policy. From v 0.9.0, this feature is now available on Linux for IBM POWER\u00ae and IBM Z\u00ae architectures. For more information about this feature, see the following command line options, which control this behavior: -XX:[+|-]IdleTuningCompactOnIdle -XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle The following blog post describes the benefits of using this feature: Are you still paying for unused memory when your Java app is idle?","title":"Idle tuning feature"},{"location":"version0.9/#new-gc-policy","text":"A new GC policy is introduced for JEP 318: Epsilon: A No-Op Garbage Collector . When this policy is enabled, the Java object heap is expanded in the normal way until the limit is reached, but memory is not reclaimed through garbage collection. When the limit is reached the VM shuts down. This JEP has a number of use cases including short-lived applications and certain test scenarios. To enable this policy you can use one of the following options: -Xgcpolicy:nogc -XX:+UseNoGC","title":"New GC policy"},{"location":"version0.9/#modifying-the-default-java-heap-size-for-applications-that-run-in-containers","text":"When using container technology, applications are typically run on their own and do not need to compete for memory. In this release, changes are introduced to detect when OpenJ9 is running inside a container. If your application is running in a container and you want the VM to allocate a larger fraction of memory to the Java heap, set the -XX:+UseContainerSupport option on the command line. The following table shows the maximum Java heap size that gets set, depending on the memory available: Physical memory <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512M Greater than 2 GB 75% <size> The default heap size for containers only takes affect when running in a container environment and when -XX:+UseContainerSupport is specified, which is expected to be the default in a future release.","title":"Modifying the default Java heap size for applications that run in containers"},{"location":"version0.9/#specifying-the-maximum-java-heap-size-as-a-percentage-value","text":"OpenJ9 now supports setting the heap size as a percentage of the physical memory. The following OpenJDK options are recognized and can be set for the VM: -XX:MaxRAMPercentage -XX:InitialRAMPercentage To understand how to set these options, see -XX:InitialRAMPercentage / -XX:MaxRAMPercentage . If your application is running in a container and you have specified -XX:+UseContainerSupport , as described in Modifying the default Java heap size for applications that run in containers , both the default heap size for containers and the -XX:MaxRAMPercentage and -XX:InitialRAMPercentage options are based on the available container memory.","title":"Specifying the maximum Java heap size as a percentage value"},{"location":"version0.9/#shared-classes-support-for-nested-jar-files","text":"Changes are made to the com.ibm.oti.shared API to support nested jar files.","title":"Shared classes support for nested jar files"},{"location":"version0.9/#direct-dump-reader-enabled-on-linux-and-windows","text":"Direct Dump Reader (DDR) support is now enabled for the OpenJ9 VM on all Linux architectures and on Windows. The DDR code enables the VM to read system dump data by using the OpenJ9 Diagnostic Tool Framework for Java (DTFJ) API or the jdmpview tool. If you use the Eclipse Memory Analyzer Tool (MAT) , you can also analyze OpenJ9 or IBM VMs by installing the DTFJ plugin. (Install from the Eclipse Help menu; Install New Software > Work with \"IBM Diagnostic Tool Framework for Java\" > IBM Monitoring and Diagnostic Tools > Diagnostic Tool Framework for Java) You must use a 32-bit VM to look at a 32-bit core, and a 64-bit VM to look at a 64-bit core. This restriction will be fixed in a later version of OpenJ9.","title":"Direct Dump Reader enabled on Linux and Windows"},{"location":"version0.9/#changes-to-the-javalangstring-class","text":"To match the behavior of OpenJDK, java.lang.String no longer has a count field, which changes the way that String.subString() works compared to Java 8. String.subString() now copies the value array. Similarly, StringBuffer and StringBuilder do not share the value array with any String created by toString() . For performance and compatibility with the new String object layout, the OpenJ9 implementations of StringBuffer and StringBuilder have been deprecated in favor of the OpenJDK implementations.","title":"Changes to the java.lang.String class"},{"location":"version0.9/#changes-to-the-sharedclasscacheinfo-class","text":"SharedClassCacheInfo.getCacheJVMLevel() used to return the JVMLEVEL constant that maps to a Java version number, for example JVMLEVEL_JAVA8 . This call now returns only the Java version number, for example 10 for Java 10.","title":"Changes to the SharedClassCacheInfo class"},{"location":"version0.9/#full-release-information","text":"To see a complete list of changes between Eclipse OpenJ9 v 0.8.0 and v 0.9.0 releases, see the Release notes .","title":"Full release information"},{"location":"x/","text":"-X Displays help on nonstandard options. Syntax -X","title":"-X"},{"location":"x/#-x","text":"Displays help on nonstandard options.","title":"-X"},{"location":"x/#syntax","text":"-X","title":"Syntax"},{"location":"x_jvm_commands/","text":"Using -X command-line options Use these options to configure the OpenJ9 virtual machine (VM). Unlike standard options, options prefixed with -X are nonstandard and are typically unique to a Java\u2122 virtual machine implementation. However, in some cases, -X option names are common to different VM implementations and might have the same function. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -Xmx value to 16 MB, you can specify -Xmx16M , -Xmx16m , -Xmx16384K , -Xmx16384k , or -Xmx16777216 on the command line.","title":"Using -X options"},{"location":"x_jvm_commands/#using-x-command-line-options","text":"Use these options to configure the OpenJ9 virtual machine (VM). Unlike standard options, options prefixed with -X are nonstandard and are typically unique to a Java\u2122 virtual machine implementation. However, in some cases, -X option names are common to different VM implementations and might have the same function. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -Xmx value to 16 MB, you can specify -Xmx16M , -Xmx16m , -Xmx16384K , -Xmx16384k , or -Xmx16777216 on the command line.","title":"Using -X command-line options"},{"location":"xaggressive/","text":"-Xaggressive Enables performance optimizations and new platform exploitation that are expected to be the default in future releases. Syntax -Xaggressive","title":"-Xaggressive"},{"location":"xaggressive/#-xaggressive","text":"Enables performance optimizations and new platform exploitation that are expected to be the default in future releases.","title":"-Xaggressive"},{"location":"xaggressive/#syntax","text":"-Xaggressive","title":"Syntax"},{"location":"xalwaysclassgc/","text":"-Xalwaysclassgc Always perform dynamic class unloading checks during global garbage collection. Syntax -Xalwaysclassgc Default behavior If you don't set this option, the default behavior is defined by -Xclassgc .","title":"-Xalwaysclassgc"},{"location":"xalwaysclassgc/#-xalwaysclassgc","text":"Always perform dynamic class unloading checks during global garbage collection.","title":"-Xalwaysclassgc"},{"location":"xalwaysclassgc/#syntax","text":"-Xalwaysclassgc","title":"Syntax"},{"location":"xalwaysclassgc/#default-behavior","text":"If you don't set this option, the default behavior is defined by -Xclassgc .","title":"Default behavior"},{"location":"xaot/","text":"-Xaot / -Xnoaot Use this option to control the behavior of the ahead-of-time (AOT) compiler. When the AOT compiler is active, the compiler selects the methods to be AOT compiled with the primary goal of improving startup time. AOT compilation allows the compilation of Java\u2122 classes into native code for subsequent executions of the same program. The AOT compiler works with the class data sharing framework. The AOT compiler generates native code dynamically while an application runs and caches any generated AOT code in the shared data cache. Subsequent VMs that execute the method can load and use the AOT code from the shared data cache without incurring the performance decrease experienced with JIT-compiled native code. Performance Because AOT code must persist over different program executions, AOT-generated code does not perform as well as JIT-generated code. AOT code usually performs better than interpreted code. In a VM without an AOT compiler or with the AOT compiler disabled, the JIT compiler selectively compiles frequently used methods into optimized native code. There is a time cost associated with compiling methods because the JIT compiler operates while the application is running. Because methods begin by being interpreted and most JIT compilations occur during startup, startup times can be increased. Startup performance can be improved by using the shared AOT code to provide native code without compiling. There is a small time cost to load the AOT code for a method from the shared data cache and bind it into a running program. The time cost is low compared to the time it takes the JIT compiler to compile that method. Default behavior The AOT compiler is enabled by default, but is only active for classes found in the shared classes cache (see Class data sharing ). Class data sharing is enabled by default for bootstrap classes, but you can use the -Xshareclasses option to modify the behavior of the shared classes cache. Syntax Setting Action Default -Xaot Enable AOT yes -Xaot:<parameter>[=<value>] (See Note ) Enable AOT with modifications -Xnoaot Disable AOT Note: You can concatenate several parameters in a comma-separated list, for example: -Xaot:<parameter1>[=<value1>], <parameter2>[=<value2>] Parameters for -Xaot Parameter Effect verbose Reports information about the AOT and JIT compiler configuration and method compilation. count Specifies the number of times a method is called before it is compiled. exclude Excludes specified methods when AOT code is compiled. limit Includes specified methods when AOT code is compiled. limitFile Compiles only the methods listed in the specified limit file. loadExclude Excludes specified methods when AOT code is loaded. loadLimit Includes specified methods when AOT code is loaded. loadLimitFile Loads only the methods listed in the specified limit file. verbose -Xaot:verbose Reports information about the AOT and JIT compiler configuration and method compilation. count -Xaot:count=<n> Specifies the number of times, <n> , a method is called before it is compiled or loaded from an existing shared classes cache. Setting -Xaot:count=0 forces the AOT compiler to compile everything on first execution, which is useful for problem determination. exclude -Xaot:exclude={<method_name>} Excludes a Java method when AOT code is compiled from the shared classes cache. Use this option if the method causes the program to fail. <method_name> is a regular expression that determines the method or methods that are to be excluded. Specify as much of the full package, class and method as necessary. For example, -Xaot:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xaot:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xaot:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:exclude , JIT compilation is also prevented and the methods specified are always interpreted. limit -Xaot:limit={<method_name>} Only the Java methods specified are included when AOT code is compiled from the shared classes cache. <method_name> is a regular expression that determines the method or methods that are to be included (see -Xaot:exclude for details). Note: limit has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limit , JIT compilation is also restricted to those methods specified; other methods are always interpreted. limitFile -Xaot:limitFile=(<filename>,<m>,<n>) Compiles or loads only the methods listed on lines <m> to, and including, <n> in the specified limit file, <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not compiled or loaded. Note: limitFile has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limitFile , JIT compilation is also restricted to those methods specified; other methods are always interpreted. loadExclude -Xaot:loadExclude={<method_name>} Excludes the specified Java methods when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on those methods instead. <method_name> is a regular expression that determines the method or methods that are to be excluded (see -Xaot:exclude for details). This option does not prevent the method from being compiled. Note: loadExclude can only be specified on -Xaot ; it does not have an equivalent on -Xjit . loadLimit -Xaot:loadLimit={<method_name>} Only the Java methods specified are included when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on other methods instead. <method_name> is a regular expression that determines the method or methods that are to be included (see -Xaot:exclude for details). Note: loadLimit can only be specified on -Xaot ; it does not have an equivalent on -Xjit . This option filters what AOT code the compiler is allowed to load from the shared classes cache. loadLimitFile -Xaot:loadLimitFile=(<filename>,<m>,<n>) Loads only the methods listed on lines <m> to, and including, <n> in the specified limit file. In consequence, the compiler does a JIT compilation on other methods instead. <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not loaded. Note: loadLimitFile can only be specified on -Xaot ; it does not have an equivalent on -Xjit . See also Class data sharing -Xquickstart -Xshareclasses -Xjit","title":"-Xnoaot"},{"location":"xaot/#-xaot-xnoaot","text":"Use this option to control the behavior of the ahead-of-time (AOT) compiler. When the AOT compiler is active, the compiler selects the methods to be AOT compiled with the primary goal of improving startup time. AOT compilation allows the compilation of Java\u2122 classes into native code for subsequent executions of the same program. The AOT compiler works with the class data sharing framework. The AOT compiler generates native code dynamically while an application runs and caches any generated AOT code in the shared data cache. Subsequent VMs that execute the method can load and use the AOT code from the shared data cache without incurring the performance decrease experienced with JIT-compiled native code.","title":"-Xaot / -Xnoaot"},{"location":"xaot/#performance","text":"Because AOT code must persist over different program executions, AOT-generated code does not perform as well as JIT-generated code. AOT code usually performs better than interpreted code. In a VM without an AOT compiler or with the AOT compiler disabled, the JIT compiler selectively compiles frequently used methods into optimized native code. There is a time cost associated with compiling methods because the JIT compiler operates while the application is running. Because methods begin by being interpreted and most JIT compilations occur during startup, startup times can be increased. Startup performance can be improved by using the shared AOT code to provide native code without compiling. There is a small time cost to load the AOT code for a method from the shared data cache and bind it into a running program. The time cost is low compared to the time it takes the JIT compiler to compile that method.","title":"Performance"},{"location":"xaot/#default-behavior","text":"The AOT compiler is enabled by default, but is only active for classes found in the shared classes cache (see Class data sharing ). Class data sharing is enabled by default for bootstrap classes, but you can use the -Xshareclasses option to modify the behavior of the shared classes cache.","title":"Default behavior"},{"location":"xaot/#syntax","text":"Setting Action Default -Xaot Enable AOT yes -Xaot:<parameter>[=<value>] (See Note ) Enable AOT with modifications -Xnoaot Disable AOT Note: You can concatenate several parameters in a comma-separated list, for example: -Xaot:<parameter1>[=<value1>], <parameter2>[=<value2>]","title":"Syntax"},{"location":"xaot/#parameters-for-xaot","text":"Parameter Effect verbose Reports information about the AOT and JIT compiler configuration and method compilation. count Specifies the number of times a method is called before it is compiled. exclude Excludes specified methods when AOT code is compiled. limit Includes specified methods when AOT code is compiled. limitFile Compiles only the methods listed in the specified limit file. loadExclude Excludes specified methods when AOT code is loaded. loadLimit Includes specified methods when AOT code is loaded. loadLimitFile Loads only the methods listed in the specified limit file.","title":"Parameters for -Xaot"},{"location":"xaot/#verbose","text":"-Xaot:verbose Reports information about the AOT and JIT compiler configuration and method compilation.","title":"verbose"},{"location":"xaot/#count","text":"-Xaot:count=<n> Specifies the number of times, <n> , a method is called before it is compiled or loaded from an existing shared classes cache. Setting -Xaot:count=0 forces the AOT compiler to compile everything on first execution, which is useful for problem determination.","title":"count"},{"location":"xaot/#exclude","text":"-Xaot:exclude={<method_name>} Excludes a Java method when AOT code is compiled from the shared classes cache. Use this option if the method causes the program to fail. <method_name> is a regular expression that determines the method or methods that are to be excluded. Specify as much of the full package, class and method as necessary. For example, -Xaot:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xaot:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xaot:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:exclude , JIT compilation is also prevented and the methods specified are always interpreted.","title":"exclude"},{"location":"xaot/#limit","text":"-Xaot:limit={<method_name>} Only the Java methods specified are included when AOT code is compiled from the shared classes cache. <method_name> is a regular expression that determines the method or methods that are to be included (see -Xaot:exclude for details). Note: limit has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limit , JIT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limit"},{"location":"xaot/#limitfile","text":"-Xaot:limitFile=(<filename>,<m>,<n>) Compiles or loads only the methods listed on lines <m> to, and including, <n> in the specified limit file, <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not compiled or loaded. Note: limitFile has the same effect regardless of whether it's specified on -Xjit or -Xaot . In consequence, if you specify -Xaot:limitFile , JIT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limitFile"},{"location":"xaot/#loadexclude","text":"-Xaot:loadExclude={<method_name>} Excludes the specified Java methods when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on those methods instead. <method_name> is a regular expression that determines the method or methods that are to be excluded (see -Xaot:exclude for details). This option does not prevent the method from being compiled. Note: loadExclude can only be specified on -Xaot ; it does not have an equivalent on -Xjit .","title":"loadExclude"},{"location":"xaot/#loadlimit","text":"-Xaot:loadLimit={<method_name>} Only the Java methods specified are included when AOT code is loaded from the shared classes cache. In consequence, the compiler does a JIT compilation on other methods instead. <method_name> is a regular expression that determines the method or methods that are to be included (see -Xaot:exclude for details). Note: loadLimit can only be specified on -Xaot ; it does not have an equivalent on -Xjit . This option filters what AOT code the compiler is allowed to load from the shared classes cache.","title":"loadLimit"},{"location":"xaot/#loadlimitfile","text":"-Xaot:loadLimitFile=(<filename>,<m>,<n>) Loads only the methods listed on lines <m> to, and including, <n> in the specified limit file. In consequence, the compiler does a JIT compilation on other methods instead. <filename> . Methods not listed in the limit file and methods listed on lines outside the range are not loaded. Note: loadLimitFile can only be specified on -Xaot ; it does not have an equivalent on -Xjit .","title":"loadLimitFile"},{"location":"xaot/#see-also","text":"Class data sharing -Xquickstart -Xshareclasses -Xjit","title":"See also"},{"location":"xargencoding/","text":"-Xargencoding The java and javaw launchers accept arguments and class names containing any character that is in the character set of the current locale. You can also specify any Unicode character in the class name and arguments by using Java\u2122 escape sequences. To do this, use the -Xargencoding command-line option. Syntax -Xargencoding:<parameter> Parameters No parameter -Xargencoding You can use Unicode escape sequences in the argument list that you pass to this option. To specify a Unicode character, use escape sequences in the form \\u#### , where # is a hexadecimal digit (0-9, A-F). For example, to specify a class that is called HelloWorld and use Unicode encoding for both capital letters, use this command: java -Xargencoding \\u0048ello\\u0057orld utf8 -Xargencoding:utf8 Use utf8 encoding. latin -Xargencoding:latin Use ISO8859_1 encoding.","title":"-Xargencoding"},{"location":"xargencoding/#-xargencoding","text":"The java and javaw launchers accept arguments and class names containing any character that is in the character set of the current locale. You can also specify any Unicode character in the class name and arguments by using Java\u2122 escape sequences. To do this, use the -Xargencoding command-line option.","title":"-Xargencoding"},{"location":"xargencoding/#syntax","text":"-Xargencoding:<parameter>","title":"Syntax"},{"location":"xargencoding/#parameters","text":"","title":"Parameters"},{"location":"xargencoding/#no-parameter","text":"-Xargencoding You can use Unicode escape sequences in the argument list that you pass to this option. To specify a Unicode character, use escape sequences in the form \\u#### , where # is a hexadecimal digit (0-9, A-F). For example, to specify a class that is called HelloWorld and use Unicode encoding for both capital letters, use this command: java -Xargencoding \\u0048ello\\u0057orld","title":"No parameter"},{"location":"xargencoding/#utf8","text":"-Xargencoding:utf8 Use utf8 encoding.","title":"utf8"},{"location":"xargencoding/#latin","text":"-Xargencoding:latin Use ISO8859_1 encoding.","title":"latin"},{"location":"xbootclasspath/","text":"-Xbootclasspath This Oracle\u00ae HotSpot\u2122 option specifies the search path for bootstrap classes and resources. The default is to search for bootstrap classes and resources in the internal VM directories and .jar files. The option is recognized by the OpenJ9 VM. Syntax Limited to... Setting Effect -Xbootclasspath:<path> Sets the search path for bootstrap classes and resources. -Xbootclasspath/p:<path> Prepends the specified resources to the front of the bootstrap class path. -Xbootclasspath/a:<path> Appends the specified resources to the end of the bootstrap class path. where <path> represents directories and compressed or Java\u2122 archive files separated with colons (:). On Windows\u2122 systems, use a semicolon (;) as a separator. Oracle advise that you should \"not deploy applications that use this option to override a class in rt.jar , because this violates the JRE binary code license.\"","title":"-Xbootclasspath"},{"location":"xbootclasspath/#-xbootclasspath","text":"This Oracle\u00ae HotSpot\u2122 option specifies the search path for bootstrap classes and resources. The default is to search for bootstrap classes and resources in the internal VM directories and .jar files. The option is recognized by the OpenJ9 VM.","title":"-Xbootclasspath"},{"location":"xbootclasspath/#syntax","text":"Limited to... Setting Effect -Xbootclasspath:<path> Sets the search path for bootstrap classes and resources. -Xbootclasspath/p:<path> Prepends the specified resources to the front of the bootstrap class path. -Xbootclasspath/a:<path> Appends the specified resources to the end of the bootstrap class path. where <path> represents directories and compressed or Java\u2122 archive files separated with colons (:). On Windows\u2122 systems, use a semicolon (;) as a separator. Oracle advise that you should \"not deploy applications that use this option to override a class in rt.jar , because this violates the JRE binary code license.\"","title":"Syntax"},{"location":"xceehdlr/","text":"-XCEEHDLR (31-bit z/OS\u00ae only) Controls OpenJ9 VM Language Environment\u00ae condition handling. Syntax -XCEEHDLR Explanation Use the -XCEEHDLR option if you want the new behavior for the Java\u2122 and COBOL interoperability batch mode environment, because this option makes signal and condition handling behavior more predictable in a mixed Java and COBOL environment. When the -XCEEHDLR option is enabled, a condition triggered by an arithmetic operation while executing a Java Native Interface (JNI) component causes the VM to convert the Language Environment condition into a Java ConditionException . When the -XCEEHDLR option is used the VM does not install POSIX signal handlers for the following signals: SIGBUS SIGFPE SIGILL SIGSEGV SIGTRAP Instead, user condition handlers are registered by the VM, using the CEEHDLR() method. These condition handlers are registered every time a thread calls into the VM. Threads call into the VM using the Java Native Interface and including the invocation interfaces, for example JNI\\_CreateJavaVM . The Java runtime continues to register POSIX signal handlers for the following signals: SIGABRT SIGINT SIGQUIT SIGTERM Signal chaining using the libjsig.so library is not supported. When the -XCEEHDLR option is used, condition handler actions take place in the following sequence: All severity 0 and severity 1 conditions are percolated. If a Language Environment condition is triggered in JNI code as a result of an arithmetic operation, the VM condition handler resumes executing Java code as if the JNI native code had thrown a com.ibm.le.conditionhandling.ConditionException exception. This exception class is a subclass of java.lang.RuntimeException . Note: The Language Environment conditions that correspond to arithmetic operations are CEE3208S through CEE3234S . However, the Language Environment does not deliver conditions CEE3208S , CEE3213S , or CEE3234S to C applications, so the VM condition handler will not receive them. If the condition handling reaches this step, the condition is considered to be unrecoverable. RAS diagnostic information is generated, and the VM ends by calling the CEE3AB2() service with abend code 3565, reason code 0, and cleanup code 0. Restriction: You cannot use -Xsignal:userConditionHandler=percolate and -XCEEHDLR together. See also -Xsignal:userConditionHandler=percolate Signals used by the VM .","title":"-XCEEHDLR"},{"location":"xceehdlr/#-xceehdlr","text":"(31-bit z/OS\u00ae only) Controls OpenJ9 VM Language Environment\u00ae condition handling.","title":"-XCEEHDLR"},{"location":"xceehdlr/#syntax","text":"-XCEEHDLR","title":"Syntax"},{"location":"xceehdlr/#explanation","text":"Use the -XCEEHDLR option if you want the new behavior for the Java\u2122 and COBOL interoperability batch mode environment, because this option makes signal and condition handling behavior more predictable in a mixed Java and COBOL environment. When the -XCEEHDLR option is enabled, a condition triggered by an arithmetic operation while executing a Java Native Interface (JNI) component causes the VM to convert the Language Environment condition into a Java ConditionException . When the -XCEEHDLR option is used the VM does not install POSIX signal handlers for the following signals: SIGBUS SIGFPE SIGILL SIGSEGV SIGTRAP Instead, user condition handlers are registered by the VM, using the CEEHDLR() method. These condition handlers are registered every time a thread calls into the VM. Threads call into the VM using the Java Native Interface and including the invocation interfaces, for example JNI\\_CreateJavaVM . The Java runtime continues to register POSIX signal handlers for the following signals: SIGABRT SIGINT SIGQUIT SIGTERM Signal chaining using the libjsig.so library is not supported. When the -XCEEHDLR option is used, condition handler actions take place in the following sequence: All severity 0 and severity 1 conditions are percolated. If a Language Environment condition is triggered in JNI code as a result of an arithmetic operation, the VM condition handler resumes executing Java code as if the JNI native code had thrown a com.ibm.le.conditionhandling.ConditionException exception. This exception class is a subclass of java.lang.RuntimeException . Note: The Language Environment conditions that correspond to arithmetic operations are CEE3208S through CEE3234S . However, the Language Environment does not deliver conditions CEE3208S , CEE3213S , or CEE3234S to C applications, so the VM condition handler will not receive them. If the condition handling reaches this step, the condition is considered to be unrecoverable. RAS diagnostic information is generated, and the VM ends by calling the CEE3AB2() service with abend code 3565, reason code 0, and cleanup code 0. Restriction: You cannot use -Xsignal:userConditionHandler=percolate and -XCEEHDLR together.","title":"Explanation"},{"location":"xceehdlr/#see-also","text":"-Xsignal:userConditionHandler=percolate Signals used by the VM .","title":"See also"},{"location":"xcheck/","text":"-Xcheck You can use the -Xcheck option to run checks during OpenJ9 virtual machine (VM) startup, such as memory checks or checks on JNI functions. Syntax -Xcheck:<parameter> Parameters Parameter Effect classpath Checks the classpath and reports errors such as a missing directory or JAR file. dump Checks the operating system for settings that might truncate system dumps. (AIX\u00ae and Linux\u00ae only) gc Runs additional checks on garbage collection. jni Runs additional checks for JNI functions. memory Identifies memory leaks inside the VM using strict checks that cause the VM to exit on failure. vm Performs additional checks on the VM. classpath -Xcheck:classpath Checks the classpath and reports errors such as a missing directory or JAR file. dump AIX and Linux only -Xcheck:dump Checks operating system settings during VM startup. Messages are issued if the operating system has settings that might truncate system dumps. On AIX systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated This message indicates that the AIX operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM it might be truncated, and therefore of greatly reduced value in investigating the cause of crashes and other issues. For more information about how to set user limits on AIX, see Setting system resource limits on AIX and Linux systems . JVMJ9VM134W The system fullcore option is set to FALSE, system dumps may be truncated This message indicates that the AIX operating system Enable full CORE dump option is set to FALSE . This setting might result in truncated system dumps. For more information about how to set this option correctly on AIX, see Setting system resource limits on AIX and Linux systems . On Linux systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated. This message indicates that the Linux operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM, it might be truncated and therefore of greatly reduced value in investigating the cause of crashes and other issues. Review the documentation that is provided for your operating system to correctly configure the value for ulimits . For further information, see Setting system resource limits on AIX and Linux systems . JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, abrt-hook-ccpp , is configured in the operating system to intercept any system dump files that are generated. This program is part of the Automatic Bug Reporting Tool (ABRT). For more information, see Automatic Bug Reporting Tool . This tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the ABRT tool and messages that are written by the tool in /var/log/messages . If problems occur when generating system dumps from the VM, consider disabling ABRT. JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/share/apport/apport %p %s %c\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, apport , is configured in the operating system to intercept any system dump files that are generated. For more information about this tool, see: Apport The tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the Apport tool and messages that are written by the tool in /var/log/apport.log . If problems occur when generating system dumps from the VM, consider disabling the Apport tool. JVMJ9VM136W \"/proc/sys/kernel/core_pattern setting \"/tmp/cores/core.%e.%p.%h.%t \" specifies a format string for renaming core dumps. The JVM may be unable to locate core dumps and rename them. This message indicates that the Linux /proc/sys/kernel/core_pattern option is set to rename system dumps. The tokens that are used in the operating system dump name might interfere with the VM's system dump file processing, in particular with file names specified in the VM -Xdump options. If problems occur when generating system dumps from the VM, consider changing the /proc/sys/kernel/core_pattern setting to the default value of core . gc -Xcheck:gc[:help][:<scan options>][:<verify options>][:<misc options>] Runs additional checks on garbage collection. By default, no checks are made. There are many scan, verify, and miscellaneous suboptions available. If you do not specify any, all possible scan and verify suboptions are run, plus the miscellaneous verbose and check suboptions. For more information, see the output of -Xcheck:gc:help . jni -Xcheck:jni[:help][:<option>] Runs additional checks for JNI functions. By default, no checks are made. For more information, see the output of -Xcheck:jni:help . memory -Xcheck:memory[:<option>] Identifies memory leaks inside the VM by using strict checks that cause the VM to exit on failure. Restriction: You cannot include -Xcheck:memory in the options file (see -Xoptionsfile ). The available parameters are as follows: :all (Default if no options specified) Enables checking of all allocated and freed blocks on every free and allocate call. This check of the heap is the most thorough. It typically causes the VM to exit on nearly all memory-related problems soon after they are caused. This option has the greatest affect on performance. :callsite=<number_of_allocations> Displays callsite information every <number_of_allocations> . De-allocations are not counted. Callsite information is presented in a table with separate information for each callsite. Statistics include: The number and size of allocation and free requests since the last report. The number of the allocation request responsible for the largest allocation from each site. Callsites are presented as sourcefile:linenumber for C code and assembly function name for assembler code. Callsites that do not provide callsite information are accumulated into an \"unknown\" entry. :failat=<number_of_allocations> Causes memory allocation to fail (return NULL) after <number_of_allocations> . For example, setting <number_of_allocations> to 13 causes the 14th allocation to return NULL. De-allocations are not counted. Use this option to ensure that VM code reliably handles allocation failures. This option is useful for checking allocation site behavior rather than setting a specific allocation limit. :ignoreUnknownBlocks Ignores attempts to free memory that was not allocated using the -Xcheck:memory tool. Instead, the -Xcheck:memory statistics that are printed out at the end of a run indicates the number of \"unknown\" blocks that were freed. :mprotect=[top|bottom] Locks pages of memory on supported platforms, causing the program to stop if padding before or after the allocated block is accessed for reads or writes. An extra page is locked on each side of the block returned to the user. If you do not request an exact multiple of one page of memory, a region on one side of your memory is not locked. The top and bottom options control which side of the memory area is locked. top aligns your memory blocks to the top of the page (lower address), so buffer underruns result in an application failure. bottom aligns your memory blocks to the bottom of the page (higher address) so buffer overruns result in an application failure. Standard padding scans detect buffer underruns when using top and buffer overruns when using bottom . :nofree Keeps a list of blocks that are already used instead of freeing memory. This list, and the list of currently allocated blocks, is checked for memory corruption on every allocation and deallocation. Use this option to detect a dangling pointer (a pointer that is \"dereferenced\" after its target memory is freed). This option cannot be reliably used with long-running applications (such as WebSphere\u00ae Application Server), because \"freed\" memory is never reused or released by the VM. :noscan Checks for blocks that are not freed. This option has little effect on performance, but memory corruption is not detected. This option is compatible only with subAllocator , callsite , and callsitesmall . :quick Enables block padding only and is used to detect basic heap corruption. Every allocated block is padded with sentinel bytes, which are verified on every allocate and free. Block padding is faster than the default of checking every block, but is not as effective. :skipto=<number_of_allocations> Causes the program to check only on allocations that occur after <number_of_allocations> . De-allocations are not counted. Use this option to speed up VM startup when early allocations are not causing the memory problem. The VM performs approximately 250+ allocations during startup. :subAllocator[=<size_in_MB>] Allocates a dedicated and contiguous region of memory for all VM allocations. This option helps to determine if user JNI code or the VM is responsible for memory corruption. Corruption in the VM subAllocator heap suggests that the VM is causing the problem; corruption in the user-allocated memory suggests that user code is corrupting memory. Typically, user and VM allocated memory are interleaved. :zero Newly allocated blocks are set to 0 instead of being filled with the 0xE7E7xxxxxxxxE7E7 pattern. Setting these blocks to 0 helps you to determine whether a callsite is expecting zeroed memory, in which case the allocation request is followed by memset(pointer, 0, size) . vm -Xcheck:vm[:<option>] Performs additional checks on the VM. By default, no checking is performed. For more information, run -Xcheck:vm:help .","title":"-Xcheck"},{"location":"xcheck/#-xcheck","text":"You can use the -Xcheck option to run checks during OpenJ9 virtual machine (VM) startup, such as memory checks or checks on JNI functions.","title":"-Xcheck"},{"location":"xcheck/#syntax","text":"-Xcheck:<parameter>","title":"Syntax"},{"location":"xcheck/#parameters","text":"Parameter Effect classpath Checks the classpath and reports errors such as a missing directory or JAR file. dump Checks the operating system for settings that might truncate system dumps. (AIX\u00ae and Linux\u00ae only) gc Runs additional checks on garbage collection. jni Runs additional checks for JNI functions. memory Identifies memory leaks inside the VM using strict checks that cause the VM to exit on failure. vm Performs additional checks on the VM.","title":"Parameters"},{"location":"xcheck/#classpath","text":"-Xcheck:classpath Checks the classpath and reports errors such as a missing directory or JAR file.","title":"classpath"},{"location":"xcheck/#dump","text":"AIX and Linux only -Xcheck:dump Checks operating system settings during VM startup. Messages are issued if the operating system has settings that might truncate system dumps. On AIX systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated This message indicates that the AIX operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM it might be truncated, and therefore of greatly reduced value in investigating the cause of crashes and other issues. For more information about how to set user limits on AIX, see Setting system resource limits on AIX and Linux systems . JVMJ9VM134W The system fullcore option is set to FALSE, system dumps may be truncated This message indicates that the AIX operating system Enable full CORE dump option is set to FALSE . This setting might result in truncated system dumps. For more information about how to set this option correctly on AIX, see Setting system resource limits on AIX and Linux systems . On Linux systems, the following messages are possible: JVMJ9VM133W The system core size hard ulimit is set to <value>, system dumps may be truncated. This message indicates that the Linux operating system user limit is set to restrict the size of system dumps to the value indicated. If a system dump is produced by the VM, it might be truncated and therefore of greatly reduced value in investigating the cause of crashes and other issues. Review the documentation that is provided for your operating system to correctly configure the value for ulimits . For further information, see Setting system resource limits on AIX and Linux systems . JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, abrt-hook-ccpp , is configured in the operating system to intercept any system dump files that are generated. This program is part of the Automatic Bug Reporting Tool (ABRT). For more information, see Automatic Bug Reporting Tool . This tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the ABRT tool and messages that are written by the tool in /var/log/messages . If problems occur when generating system dumps from the VM, consider disabling ABRT. JVMJ9VM135W /proc/sys/kernel/core_pattern setting \"|/usr/share/apport/apport %p %s %c\" specifies that core dumps are to be piped to an external program. The JVM may be unable to locate core dumps and rename them. This message means that an external program, apport , is configured in the operating system to intercept any system dump files that are generated. For more information about this tool, see: Apport The tool might interfere with the VM's system dump file processing by renaming or truncating system dumps. Review the configuration of the Apport tool and messages that are written by the tool in /var/log/apport.log . If problems occur when generating system dumps from the VM, consider disabling the Apport tool. JVMJ9VM136W \"/proc/sys/kernel/core_pattern setting \"/tmp/cores/core.%e.%p.%h.%t \" specifies a format string for renaming core dumps. The JVM may be unable to locate core dumps and rename them. This message indicates that the Linux /proc/sys/kernel/core_pattern option is set to rename system dumps. The tokens that are used in the operating system dump name might interfere with the VM's system dump file processing, in particular with file names specified in the VM -Xdump options. If problems occur when generating system dumps from the VM, consider changing the /proc/sys/kernel/core_pattern setting to the default value of core .","title":"dump"},{"location":"xcheck/#gc","text":"-Xcheck:gc[:help][:<scan options>][:<verify options>][:<misc options>] Runs additional checks on garbage collection. By default, no checks are made. There are many scan, verify, and miscellaneous suboptions available. If you do not specify any, all possible scan and verify suboptions are run, plus the miscellaneous verbose and check suboptions. For more information, see the output of -Xcheck:gc:help .","title":"gc"},{"location":"xcheck/#jni","text":"-Xcheck:jni[:help][:<option>] Runs additional checks for JNI functions. By default, no checks are made. For more information, see the output of -Xcheck:jni:help .","title":"jni"},{"location":"xcheck/#memory","text":"-Xcheck:memory[:<option>] Identifies memory leaks inside the VM by using strict checks that cause the VM to exit on failure. Restriction: You cannot include -Xcheck:memory in the options file (see -Xoptionsfile ). The available parameters are as follows: :all (Default if no options specified) Enables checking of all allocated and freed blocks on every free and allocate call. This check of the heap is the most thorough. It typically causes the VM to exit on nearly all memory-related problems soon after they are caused. This option has the greatest affect on performance. :callsite=<number_of_allocations> Displays callsite information every <number_of_allocations> . De-allocations are not counted. Callsite information is presented in a table with separate information for each callsite. Statistics include: The number and size of allocation and free requests since the last report. The number of the allocation request responsible for the largest allocation from each site. Callsites are presented as sourcefile:linenumber for C code and assembly function name for assembler code. Callsites that do not provide callsite information are accumulated into an \"unknown\" entry. :failat=<number_of_allocations> Causes memory allocation to fail (return NULL) after <number_of_allocations> . For example, setting <number_of_allocations> to 13 causes the 14th allocation to return NULL. De-allocations are not counted. Use this option to ensure that VM code reliably handles allocation failures. This option is useful for checking allocation site behavior rather than setting a specific allocation limit. :ignoreUnknownBlocks Ignores attempts to free memory that was not allocated using the -Xcheck:memory tool. Instead, the -Xcheck:memory statistics that are printed out at the end of a run indicates the number of \"unknown\" blocks that were freed. :mprotect=[top|bottom] Locks pages of memory on supported platforms, causing the program to stop if padding before or after the allocated block is accessed for reads or writes. An extra page is locked on each side of the block returned to the user. If you do not request an exact multiple of one page of memory, a region on one side of your memory is not locked. The top and bottom options control which side of the memory area is locked. top aligns your memory blocks to the top of the page (lower address), so buffer underruns result in an application failure. bottom aligns your memory blocks to the bottom of the page (higher address) so buffer overruns result in an application failure. Standard padding scans detect buffer underruns when using top and buffer overruns when using bottom . :nofree Keeps a list of blocks that are already used instead of freeing memory. This list, and the list of currently allocated blocks, is checked for memory corruption on every allocation and deallocation. Use this option to detect a dangling pointer (a pointer that is \"dereferenced\" after its target memory is freed). This option cannot be reliably used with long-running applications (such as WebSphere\u00ae Application Server), because \"freed\" memory is never reused or released by the VM. :noscan Checks for blocks that are not freed. This option has little effect on performance, but memory corruption is not detected. This option is compatible only with subAllocator , callsite , and callsitesmall . :quick Enables block padding only and is used to detect basic heap corruption. Every allocated block is padded with sentinel bytes, which are verified on every allocate and free. Block padding is faster than the default of checking every block, but is not as effective. :skipto=<number_of_allocations> Causes the program to check only on allocations that occur after <number_of_allocations> . De-allocations are not counted. Use this option to speed up VM startup when early allocations are not causing the memory problem. The VM performs approximately 250+ allocations during startup. :subAllocator[=<size_in_MB>] Allocates a dedicated and contiguous region of memory for all VM allocations. This option helps to determine if user JNI code or the VM is responsible for memory corruption. Corruption in the VM subAllocator heap suggests that the VM is causing the problem; corruption in the user-allocated memory suggests that user code is corrupting memory. Typically, user and VM allocated memory are interleaved. :zero Newly allocated blocks are set to 0 instead of being filled with the 0xE7E7xxxxxxxxE7E7 pattern. Setting these blocks to 0 helps you to determine whether a callsite is expecting zeroed memory, in which case the allocation request is followed by memset(pointer, 0, size) .","title":"memory"},{"location":"xcheck/#vm","text":"-Xcheck:vm[:<option>] Performs additional checks on the VM. By default, no checking is performed. For more information, run -Xcheck:vm:help .","title":"vm"},{"location":"xclassgc/","text":"-Xclassgc / -Xnoclassgc Enables and disables class garbage collection (the dynamic unloading of class objects by the VM). When enabled, garbage collection, occurs only on class loader changes. This is the default behavior. Note: Disabling class garbage collection is not recommended as this causes unlimited native memory growth, leading to out-of-memory errors. Syntax Setting Action Default -Xclassgc Enable GC yes -Xnoclassgc Disable GC","title":"-Xnoclassgc"},{"location":"xclassgc/#-xclassgc-xnoclassgc","text":"Enables and disables class garbage collection (the dynamic unloading of class objects by the VM). When enabled, garbage collection, occurs only on class loader changes. This is the default behavior. Note: Disabling class garbage collection is not recommended as this causes unlimited native memory growth, leading to out-of-memory errors.","title":"-Xclassgc / -Xnoclassgc"},{"location":"xclassgc/#syntax","text":"Setting Action Default -Xclassgc Enable GC yes -Xnoclassgc Disable GC","title":"Syntax"},{"location":"xcodecache/","text":"-Xcodecache Use this option to tune performance. This option sets the size of each block of memory that is allocated to store the native code of compiled Java\u2122 methods. By default, this size is selected internally according to the processor architecture and the capability of your system. The maximum value you can specify is 32 MB. If you set a value larger than 32 MB, the JIT ignores the input and sets the value to 32 MB. Note: The JIT compiler might allocate more than one code cache for an application. Use the -Xcodecachetotal option to set the maximum amount of memory that is used by all code caches. Syntax -Xcodecache<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"-Xcodecache"},{"location":"xcodecache/#-xcodecache","text":"Use this option to tune performance. This option sets the size of each block of memory that is allocated to store the native code of compiled Java\u2122 methods. By default, this size is selected internally according to the processor architecture and the capability of your system. The maximum value you can specify is 32 MB. If you set a value larger than 32 MB, the JIT ignores the input and sets the value to 32 MB. Note: The JIT compiler might allocate more than one code cache for an application. Use the -Xcodecachetotal option to set the maximum amount of memory that is used by all code caches.","title":"-Xcodecache"},{"location":"xcodecache/#syntax","text":"-Xcodecache<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xcodecachetotal/","text":"-Xcodecachetotal Use this option to set the maximum size limit for the JIT code cache. This option also affects the size of the JIT data cache. Syntax -Xcodecachetotal<size> The default size is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. See Using -X command-line options for more information about specifying the <size> parameter. Explanation By default, the total size of the JIT code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. Long-running, complex, server-type applications can fill the JIT code cache, which can cause performance problems because not all of the important methods can be JIT-compiled. Use the -Xcodecachetotal option to increase or decrease the maximum code cache size to a setting that suits your application. The minimum size of the code cache is restricted to 2 MB. The value that you specify is rounded up to a multiple of the code cache block size, as specified by the -Xcodecache option. If you specify a value for the -Xcodecachetotal option that is smaller than the default setting, that value is ignored. When you use this option, the maximum size limit for the JIT data cache, which holds metadata about compiled methods, is increased or decreased proportionally to support the JIT compilations. The maximum size limits, for both the JIT code and data caches, that are in use by the VM are shown in Javadump output. Look for lines that begin with 1STSEGLIMIT . Use this information together with verbose JIT tracing to determine suitable values for this option on your system. For example Javadump output, see Java dump: Storage Management (MEMINFO) . See also -Xjit","title":"-Xcodecachetotal"},{"location":"xcodecachetotal/#-xcodecachetotal","text":"Use this option to set the maximum size limit for the JIT code cache. This option also affects the size of the JIT data cache.","title":"-Xcodecachetotal"},{"location":"xcodecachetotal/#syntax","text":"-Xcodecachetotal<size> The default size is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xcodecachetotal/#explanation","text":"By default, the total size of the JIT code cache is 256 MB for a 64-bit VM and 64 MB for a 31/32-bit VM. Long-running, complex, server-type applications can fill the JIT code cache, which can cause performance problems because not all of the important methods can be JIT-compiled. Use the -Xcodecachetotal option to increase or decrease the maximum code cache size to a setting that suits your application. The minimum size of the code cache is restricted to 2 MB. The value that you specify is rounded up to a multiple of the code cache block size, as specified by the -Xcodecache option. If you specify a value for the -Xcodecachetotal option that is smaller than the default setting, that value is ignored. When you use this option, the maximum size limit for the JIT data cache, which holds metadata about compiled methods, is increased or decreased proportionally to support the JIT compilations. The maximum size limits, for both the JIT code and data caches, that are in use by the VM are shown in Javadump output. Look for lines that begin with 1STSEGLIMIT . Use this information together with verbose JIT tracing to determine suitable values for this option on your system. For example Javadump output, see Java dump: Storage Management (MEMINFO) .","title":"Explanation"},{"location":"xcodecachetotal/#see-also","text":"-Xjit","title":"See also"},{"location":"xcomp/","text":"-Xcomp The use of this option is deprecated; use -Xjit:count=0 instead. Syntax -Xcomp","title":"-Xcomp"},{"location":"xcomp/#-xcomp","text":"The use of this option is deprecated; use -Xjit:count=0 instead.","title":"-Xcomp"},{"location":"xcomp/#syntax","text":"-Xcomp","title":"Syntax"},{"location":"xcompactexplicitgc/","text":"\u2011Xcompactexplicitgc / \u2011Xnocompactexplicitgc Enables or disables full compaction each time System.gc() is called. Compaction takes place on global garbage collections if you specify -Xcompactgc or if compaction triggers are met. Syntax Setting Action Default -Xcompactexplicitgc Enable compaction yes -Xnocompactexplicitgc Disable compaction See also Global garbage collection: Compaction phase","title":"-Xnocompactexplicitgc"},{"location":"xcompactexplicitgc/#xcompactexplicitgc-xnocompactexplicitgc","text":"Enables or disables full compaction each time System.gc() is called. Compaction takes place on global garbage collections if you specify -Xcompactgc or if compaction triggers are met.","title":"\u2011Xcompactexplicitgc / \u2011Xnocompactexplicitgc"},{"location":"xcompactexplicitgc/#syntax","text":"Setting Action Default -Xcompactexplicitgc Enable compaction yes -Xnocompactexplicitgc Disable compaction","title":"Syntax"},{"location":"xcompactexplicitgc/#see-also","text":"Global garbage collection: Compaction phase","title":"See also"},{"location":"xcompactgc/","text":"-Xcompactgc / -Xnocompactgc Enables or disables full compaction on all garbage collections (system and global). Syntax Setting Action -Xcompactgc Enable full compaction -Xnocompactgc Disable full compaction Default behavior If no compaction option is specified, the garbage collector compacts based on a series of triggers that attempt to compact only when it is beneficial to the future performance of the OpenJ9 VM. See also Global garbage collection: Compaction phase","title":"-Xnocompactgc"},{"location":"xcompactgc/#-xcompactgc-xnocompactgc","text":"Enables or disables full compaction on all garbage collections (system and global).","title":"-Xcompactgc / -Xnocompactgc"},{"location":"xcompactgc/#syntax","text":"Setting Action -Xcompactgc Enable full compaction -Xnocompactgc Disable full compaction","title":"Syntax"},{"location":"xcompactgc/#default-behavior","text":"If no compaction option is specified, the garbage collector compacts based on a series of triggers that attempt to compact only when it is beneficial to the future performance of the OpenJ9 VM.","title":"Default behavior"},{"location":"xcompactgc/#see-also","text":"Global garbage collection: Compaction phase","title":"See also"},{"location":"xcompilationthreads/","text":"-XcompilationThreads Use this option to specify the number of compilation threads that are used by the JIT compiler. Syntax -XcompilationThreads<n> where <n> is the number of threads, in the range 1-7 inclusive. Any number outside this range is ignored. Setting the compilation threads to zero does not prevent the JIT from working. Instead, if you do not want the JIT to work, use the -Xint option. Explanation When multiple compilation threads are used, the JIT might generate several diagnostic log files. A log file is generated for each compilation thread. The naming convention for the log file generated by the first compilation thread uses the following pattern: <specified_filename>.<date>.<time>.<pid> The first compilation thread has ID 0. Log files generated by the second and subsequent compilation threads append the ID of the corresponding compilation thread as a suffix to the log file name. The pattern for these log file names is as follows: <specified_filename>.<date>.<time>.<pid>.<compilation_thread_ID> For example, the second compilation thread has ID 1. The result is that the corresponding log file name has the form: <specified_filename>.<date>.<time>.<pid>.1","title":"-XcompilationThreads"},{"location":"xcompilationthreads/#-xcompilationthreads","text":"Use this option to specify the number of compilation threads that are used by the JIT compiler.","title":"-XcompilationThreads"},{"location":"xcompilationthreads/#syntax","text":"-XcompilationThreads<n> where <n> is the number of threads, in the range 1-7 inclusive. Any number outside this range is ignored. Setting the compilation threads to zero does not prevent the JIT from working. Instead, if you do not want the JIT to work, use the -Xint option.","title":"Syntax"},{"location":"xcompilationthreads/#explanation","text":"When multiple compilation threads are used, the JIT might generate several diagnostic log files. A log file is generated for each compilation thread. The naming convention for the log file generated by the first compilation thread uses the following pattern: <specified_filename>.<date>.<time>.<pid> The first compilation thread has ID 0. Log files generated by the second and subsequent compilation threads append the ID of the corresponding compilation thread as a suffix to the log file name. The pattern for these log file names is as follows: <specified_filename>.<date>.<time>.<pid>.<compilation_thread_ID> For example, the second compilation thread has ID 1. The result is that the corresponding log file name has the form: <specified_filename>.<date>.<time>.<pid>.1","title":"Explanation"},{"location":"xcompressedrefs/","text":"-Xcompressedrefs / -Xnocompressedrefs (64-bit only) Enables or disables the use of compressed references. Restriction: You cannot include -Xcompressedrefs in the options file (see -Xoptionsfile ). Syntax Setting Action Default -Xcompressedrefs Enable compression yes (see Default behavior ) -Xnocompressedrefs Disable compression Default behavior Compressed references are enabled by default when -Xmx \u2264 57 GB. z/OS\u00ae: This threshold value assumes that you have APAR OA49416 installed. If you do not have the APAR installed, the threshold value is 25 GB. AIX\u00ae and Linux\u00ae: For the metronome garbage collection policy, the threshold is 25 GB. See also Compressed references","title":"-Xnocompressedrefs"},{"location":"xcompressedrefs/#-xcompressedrefs-xnocompressedrefs","text":"(64-bit only) Enables or disables the use of compressed references. Restriction: You cannot include -Xcompressedrefs in the options file (see -Xoptionsfile ).","title":"-Xcompressedrefs / -Xnocompressedrefs"},{"location":"xcompressedrefs/#syntax","text":"Setting Action Default -Xcompressedrefs Enable compression yes (see Default behavior ) -Xnocompressedrefs Disable compression","title":"Syntax"},{"location":"xcompressedrefs/#default-behavior","text":"Compressed references are enabled by default when -Xmx \u2264 57 GB. z/OS\u00ae: This threshold value assumes that you have APAR OA49416 installed. If you do not have the APAR installed, the threshold value is 25 GB. AIX\u00ae and Linux\u00ae: For the metronome garbage collection policy, the threshold is 25 GB.","title":"Default behavior"},{"location":"xcompressedrefs/#see-also","text":"Compressed references","title":"See also"},{"location":"xconcurrentbackground/","text":"-Xconcurrentbackground Specifies the number of low-priority background threads attached to assist the mutator threads in concurrent mark. Syntax -Xconcurrentbackground<n> Default behavior The default is 0 for Linux\u00ae on IBM Z\u00ae and 1 on all other platforms.","title":"-Xconcurrentbackground"},{"location":"xconcurrentbackground/#-xconcurrentbackground","text":"Specifies the number of low-priority background threads attached to assist the mutator threads in concurrent mark.","title":"-Xconcurrentbackground"},{"location":"xconcurrentbackground/#syntax","text":"-Xconcurrentbackground<n>","title":"Syntax"},{"location":"xconcurrentbackground/#default-behavior","text":"The default is 0 for Linux\u00ae on IBM Z\u00ae and 1 on all other platforms.","title":"Default behavior"},{"location":"xconcurrentlevel/","text":"-Xconcurrentlevel This option indicates the ratio between the amount of heap allocated and the amount of heap marked (the allocation \"tax\" rate). Syntax -Xconcurrentlevel<number> Default behavior The default is 8.","title":"-Xconcurrentlevel"},{"location":"xconcurrentlevel/#-xconcurrentlevel","text":"This option indicates the ratio between the amount of heap allocated and the amount of heap marked (the allocation \"tax\" rate).","title":"-Xconcurrentlevel"},{"location":"xconcurrentlevel/#syntax","text":"-Xconcurrentlevel<number>","title":"Syntax"},{"location":"xconcurrentlevel/#default-behavior","text":"The default is 8.","title":"Default behavior"},{"location":"xconcurrentslack/","text":"-Xconcurrentslack Attempts to keep the specified amount of the heap space free in concurrent collectors by starting the concurrent operations earlier. Using this option can sometimes alleviate pause time problems in concurrent collectors at the cost of longer concurrent cycles, affecting total throughput. Syntax -Xconcurrentslack<size> See Using -X command-line options for more information about specifying the <size> parameter. Default behavior The default value is 0, which is optimal for most applications.","title":"-Xconcurrentslack"},{"location":"xconcurrentslack/#-xconcurrentslack","text":"Attempts to keep the specified amount of the heap space free in concurrent collectors by starting the concurrent operations earlier. Using this option can sometimes alleviate pause time problems in concurrent collectors at the cost of longer concurrent cycles, affecting total throughput.","title":"-Xconcurrentslack"},{"location":"xconcurrentslack/#syntax","text":"-Xconcurrentslack<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xconcurrentslack/#default-behavior","text":"The default value is 0, which is optimal for most applications.","title":"Default behavior"},{"location":"xconmeter/","text":"-Xconmeter This option determines the usage of which area, LOA (large object area) or SOA (small object area), is metered and hence which allocations are taxed during concurrent mark. Syntax -Xconmeter:<parameter> Parameters soa -Xconmeter:soa (Default) Applies the allocation tax to allocations from the small object area (SOA). loa -Xconmeter:loa Applies the allocation tax to allocations from the large object area (LOA). dynamic -Xconmeter:dynamic The collector dynamically determines which area to meter based on which area is exhausted first, whether it is the SOA or the LOA. Default behavior By default, allocation tax is applied to the SOA.","title":"-Xconmeter"},{"location":"xconmeter/#-xconmeter","text":"This option determines the usage of which area, LOA (large object area) or SOA (small object area), is metered and hence which allocations are taxed during concurrent mark.","title":"-Xconmeter"},{"location":"xconmeter/#syntax","text":"-Xconmeter:<parameter>","title":"Syntax"},{"location":"xconmeter/#parameters","text":"","title":"Parameters"},{"location":"xconmeter/#soa","text":"-Xconmeter:soa (Default) Applies the allocation tax to allocations from the small object area (SOA).","title":"soa"},{"location":"xconmeter/#loa","text":"-Xconmeter:loa Applies the allocation tax to allocations from the large object area (LOA).","title":"loa"},{"location":"xconmeter/#dynamic","text":"-Xconmeter:dynamic The collector dynamically determines which area to meter based on which area is exhausted first, whether it is the SOA or the LOA.","title":"dynamic"},{"location":"xconmeter/#default-behavior","text":"By default, allocation tax is applied to the SOA.","title":"Default behavior"},{"location":"xdisablejavadump/","text":"-Xdisablejavadump Turns off Java dump generation on errors and signals. Syntax -Xdisablejavadump Default behavior By default, Javadump generation is enabled. See also -Xdump","title":"-Xdisablejavadump"},{"location":"xdisablejavadump/#-xdisablejavadump","text":"Turns off Java dump generation on errors and signals.","title":"-Xdisablejavadump"},{"location":"xdisablejavadump/#syntax","text":"-Xdisablejavadump","title":"Syntax"},{"location":"xdisablejavadump/#default-behavior","text":"By default, Javadump generation is enabled.","title":"Default behavior"},{"location":"xdisablejavadump/#see-also","text":"-Xdump","title":"See also"},{"location":"xdump/","text":"-Xdump OpenJ9 produces various types of diagnostic information for analysis when different events occur, such as a general protection fault. The dumps produced are controlled by dump agents, which are initialized when the OpenJ9 virtual machine (VM) starts. The default settings for the dump agents are sufficient for most cases. However, you can use the -Xdump option on the command line to fine tune the dump agent settings. For example, you can use the -Xdump option to add and remove dump agents for various VM events, update default dump settings, and limit the number of dumps that are produced. A large set of options and suboptions are available for controlling dumps, which provides a lot of flexibility. Xdump Option Builder Use the Xdump Option Builder tool to help you specify the correct options and avoid incompatibilities. Syntax -Xdump:<parameter> The following table lists the help options for -Xdump , which provide usage and configuration information: Command Result -Xdump:help Displays general dump help. -Xdump:events Lists available trigger events. -Xdump:request Lists additional VM requests. -Xdump:tokens Lists recognized label tokens. -Xdump:what Shows registered agents on startup. -Xdump:<agent>:help Displays dump agent usage information. The following options can be used to control the production of diagnostic data: Parameter Result -Xdump:none Removes all default dump agents and any preceding dump options. -Xdump:dynamic Enable support for pluggable agents -Xdump:nofailover Discards dumps when the default or specified dump location is full. -Xdump:directory=<path> Specifies a directory for all dump types to be written to. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents. -Xdump:suspendwith=<offset> Modifies the signal that is used to suspend VM threads while a dump file is being written. Use <offset> to change the default signal number. (Linux\u00ae only) -Xdump:<agent>:<suboptions> Provides detailed suboptions per dump agent that provide more granular control. Dump agents can be configured at a very granular level by specifying suboptions. The <events> suboption is the prime trigger mechanism. The full set of suboptions are listed in the following table: Dump agent suboptions Result -Xdump:<agent>:none Removes the dump agent. -Xdump:<agent>:defaults Prints the default options for the dump agent. -Xdump:<agent>:events=<events> Triggers a dump agent when a specific event occurs. -Xdump:<agent>:exec=<command> Starts an external application for the dump agent. -Xdump:<agent>:file=<filename> Specifies where to write the dump for the dump agent. -Xdump:<agent>:filter=<filter> Filters dumps by wildcards or events. -Xdump:<agent>:msg_filter=<filter> Filters on text strings within an exception message. -Xdump:<agent>:opts=<options> Used by specific dump agents to select the type of dump file to produce. -Xdump:<agent>:priority=<0-999> Specifies the priority that the dump agents run in. -Xdump:<agent>:range=<ranges> Starts and stops a dump agent on a particular occurrence of a VM. -Xdump:<agent>:request=<requests> Asks the VM to prepare the state before starting the dump agent. You can have multiple -Xdump options on the command line. You can also have multiple dump types triggered by multiple events. For example, the following command turns off the creation of heap dump files, and creates a dump agent that produces a heap dump file and a Java\u2122 dump file when either a vmstart or vmstop event occurs: java -Xdump:heap:none -Xdump:heap+java:events=vmstart+vmstop -mp . -m <class> [args...] Note: Multiple suboptions that follow an Xdump suboption must be split with a comma (,), for example: java -Xdump:java:events=vmstart,file=/STDERR/ -version For more detailed information on the these parameters and suboptions, including examples, see Parameters . Dump agents A dump agent performs diagnostic tasks when triggered. Most dump agents save information on the state of the VM in some form of dump or trace file for later analysis. An exception is the \"tool\" agent, which can be used to trigger external processes when specific events occur. Dump agent Description stack Stack dumps are very basic dumps in which the status and Java stack of the thread is written to stderr. console Console dumps are very basic dumps, in which the status of every Java thread is written to stderr. system System dumps capture the raw process image or address space of an application. tool The tool option allows external processes to be started when an event occurs. java Java dumps are an internally generated and formatted analysis of the VM, giving information that includes the Java threads present, the classes loaded, and heap statistics. heap Heap dumps capture all object instances in the heap, including each object address, type or class name, size, and references to other objects. snap Take a snap of the trace buffers, which contain tracepoint data. ceedump LE CEEDUMP dumps are z/OS\u00ae formatted summary system dumps that show stack traces for each thread that is in the VM process, together with register information and a short dump of storage for each register. jit JIT compiler dumps contain diagnostic data in a binary format. exit Shut down the VM. Default dump agents During VM initialization a set of dump agents are added by default. You can override this set of dump agents using -Xdump on the command line. To show the registered dump agents, user the Xdump:what option on the command line. The following sample output shows the default dump agents that are in place on a Linux system: java -Xdump:what Registered dump agents ---------------------- -Xdump:system: events=gpf+abort+traceassert+corruptcache, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=999, request=serial ---------------------- -Xdump:system: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..1, priority=999, request=exclusive+compact+prepwalk ---------------------- -Xdump:heap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.%seq.phd, range=1..4, priority=500, request=exclusive+compact+prepwalk, opts=PHD ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- -Xdump:java: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..4, priority=400, request=exclusive+preempt ---------------------- -Xdump:snap: events=gpf+abort+traceassert+corruptcache, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..0, priority=300, request=serial ---------------------- -Xdump:snap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..4, priority=300, request=serial ---------------------- -Xdump:jit: events=gpf+abort, label=/home/user/jitdump.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=200, request=serial ---------------------- Dump agent tokens You can use tokens to add context to dump file names and directories, and to pass command-line arguments to the tool agent. The tokens available are listed in the following table: Token Description %Y Year (4 digits) %y Year (2 digits) %m Month (2 digits) %d Day of the month (2 digits) %H Hour ( 2 digits) %M Minute (2 digits) %S Second (2 digits) %pid Process ID %uid User name %seq Dump counter %tick msec counter %home Java home directory %last Last dump %job Job name (z/OS only) %jobid Job ID (z/OS only) %asid Address space ID (z/OS only) &DS Dump Section. An incrementing sequence number used for splitting TDUMP files to be less than 2 GB in size. (z/OS 64-bit only) Merging dump agents If you configure more than one dump agent, each responds to events according to its configuration. However, the internal structures representing the dump agent configuration might not match the command line, because dump agents are merged for efficiency. Two sets of options can be merged as long as none of the agent settings conflict. This means that the list of installed dump agents and their parameters produced by -Xdump:what might not be grouped in the same way as the original -Xdump options that configured them. For example, you can use the following command to specify that a dump agent creates a Java dump file on class unload: java -Xdump:java:events=unload -Xdump:what This command does not create a new agent, as can be seen in the results from the -Xdump:what option. ... ---------------------- -Xdump:java: events=gpf+user+abort+unload+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- The configuration is merged with the existing Java dump agent for events gpf , user , abort , traceassert , and corruptcache , because none of the specified options for the new unload agent conflict with those for the existing agent. In the previous example, if one of the parameters for the unload agent is changed so that it conflicts with the existing agent, then it cannot be merged. For example, the following command specifies a different priority, forcing a separate agent to be created: java -Xdump:java:events=unload,priority=100 -Xdump:what The results of the -Xdump:what option in the command are as follows. ... ---------------------- -Xdump:java: events=unload, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=100, request=exclusive+preempt ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- To merge dump agents, the request , filter , opts , label , and range parameters must match exactly. If you specify multiple agents that filter on the same string, but keep all other parameters the same, the agents are merged. For example: java -Xdump:none -Xdump:java:events=uncaught,filter=java/lang/NullPointerException -Xdump:java:events=unload,filter=java/lang/NullPointerException -Xdump:what The results of this command are as follows: Registered dump agents ---------------------- -Xdump:java: events=unload+uncaught, filter=java/lang/NullPointerException, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- Dump events Dump agents are triggered by events occurring during operation of the OpenJ9 VM. Some events can be filtered to improve the relevance of the output. The following table shows the events that are available as dump agent triggers: Event Triggered when.... Filters on .... gpf A General Protection Fault (GPF) occurs. Not applicable user The VM receives the SIGQUIT (Linux, macOS\u00ae, AIX\u00ae, z/OS) or SIGBREAK (Windows\u2122) signal from the operating system. Not applicable abort The VM receives the SIGABRT signal from the operating system. Not applicable vmstart The virtual machine is started. Not applicable vmstop The virtual machine stops. Exit code; for example, filter=#129..#192#-42#255 load A class is loaded. Class name; for example, filter=java/lang/String unload A class is unloaded. Not applicable throw An exception is thrown explicitly in Java code. Use 'systhrow' for unexpected VM exceptions. Exception class name; for example, filter=java/lang/OutOfMem* catch An exception is caught. Exception class name; for example, filter=*Memory* uncaught A Java exception is not caught by the application. Exception class name; for example, filter=*MemoryError systhrow A Java exception is about to be thrown by the VM. This is different from the 'throw' event because it is only triggered for error conditions detected internally in the VM. Exception class name; for example, filter=java/lang/OutOfMem* . thrstart A new thread is started. Not applicable blocked A thread becomes blocked. Not applicable thrstop A thread stops. Not applicable fullgc A garbage collection cycle is started. Not applicable slow A thread takes longer than 50ms to respond to an internal VM request. Time taken; for example, filter=#300ms will trigger when a thread takes longer than 300ms to respond to an internal VM request. allocation A Java object is allocated with a size matching the given filter specification. Object size; a filter must be supplied. For example, filter=#5m will trigger on objects larger than 5 Mb. Ranges are also supported; for example, filter=#256k..512k will trigger on objects between 256 Kb and 512 Kb in size. traceassert An internal error occurs in the VM. Not applicable corruptcache The VM finds that the shared classes cache is corrupt. Not applicable excessivegc An excessive amount of time is being spent in the garbage collector. Not applicable Note: The gpf , traceassert , and abort events cannot trigger a heap dump, prepare the heap (request=prepwalk), or compact the heap (request=compact). Parameters -Xdump:<agent>:<suboptions> descriptions and examples. help To print usage information for a specific dump agent, use -Xdump:<agent>:help none:<options> Use the -Xdump:none option to add and remove dump agents for various VM events, update default dump settings (such as the dump name), and limit the number of dumps that are produced. The option can be used to affect all agents by specifying -Xdump:none:<options> or specific agents by specifying -Xdump:<agent>:none:<suboptions> where <suboptions> is one of the following control types: events=<event> exec=<command> file=<filename> filter=<filter> opts=<options> priority=<0-999> range=<ranges> request=<requests> Explanations for these suboptions are provided elsewhere in this topic. To remove all default dump agents and any preceding dump options, use -Xdump:none . Use this option so that you can subsequently specify a completely new dump configuration. You can also remove dump agents of a particular type. Here are some examples: To turn off all heap dumps (including default agents) but leave Java dumps enabled, use the following option: -Xdump:java+heap:events=vmstop -Xdump:heap:none To turn off all dump agents for corruptcache events: -Xdump:none:events=corruptcache To turn off just system dumps for corruptcache events: -Xdump:system:none:events=corruptcache To turn off all dumps when a java/lang/OutOfMemory error is thrown: -Xdump:none:events=systhrow,filter=java/lang/OutOfMemoryError To turn off just system dumps when a java/lang/OutOfMemory error is thrown: -Xdump:system:none:events=systhrow,filter=java/lang/OutOfMemoryError If you remove all dump agents by using -Xdump:none with no further -Xdump options, the VM still provides these basic diagnostic outputs: If a user signal (kill -QUIT) is sent to the VM, a brief listing of the Java threads including their stacks, status, and monitor information is written to stderr. If a crash occurs, information about the location of the crash, VM options, and native and Java stack traces are written to stderr. A system dump file is also written to the user's home directory. Note: Removing dump agents and specifying a new dump configuration can require a long set of command-line options. To reuse command-line options, save the new dump configuration in a file and use the -Xoptionsfile option. For more information, see -Xoptionsfile . defaults Each dump type has default options. To view the default options for a particular dump type, use -Xdump:<agent>:defaults . You can change the default options at run time. For example, you can direct Java dump files into a separate directory for each process, and guarantee unique files by adding a sequence number to the file name using: -Xdump:java:defaults:file=dumps/%pid/javacore-%seq.txt` Or, for example, on z/OS, you can add the jobname to the Java dump file name using: -Xdump:java:defaults:file=javacore.%job.%H%M%S.txt This option does not add a Java dump agent; it updates the default settings for Java dump agents. Further Java dump agents will then create dump files using this specification for filenames, unless overridden. Note: Changing the defaults for a dump type will also affect the default agents for that dump type added by the VM during initialization. For example if you change the default file name for Java dump files, that will change the file name used by the default Java dump agents. However, changing the default range option will not change the range used by the default Java dump agents, because those agents override the range option with specific values. events=<event> To trigger a dump as a result of an event, use the -Xdump:<agent>:events=<event> suboption. For a list of possible events, see Dump events . For example, the following command instructs the VM to create a dump agent at startup that produces a Heap dump whenever the vmstop event happens: -Xdump:heap:events=vmstop exec=<command> The exec suboption is used by the tool dump agent to specify an external application to start. You can set a specific command to run for a particular dump agent with the following command: -Xdump:<agent>:exec=<command> file=<filename> The file suboption specifies where the diagnostics information is written for the specified dump type. The syntax is -Xdump:<agent>:file=<filename> . For example, to create a Heap dump called my.dmp when a vmstop event is received, use: java -Xdump:heap:events=vmstop,file=my.dmp When producing system dump files on z/OS platforms, use the dsn option instead of the file option. For example: java -Xdump:system:events=vmstop,dsn=%uid.MYDUMP Writing to STDOUT / STDERR Add one of the following options to write a Java dump file to STDOUT or STDERR respectively: -Xdump:java:file=/STDOUT/ -Xdump:java:file=/STDERR/ The keywords /STDOUT/ and /STDERR/ are not case sensitive; /stdout/ and /stderr/ are equivalent. By common convention, you can use a dash ( - ) to refer to STDOUT: -Xdump:java:file=- Tokens You can use tokens to add context to dump file names. For a list of tokens, see Dump agent tokens . File location The location for the dump file is selected from the following options, in this order: The location specified by the -Xdump:<agent>:file suboption on the command line (if that location includes a path). This location applies to the specified dump agent type only. The location specified by the -Xdump:directory option on the command line. This location applies to all dump agent types. The location specified by the relevant environment variable: Dump agent type z/OS operating systems Other operating systems Java dumps _CEE_DMPTARG IBM_JAVACOREDIR Heap dumps _CEE_DMPTARG IBM_HEAPDUMPDIR System dumps JAVA_DUMP_TDUMP_PATTERN IBM_COREDIR JIT dumps _CEE_DMPTARG IBM_COREDIR Snap traces _CEE_DMPTARG IBM_COREDIR The current working directory of the OpenJ9 VM process. If the directory does not exist, it is created. If the dump file cannot be written to the selected location, the VM reverts to using the following locations, in this order: On Windows platforms only, the system default location is C:\\WINDOWS . The location specified by the TMPDIR environment variable. The C:\\Temp on Windows operating systems, or the /tmp directory on other operating systems. This VM action does not apply to system dumps on z/OS operating systems that use the dsn option. You can prevent the VM reverting to different dump locations by using the -Xdump:nofailover option. filter=<filter> Some VM events occur thousands of times during the lifetime of an application. Dump agents can use filters and ranges to avoid producing an excessive number of dump files. The following syntax must be used: -Xdump:<agent>:filter=<filter> Wildcards You can use a wildcard in your exception event filter by placing an asterisk only at the beginning or end of the filter. The following command does not work because the second asterisk is not at the end: -Xdump:java:events=throw,filter=*InvalidArgumentException#*.myVirtualMethod To fix the problem, change this filter to the following string: -Xdump:java:events=throw,filter=*InvalidArgumentException#MyApplication.* Class loading and exception events You can filter class loading ( load ) and exception ( throw , catch , uncaught , systhrow ) events by the name of the class that is being loaded, thrown or caught. For example: -Xdump:java:events=load,filter=java/lang/String -Xdump:java:events=throw,filter=java/lang/ArrayStoreException -Xdump:java:events=catch,filter=java/lang/NullPointerException In addition, you can filter throw , uncaught , and systhrow exception events by the name of the method that throws the exception. The name of the parent class must include the full package name, using the forward slash (/) as a separator. Use a dot (.) to separate the method name from the class name. You can use an asterisk (*) as a wildcard character, to include all methods (optional portions are shown in brackets). For example: -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] For example, to trigger a Java dump when method MyApplication.myMethod() throws a NullPointerException exception, use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.myMethod The stack frame offset allows you to filter on the name of a method that calls the throwing method. This option is useful if the exception is being thrown from a general purpose or utility class. For example, to trigger a Java dump when a method called by MyApplication.main() throws a NullPointerException , use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.main#1 The default value of the stack frame offset is zero. You can filter the catch exception events by Java method name (optional portions are shown in brackets). For example: -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] You can filter throw , uncaught , and systhrowexception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] You can filter the catch exception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] Note: The filters apply to the stacktrace and fire every time the same exception is rethrown, which might result in multiple Java core files. vmstop event You can filter the VM shut down event ( vmstop ) by using one or more exit codes: -Xdump:java:events=vmstop,filter=#129..192#-42#255 slow event You can filter the slow event to change the time threshold from the default of 50 ms: -Xdump:java:events=slow,filter=#300ms allocation event You must filter the allocation event to specify the size of objects that cause a trigger. You can set the filter size from zero up to the maximum value of a 32-bit pointer on 32-bit platforms, or the maximum value of a 64-bit pointer on 64-bit platforms. Setting the lower filter value to zero triggers a dump on all allocations. For example, to trigger dumps on allocations greater than 5 Mb in size, use: -Xdump:stack:events=allocation,filter=#5m To trigger dumps on allocations between 256Kb and 512Kb in size, use: -Xdump:stack:events=allocation,filter=#256k..512k Other events If you apply a filter to an event that does not support filtering, the filter is ignored. msg_filter=<filter> You can use the msg_filter suboption to filter on text strings within an exception message, allowing you to reduce the number of dump files produced. This option is supported only for the following events: throw , catch , systhrow , and uncaught . Use the following syntax to include message filtering in your dump output: -Xdump:<agent>:events=<event>,msg_filter=<filter>` where <filter> is a text string from the exceptions that you want to include in the dump file. This suboption supports asterisks as wild cards. The following example filters java/lang/VerifyError exceptions that contains the text string class format : -Xdump:java:events=throw,filter=java/lang/VerifyError,msg_filter=*class format* opts=<options> The full syntax is -Xdump:<agent>:opts=<options> . The heap dump agent uses this suboption to specify the type of file to produce. On z/OS, the system dump agent uses this suboption to specify the type of dump to produce. Heap dumps You can specify a PHD heap dump file (PHD), a classic text heap dump file (CLASSIC), or both. The default is a PHD file. For example: -Xdump:heap:opts=PHD -Xdump:heap:opts=CLASSIC -Xdump:heap:opts=PHD+CLASSIC z/OS system dumps You can specify a system transaction dump (IEATDUMP), an LE dump (CEEDUMP), or both. The default is an IEADUMP file. For example: -Xdump:system:opts=IEATDUMP -Xdump:system:opts=CEEDUMP -Xdump:system:opts=IEATDUMP+CEEDUMP The ceedump agent is the preferred way to specify LE dumps, for example: -Xdump:ceedump:events=gpf Tool dumps The tool dump agent supports two suboptions that can be specified using the opts subption. You can run the external process asynchronously with opts=ASYNC. You can also specify a delay in milliseconds that produces a pause after starting the command. These two options can be used independently or together. The following examples show different options for starting a new process that runs myProgram : -Xdump:tool:events=vmstop,exec=myProgram Without the opts suboption, the tool dump agent starts the process, and waits for the process to end before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC When opts=ASYNC is specified, the tool dump agent starts the process, and continues without waiting for the new process to end. -Xdump:tool:events=vmstop,exec=myProgram,opts=WAIT1000 This option starts the process, waits for the process to end, and then waits a further 1 second (1000 milliseconds) before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC+WAIT10000 Finally the last example starts the process and waits for 10 seconds before continuing, whether the process is still running or not. This last form is useful if you are starting a process that does not end, but requires time to initialize properly. priority=<0-999> One event can generate multiple dump files. The agents that produce each dump file run sequentially and their order is determined by the priority keyword set for each agent. The full syntax for this command is -Xdump:<agent>:priority=<0-999> . Examination of the output from -Xdump:what shows that a gpf event produces a snap trace, a Java dump file, and a system dump file. In this example, the system dump runs first, with priority 999. The snap dump runs second, with priority 500. The Java dump runs last, with priority 10: -Xdump:heap:events=vmstop,priority=123 The maximum value allowed for priority is 999. Higher priority dump agents are started first. If you do not specifically set a priority, default values are taken based on the dump type. The default priority and the other default values for a particular type of dump, can be displayed by using -Xdump:<type>:defaults . For example: java -Xdump:heap:defaults -version Default -Xdump:heap settings: events=gpf+user filter= file=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.phd range=1..0 priority=500 request=exclusive+compact+prepwalk opts=PHD range=<ranges> You can start and stop dump agents on a particular occurrence of a VM event by using the range suboption: -Xdump:<agent>:range=<ranges> For example: -Xdump:java:events=fullgc,range=100..200 Note: range=1..0 against an event means \"on every occurrence\". The VM default dump agents have the range suboption set to 1..0 for all events except systhrow. Most systhrow events with filter=java/lang/OutOfMemoryError have the range suboption set to 1..4, which limits the number of dump files produced on OutOfMemory conditions to a maximum of 4. For more information, see Default dump agents . If you add a new dump agent and do not specify the range, a default of 1..0 is used. request=<requests> Use the request suboption to ask the VM to prepare the state before starting the dump agent: -Xdump:<agent>:request=<requests> The available suboptions are listed in the following table: suboption value Description exclusive Request exclusive access to the VM. compact Run garbage collection. This option removes all unreachable objects from the heap before the dump file is generated. prepwalk Prepare the heap for walking. You must also specify exclusive when you use this option. serial Suspend other dumps until this dump is finished. preempt Applies to the Java dump agent and controls whether native threads in the process are forcibly pre-empted in order to collect stack traces. If this option is not specified, only Java stack traces are collected in the Java dump. You can specify more than one request option by using + . For example: -Xdump:heap:request=exclusive+compact+prepwalk The VM exclusive access mechanism allows a VM thread to halt the activity of other VM threads in a controlled way by using internal VM locks. When the request=exclusive option is specified for a dump agent, the VM thread that is producing the dump waits for threads that are running Java code to halt, and for garbage collection operations to complete, before the dump file is written. This process helps ensure that the dump has consistent data. When the dump is complete, the mechanism allows the other threads to resume. By default, only system dumps for OutOfMemoryError exceptions request exclusive access. Other system dump events typically result from a crash. In these cases, exclusive access is not requested because acquiring locks during a crash can be problematic. If system dumps are requested by using the com.ibm.jvm.Dump.SystemDump() API, the default system dump agent settings are used, and exclusive access is not requested. However, if you intend to use the system dump file for Java heap memory analysis, use the following option to request exclusive access when the dump is taken: -Xdump:system:defaults:request=exclusive+compact+prepwalk These settings avoid capturing a dump file with in-flight data during garbage collection. As an alternative, you can use the com.ibm.jvm.Dump.triggerDump() API and specify request=exclusive+compact+prepwalk on the API call. For more information about the com.ibm.jvm.Dump API , see the API reference information. The default setting of the request suboption for Java dump files is request=exclusive+preempt . To change the settings so that Java dump files are produced without pre-empting threads to collect native stack traces, use the following option: -Xdump:java:request=exclusive In general, the default request options are sufficient. Dump output Dump output is written to different files, depending on the type of dump and the platform. File names include a time stamp. Dump type File name (AIX, Linux, macOS, Windows) File name (z/OS) System dump core.%Y%m%d.%H%M%S.%pid.dmp %uid.JVM.TDUMP.%job.D%Y%m%d.T%H%M%S (31-bit), %uid.JVM.%job.D%y%m%d.T%H%M%S.X&DS (64-bit) See Note Java dump javacore.%Y%m%d.%H%M%S.%pid.%seq.txt javacore.%Y%m%d.%H%M%S.%pid.%seq.txt Heap dump heapdump.%Y%m%d.%H%M%S.%pid.phd heapdump.%Y%m%d.T%H%M%S.phd JIT dump jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp LE CEEDUMP - CEEDUMP.%Y%m%d.%H%M%S.%pid See Note The tokens used in this table, for example %Y , are described in Dump agent tokens . Note: On z/OS, the system dump file name can be set with the JAVA_DUMP_TDUMP_PATTERN environment variable. The CEEDUMP, which is not produced by default, is stored in the directory specified by _CEE_DMPTARG or the current directory if _CEE_DMPTARG is not specified. System dumps on Linux Linux does not provide an operating system API for generating a system dump from a running process. The VM produces system dumps on Linux by using the fork() API to start an identical process to the parent VM process. The VM then generates a SIGSEGV signal in the child process. The SIGSEGV signal causes Linux to create a system dump for the child process. The parent VM processes and renames the system dump, as required, by the -Xdump options, and might add additional data into the dump file. The system dump file for the child process contains an exact copy of the memory areas used in the parent. The dump viewer can obtain information about the Java threads, classes, and heap from the system dump. However, the dump viewer, and other system dump debuggers show only the single native thread that was running in the child process. You can use the Linux kernel.core_pattern setting to specify the name and path for system dumps. The VM dump agents override the Linux system dump name and path by renaming the dump as specified in the -Xdump options. If the kernel.core_pattern setting specifies a different file system to the -Xdump options, the VM dump agents might be unable to change the file path. In this case the VM renames the dump file, but leaves the file path unchanged. You can find the dump file name and location in the JVMDUMP010I message. Note: If you use the %t specifier in the kernel.core_pattern setting, the VM does not rename the dump. The VM cannot determine the exact time that Linux generated the core file, and therefore cannot be certain which Linux dump file is the correct one to rename. See also -Xtrace -Xdisablejavadump","title":"-Xdump"},{"location":"xdump/#-xdump","text":"OpenJ9 produces various types of diagnostic information for analysis when different events occur, such as a general protection fault. The dumps produced are controlled by dump agents, which are initialized when the OpenJ9 virtual machine (VM) starts. The default settings for the dump agents are sufficient for most cases. However, you can use the -Xdump option on the command line to fine tune the dump agent settings. For example, you can use the -Xdump option to add and remove dump agents for various VM events, update default dump settings, and limit the number of dumps that are produced. A large set of options and suboptions are available for controlling dumps, which provides a lot of flexibility.","title":"-Xdump"},{"location":"xdump/#xdump-option-builder","text":"Use the Xdump Option Builder tool to help you specify the correct options and avoid incompatibilities.","title":"Xdump Option Builder"},{"location":"xdump/#syntax","text":"-Xdump:<parameter> The following table lists the help options for -Xdump , which provide usage and configuration information: Command Result -Xdump:help Displays general dump help. -Xdump:events Lists available trigger events. -Xdump:request Lists additional VM requests. -Xdump:tokens Lists recognized label tokens. -Xdump:what Shows registered agents on startup. -Xdump:<agent>:help Displays dump agent usage information. The following options can be used to control the production of diagnostic data: Parameter Result -Xdump:none Removes all default dump agents and any preceding dump options. -Xdump:dynamic Enable support for pluggable agents -Xdump:nofailover Discards dumps when the default or specified dump location is full. -Xdump:directory=<path> Specifies a directory for all dump types to be written to. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents. -Xdump:suspendwith=<offset> Modifies the signal that is used to suspend VM threads while a dump file is being written. Use <offset> to change the default signal number. (Linux\u00ae only) -Xdump:<agent>:<suboptions> Provides detailed suboptions per dump agent that provide more granular control. Dump agents can be configured at a very granular level by specifying suboptions. The <events> suboption is the prime trigger mechanism. The full set of suboptions are listed in the following table: Dump agent suboptions Result -Xdump:<agent>:none Removes the dump agent. -Xdump:<agent>:defaults Prints the default options for the dump agent. -Xdump:<agent>:events=<events> Triggers a dump agent when a specific event occurs. -Xdump:<agent>:exec=<command> Starts an external application for the dump agent. -Xdump:<agent>:file=<filename> Specifies where to write the dump for the dump agent. -Xdump:<agent>:filter=<filter> Filters dumps by wildcards or events. -Xdump:<agent>:msg_filter=<filter> Filters on text strings within an exception message. -Xdump:<agent>:opts=<options> Used by specific dump agents to select the type of dump file to produce. -Xdump:<agent>:priority=<0-999> Specifies the priority that the dump agents run in. -Xdump:<agent>:range=<ranges> Starts and stops a dump agent on a particular occurrence of a VM. -Xdump:<agent>:request=<requests> Asks the VM to prepare the state before starting the dump agent. You can have multiple -Xdump options on the command line. You can also have multiple dump types triggered by multiple events. For example, the following command turns off the creation of heap dump files, and creates a dump agent that produces a heap dump file and a Java\u2122 dump file when either a vmstart or vmstop event occurs: java -Xdump:heap:none -Xdump:heap+java:events=vmstart+vmstop -mp . -m <class> [args...] Note: Multiple suboptions that follow an Xdump suboption must be split with a comma (,), for example: java -Xdump:java:events=vmstart,file=/STDERR/ -version For more detailed information on the these parameters and suboptions, including examples, see Parameters .","title":"Syntax"},{"location":"xdump/#dump-agents","text":"A dump agent performs diagnostic tasks when triggered. Most dump agents save information on the state of the VM in some form of dump or trace file for later analysis. An exception is the \"tool\" agent, which can be used to trigger external processes when specific events occur. Dump agent Description stack Stack dumps are very basic dumps in which the status and Java stack of the thread is written to stderr. console Console dumps are very basic dumps, in which the status of every Java thread is written to stderr. system System dumps capture the raw process image or address space of an application. tool The tool option allows external processes to be started when an event occurs. java Java dumps are an internally generated and formatted analysis of the VM, giving information that includes the Java threads present, the classes loaded, and heap statistics. heap Heap dumps capture all object instances in the heap, including each object address, type or class name, size, and references to other objects. snap Take a snap of the trace buffers, which contain tracepoint data. ceedump LE CEEDUMP dumps are z/OS\u00ae formatted summary system dumps that show stack traces for each thread that is in the VM process, together with register information and a short dump of storage for each register. jit JIT compiler dumps contain diagnostic data in a binary format. exit Shut down the VM.","title":"Dump agents"},{"location":"xdump/#default-dump-agents","text":"During VM initialization a set of dump agents are added by default. You can override this set of dump agents using -Xdump on the command line. To show the registered dump agents, user the Xdump:what option on the command line. The following sample output shows the default dump agents that are in place on a Linux system: java -Xdump:what Registered dump agents ---------------------- -Xdump:system: events=gpf+abort+traceassert+corruptcache, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=999, request=serial ---------------------- -Xdump:system: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/core.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..1, priority=999, request=exclusive+compact+prepwalk ---------------------- -Xdump:heap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.%seq.phd, range=1..4, priority=500, request=exclusive+compact+prepwalk, opts=PHD ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- -Xdump:java: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..4, priority=400, request=exclusive+preempt ---------------------- -Xdump:snap: events=gpf+abort+traceassert+corruptcache, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..0, priority=300, request=serial ---------------------- -Xdump:snap: events=systhrow, filter=java/lang/OutOfMemoryError, label=/home/user/Snap.%Y%m%d.%H%M%S.%pid.%seq.trc, range=1..4, priority=300, request=serial ---------------------- -Xdump:jit: events=gpf+abort, label=/home/user/jitdump.%Y%m%d.%H%M%S.%pid.%seq.dmp, range=1..0, priority=200, request=serial ----------------------","title":"Default dump agents"},{"location":"xdump/#dump-agent-tokens","text":"You can use tokens to add context to dump file names and directories, and to pass command-line arguments to the tool agent. The tokens available are listed in the following table: Token Description %Y Year (4 digits) %y Year (2 digits) %m Month (2 digits) %d Day of the month (2 digits) %H Hour ( 2 digits) %M Minute (2 digits) %S Second (2 digits) %pid Process ID %uid User name %seq Dump counter %tick msec counter %home Java home directory %last Last dump %job Job name (z/OS only) %jobid Job ID (z/OS only) %asid Address space ID (z/OS only) &DS Dump Section. An incrementing sequence number used for splitting TDUMP files to be less than 2 GB in size. (z/OS 64-bit only)","title":"Dump agent tokens"},{"location":"xdump/#merging-dump-agents","text":"If you configure more than one dump agent, each responds to events according to its configuration. However, the internal structures representing the dump agent configuration might not match the command line, because dump agents are merged for efficiency. Two sets of options can be merged as long as none of the agent settings conflict. This means that the list of installed dump agents and their parameters produced by -Xdump:what might not be grouped in the same way as the original -Xdump options that configured them. For example, you can use the following command to specify that a dump agent creates a Java dump file on class unload: java -Xdump:java:events=unload -Xdump:what This command does not create a new agent, as can be seen in the results from the -Xdump:what option. ... ---------------------- -Xdump:java: events=gpf+user+abort+unload+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- The configuration is merged with the existing Java dump agent for events gpf , user , abort , traceassert , and corruptcache , because none of the specified options for the new unload agent conflict with those for the existing agent. In the previous example, if one of the parameters for the unload agent is changed so that it conflicts with the existing agent, then it cannot be merged. For example, the following command specifies a different priority, forcing a separate agent to be created: java -Xdump:java:events=unload,priority=100 -Xdump:what The results of the -Xdump:what option in the command are as follows. ... ---------------------- -Xdump:java: events=unload, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=100, request=exclusive+preempt ---------------------- -Xdump:java: events=gpf+user+abort+traceassert+corruptcache, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ---------------------- To merge dump agents, the request , filter , opts , label , and range parameters must match exactly. If you specify multiple agents that filter on the same string, but keep all other parameters the same, the agents are merged. For example: java -Xdump:none -Xdump:java:events=uncaught,filter=java/lang/NullPointerException -Xdump:java:events=unload,filter=java/lang/NullPointerException -Xdump:what The results of this command are as follows: Registered dump agents ---------------------- -Xdump:java: events=unload+uncaught, filter=java/lang/NullPointerException, label=/home/user/javacore.%Y%m%d.%H%M%S.%pid.%seq.txt, range=1..0, priority=400, request=exclusive+preempt ----------------------","title":"Merging dump agents"},{"location":"xdump/#dump-events","text":"Dump agents are triggered by events occurring during operation of the OpenJ9 VM. Some events can be filtered to improve the relevance of the output. The following table shows the events that are available as dump agent triggers: Event Triggered when.... Filters on .... gpf A General Protection Fault (GPF) occurs. Not applicable user The VM receives the SIGQUIT (Linux, macOS\u00ae, AIX\u00ae, z/OS) or SIGBREAK (Windows\u2122) signal from the operating system. Not applicable abort The VM receives the SIGABRT signal from the operating system. Not applicable vmstart The virtual machine is started. Not applicable vmstop The virtual machine stops. Exit code; for example, filter=#129..#192#-42#255 load A class is loaded. Class name; for example, filter=java/lang/String unload A class is unloaded. Not applicable throw An exception is thrown explicitly in Java code. Use 'systhrow' for unexpected VM exceptions. Exception class name; for example, filter=java/lang/OutOfMem* catch An exception is caught. Exception class name; for example, filter=*Memory* uncaught A Java exception is not caught by the application. Exception class name; for example, filter=*MemoryError systhrow A Java exception is about to be thrown by the VM. This is different from the 'throw' event because it is only triggered for error conditions detected internally in the VM. Exception class name; for example, filter=java/lang/OutOfMem* . thrstart A new thread is started. Not applicable blocked A thread becomes blocked. Not applicable thrstop A thread stops. Not applicable fullgc A garbage collection cycle is started. Not applicable slow A thread takes longer than 50ms to respond to an internal VM request. Time taken; for example, filter=#300ms will trigger when a thread takes longer than 300ms to respond to an internal VM request. allocation A Java object is allocated with a size matching the given filter specification. Object size; a filter must be supplied. For example, filter=#5m will trigger on objects larger than 5 Mb. Ranges are also supported; for example, filter=#256k..512k will trigger on objects between 256 Kb and 512 Kb in size. traceassert An internal error occurs in the VM. Not applicable corruptcache The VM finds that the shared classes cache is corrupt. Not applicable excessivegc An excessive amount of time is being spent in the garbage collector. Not applicable Note: The gpf , traceassert , and abort events cannot trigger a heap dump, prepare the heap (request=prepwalk), or compact the heap (request=compact).","title":"Dump events"},{"location":"xdump/#parameters","text":"-Xdump:<agent>:<suboptions> descriptions and examples.","title":"Parameters"},{"location":"xdump/#help","text":"To print usage information for a specific dump agent, use -Xdump:<agent>:help","title":"help"},{"location":"xdump/#noneltoptionsgt","text":"Use the -Xdump:none option to add and remove dump agents for various VM events, update default dump settings (such as the dump name), and limit the number of dumps that are produced. The option can be used to affect all agents by specifying -Xdump:none:<options> or specific agents by specifying -Xdump:<agent>:none:<suboptions> where <suboptions> is one of the following control types: events=<event> exec=<command> file=<filename> filter=<filter> opts=<options> priority=<0-999> range=<ranges> request=<requests> Explanations for these suboptions are provided elsewhere in this topic. To remove all default dump agents and any preceding dump options, use -Xdump:none . Use this option so that you can subsequently specify a completely new dump configuration. You can also remove dump agents of a particular type. Here are some examples: To turn off all heap dumps (including default agents) but leave Java dumps enabled, use the following option: -Xdump:java+heap:events=vmstop -Xdump:heap:none To turn off all dump agents for corruptcache events: -Xdump:none:events=corruptcache To turn off just system dumps for corruptcache events: -Xdump:system:none:events=corruptcache To turn off all dumps when a java/lang/OutOfMemory error is thrown: -Xdump:none:events=systhrow,filter=java/lang/OutOfMemoryError To turn off just system dumps when a java/lang/OutOfMemory error is thrown: -Xdump:system:none:events=systhrow,filter=java/lang/OutOfMemoryError If you remove all dump agents by using -Xdump:none with no further -Xdump options, the VM still provides these basic diagnostic outputs: If a user signal (kill -QUIT) is sent to the VM, a brief listing of the Java threads including their stacks, status, and monitor information is written to stderr. If a crash occurs, information about the location of the crash, VM options, and native and Java stack traces are written to stderr. A system dump file is also written to the user's home directory. Note: Removing dump agents and specifying a new dump configuration can require a long set of command-line options. To reuse command-line options, save the new dump configuration in a file and use the -Xoptionsfile option. For more information, see -Xoptionsfile .","title":"none:&lt;options&gt;"},{"location":"xdump/#defaults","text":"Each dump type has default options. To view the default options for a particular dump type, use -Xdump:<agent>:defaults . You can change the default options at run time. For example, you can direct Java dump files into a separate directory for each process, and guarantee unique files by adding a sequence number to the file name using: -Xdump:java:defaults:file=dumps/%pid/javacore-%seq.txt` Or, for example, on z/OS, you can add the jobname to the Java dump file name using: -Xdump:java:defaults:file=javacore.%job.%H%M%S.txt This option does not add a Java dump agent; it updates the default settings for Java dump agents. Further Java dump agents will then create dump files using this specification for filenames, unless overridden. Note: Changing the defaults for a dump type will also affect the default agents for that dump type added by the VM during initialization. For example if you change the default file name for Java dump files, that will change the file name used by the default Java dump agents. However, changing the default range option will not change the range used by the default Java dump agents, because those agents override the range option with specific values.","title":"defaults"},{"location":"xdump/#eventslteventgt","text":"To trigger a dump as a result of an event, use the -Xdump:<agent>:events=<event> suboption. For a list of possible events, see Dump events . For example, the following command instructs the VM to create a dump agent at startup that produces a Heap dump whenever the vmstop event happens: -Xdump:heap:events=vmstop","title":"events=&lt;event&gt;"},{"location":"xdump/#execltcommandgt","text":"The exec suboption is used by the tool dump agent to specify an external application to start. You can set a specific command to run for a particular dump agent with the following command: -Xdump:<agent>:exec=<command>","title":"exec=&lt;command&gt;"},{"location":"xdump/#fileltfilenamegt","text":"The file suboption specifies where the diagnostics information is written for the specified dump type. The syntax is -Xdump:<agent>:file=<filename> . For example, to create a Heap dump called my.dmp when a vmstop event is received, use: java -Xdump:heap:events=vmstop,file=my.dmp When producing system dump files on z/OS platforms, use the dsn option instead of the file option. For example: java -Xdump:system:events=vmstop,dsn=%uid.MYDUMP","title":"file=&lt;filename&gt;"},{"location":"xdump/#writing-to-stdoutstderr","text":"Add one of the following options to write a Java dump file to STDOUT or STDERR respectively: -Xdump:java:file=/STDOUT/ -Xdump:java:file=/STDERR/ The keywords /STDOUT/ and /STDERR/ are not case sensitive; /stdout/ and /stderr/ are equivalent. By common convention, you can use a dash ( - ) to refer to STDOUT: -Xdump:java:file=-","title":"Writing to STDOUT/STDERR"},{"location":"xdump/#tokens","text":"You can use tokens to add context to dump file names. For a list of tokens, see Dump agent tokens .","title":"Tokens"},{"location":"xdump/#file-location","text":"The location for the dump file is selected from the following options, in this order: The location specified by the -Xdump:<agent>:file suboption on the command line (if that location includes a path). This location applies to the specified dump agent type only. The location specified by the -Xdump:directory option on the command line. This location applies to all dump agent types. The location specified by the relevant environment variable: Dump agent type z/OS operating systems Other operating systems Java dumps _CEE_DMPTARG IBM_JAVACOREDIR Heap dumps _CEE_DMPTARG IBM_HEAPDUMPDIR System dumps JAVA_DUMP_TDUMP_PATTERN IBM_COREDIR JIT dumps _CEE_DMPTARG IBM_COREDIR Snap traces _CEE_DMPTARG IBM_COREDIR The current working directory of the OpenJ9 VM process. If the directory does not exist, it is created. If the dump file cannot be written to the selected location, the VM reverts to using the following locations, in this order: On Windows platforms only, the system default location is C:\\WINDOWS . The location specified by the TMPDIR environment variable. The C:\\Temp on Windows operating systems, or the /tmp directory on other operating systems. This VM action does not apply to system dumps on z/OS operating systems that use the dsn option. You can prevent the VM reverting to different dump locations by using the -Xdump:nofailover option.","title":"File location"},{"location":"xdump/#filterltfiltergt","text":"Some VM events occur thousands of times during the lifetime of an application. Dump agents can use filters and ranges to avoid producing an excessive number of dump files. The following syntax must be used: -Xdump:<agent>:filter=<filter>","title":"filter=&lt;filter&gt;"},{"location":"xdump/#wildcards","text":"You can use a wildcard in your exception event filter by placing an asterisk only at the beginning or end of the filter. The following command does not work because the second asterisk is not at the end: -Xdump:java:events=throw,filter=*InvalidArgumentException#*.myVirtualMethod To fix the problem, change this filter to the following string: -Xdump:java:events=throw,filter=*InvalidArgumentException#MyApplication.*","title":"Wildcards"},{"location":"xdump/#class-loading-and-exception-events","text":"You can filter class loading ( load ) and exception ( throw , catch , uncaught , systhrow ) events by the name of the class that is being loaded, thrown or caught. For example: -Xdump:java:events=load,filter=java/lang/String -Xdump:java:events=throw,filter=java/lang/ArrayStoreException -Xdump:java:events=catch,filter=java/lang/NullPointerException In addition, you can filter throw , uncaught , and systhrow exception events by the name of the method that throws the exception. The name of the parent class must include the full package name, using the forward slash (/) as a separator. Use a dot (.) to separate the method name from the class name. You can use an asterisk (*) as a wildcard character, to include all methods (optional portions are shown in brackets). For example: -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] For example, to trigger a Java dump when method MyApplication.myMethod() throws a NullPointerException exception, use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.myMethod The stack frame offset allows you to filter on the name of a method that calls the throwing method. This option is useful if the exception is being thrown from a general purpose or utility class. For example, to trigger a Java dump when a method called by MyApplication.main() throws a NullPointerException , use the following syntax: -Xdump:java:events=throw,filter=java/lang/NullPointerException#com/ibm/MyApplication.main#1 The default value of the stack frame offset is zero. You can filter the catch exception events by Java method name (optional portions are shown in brackets). For example: -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] You can filter throw , uncaught , and systhrowexception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=throw,filter=ExceptionClassName[#com/ibm/ThrowingClassName.throwingMethodName[#stackFrameOffset]] You can filter the catch exception events by Java method name (optional portions are shown in brackets): -Xdump:java:events=catch,filter=ExceptionClassName[#com/ibm/CatchingClassName.catchingMethodName] Note: The filters apply to the stacktrace and fire every time the same exception is rethrown, which might result in multiple Java core files.","title":"Class loading and exception events"},{"location":"xdump/#vmstop-event","text":"You can filter the VM shut down event ( vmstop ) by using one or more exit codes: -Xdump:java:events=vmstop,filter=#129..192#-42#255","title":"vmstop event"},{"location":"xdump/#slow-event","text":"You can filter the slow event to change the time threshold from the default of 50 ms: -Xdump:java:events=slow,filter=#300ms","title":"slow event"},{"location":"xdump/#allocation-event","text":"You must filter the allocation event to specify the size of objects that cause a trigger. You can set the filter size from zero up to the maximum value of a 32-bit pointer on 32-bit platforms, or the maximum value of a 64-bit pointer on 64-bit platforms. Setting the lower filter value to zero triggers a dump on all allocations. For example, to trigger dumps on allocations greater than 5 Mb in size, use: -Xdump:stack:events=allocation,filter=#5m To trigger dumps on allocations between 256Kb and 512Kb in size, use: -Xdump:stack:events=allocation,filter=#256k..512k","title":"allocation event"},{"location":"xdump/#other-events","text":"If you apply a filter to an event that does not support filtering, the filter is ignored.","title":"Other events"},{"location":"xdump/#msg_filterltfiltergt","text":"You can use the msg_filter suboption to filter on text strings within an exception message, allowing you to reduce the number of dump files produced. This option is supported only for the following events: throw , catch , systhrow , and uncaught . Use the following syntax to include message filtering in your dump output: -Xdump:<agent>:events=<event>,msg_filter=<filter>` where <filter> is a text string from the exceptions that you want to include in the dump file. This suboption supports asterisks as wild cards. The following example filters java/lang/VerifyError exceptions that contains the text string class format : -Xdump:java:events=throw,filter=java/lang/VerifyError,msg_filter=*class format*","title":"msg_filter=&lt;filter&gt;"},{"location":"xdump/#optsltoptionsgt","text":"The full syntax is -Xdump:<agent>:opts=<options> . The heap dump agent uses this suboption to specify the type of file to produce. On z/OS, the system dump agent uses this suboption to specify the type of dump to produce.","title":"opts=&lt;options&gt;"},{"location":"xdump/#heap-dumps","text":"You can specify a PHD heap dump file (PHD), a classic text heap dump file (CLASSIC), or both. The default is a PHD file. For example: -Xdump:heap:opts=PHD -Xdump:heap:opts=CLASSIC -Xdump:heap:opts=PHD+CLASSIC","title":"Heap dumps"},{"location":"xdump/#zos-system-dumps","text":"You can specify a system transaction dump (IEATDUMP), an LE dump (CEEDUMP), or both. The default is an IEADUMP file. For example: -Xdump:system:opts=IEATDUMP -Xdump:system:opts=CEEDUMP -Xdump:system:opts=IEATDUMP+CEEDUMP The ceedump agent is the preferred way to specify LE dumps, for example: -Xdump:ceedump:events=gpf","title":"z/OS system dumps"},{"location":"xdump/#tool-dumps","text":"The tool dump agent supports two suboptions that can be specified using the opts subption. You can run the external process asynchronously with opts=ASYNC. You can also specify a delay in milliseconds that produces a pause after starting the command. These two options can be used independently or together. The following examples show different options for starting a new process that runs myProgram : -Xdump:tool:events=vmstop,exec=myProgram Without the opts suboption, the tool dump agent starts the process, and waits for the process to end before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC When opts=ASYNC is specified, the tool dump agent starts the process, and continues without waiting for the new process to end. -Xdump:tool:events=vmstop,exec=myProgram,opts=WAIT1000 This option starts the process, waits for the process to end, and then waits a further 1 second (1000 milliseconds) before continuing. -Xdump:tool:events=vmstop,exec=myProgram,opts=ASYNC+WAIT10000 Finally the last example starts the process and waits for 10 seconds before continuing, whether the process is still running or not. This last form is useful if you are starting a process that does not end, but requires time to initialize properly.","title":"Tool dumps"},{"location":"xdump/#prioritylt0-999gt","text":"One event can generate multiple dump files. The agents that produce each dump file run sequentially and their order is determined by the priority keyword set for each agent. The full syntax for this command is -Xdump:<agent>:priority=<0-999> . Examination of the output from -Xdump:what shows that a gpf event produces a snap trace, a Java dump file, and a system dump file. In this example, the system dump runs first, with priority 999. The snap dump runs second, with priority 500. The Java dump runs last, with priority 10: -Xdump:heap:events=vmstop,priority=123 The maximum value allowed for priority is 999. Higher priority dump agents are started first. If you do not specifically set a priority, default values are taken based on the dump type. The default priority and the other default values for a particular type of dump, can be displayed by using -Xdump:<type>:defaults . For example: java -Xdump:heap:defaults -version Default -Xdump:heap settings: events=gpf+user filter= file=/home/user/heapdump.%Y%m%d.%H%M%S.%pid.phd range=1..0 priority=500 request=exclusive+compact+prepwalk opts=PHD","title":"priority=&lt;0-999&gt;"},{"location":"xdump/#rangeltrangesgt","text":"You can start and stop dump agents on a particular occurrence of a VM event by using the range suboption: -Xdump:<agent>:range=<ranges> For example: -Xdump:java:events=fullgc,range=100..200 Note: range=1..0 against an event means \"on every occurrence\". The VM default dump agents have the range suboption set to 1..0 for all events except systhrow. Most systhrow events with filter=java/lang/OutOfMemoryError have the range suboption set to 1..4, which limits the number of dump files produced on OutOfMemory conditions to a maximum of 4. For more information, see Default dump agents . If you add a new dump agent and do not specify the range, a default of 1..0 is used.","title":"range=&lt;ranges&gt;"},{"location":"xdump/#requestltrequestsgt","text":"Use the request suboption to ask the VM to prepare the state before starting the dump agent: -Xdump:<agent>:request=<requests> The available suboptions are listed in the following table: suboption value Description exclusive Request exclusive access to the VM. compact Run garbage collection. This option removes all unreachable objects from the heap before the dump file is generated. prepwalk Prepare the heap for walking. You must also specify exclusive when you use this option. serial Suspend other dumps until this dump is finished. preempt Applies to the Java dump agent and controls whether native threads in the process are forcibly pre-empted in order to collect stack traces. If this option is not specified, only Java stack traces are collected in the Java dump. You can specify more than one request option by using + . For example: -Xdump:heap:request=exclusive+compact+prepwalk The VM exclusive access mechanism allows a VM thread to halt the activity of other VM threads in a controlled way by using internal VM locks. When the request=exclusive option is specified for a dump agent, the VM thread that is producing the dump waits for threads that are running Java code to halt, and for garbage collection operations to complete, before the dump file is written. This process helps ensure that the dump has consistent data. When the dump is complete, the mechanism allows the other threads to resume. By default, only system dumps for OutOfMemoryError exceptions request exclusive access. Other system dump events typically result from a crash. In these cases, exclusive access is not requested because acquiring locks during a crash can be problematic. If system dumps are requested by using the com.ibm.jvm.Dump.SystemDump() API, the default system dump agent settings are used, and exclusive access is not requested. However, if you intend to use the system dump file for Java heap memory analysis, use the following option to request exclusive access when the dump is taken: -Xdump:system:defaults:request=exclusive+compact+prepwalk These settings avoid capturing a dump file with in-flight data during garbage collection. As an alternative, you can use the com.ibm.jvm.Dump.triggerDump() API and specify request=exclusive+compact+prepwalk on the API call. For more information about the com.ibm.jvm.Dump API , see the API reference information. The default setting of the request suboption for Java dump files is request=exclusive+preempt . To change the settings so that Java dump files are produced without pre-empting threads to collect native stack traces, use the following option: -Xdump:java:request=exclusive In general, the default request options are sufficient.","title":"request=&lt;requests&gt;"},{"location":"xdump/#dump-output","text":"Dump output is written to different files, depending on the type of dump and the platform. File names include a time stamp. Dump type File name (AIX, Linux, macOS, Windows) File name (z/OS) System dump core.%Y%m%d.%H%M%S.%pid.dmp %uid.JVM.TDUMP.%job.D%Y%m%d.T%H%M%S (31-bit), %uid.JVM.%job.D%y%m%d.T%H%M%S.X&DS (64-bit) See Note Java dump javacore.%Y%m%d.%H%M%S.%pid.%seq.txt javacore.%Y%m%d.%H%M%S.%pid.%seq.txt Heap dump heapdump.%Y%m%d.%H%M%S.%pid.phd heapdump.%Y%m%d.T%H%M%S.phd JIT dump jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp jitdump%Y%m%d.%H%M%S.%pid.%seq.dmp LE CEEDUMP - CEEDUMP.%Y%m%d.%H%M%S.%pid See Note The tokens used in this table, for example %Y , are described in Dump agent tokens . Note: On z/OS, the system dump file name can be set with the JAVA_DUMP_TDUMP_PATTERN environment variable. The CEEDUMP, which is not produced by default, is stored in the directory specified by _CEE_DMPTARG or the current directory if _CEE_DMPTARG is not specified.","title":"Dump output"},{"location":"xdump/#system-dumps-on-linux","text":"Linux does not provide an operating system API for generating a system dump from a running process. The VM produces system dumps on Linux by using the fork() API to start an identical process to the parent VM process. The VM then generates a SIGSEGV signal in the child process. The SIGSEGV signal causes Linux to create a system dump for the child process. The parent VM processes and renames the system dump, as required, by the -Xdump options, and might add additional data into the dump file. The system dump file for the child process contains an exact copy of the memory areas used in the parent. The dump viewer can obtain information about the Java threads, classes, and heap from the system dump. However, the dump viewer, and other system dump debuggers show only the single native thread that was running in the child process. You can use the Linux kernel.core_pattern setting to specify the name and path for system dumps. The VM dump agents override the Linux system dump name and path by renaming the dump as specified in the -Xdump options. If the kernel.core_pattern setting specifies a different file system to the -Xdump options, the VM dump agents might be unable to change the file path. In this case the VM renames the dump file, but leaves the file path unchanged. You can find the dump file name and location in the JVMDUMP010I message. Note: If you use the %t specifier in the kernel.core_pattern setting, the VM does not rename the dump. The VM cannot determine the exact time that Linux generated the core file, and therefore cannot be certain which Linux dump file is the correct one to rename.","title":"System dumps on Linux"},{"location":"xdump/#see-also","text":"-Xtrace -Xdisablejavadump","title":"See also"},{"location":"xenableexcessivegc/","text":"\u2011Xenableexcessivegc / \u2011Xdisableexcessivegc Enables or disables the throwing of an OutOfMemory exception if excessive time is spent in the GC. If excessive time is spent in the GC, the option returns null for an allocate request and thus causes an OutOfMemory exception to be thrown. Note: The OutOfMemory exception is thrown only when the heap has been fully expanded and the percentage of application run time that is not spent in garbage collection is at least 95%. This percentage is the default value that triggers an excessive GC event. You can control this value with the -Xgc:excessiveGCratio option. Syntax Setting Effect Default -Xenableexcessivegc Enable exception yes -Xdisableexcessivegc Disable exception","title":"-Xenableexcessivegc"},{"location":"xenableexcessivegc/#xenableexcessivegc-xdisableexcessivegc","text":"Enables or disables the throwing of an OutOfMemory exception if excessive time is spent in the GC. If excessive time is spent in the GC, the option returns null for an allocate request and thus causes an OutOfMemory exception to be thrown. Note: The OutOfMemory exception is thrown only when the heap has been fully expanded and the percentage of application run time that is not spent in garbage collection is at least 95%. This percentage is the default value that triggers an excessive GC event. You can control this value with the -Xgc:excessiveGCratio option.","title":"\u2011Xenableexcessivegc / \u2011Xdisableexcessivegc"},{"location":"xenableexcessivegc/#syntax","text":"Setting Effect Default -Xenableexcessivegc Enable exception yes -Xdisableexcessivegc Disable exception","title":"Syntax"},{"location":"xenableexplicitgc/","text":"\u2011Xenableexplicitgc / \u2011Xdisableexplicitgc Enables and disables garbage collection (GC) when calls are made to System.gc() . Syntax Setting Effect Default -Xenableexplicitgc Enable GC yes -Xdisableexplicitgc Disable GC Explanation Although it is possible to programmatically trigger a garbage collection by calling System.gc() , performance can be adversely affected by halting the application before it is really necessary. Use this option to prevent the VM responding to application requests for a garage collection cycle.","title":"-Xenableexplicitgc"},{"location":"xenableexplicitgc/#xenableexplicitgc-xdisableexplicitgc","text":"Enables and disables garbage collection (GC) when calls are made to System.gc() .","title":"\u2011Xenableexplicitgc / \u2011Xdisableexplicitgc"},{"location":"xenableexplicitgc/#syntax","text":"Setting Effect Default -Xenableexplicitgc Enable GC yes -Xdisableexplicitgc Disable GC","title":"Syntax"},{"location":"xenableexplicitgc/#explanation","text":"Although it is possible to programmatically trigger a garbage collection by calling System.gc() , performance can be adversely affected by halting the application before it is really necessary. Use this option to prevent the VM responding to application requests for a garage collection cycle.","title":"Explanation"},{"location":"xenablestringconstantgc/","text":"\u2011Xenablestringconstantgc / \u2011Xdisablestringconstantgc Enables or disables the collection of strings from the string intern table. Syntax Setting Effect Default -Xenablestringconstantgc Enable collection yes -Xdisablestringconstantgc Disable collection","title":"-Xenablestringconstantgc"},{"location":"xenablestringconstantgc/#xenablestringconstantgc-xdisablestringconstantgc","text":"Enables or disables the collection of strings from the string intern table.","title":"\u2011Xenablestringconstantgc / \u2011Xdisablestringconstantgc"},{"location":"xenablestringconstantgc/#syntax","text":"Setting Effect Default -Xenablestringconstantgc Enable collection yes -Xdisablestringconstantgc Disable collection","title":"Syntax"},{"location":"xfastresolve/","text":"-Xfastresolve Tune performance by improving the resolution time for classes when the field count exceeds the specified threshold. If profiling tools show significant costs in field resolution, change the threshold until the costs are reduced. If you enable this option, additional memory is used when the threshold is exceeded. Note: The use of this option is deprecated. Syntax -Xfastresolve<n> where <n> is the required threshold.","title":"-Xfastresolve"},{"location":"xfastresolve/#-xfastresolve","text":"Tune performance by improving the resolution time for classes when the field count exceeds the specified threshold. If profiling tools show significant costs in field resolution, change the threshold until the costs are reduced. If you enable this option, additional memory is used when the threshold is exceeded. Note: The use of this option is deprecated.","title":"-Xfastresolve"},{"location":"xfastresolve/#syntax","text":"-Xfastresolve<n> where <n> is the required threshold.","title":"Syntax"},{"location":"xfuture/","text":"-Xfuture As described in the Oracle \"Non-Standard Options\" documentation , this HotSpot option turns on strict class-file format checks. For compatibility, this option is also supported by the OpenJ9 VM. Syntax -Xfuture Explanation Oracle recommend that you use this flag when you are developing new code because stricter checks will become the default in future releases. Note: You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier . Default behavior By default, strict format checks are disabled.","title":"-Xfuture"},{"location":"xfuture/#-xfuture","text":"As described in the Oracle \"Non-Standard Options\" documentation , this HotSpot option turns on strict class-file format checks. For compatibility, this option is also supported by the OpenJ9 VM.","title":"-Xfuture"},{"location":"xfuture/#syntax","text":"-Xfuture","title":"Syntax"},{"location":"xfuture/#explanation","text":"Oracle recommend that you use this flag when you are developing new code because stricter checks will become the default in future releases. Note: You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier .","title":"Explanation"},{"location":"xfuture/#default-behavior","text":"By default, strict format checks are disabled.","title":"Default behavior"},{"location":"xgc/","text":"-Xgc Options that change the behavior of the Garbage Collector (GC). Syntax -Xgc:<parameter> Parameters Parameter Effect concurrentScavenge Enables a garbage collection (GC) mode with less pause times. dnssExpectedTimeRatioMaximum Sets the maximum time to spend on GC of the nursery area. dnssExpectedTimeRatioMinimum Sets the minimum time to spend on GC of the nursery area. excessiveGCratio Sets a boundary value beyond which GC is deemed to be excessive. minContractPercent Sets the minimum percentage of the heap that can be contracted at any given time. maxContractPercent Sets the maximum percentage of the heap that can be contracted at any given time. overrideHiresTimerCheck Overrides GC operating system checks for timer resolution. noConcurrentScavenge Disables concurrent scavenge. preferredHeapBase Sets a memory range for the Java\u2122 heap. (AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) scvNoAdaptiveTenure Turns off the adaptive tenure age in the generational concurrent GC policy. scvTenureAge Sets the initial scavenger tenure age in the generational concurrent GC policy. stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required. tlhIncrementSize Sets the size of the thread local heap (TLH) increment. tlhInitialSize Sets the initial size of the thread local heap. tlhMaximumSize Sets the maximum size of the thread local heap. verboseFormat Sets the verbose GC format. concurrentScavenge (64-bit only) -Xgc:concurrentScavenge This option supports pause-less garbage collection mode when you use the Generational Concurrent ( gencon ) garbage collection policy (the default policy). If you set this option, the VM attempts to reduce GC pause times for response-time sensitive, large-heap applications. Note: Linux on Z and z/OS This option is supported by all generations of IBM Z\u00ae hardware to enable pause-less GC with two modes of operation: hardware-based and software-based operations. IBM z13\u2122 and earlier hardware operates in software-based pause-less GC mode; and IBM z14\u2122 and later hardware (with supported software) operates in hardware-based mode. Hardware-based pause-less GC is supported on IBM z14\u2122 and later hardware running the following software: Operating systems: z/OS V2R3 z/OS V2R2 and APAR OA51643 . RHEL 7.5 (minimum kernel level 4.14) Ubuntu 18.04 (minimum kernel level 4.15) Hypervisors: IBM z/VM 6.4 with APAR VM65987 IBM z/VM 7.1 KVM solutions with QEMU 2.10 or later and minimum host kernel level 4.12 (for example, RHEL 7.5 with kernel level 4.14) If these requirements are not met, the option is ignored. Note: On z/OS, the virtual storage used might exceed the Java maximum heap size. Set the z/OS memory limit, specified by ulimit -M , to a larger value than the maximum heap size. dnssExpectedTimeRatioMaximum -Xgc:dnssExpectedTimeRatioMaximum=<value> Setting Value Default <value> [percentage] 5 The maximum amount of time spent on garbage collection of the nursery area, expressed as a percentage of the overall time for the last three GC intervals. dnssExpectedTimeRatioMinimum -Xgc:dnssExpectedTimeRatioMinimum=<value> Setting Value Default <value> [percentage] 1 The minimum amount of time spent on garbage collection of the nursery area, expressed as a percentage of the overall time for the last three GC intervals. excessiveGCratio -Xgc:excessiveGCratio=<value> Setting Value Default <value> [percentage] 95 where <value> is a percentage of total application run time that is not spent in GC. The default value is 95, which means that anything over 5% of total application run time spent on GC is deemed excessive. This option can be used only when -Xenableexcessivegc is set (enabled by default). minContractPercent -Xgc:minContractPercent=<n> Setting Value Default <n> [percentage] - The minimum percentage of the heap that can be contracted at any given time. maxContractPercent -Xgc:maxContractPercent=<n> Setting Value Default <n> [percentage] - The maximum percentage of the heap that can be contracted at any given time. For example, -Xgc:maxContractPercent=20 causes the heap to contract by as much as 20%. noConcurrentScavenge (64-bit only) -Xgc:noConcurrentScavenge This option disables pause-less garbage collection that you might have enabled with the -Xgc:concurrentScavenge option when using the Generational Concurrent ( gencon ) garbage collection policy (the default policy). Note: No concurrent scavenge is the default state, but the noConcurrentScavenge option is useful as it will disable concurrent scavenge even if it has been enabled by a previous option; the right-most option always takes precedence. overrideHiresTimerCheck -Xgc:overrideHiresTimerCheck When the VM starts, the GC checks that the operating system can meet the timer resolution requirements for the requested target pause time. Typically, this check correctly identifies operating systems that can deliver adequate time resolution. However, in some cases the operating system provides a more conservative answer than strictly necessary for GC pause time management, which prevents startup. Specifying this parameter causes the GC to ignore the answer returned by the operating system. The VM starts, but GC pause time management remains subject to operating system performance, which might not provide adequate timer resolution. Note: Use this option with caution, and only when you are unable to use a supported operating system. preferredHeapBase (AIX, Linux, macOS, and Windows only) -Xgc:preferredHeapBase=<address> Setting Value Default <value> [hexadecimal] - where, <address> is the base memory address for the heap. Use this option with the -Xcompressedrefs option to allocate the heap you specify with the -Xmx option, in a memory range of your choice. If -Xcompressedrefs is not specified, this option has no effect. In the following example, the heap is located at the 4 GB mark, leaving the lowest 4 GB of address space for use by other processes. -Xgc:preferredHeapBase=0x100000000 If the heap cannot be allocated in a contiguous block at the preferredHeapBase address you specified, an error occurs detailing a Garbage Collection (GC) allocation failure startup. When the preferredHeapBase option is used with the -Xlp option, the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size. scvNoAdaptiveTenure -Xgc:scvNoAdaptiveTenure Turns off the adaptive tenure age in the generational concurrent GC policy. The initial age that is set is maintained throughout the run time of the VM. See scvTenureAge . scvTenureAge -Xgc:scvTenureAge=<n> Setting Value Default <n> [1 - 14] 10 Sets the initial scavenger tenure age in the generational concurrent GC policy. For more information, see Generational Concurrent policy . stdGlobalCompactToSatisfyAllocate -Xgc:stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required to satisfy the current allocation failure by removing the dynamic compaction triggers that look at heap occupancy. This option works only with the following GC policies: gencon optthruput optavgpause tlhIncrementSize -Xgc:tlhIncrementSize=<bytes> Sets the increment size of the thread local heap (TLH), which plays a key role in cache allocation. Threads start creating TLHs with a predefined initial size (default 2 KB). On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). Use this option to control the increment size. tlhInitialSize -Xgc:tlhInitialSize=<bytes> Sets the initial size of the TLH. The default size is 2 KB. tlhMaximumSize -Xgc:tlhMaximumSize=<bytes> Sets the maximum size of the TLH. The size of the TLH varies from 512 bytes (768 on 64-bit JVMs) to 128 KB, depending on the allocation rate of the thread. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilisation and increase heap fragmentation. Typically, when the maximum TLH size is increased, you should also increase the increment size ( -XtlhIncrementSize ) proportionally, so that active threads can reach the maximum requested TLH size more quickly. verboseFormat -Xgc:verboseFormat=<format> Setting Value Default <format> default yes deprecated default : The default verbose garbage collection format for OpenJ9. For more information, see Verbose garbage collection logging . deprecated : The verbose garbage collection format available in the IBM J9 VM V2.4 and earlier.","title":"-Xgc"},{"location":"xgc/#-xgc","text":"Options that change the behavior of the Garbage Collector (GC).","title":"-Xgc"},{"location":"xgc/#syntax","text":"-Xgc:<parameter>","title":"Syntax"},{"location":"xgc/#parameters","text":"Parameter Effect concurrentScavenge Enables a garbage collection (GC) mode with less pause times. dnssExpectedTimeRatioMaximum Sets the maximum time to spend on GC of the nursery area. dnssExpectedTimeRatioMinimum Sets the minimum time to spend on GC of the nursery area. excessiveGCratio Sets a boundary value beyond which GC is deemed to be excessive. minContractPercent Sets the minimum percentage of the heap that can be contracted at any given time. maxContractPercent Sets the maximum percentage of the heap that can be contracted at any given time. overrideHiresTimerCheck Overrides GC operating system checks for timer resolution. noConcurrentScavenge Disables concurrent scavenge. preferredHeapBase Sets a memory range for the Java\u2122 heap. (AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) scvNoAdaptiveTenure Turns off the adaptive tenure age in the generational concurrent GC policy. scvTenureAge Sets the initial scavenger tenure age in the generational concurrent GC policy. stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required. tlhIncrementSize Sets the size of the thread local heap (TLH) increment. tlhInitialSize Sets the initial size of the thread local heap. tlhMaximumSize Sets the maximum size of the thread local heap. verboseFormat Sets the verbose GC format.","title":"Parameters"},{"location":"xgc/#concurrentscavenge","text":"(64-bit only) -Xgc:concurrentScavenge This option supports pause-less garbage collection mode when you use the Generational Concurrent ( gencon ) garbage collection policy (the default policy). If you set this option, the VM attempts to reduce GC pause times for response-time sensitive, large-heap applications. Note: Linux on Z and z/OS This option is supported by all generations of IBM Z\u00ae hardware to enable pause-less GC with two modes of operation: hardware-based and software-based operations. IBM z13\u2122 and earlier hardware operates in software-based pause-less GC mode; and IBM z14\u2122 and later hardware (with supported software) operates in hardware-based mode. Hardware-based pause-less GC is supported on IBM z14\u2122 and later hardware running the following software: Operating systems: z/OS V2R3 z/OS V2R2 and APAR OA51643 . RHEL 7.5 (minimum kernel level 4.14) Ubuntu 18.04 (minimum kernel level 4.15) Hypervisors: IBM z/VM 6.4 with APAR VM65987 IBM z/VM 7.1 KVM solutions with QEMU 2.10 or later and minimum host kernel level 4.12 (for example, RHEL 7.5 with kernel level 4.14) If these requirements are not met, the option is ignored. Note: On z/OS, the virtual storage used might exceed the Java maximum heap size. Set the z/OS memory limit, specified by ulimit -M , to a larger value than the maximum heap size.","title":"concurrentScavenge"},{"location":"xgc/#dnssexpectedtimeratiomaximum","text":"-Xgc:dnssExpectedTimeRatioMaximum=<value> Setting Value Default <value> [percentage] 5 The maximum amount of time spent on garbage collection of the nursery area, expressed as a percentage of the overall time for the last three GC intervals.","title":"dnssExpectedTimeRatioMaximum"},{"location":"xgc/#dnssexpectedtimeratiominimum","text":"-Xgc:dnssExpectedTimeRatioMinimum=<value> Setting Value Default <value> [percentage] 1 The minimum amount of time spent on garbage collection of the nursery area, expressed as a percentage of the overall time for the last three GC intervals.","title":"dnssExpectedTimeRatioMinimum"},{"location":"xgc/#excessivegcratio","text":"-Xgc:excessiveGCratio=<value> Setting Value Default <value> [percentage] 95 where <value> is a percentage of total application run time that is not spent in GC. The default value is 95, which means that anything over 5% of total application run time spent on GC is deemed excessive. This option can be used only when -Xenableexcessivegc is set (enabled by default).","title":"excessiveGCratio"},{"location":"xgc/#mincontractpercent","text":"-Xgc:minContractPercent=<n> Setting Value Default <n> [percentage] - The minimum percentage of the heap that can be contracted at any given time.","title":"minContractPercent"},{"location":"xgc/#maxcontractpercent","text":"-Xgc:maxContractPercent=<n> Setting Value Default <n> [percentage] - The maximum percentage of the heap that can be contracted at any given time. For example, -Xgc:maxContractPercent=20 causes the heap to contract by as much as 20%.","title":"maxContractPercent"},{"location":"xgc/#noconcurrentscavenge","text":"(64-bit only) -Xgc:noConcurrentScavenge This option disables pause-less garbage collection that you might have enabled with the -Xgc:concurrentScavenge option when using the Generational Concurrent ( gencon ) garbage collection policy (the default policy). Note: No concurrent scavenge is the default state, but the noConcurrentScavenge option is useful as it will disable concurrent scavenge even if it has been enabled by a previous option; the right-most option always takes precedence.","title":"noConcurrentScavenge"},{"location":"xgc/#overridehirestimercheck","text":"-Xgc:overrideHiresTimerCheck When the VM starts, the GC checks that the operating system can meet the timer resolution requirements for the requested target pause time. Typically, this check correctly identifies operating systems that can deliver adequate time resolution. However, in some cases the operating system provides a more conservative answer than strictly necessary for GC pause time management, which prevents startup. Specifying this parameter causes the GC to ignore the answer returned by the operating system. The VM starts, but GC pause time management remains subject to operating system performance, which might not provide adequate timer resolution. Note: Use this option with caution, and only when you are unable to use a supported operating system.","title":"overrideHiresTimerCheck"},{"location":"xgc/#preferredheapbase","text":"(AIX, Linux, macOS, and Windows only) -Xgc:preferredHeapBase=<address> Setting Value Default <value> [hexadecimal] - where, <address> is the base memory address for the heap. Use this option with the -Xcompressedrefs option to allocate the heap you specify with the -Xmx option, in a memory range of your choice. If -Xcompressedrefs is not specified, this option has no effect. In the following example, the heap is located at the 4 GB mark, leaving the lowest 4 GB of address space for use by other processes. -Xgc:preferredHeapBase=0x100000000 If the heap cannot be allocated in a contiguous block at the preferredHeapBase address you specified, an error occurs detailing a Garbage Collection (GC) allocation failure startup. When the preferredHeapBase option is used with the -Xlp option, the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size.","title":"preferredHeapBase"},{"location":"xgc/#scvnoadaptivetenure","text":"-Xgc:scvNoAdaptiveTenure Turns off the adaptive tenure age in the generational concurrent GC policy. The initial age that is set is maintained throughout the run time of the VM. See scvTenureAge .","title":"scvNoAdaptiveTenure"},{"location":"xgc/#scvtenureage","text":"-Xgc:scvTenureAge=<n> Setting Value Default <n> [1 - 14] 10 Sets the initial scavenger tenure age in the generational concurrent GC policy. For more information, see Generational Concurrent policy .","title":"scvTenureAge"},{"location":"xgc/#stdglobalcompacttosatisfyallocate","text":"-Xgc:stdGlobalCompactToSatisfyAllocate Prevents the GC from performing a compaction unless absolutely required to satisfy the current allocation failure by removing the dynamic compaction triggers that look at heap occupancy. This option works only with the following GC policies: gencon optthruput optavgpause","title":"stdGlobalCompactToSatisfyAllocate"},{"location":"xgc/#tlhincrementsize","text":"-Xgc:tlhIncrementSize=<bytes> Sets the increment size of the thread local heap (TLH), which plays a key role in cache allocation. Threads start creating TLHs with a predefined initial size (default 2 KB). On every TLH refresh, the requested size for that thread is increased by an increment (default 4 KB). Use this option to control the increment size.","title":"tlhIncrementSize"},{"location":"xgc/#tlhinitialsize","text":"-Xgc:tlhInitialSize=<bytes> Sets the initial size of the TLH. The default size is 2 KB.","title":"tlhInitialSize"},{"location":"xgc/#tlhmaximumsize","text":"-Xgc:tlhMaximumSize=<bytes> Sets the maximum size of the TLH. The size of the TLH varies from 512 bytes (768 on 64-bit JVMs) to 128 KB, depending on the allocation rate of the thread. Larger TLHs can help reduce heap lock contention, but might also reduce heap utilisation and increase heap fragmentation. Typically, when the maximum TLH size is increased, you should also increase the increment size ( -XtlhIncrementSize ) proportionally, so that active threads can reach the maximum requested TLH size more quickly.","title":"tlhMaximumSize"},{"location":"xgc/#verboseformat","text":"-Xgc:verboseFormat=<format> Setting Value Default <format> default yes deprecated default : The default verbose garbage collection format for OpenJ9. For more information, see Verbose garbage collection logging . deprecated : The verbose garbage collection format available in the IBM J9 VM V2.4 and earlier.","title":"verboseFormat"},{"location":"xgcpolicy/","text":"-Xgcpolicy Controls the behavior of the garbage collector by specifying different garbage collection policies. Syntax -Xgcpolicy:<parameter> Parameters Parameter Default balanced gencon yes metronome (AIX\u00ae, Linux\u00ae x86 only) nogc optavgpause optthruput Specify the garbage collection policy that you want the OpenJ9 VM to use: balanced -Xgcpolicy:balanced The balanced policy policy uses mark, sweep, compact and generational style garbage collection. The concurrent mark phase is disabled; concurrent garbage collection technology is used, but not in the way that concurrent mark is implemented for other policies. The balanced policy uses a region-based layout for the Java\u2122 heap. These regions are individually managed to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The policy tries to avoid global collections by matching object allocation and survival rates. If you have problems with application pause times that are caused by global garbage collections, particularly compactions, this policy might improve application performance. If you are using large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER\u2122 platforms only), the balanced policy might further improve application throughput. Note: If you are using the balanced GC policy in a Docker container that uses the default seccomp Docker profile, you must start the container with --security-opt seccomp=unconfined to exploit NUMA characteristics. These options are not required if you are running in Kubernetes, because unconfined is set by default (see Seccomp ). For more information about this policy, including when to use it, see Balanced Garbage Collection policy . Defaults and options The initial heap size is Xmx/1024 , rounded down to the nearest power of 2, where Xmx is the maximum heap size available. You can override this value by specifying the -Xms option on the command line. The following options can also be specified on the command line with -Xgcpolicy:balanced : -Xalwaysclassgc -Xclassgc -Xcompactexplicitgc -Xdisableexcessivegc -Xdisableexplicitgc -Xenableexcessivegc -Xgcthreads<number> -Xgcworkpackets<number> -Xmaxe<size> -Xmaxf<percentage> -Xmaxt<percentage> -Xmca<size> -Xmco<size> -Xmine<size> -Xminf<percentage> -Xmint<percentage> -Xmn<size> -Xmns<size> -Xmnx<size> -Xms<size> -Xmx<size> -Xnoclassgc -Xnocompactexplicitgc -Xnuma:none -Xsoftmx<size> -Xsoftrefthreshold<number> -Xverbosegclog[:<file> [, <X>,<Y>]] The behavior of the following options is different when specified with -Xgcpolicy:balanced : -Xcompactgc Compaction occurs when a System.gc() call is received (default). Compaction always occurs on all other collection types. -Xnocompactgc Compaction does not occur when a System.gc() call is received. Compaction always occurs on all other collection types. The following options are ignored when specified with -Xgcpolicy:balanced : -Xconcurrentbackground<number> -Xconcurrentlevel<number> -Xconcurrentslack<size> -Xconmeter:<soa | loa | dynamic> -Xdisablestringconstantgc -Xenablestringconstantgc -Xloa -Xloainitial<percentage> -Xloamaximum<percentage> -Xloaminimum<percentage> -Xmo<size> -Xmoi<size> -Xmos<size> -Xmr<size> -Xmrx<size> -Xnoloa -Xnopartialcompactgc (deprecated) -Xpartialcompactgc (deprecated) gencon -Xgcpolicy:gencon The generational concurrent policy (default) uses a concurrent mark phase combined with generational garbage collection to help minimize the time that is spent in any garbage collection pause. This policy is particularly useful for applications with many short-lived objects, such as transactional applications. Pause times can be significantly shorter than with the optthruput policy, while still producing good throughput. Heap fragmentation is also reduced. metronome (AIX, Linux x86 only) -Xgcpolicy:metronome The metronome policy is an incremental, deterministic garbage collector with short pause times. Applications that are dependent on precise response times can take advantage of this technology by avoiding potentially long delays from garbage collection activity. The metronome policy is supported on specific hardware and operating system configurations. For more information, see Using the Metronome Garbage Collector . Defaults and options -Xgc:synchronousGCOnOOM | -Xgc:nosynchronousGCOnOOM One occasion when garbage collection occurs is when the heap runs out of memory. If there is no more free space in the heap, using -Xgc:synchronousGCOnOOM stops your application while garbage collection removes unused objects. If free space runs out again, consider decreasing the target utilization to allow garbage collection more time to complete. Setting -Xgc:nosynchronousGCOnOOM implies that when heap memory is full your application stops and issues an out-of-memory message. The default is -Xgc:synchronousGCOnOOM . -Xnoclassgc Disables class garbage collection. This option switches off garbage collection of storage associated with Java classes that are no longer being used by the OpenJ9 VM. The default behavior is -Xnoclassgc. -Xgc:targetPauseTime=N Sets the garbage collection pause time, where N is the time in milliseconds. When this option is specified, the GC operates with pauses that do not exceed the value specified. If this option is not specified the default pause time is set to 3 milliseconds. For example, running with -Xgc:targetPauseTime=20 causes the GC to pause for no longer than 20 milliseconds during GC operations. -Xgc:targetUtilization=N Sets the application utilization to N% ; the Garbage Collector attempts to use at most (100-N)% of each time interval. Reasonable values are in the range of 50-80%. Applications with low allocation rates might be able to run at 90%. The default is 70%. This example shows the maximum size of the heap memory is 30 MB. The garbage collector attempts to use 25% of each time interval because the target utilization for the application is 75%. java -Xgcpolicy:metronome -Xmx30m -Xgc:targetUtilization=75 Test -Xgc:threads=N Specifies the number of GC threads to run. The default is the number of processor cores available to the process. The maximum value you can specify is the number of processors available to the operating system. -Xgc:verboseGCCycleTime=N N is the time in milliseconds that the summary information should be dumped. Note: The cycle time does not mean that the summary information is dumped precisely at that time, but when the last garbage collection event that meets this time criterion passes. -Xmx<size> Specifies the Java heap size. Unlike other garbage collection strategies, the real-time Metronome GC does not support heap expansion. There is not an initial or maximum heap size option. You can specify only the maximum heap size. nogc -Xgcpolicy:nogc This policy handles only memory allocation and heap expansion, but doesn't reclaim any memory. If the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops. Because there is no GC pause and most overheads on allocations are eliminated, the impact on runtime performance is minimized. This policy therefore provides benfits for \"garbage-free\" applications. See the following section, \"When to use nogc\", for some possible use cases. You should be especially careful when using any of the following techniques with nogc because memory is never released under this policy: - Finalization - Direct memory access - Weak, soft, and phantom references This policy can also be enabled with the -XX:+UseNoGC option. Further details are available at JEP 318: Epsilon: A No-Op Garbage Collector . When to use nogc For most Java applications, you should not use nogc . However, there are some particular situations where it can be appropriate: Testing during development GC performance. Use nogc as a baseline when testing the performance of other GC policies, including the provision of a low-latency baseline. Application memory. Use nogc to test your settings for allocated memory. If you use -Xmx to set the heap size that should not be exceeded, then your application will crash with a heap dump if it tries to exceed your memory limit. Running applications with minimal or no GC requrements You might use nogc when an application is so short lived that allocated memory is never exhausted and running a full GC cycle is therefore a waste of resources. Similarly, when memory application is well understood or where there is rarely memory to be reclaimed, you might prefer to avoid unnecessary GC cycles and rely on a failover mechanism to occasionally restart the VM as necessary. optavgpause -Xgcpolicy:optavgpause The \"optimize for pause time\" policy uses concurrent mark and concurrent sweep phases. Pause times are shorter than with optthruput , but application throughput is reduced because some garbage collection work is taking place while the application is running. Consider using this policy if you have a large heap size (available on 64-bit platforms), because this policy limits the effect of increasing heap size on the length of the garbage collection pause. However, if your application uses many short-lived objects, the gencon policy might produce better performance. optthruput -Xgcpolicy:optthruput The \"optimize for throughput\" policy disables the concurrent mark phase. The application stops during global garbage collection, so long pauses can occur. This configuration is typically used for large-heap applications when high application throughput, rather than short garbage collection pauses, is the main performance goal. If your application cannot tolerate long garbage collection pauses, consider using another policy, such as gencon .","title":"-Xgcpolicy"},{"location":"xgcpolicy/#-xgcpolicy","text":"Controls the behavior of the garbage collector by specifying different garbage collection policies.","title":"-Xgcpolicy"},{"location":"xgcpolicy/#syntax","text":"-Xgcpolicy:<parameter>","title":"Syntax"},{"location":"xgcpolicy/#parameters","text":"Parameter Default balanced gencon yes metronome (AIX\u00ae, Linux\u00ae x86 only) nogc optavgpause optthruput Specify the garbage collection policy that you want the OpenJ9 VM to use:","title":"Parameters"},{"location":"xgcpolicy/#balanced","text":"-Xgcpolicy:balanced The balanced policy policy uses mark, sweep, compact and generational style garbage collection. The concurrent mark phase is disabled; concurrent garbage collection technology is used, but not in the way that concurrent mark is implemented for other policies. The balanced policy uses a region-based layout for the Java\u2122 heap. These regions are individually managed to reduce the maximum pause time on large heaps and increase the efficiency of garbage collection. The policy tries to avoid global collections by matching object allocation and survival rates. If you have problems with application pause times that are caused by global garbage collections, particularly compactions, this policy might improve application performance. If you are using large systems that have Non-Uniform Memory Architecture (NUMA) characteristics (x86 and POWER\u2122 platforms only), the balanced policy might further improve application throughput. Note: If you are using the balanced GC policy in a Docker container that uses the default seccomp Docker profile, you must start the container with --security-opt seccomp=unconfined to exploit NUMA characteristics. These options are not required if you are running in Kubernetes, because unconfined is set by default (see Seccomp ). For more information about this policy, including when to use it, see Balanced Garbage Collection policy .","title":"balanced"},{"location":"xgcpolicy/#defaults-and-options","text":"The initial heap size is Xmx/1024 , rounded down to the nearest power of 2, where Xmx is the maximum heap size available. You can override this value by specifying the -Xms option on the command line. The following options can also be specified on the command line with -Xgcpolicy:balanced : -Xalwaysclassgc -Xclassgc -Xcompactexplicitgc -Xdisableexcessivegc -Xdisableexplicitgc -Xenableexcessivegc -Xgcthreads<number> -Xgcworkpackets<number> -Xmaxe<size> -Xmaxf<percentage> -Xmaxt<percentage> -Xmca<size> -Xmco<size> -Xmine<size> -Xminf<percentage> -Xmint<percentage> -Xmn<size> -Xmns<size> -Xmnx<size> -Xms<size> -Xmx<size> -Xnoclassgc -Xnocompactexplicitgc -Xnuma:none -Xsoftmx<size> -Xsoftrefthreshold<number> -Xverbosegclog[:<file> [, <X>,<Y>]] The behavior of the following options is different when specified with -Xgcpolicy:balanced : -Xcompactgc Compaction occurs when a System.gc() call is received (default). Compaction always occurs on all other collection types. -Xnocompactgc Compaction does not occur when a System.gc() call is received. Compaction always occurs on all other collection types. The following options are ignored when specified with -Xgcpolicy:balanced : -Xconcurrentbackground<number> -Xconcurrentlevel<number> -Xconcurrentslack<size> -Xconmeter:<soa | loa | dynamic> -Xdisablestringconstantgc -Xenablestringconstantgc -Xloa -Xloainitial<percentage> -Xloamaximum<percentage> -Xloaminimum<percentage> -Xmo<size> -Xmoi<size> -Xmos<size> -Xmr<size> -Xmrx<size> -Xnoloa -Xnopartialcompactgc (deprecated) -Xpartialcompactgc (deprecated)","title":"Defaults and options"},{"location":"xgcpolicy/#gencon","text":"-Xgcpolicy:gencon The generational concurrent policy (default) uses a concurrent mark phase combined with generational garbage collection to help minimize the time that is spent in any garbage collection pause. This policy is particularly useful for applications with many short-lived objects, such as transactional applications. Pause times can be significantly shorter than with the optthruput policy, while still producing good throughput. Heap fragmentation is also reduced.","title":"gencon"},{"location":"xgcpolicy/#metronome-aix-linux-x86-only","text":"-Xgcpolicy:metronome The metronome policy is an incremental, deterministic garbage collector with short pause times. Applications that are dependent on precise response times can take advantage of this technology by avoiding potentially long delays from garbage collection activity. The metronome policy is supported on specific hardware and operating system configurations. For more information, see Using the Metronome Garbage Collector .","title":"metronome (AIX, Linux x86 only)"},{"location":"xgcpolicy/#defaults-and-options_1","text":"-Xgc:synchronousGCOnOOM | -Xgc:nosynchronousGCOnOOM One occasion when garbage collection occurs is when the heap runs out of memory. If there is no more free space in the heap, using -Xgc:synchronousGCOnOOM stops your application while garbage collection removes unused objects. If free space runs out again, consider decreasing the target utilization to allow garbage collection more time to complete. Setting -Xgc:nosynchronousGCOnOOM implies that when heap memory is full your application stops and issues an out-of-memory message. The default is -Xgc:synchronousGCOnOOM . -Xnoclassgc Disables class garbage collection. This option switches off garbage collection of storage associated with Java classes that are no longer being used by the OpenJ9 VM. The default behavior is -Xnoclassgc. -Xgc:targetPauseTime=N Sets the garbage collection pause time, where N is the time in milliseconds. When this option is specified, the GC operates with pauses that do not exceed the value specified. If this option is not specified the default pause time is set to 3 milliseconds. For example, running with -Xgc:targetPauseTime=20 causes the GC to pause for no longer than 20 milliseconds during GC operations. -Xgc:targetUtilization=N Sets the application utilization to N% ; the Garbage Collector attempts to use at most (100-N)% of each time interval. Reasonable values are in the range of 50-80%. Applications with low allocation rates might be able to run at 90%. The default is 70%. This example shows the maximum size of the heap memory is 30 MB. The garbage collector attempts to use 25% of each time interval because the target utilization for the application is 75%. java -Xgcpolicy:metronome -Xmx30m -Xgc:targetUtilization=75 Test -Xgc:threads=N Specifies the number of GC threads to run. The default is the number of processor cores available to the process. The maximum value you can specify is the number of processors available to the operating system. -Xgc:verboseGCCycleTime=N N is the time in milliseconds that the summary information should be dumped. Note: The cycle time does not mean that the summary information is dumped precisely at that time, but when the last garbage collection event that meets this time criterion passes. -Xmx<size> Specifies the Java heap size. Unlike other garbage collection strategies, the real-time Metronome GC does not support heap expansion. There is not an initial or maximum heap size option. You can specify only the maximum heap size.","title":"Defaults and options"},{"location":"xgcpolicy/#nogc","text":"-Xgcpolicy:nogc This policy handles only memory allocation and heap expansion, but doesn't reclaim any memory. If the available Java heap becomes exhausted, an OutOfMemoryError exception is triggered and the VM stops. Because there is no GC pause and most overheads on allocations are eliminated, the impact on runtime performance is minimized. This policy therefore provides benfits for \"garbage-free\" applications. See the following section, \"When to use nogc\", for some possible use cases. You should be especially careful when using any of the following techniques with nogc because memory is never released under this policy: - Finalization - Direct memory access - Weak, soft, and phantom references This policy can also be enabled with the -XX:+UseNoGC option. Further details are available at JEP 318: Epsilon: A No-Op Garbage Collector .","title":"nogc"},{"location":"xgcpolicy/#when-to-use-nogc","text":"For most Java applications, you should not use nogc . However, there are some particular situations where it can be appropriate: Testing during development GC performance. Use nogc as a baseline when testing the performance of other GC policies, including the provision of a low-latency baseline. Application memory. Use nogc to test your settings for allocated memory. If you use -Xmx to set the heap size that should not be exceeded, then your application will crash with a heap dump if it tries to exceed your memory limit. Running applications with minimal or no GC requrements You might use nogc when an application is so short lived that allocated memory is never exhausted and running a full GC cycle is therefore a waste of resources. Similarly, when memory application is well understood or where there is rarely memory to be reclaimed, you might prefer to avoid unnecessary GC cycles and rely on a failover mechanism to occasionally restart the VM as necessary.","title":"When to use nogc"},{"location":"xgcpolicy/#optavgpause","text":"-Xgcpolicy:optavgpause The \"optimize for pause time\" policy uses concurrent mark and concurrent sweep phases. Pause times are shorter than with optthruput , but application throughput is reduced because some garbage collection work is taking place while the application is running. Consider using this policy if you have a large heap size (available on 64-bit platforms), because this policy limits the effect of increasing heap size on the length of the garbage collection pause. However, if your application uses many short-lived objects, the gencon policy might produce better performance.","title":"optavgpause"},{"location":"xgcpolicy/#optthruput","text":"-Xgcpolicy:optthruput The \"optimize for throughput\" policy disables the concurrent mark phase. The application stops during global garbage collection, so long pauses can occur. This configuration is typically used for large-heap applications when high application throughput, rather than short garbage collection pauses, is the main performance goal. If your application cannot tolerate long garbage collection pauses, consider using another policy, such as gencon .","title":"optthruput"},{"location":"xgcsplitheap/","text":"-Xgc:splitheap (Windows\u2122 32-bit only) By default, the VM uses a contiguous Java\u2122 heap to store Java objects. However, on Windows 32-bit systems, there are restrictions in the 32-bit memory space that prevents a process accessing more than 2GB of memory, even if there is more memory available. To increase the maximum allocatable heap size, OpenJ9 can split the heap, allowing memory use up to the 4GB limit. Restrictions: A split heap forces the Garbage Collector to use the gencon policy and allocates the new and old areas of the generational Java heap in separate areas of memory. Resizing of the new and old memory areas is disabled. This option can be used only with Java SE version 8 runtime environments. This option is deprecated in Version 8 and will be removed from future versions. Syntax -Xgc:splitheap Explanation Use -Xgc:splitheap for applications that must run on the 32-bit VM because of 32-bit JNI libraries, a 32-bit operating system, or 32-bit hardware, but need large Java heaps. By using a larger heap, you can allocate more objects before incurring a garbage collection and you can increase the number of live objects that you can use before an OutOfMemoryError exception occurs. With a split heap, the old area is committed to its maximum size (set with -Xmox ) in a lower region of memory and the new area is committed to its maximum size (set with -Xmnx ) in a higher region of memory. This option is not recommended if your application works in the any of the following ways: Performs poorly under the gencon garbage collection policy. Loads a very large number of classes. Uses large amounts of native system memory in JNI libraries; the increased size Java heap might reserve too much of the application's address space.","title":"-Xgc:splitheap"},{"location":"xgcsplitheap/#-xgcsplitheap","text":"(Windows\u2122 32-bit only) By default, the VM uses a contiguous Java\u2122 heap to store Java objects. However, on Windows 32-bit systems, there are restrictions in the 32-bit memory space that prevents a process accessing more than 2GB of memory, even if there is more memory available. To increase the maximum allocatable heap size, OpenJ9 can split the heap, allowing memory use up to the 4GB limit. Restrictions: A split heap forces the Garbage Collector to use the gencon policy and allocates the new and old areas of the generational Java heap in separate areas of memory. Resizing of the new and old memory areas is disabled. This option can be used only with Java SE version 8 runtime environments. This option is deprecated in Version 8 and will be removed from future versions.","title":"-Xgc:splitheap"},{"location":"xgcsplitheap/#syntax","text":"-Xgc:splitheap","title":"Syntax"},{"location":"xgcsplitheap/#explanation","text":"Use -Xgc:splitheap for applications that must run on the 32-bit VM because of 32-bit JNI libraries, a 32-bit operating system, or 32-bit hardware, but need large Java heaps. By using a larger heap, you can allocate more objects before incurring a garbage collection and you can increase the number of live objects that you can use before an OutOfMemoryError exception occurs. With a split heap, the old area is committed to its maximum size (set with -Xmox ) in a lower region of memory and the new area is committed to its maximum size (set with -Xmnx ) in a higher region of memory. This option is not recommended if your application works in the any of the following ways: Performs poorly under the gencon garbage collection policy. Loads a very large number of classes. Uses large amounts of native system memory in JNI libraries; the increased size Java heap might reserve too much of the application's address space.","title":"Explanation"},{"location":"xgcthreads/","text":"-Xgcthreads Sets the number of threads that the Garbage Collector uses for parallel operations. Syntax -Xgcthreads<number> Explanation The total number of GC threads is composed of one application thread with the remainder being dedicated GC threads. By default, the number is set to n-1 , where n is the number of reported CPUs, up to a maximum of 64. Where SMT or hyperthreading is in place, the number of reported CPUs is larger than the number of physical CPUs. Likewise, where virtualization is in place, the number of reported CPUs is the number of virtual CPUs assigned to the operating system. To set it to a different number, for example 4, use -Xgcthreads4 . The minimum valid value is 1, which disables parallel operations, at the cost of performance. No advantage is gained if you increase the number of threads to more than the default setting. On systems running multiple VMs or in LPAR environments where multiple VMs can share the same physical CPUs, you might want to restrict the number of GC threads used by each VM. The restriction helps prevent the total number of parallel operation GC threads for all VMs exceeding the number of physical CPUs present, when multiple VMs perform garbage collection at the same time.","title":"-Xgcthreads"},{"location":"xgcthreads/#-xgcthreads","text":"Sets the number of threads that the Garbage Collector uses for parallel operations.","title":"-Xgcthreads"},{"location":"xgcthreads/#syntax","text":"-Xgcthreads<number>","title":"Syntax"},{"location":"xgcthreads/#explanation","text":"The total number of GC threads is composed of one application thread with the remainder being dedicated GC threads. By default, the number is set to n-1 , where n is the number of reported CPUs, up to a maximum of 64. Where SMT or hyperthreading is in place, the number of reported CPUs is larger than the number of physical CPUs. Likewise, where virtualization is in place, the number of reported CPUs is the number of virtual CPUs assigned to the operating system. To set it to a different number, for example 4, use -Xgcthreads4 . The minimum valid value is 1, which disables parallel operations, at the cost of performance. No advantage is gained if you increase the number of threads to more than the default setting. On systems running multiple VMs or in LPAR environments where multiple VMs can share the same physical CPUs, you might want to restrict the number of GC threads used by each VM. The restriction helps prevent the total number of parallel operation GC threads for all VMs exceeding the number of physical CPUs present, when multiple VMs perform garbage collection at the same time.","title":"Explanation"},{"location":"xgcworkpackets/","text":"-Xgcworkpackets Specifies the total number of work packets available in the global collector. Syntax -Xgcworkpackets<number> Explanation If you do not specify a value, the collector allocates a number of packets based on the maximum heap size.","title":"-Xgcworkpackets"},{"location":"xgcworkpackets/#-xgcworkpackets","text":"Specifies the total number of work packets available in the global collector.","title":"-Xgcworkpackets"},{"location":"xgcworkpackets/#syntax","text":"-Xgcworkpackets<number>","title":"Syntax"},{"location":"xgcworkpackets/#explanation","text":"If you do not specify a value, the collector allocates a number of packets based on the maximum heap size.","title":"Explanation"},{"location":"xint/","text":"-Xint As described in the Oracle \"Non-Standard Options\" documentation , this VM option runs an application in interpreted-only mode. For compatibility, this option is also supported by the OpenJ9 VM. Syntax -Xint Explanation If you use this option, the OpenJ9 VM uses only the interpreter, disabling the OpenJ9 just-in-time (JIT) and ahead-of-time (AOT) compilers. By default, both these compilers are enabled, although the AOT compiler is not used by the VM unless shared classes are also enabled.","title":"-Xint"},{"location":"xint/#-xint","text":"As described in the Oracle \"Non-Standard Options\" documentation , this VM option runs an application in interpreted-only mode. For compatibility, this option is also supported by the OpenJ9 VM.","title":"-Xint"},{"location":"xint/#syntax","text":"-Xint","title":"Syntax"},{"location":"xint/#explanation","text":"If you use this option, the OpenJ9 VM uses only the interpreter, disabling the OpenJ9 just-in-time (JIT) and ahead-of-time (AOT) compilers. By default, both these compilers are enabled, although the AOT compiler is not used by the VM unless shared classes are also enabled.","title":"Explanation"},{"location":"xjit/","text":"-Xjit / -Xnojit Use this option to control the behavior of the JIT compiler. Specifying -Xjit with no parameters, has no effect as the JIT compiler is enabled by default. -Xnojit turns off the JIT compiler but does not affect the AOT compiler. Syntax Setting Action Default -Xjit Enable JIT yes -Xjit[:<parameter>=<value>{,<parameter>=<value>}] Enable JIT with options -Xnojit Disable JIT Parameters These parameters can be used to modify the behavior of -Xjit : Parameter Effect count Specifies the number of times a method is called before it is compiled. disableRMODE64 Allows the JIT to allocate executable code caches above the 2 GB memory bar. enableGPU Allows the JIT to offload certain processing tasks to a graphics processing unit (GPU) exclude Excludes the specified method from compilation. limit Includes the specified method in compilation. limitFile Compile methods that are listed in the limit file. optlevel Forces the JIT compiler to compile all methods at a specific optimization level. verbose Reports information about the JIT and AOT compiler configuration and method compilation. vlog Sends verbose output to a file. count -Xjit:count=<n> Specifies the number of times, <n> , a method is called before it is compiled. For example, setting count=0 forces the JIT compiler to compile everything on first execution, which is useful for problem determination. disableRMODE64 (z/OS\u00ae only) -Xjit:disableRMODE64 From z/OS V2R3, residency mode for 64-bit applications (RMODE64) is enabled by default. This feature allows the JIT to allocate executable code caches above the 2 GB memory bar, which is the default behavior. Use this option to turn off this JIT behavior. enableGPU (Windows (x86-64) or Linux (x86-64 and IBM POWER LE)) -Xjit:enableGPU Enables the JIT compiler to offload certain processing tasks to a graphics processing unit (GPU). The JIT determines which functions to offload based on performance heuristics. Systems must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0. To troubleshoot operations between the JIT compiler and the GPU, use -Xjit:enableGPU={verbose} , which provides output showing the processing tasks that are offloaded and their status. To send this output to a file ( output.txt ), run -Xjit:enableGPU={verbose},vlog=output.txt when you start your application. exclude -Xjit:exclude={<method>} Excludes the specified method from compilation. <method_name> is a regular expression that determines the method or methods that are to be excluded. Specify as much of the full package, class and method as necessary. For example, -Xjit:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xjit:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xjit:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:exclude , AOT compilation is also prevented and the methods specified are always interpreted. limit -Xjit:limit={<method_name>} Only the Java methods specified are included when code is compiled or loaded from the shared classes cache. <method_name> is a regular expression that determines the method or methods that are to be included (see -Xjit:exclude for details). Note: limit has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limit , AOT compilation is also restricted to those methods specified; other methods are always interpreted. limitFile -Xjit:limitFile=(<vlog_filename>, <m>, <n>) Compile only the methods that are listed on lines <m> to <n> in the specified limit file, where the limit file is a verbose log that you generated with the -Xjit:verbose,vlog=<vlog_filename> option. Methods that are not listed in the limit file and methods that are listed on lines outside the range are not compiled. Note: limitFile has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limitFile , AOT compilation is also restricted to those methods specified; other methods are always interpreted. optlevel -Xjit:optlevel=[noOpt|cold|warm|hot|veryHot|scorching] Forces the JIT compiler to compile all methods at a specific optimization level. Specifying optlevel might have an unexpected effect on performance, including reduced overall performance. verbose -Xjit:verbose Generates a JIT verbose log. The log provides a summary of which methods were compiled by the JIT and some of the compilation heurisic decisions that were taken while the JIT operates inside the OpenJ9 VM. -Xjit:verbose={compileStart} Prints out a line when the JIT is about to start compiling a method. -Xjit:verbose={compileEnd} Prints out a line when the JIT stops compiling a method. -Xjit:verbose={compilePerformance} Adds the values time (time taken to do the compilation) and mem (the amount of memory that was allocated during the compilation) into each line. This option includes the compileStart and compileEnd suboptions by default. -Xjit:verbose={disableInlining} Turns off inlining operations. -Xjit:verbose={inlining} Shows the methods that are inlined. Note: Suboptions can be chained together by using a pipe ( | ) symbol. When used, you must enclose the full option name in single quotation marks ( ' ) to avoid the shell misinterpreting these characters as pipe commands. For example: java '-Xjit:verbose={compileStart|compileEnd|inlining}' -version vlog -Xjit:vlog=<vlog_filename> Sends verbose output to a file, of the format <vlog_filename>.<date>.<time>.<JVM_process_ID> , which is created in your current directory. Running the command multiple times produces multiple distinct versions of this file. If you do not specify this parameter, the output is sent to the standard error output stream (STDERR). This type of log file can be used with the limitFile suboption to target the compilation of specific methods. Examples Generating a JIT verbose log The following example requests a JIT verbose log of the java -version command: java -Xjit:verbose,vlog=vlogfile -version Analyzing JIT performance The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the following information to compilation entry: the amount of time taken to do the compilation. the amount of memory that was allocated during the compilation. Analyzing inlining operations The following example generates output that contains performance data and inlining operations. The suboptions count and -XcompilationThreads1 are used only to simplify the output. These options are not recommended for production because performance will be affected. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version See also Diagnosing a JIT or AOT problem -Xaot","title":"-Xnojit"},{"location":"xjit/#-xjit-xnojit","text":"Use this option to control the behavior of the JIT compiler. Specifying -Xjit with no parameters, has no effect as the JIT compiler is enabled by default. -Xnojit turns off the JIT compiler but does not affect the AOT compiler.","title":"-Xjit / -Xnojit"},{"location":"xjit/#syntax","text":"Setting Action Default -Xjit Enable JIT yes -Xjit[:<parameter>=<value>{,<parameter>=<value>}] Enable JIT with options -Xnojit Disable JIT","title":"Syntax"},{"location":"xjit/#parameters","text":"These parameters can be used to modify the behavior of -Xjit : Parameter Effect count Specifies the number of times a method is called before it is compiled. disableRMODE64 Allows the JIT to allocate executable code caches above the 2 GB memory bar. enableGPU Allows the JIT to offload certain processing tasks to a graphics processing unit (GPU) exclude Excludes the specified method from compilation. limit Includes the specified method in compilation. limitFile Compile methods that are listed in the limit file. optlevel Forces the JIT compiler to compile all methods at a specific optimization level. verbose Reports information about the JIT and AOT compiler configuration and method compilation. vlog Sends verbose output to a file.","title":"Parameters"},{"location":"xjit/#count","text":"-Xjit:count=<n> Specifies the number of times, <n> , a method is called before it is compiled. For example, setting count=0 forces the JIT compiler to compile everything on first execution, which is useful for problem determination.","title":"count"},{"location":"xjit/#disablermode64","text":"(z/OS\u00ae only) -Xjit:disableRMODE64 From z/OS V2R3, residency mode for 64-bit applications (RMODE64) is enabled by default. This feature allows the JIT to allocate executable code caches above the 2 GB memory bar, which is the default behavior. Use this option to turn off this JIT behavior.","title":"disableRMODE64"},{"location":"xjit/#enablegpu","text":"(Windows (x86-64) or Linux (x86-64 and IBM POWER LE)) -Xjit:enableGPU Enables the JIT compiler to offload certain processing tasks to a graphics processing unit (GPU). The JIT determines which functions to offload based on performance heuristics. Systems must support NVIDIA Compute Unified Device Architecture (CUDA). The JIT requires the CUDA Toolkit 7.5 and your GPU device must have a minimum compute capability of 3.0. To troubleshoot operations between the JIT compiler and the GPU, use -Xjit:enableGPU={verbose} , which provides output showing the processing tasks that are offloaded and their status. To send this output to a file ( output.txt ), run -Xjit:enableGPU={verbose},vlog=output.txt when you start your application.","title":"enableGPU"},{"location":"xjit/#exclude","text":"-Xjit:exclude={<method>} Excludes the specified method from compilation. <method_name> is a regular expression that determines the method or methods that are to be excluded. Specify as much of the full package, class and method as necessary. For example, -Xjit:exclude={test/sample/MyClass.testMethod()V} excludes the single method specified. However, -Xjit:exclude={test/sample/MyClass.testMethod()*} excludes the method regardless of return type. Similarly, -Xjit:exclude={*} excludes all methods. Note: exclude has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:exclude , AOT compilation is also prevented and the methods specified are always interpreted.","title":"exclude"},{"location":"xjit/#limit","text":"-Xjit:limit={<method_name>} Only the Java methods specified are included when code is compiled or loaded from the shared classes cache. <method_name> is a regular expression that determines the method or methods that are to be included (see -Xjit:exclude for details). Note: limit has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limit , AOT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limit"},{"location":"xjit/#limitfile","text":"-Xjit:limitFile=(<vlog_filename>, <m>, <n>) Compile only the methods that are listed on lines <m> to <n> in the specified limit file, where the limit file is a verbose log that you generated with the -Xjit:verbose,vlog=<vlog_filename> option. Methods that are not listed in the limit file and methods that are listed on lines outside the range are not compiled. Note: limitFile has the same effect regardless of whether it is specified on -Xaot or -Xjit . In consequence, if you specify -Xjit:limitFile , AOT compilation is also restricted to those methods specified; other methods are always interpreted.","title":"limitFile"},{"location":"xjit/#optlevel","text":"-Xjit:optlevel=[noOpt|cold|warm|hot|veryHot|scorching] Forces the JIT compiler to compile all methods at a specific optimization level. Specifying optlevel might have an unexpected effect on performance, including reduced overall performance.","title":"optlevel"},{"location":"xjit/#verbose","text":"-Xjit:verbose Generates a JIT verbose log. The log provides a summary of which methods were compiled by the JIT and some of the compilation heurisic decisions that were taken while the JIT operates inside the OpenJ9 VM. -Xjit:verbose={compileStart} Prints out a line when the JIT is about to start compiling a method. -Xjit:verbose={compileEnd} Prints out a line when the JIT stops compiling a method. -Xjit:verbose={compilePerformance} Adds the values time (time taken to do the compilation) and mem (the amount of memory that was allocated during the compilation) into each line. This option includes the compileStart and compileEnd suboptions by default. -Xjit:verbose={disableInlining} Turns off inlining operations. -Xjit:verbose={inlining} Shows the methods that are inlined. Note: Suboptions can be chained together by using a pipe ( | ) symbol. When used, you must enclose the full option name in single quotation marks ( ' ) to avoid the shell misinterpreting these characters as pipe commands. For example: java '-Xjit:verbose={compileStart|compileEnd|inlining}' -version","title":"verbose"},{"location":"xjit/#vlog","text":"-Xjit:vlog=<vlog_filename> Sends verbose output to a file, of the format <vlog_filename>.<date>.<time>.<JVM_process_ID> , which is created in your current directory. Running the command multiple times produces multiple distinct versions of this file. If you do not specify this parameter, the output is sent to the standard error output stream (STDERR). This type of log file can be used with the limitFile suboption to target the compilation of specific methods.","title":"vlog"},{"location":"xjit/#examples","text":"","title":"Examples"},{"location":"xjit/#generating-a-jit-verbose-log","text":"The following example requests a JIT verbose log of the java -version command: java -Xjit:verbose,vlog=vlogfile -version","title":"Generating a JIT verbose log"},{"location":"xjit/#analyzing-jit-performance","text":"The following example requests information about the performance of JIT compiler threads, with output written to vlogfile . java -Xjit:verbose={compilePerformance},vlog=vlogfile -version The output generated by using this command adds the following information to compilation entry: the amount of time taken to do the compilation. the amount of memory that was allocated during the compilation.","title":"Analyzing JIT performance"},{"location":"xjit/#analyzing-inlining-operations","text":"The following example generates output that contains performance data and inlining operations. The suboptions count and -XcompilationThreads1 are used only to simplify the output. These options are not recommended for production because performance will be affected. java '-Xjit:verbose={compileStart|compileEnd|inlining},count=5,vlog=vlogfile' -XcompilationThreads1 -version","title":"Analyzing inlining operations"},{"location":"xjit/#see-also","text":"Diagnosing a JIT or AOT problem -Xaot","title":"See also"},{"location":"xjni/","text":"-Xjni Sets JNI options. Syntax -Xjni:<parameter> Parameters arrayCacheMax -Xjni:arrayCacheMax=<size in bytes> -Xjni:arrayCacheMax=unlimited Sets the maximum size of the array cache. The default size is 128 KB ( -Xjni:arrayCacheMax=131072 ).","title":"-Xjni"},{"location":"xjni/#-xjni","text":"Sets JNI options.","title":"-Xjni"},{"location":"xjni/#syntax","text":"-Xjni:<parameter>","title":"Syntax"},{"location":"xjni/#parameters","text":"","title":"Parameters"},{"location":"xjni/#arraycachemax","text":"-Xjni:arrayCacheMax=<size in bytes> -Xjni:arrayCacheMax=unlimited Sets the maximum size of the array cache. The default size is 128 KB ( -Xjni:arrayCacheMax=131072 ).","title":"arrayCacheMax"},{"location":"xlinenumbers/","text":"-Xlinenumbers / -Xnolinenumbers Enables or disables line numbers in stack traces for debugging. Syntax Setting Effect Default -Xlinenumbers Enable yes -Xnolinenumbers Disable Explanation If you start the OpenJ9 VM with -Xnolinenumbers when creating a new shared classes cache, the Class Debug Area is not created. The option -Xnolinenumbers advises the VM not to load any class debug information, so there is no need for this region. If -Xscdmx is also used on the command line to specify a non zero debug area size, then a debug area is created despite the use of -Xnolinenumbers .","title":"-Xnolinenumbers"},{"location":"xlinenumbers/#-xlinenumbers-xnolinenumbers","text":"Enables or disables line numbers in stack traces for debugging.","title":"-Xlinenumbers / -Xnolinenumbers"},{"location":"xlinenumbers/#syntax","text":"Setting Effect Default -Xlinenumbers Enable yes -Xnolinenumbers Disable","title":"Syntax"},{"location":"xlinenumbers/#explanation","text":"If you start the OpenJ9 VM with -Xnolinenumbers when creating a new shared classes cache, the Class Debug Area is not created. The option -Xnolinenumbers advises the VM not to load any class debug information, so there is no need for this region. If -Xscdmx is also used on the command line to specify a non zero debug area size, then a debug area is created despite the use of -Xnolinenumbers .","title":"Explanation"},{"location":"xloa/","text":"-Xloa / -Xnoloa This option enables or prevents allocation of a large object area (LOA) during garbage collection. Syntax Setting Effect Default -Xloa Enable LOA yes (see Default behavior) -Xnoloa Disable LOA Default behavior By default, allocations are made in the small object area (SOA). If there is no room in the SOA, and an object is larger than 64KB, the object is allocated in the LOA. If the LOA is not used, it is shrunk to zero after a few collections. You can disable it explicitly by specifying the -Xnoloa option. Explanation The LOA is an area of the tenure area of the heap set used solely to satisfy allocations for large objects. The LOA is used when the allocation request cannot be satisfied in the main area (the SOA of the tenure heap. As objects are allocated and freed, the heap can become fragmented in such a way that allocation can be met only by time-consuming compactions. This problem is more pronounced if an application allocates large objects. In an attempt to alleviate this problem, the LOA is allocated. A large object in this context is considered to be any object 64 KB or greater in size. Allocations for new TLH objects are not considered to be large objects. Note: The Balanced Garbage Collection policy does not use the LOA. Therefore, when specifying - Xgcpolicy:balanced , any LOA options passed on the command line are ignored. The policy addresses the issues of LOA by reorganizing object layout with the VM to reduce heap fragmentation and compaction requirements. See also -Xloainitial / -Xloaminimum / -Xloamaximum","title":"-Xnoloa"},{"location":"xloa/#-xloa-xnoloa","text":"This option enables or prevents allocation of a large object area (LOA) during garbage collection.","title":"-Xloa / -Xnoloa"},{"location":"xloa/#syntax","text":"Setting Effect Default -Xloa Enable LOA yes (see Default behavior) -Xnoloa Disable LOA","title":"Syntax"},{"location":"xloa/#default-behavior","text":"By default, allocations are made in the small object area (SOA). If there is no room in the SOA, and an object is larger than 64KB, the object is allocated in the LOA. If the LOA is not used, it is shrunk to zero after a few collections. You can disable it explicitly by specifying the -Xnoloa option.","title":"Default behavior"},{"location":"xloa/#explanation","text":"The LOA is an area of the tenure area of the heap set used solely to satisfy allocations for large objects. The LOA is used when the allocation request cannot be satisfied in the main area (the SOA of the tenure heap. As objects are allocated and freed, the heap can become fragmented in such a way that allocation can be met only by time-consuming compactions. This problem is more pronounced if an application allocates large objects. In an attempt to alleviate this problem, the LOA is allocated. A large object in this context is considered to be any object 64 KB or greater in size. Allocations for new TLH objects are not considered to be large objects. Note: The Balanced Garbage Collection policy does not use the LOA. Therefore, when specifying - Xgcpolicy:balanced , any LOA options passed on the command line are ignored. The policy addresses the issues of LOA by reorganizing object layout with the VM to reduce heap fragmentation and compaction requirements.","title":"Explanation"},{"location":"xloa/#see-also","text":"-Xloainitial / -Xloaminimum / -Xloamaximum","title":"See also"},{"location":"xloaminimum/","text":"-Xloainitial / -Xloaminimum / -Xloamaximum Specifies the initial, minimum, and maximum proportion of the current tenure space allocated to the large object area (LOA). The LOA does not shrink to less than the minimum value. Syntax Setting Effect Default -Xloainitial<value> Set initial space 0.05 -Xloaminimum<value> Set minimum space 0.01 -Xloamaximum<value> Set minimum space 0.5 See also -Xloa / Xnoloa","title":"-Xloaminimum"},{"location":"xloaminimum/#-xloainitial-xloaminimum-xloamaximum","text":"Specifies the initial, minimum, and maximum proportion of the current tenure space allocated to the large object area (LOA). The LOA does not shrink to less than the minimum value.","title":"-Xloainitial / -Xloaminimum / -Xloamaximum"},{"location":"xloaminimum/#syntax","text":"Setting Effect Default -Xloainitial<value> Set initial space 0.05 -Xloaminimum<value> Set minimum space 0.01 -Xloamaximum<value> Set minimum space 0.5","title":"Syntax"},{"location":"xloaminimum/#see-also","text":"-Xloa / Xnoloa","title":"See also"},{"location":"xlockreservation/","text":"-XlockReservation Enables an optimization that presumes a monitor is owned by the thread that last acquired it. This optimization minimizes the runtime cost of acquiring and releasing a monitor for a single thread if the monitor is rarely acquired by multiple threads. Syntax -XlockReservation","title":"-XlockReservation"},{"location":"xlockreservation/#-xlockreservation","text":"Enables an optimization that presumes a monitor is owned by the thread that last acquired it. This optimization minimizes the runtime cost of acquiring and releasing a monitor for a single thread if the monitor is rarely acquired by multiple threads.","title":"-XlockReservation"},{"location":"xlockreservation/#syntax","text":"-XlockReservation","title":"Syntax"},{"location":"xlockword/","text":"-Xlockword Test whether performance optimizations are negatively impacting an application. Syntax -Xlockword:<parameters> Parameters mode -Xlockword:mode=all -Xlockword:mode=default Locking optimizations typically reduce memory usage and improve performance. However, there might be some situations where a smaller heap size is achieved for an application, but overall application performance decreases. For example, if your application synchronizes on objects that are not typically synchronized on, such as Java.lang.String , run the following test: Use the following command-line option to revert to behavior that is closer to earlier versions and monitor application performance: -Xlockword:mode=all If performance does not improve, remove the previous command-line options or use the following command-line option to reestablish the new behavior: -Xlockword:mode=default nolockword -Xlockword:nolockword=<class_name> Removes the lockword from object instances of the class <class_name> , reducing the space required for these objects. However, this action might have an adverse effect on synchronization for those objects. You should only use this option for troubleshooting. what -Xlockword:what Shows the current lockword configuration.","title":"-Xlockword"},{"location":"xlockword/#-xlockword","text":"Test whether performance optimizations are negatively impacting an application.","title":"-Xlockword"},{"location":"xlockword/#syntax","text":"-Xlockword:<parameters>","title":"Syntax"},{"location":"xlockword/#parameters","text":"","title":"Parameters"},{"location":"xlockword/#mode","text":"-Xlockword:mode=all -Xlockword:mode=default Locking optimizations typically reduce memory usage and improve performance. However, there might be some situations where a smaller heap size is achieved for an application, but overall application performance decreases. For example, if your application synchronizes on objects that are not typically synchronized on, such as Java.lang.String , run the following test: Use the following command-line option to revert to behavior that is closer to earlier versions and monitor application performance: -Xlockword:mode=all If performance does not improve, remove the previous command-line options or use the following command-line option to reestablish the new behavior: -Xlockword:mode=default","title":"mode"},{"location":"xlockword/#nolockword","text":"-Xlockword:nolockword=<class_name> Removes the lockword from object instances of the class <class_name> , reducing the space required for these objects. However, this action might have an adverse effect on synchronization for those objects. You should only use this option for troubleshooting.","title":"nolockword"},{"location":"xlockword/#what","text":"-Xlockword:what Shows the current lockword configuration.","title":"what"},{"location":"xlog/","text":"-Xlog Enables message logging. Note: Changes made to message logging using the -Xlog option do not affect messages written to the standard error stream ( stderr ). Syntax -Xlog:<parameter>{,<parameter>} Parameters Restriction: The parameters all , none and help must be used on their own and cannot be combined. However, the other parameters can be grouped. For example, to include error, vital and warning messages use -Xlog:error,vital,warn . For message details see OpenJ9 VM messages . help -Xlog:help Gives details the available parameters. (This parameter cannot be combined with others.) error -Xlog:error Turns on logging for all OpenJ9 VM error messages (default). vital -Xlog:vital Turns on logging for selected information messages JVMDUMP006I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the OpenJ9 VM (default). info -Xlog:info Turns on logging for all OpenJ9 VM information messages. warn -Xlog:warn Turns on logging for all OpenJ9 VM warning messages. config -Xlog:config Turns on logging for all OpenJ9 VM configuration messages. all -Xlog:all Turns on logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.) none -Xlog:none Turns off logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.)","title":"-Xlog"},{"location":"xlog/#-xlog","text":"Enables message logging. Note: Changes made to message logging using the -Xlog option do not affect messages written to the standard error stream ( stderr ).","title":"-Xlog"},{"location":"xlog/#syntax","text":"-Xlog:<parameter>{,<parameter>}","title":"Syntax"},{"location":"xlog/#parameters","text":"Restriction: The parameters all , none and help must be used on their own and cannot be combined. However, the other parameters can be grouped. For example, to include error, vital and warning messages use -Xlog:error,vital,warn . For message details see OpenJ9 VM messages .","title":"Parameters"},{"location":"xlog/#help","text":"-Xlog:help Gives details the available parameters. (This parameter cannot be combined with others.)","title":"help"},{"location":"xlog/#error","text":"-Xlog:error Turns on logging for all OpenJ9 VM error messages (default).","title":"error"},{"location":"xlog/#vital","text":"-Xlog:vital Turns on logging for selected information messages JVMDUMP006I , JVMDUMP032I , and JVMDUMP033I , which provide valuable additional information about dumps produced by the OpenJ9 VM (default).","title":"vital"},{"location":"xlog/#info","text":"-Xlog:info Turns on logging for all OpenJ9 VM information messages.","title":"info"},{"location":"xlog/#warn","text":"-Xlog:warn Turns on logging for all OpenJ9 VM warning messages.","title":"warn"},{"location":"xlog/#config","text":"-Xlog:config Turns on logging for all OpenJ9 VM configuration messages.","title":"config"},{"location":"xlog/#all","text":"-Xlog:all Turns on logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.)","title":"all"},{"location":"xlog/#none","text":"-Xlog:none Turns off logging for all OpenJ9 VM messages. (This parameter cannot be combined with others.)","title":"none"},{"location":"xlp/","text":"-Xlp Requests the OpenJ9 VM to allocate the Java\u2122 object heap and JIT code cache memory with large pages. Note: This option is deprecated in all versions later than Java 8. Use the -Xlp:codecache and -Xlp:objectheap options instead. Restriction: This option does not work on macOS\u00ae. If you use the -Xgc:preferredHeapBase option with -Xlp , the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output. Syntax -Xlp[<size>] See Using -X command-line options for more information about the <size> parameter. Explanation AIX\u00ae If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If a size is not specified, this option requests the VM to allocate the Java object heap (the heap from which Java objects are allocated) with large (16 MB) pages. If large pages are not available, the Java object heap is allocated with the next smaller page size that is supported by the system. AIX requires special configuration to enable large pages. The VM supports the use of large pages only to back the Java object heap shared memory segments. The VM uses shmget() with the SHM_LGPG and SHM_PIN flags to allocate large pages. The -Xlp option replaces the environment variable IBM_JAVA_LARGE_PAGE_SIZE , which is now ignored if set. For more information about configuring AIX support for large pages, see Large pages in the AIX product documentation. Linux\u00ae If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If large pages are not available, the VM does not start and produces an error message. The VM uses shmget() to allocate large pages for the heap. Large pages are supported by systems that have Linux kernels v2.6 or higher. Note: Linux for IBM Z\u00ae supports only a large page size of 1 M. Depending on the architecture, 1 MB or 2 MB large pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap . Windows\u2122 If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. z/OS\u00ae If <size> is specified but unsuccessful, or if executable pages of that size are not supported, 1 M pageable is attempted. If 1 M pageable is not available, the JIT code cache memory is allocated by using the default or smallest available executable page size. If <size> is not specified, the 1 M nonpageable size is used. If large pages are not supported by the hardware, or enabled in RACF\u00ae, the VM does not start and produces an error message. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 31-bit VM. The -Xlp[<size>] option supports only a large page size of 2 G and 1 M (nonpageable). 1 M pageable pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap . Specifying -Xlp1M uses a 1 M pageable size for the code cache, when available. Specifying -Xlp2G sets the object heap size, but generates a warning that 2 G nonpageable pages cannot be used for the code cache. Use the -Xlp:objectheap:pagesize=2G,nonpageable option to avoid the warning. Limitation and workaround The VM ends if insufficient operating system resources are available to satisfy the request. However, an error message is not issued. There are a number of reasons why the VM cannot honor a large page request. For example, there might be insufficient large pages available on the system at the time of the request. To check whether the -Xlp request was honored, you can review the output from -verbose:gc . Look for the attributes requestedPageSize and pageSize in the -verbose:gc log file. The attribute requestedPageSize contains the value specified by -Xlp . The attribute pageSize is the actual page size used by the VM. See also Configuring large page memory allocation .","title":"-Xlp"},{"location":"xlp/#-xlp","text":"Requests the OpenJ9 VM to allocate the Java\u2122 object heap and JIT code cache memory with large pages. Note: This option is deprecated in all versions later than Java 8. Use the -Xlp:codecache and -Xlp:objectheap options instead. Restriction: This option does not work on macOS\u00ae. If you use the -Xgc:preferredHeapBase option with -Xlp , the preferredHeapBase address must be a multiple of the large page size. If you specify an inaccurate heap base address, the heap is allocated with the default page size. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output.","title":"-Xlp"},{"location":"xlp/#syntax","text":"-Xlp[<size>] See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xlp/#explanation","text":"","title":"Explanation"},{"location":"xlp/#aix","text":"If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If a size is not specified, this option requests the VM to allocate the Java object heap (the heap from which Java objects are allocated) with large (16 MB) pages. If large pages are not available, the Java object heap is allocated with the next smaller page size that is supported by the system. AIX requires special configuration to enable large pages. The VM supports the use of large pages only to back the Java object heap shared memory segments. The VM uses shmget() with the SHM_LGPG and SHM_PIN flags to allocate large pages. The -Xlp option replaces the environment variable IBM_JAVA_LARGE_PAGE_SIZE , which is now ignored if set. For more information about configuring AIX support for large pages, see Large pages in the AIX product documentation.","title":"AIX&reg;"},{"location":"xlp/#linux","text":"If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM. If large pages are not available, the VM does not start and produces an error message. The VM uses shmget() to allocate large pages for the heap. Large pages are supported by systems that have Linux kernels v2.6 or higher. Note: Linux for IBM Z\u00ae supports only a large page size of 1 M. Depending on the architecture, 1 MB or 2 MB large pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap .","title":"Linux&reg;"},{"location":"xlp/#windows","text":"If <size> is specified, the VM attempts to allocate the JIT code cache memory by using pages of that size. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 32-bit VM.","title":"Windows&trade;"},{"location":"xlp/#zos","text":"If <size> is specified but unsuccessful, or if executable pages of that size are not supported, 1 M pageable is attempted. If 1 M pageable is not available, the JIT code cache memory is allocated by using the default or smallest available executable page size. If <size> is not specified, the 1 M nonpageable size is used. If large pages are not supported by the hardware, or enabled in RACF\u00ae, the VM does not start and produces an error message. Allocating large pages by using -Xlp is supported only on the 64-bit VM, not the 31-bit VM. The -Xlp[<size>] option supports only a large page size of 2 G and 1 M (nonpageable). 1 M pageable pages, when available, are the default size for the object heap and the code cache. The options that control these sizes are Xlp:codecache and -Xlp:objectheap . Specifying -Xlp1M uses a 1 M pageable size for the code cache, when available. Specifying -Xlp2G sets the object heap size, but generates a warning that 2 G nonpageable pages cannot be used for the code cache. Use the -Xlp:objectheap:pagesize=2G,nonpageable option to avoid the warning.","title":"z/OS&reg;"},{"location":"xlp/#limitation-and-workaround","text":"The VM ends if insufficient operating system resources are available to satisfy the request. However, an error message is not issued. There are a number of reasons why the VM cannot honor a large page request. For example, there might be insufficient large pages available on the system at the time of the request. To check whether the -Xlp request was honored, you can review the output from -verbose:gc . Look for the attributes requestedPageSize and pageSize in the -verbose:gc log file. The attribute requestedPageSize contains the value specified by -Xlp . The attribute pageSize is the actual page size used by the VM.","title":"Limitation and workaround"},{"location":"xlp/#see-also","text":"Configuring large page memory allocation .","title":"See also"},{"location":"xlpcodecache/","text":"-Xlp:codecache Requests the OpenJ9 VM to allocate the JIT code cache by using large page sizes. If the requested large page size is not available, the VM starts, but the JIT code cache is allocated by using a platform-defined size. A warning is displayed when the requested page size is not available. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output. Syntax AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:codecache:pagesize=<size> z/OS\u00ae: -Xlp:codecache:pagesize=<size>,pageable See Using -X command-line options for more information about the <size> parameter. Default values AIX The code cache page size is controlled by the DATAPSIZE setting of the LDR_CNTRL environment variable. The page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. For more information about the LDR_CNTRL environment variable, see Working with the LDR_CNTRL environment variable . Linux The default size for the code cache depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages Linux on Power Systems\u2122: The code cache page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. On other architectures, the VM uses the default operating system page size. macOS The default size for the code cache is 4 KB large pages. z/OS 1 MB pageable pages, when available, are the default size for the code cache. The -Xlp:codecache:pagesize=<size>,pageable option supports only a large page size of 1 MB pageable large pages. The use of 1 MB pageable large pages for the JIT code cache can improve the runtime performance of some Java\u2122 applications. A page size of 4 KB can also be used. See also Configuring large page memory allocation .","title":"-Xlp:codecache"},{"location":"xlpcodecache/#-xlpcodecache","text":"Requests the OpenJ9 VM to allocate the JIT code cache by using large page sizes. If the requested large page size is not available, the VM starts, but the JIT code cache is allocated by using a platform-defined size. A warning is displayed when the requested page size is not available. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output.","title":"-Xlp:codecache"},{"location":"xlpcodecache/#syntax","text":"AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:codecache:pagesize=<size> z/OS\u00ae: -Xlp:codecache:pagesize=<size>,pageable See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xlpcodecache/#default-values","text":"","title":"Default values"},{"location":"xlpcodecache/#aix","text":"The code cache page size is controlled by the DATAPSIZE setting of the LDR_CNTRL environment variable. The page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. For more information about the LDR_CNTRL environment variable, see Working with the LDR_CNTRL environment variable .","title":"AIX"},{"location":"xlpcodecache/#linux","text":"The default size for the code cache depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages Linux on Power Systems\u2122: The code cache page size cannot be controlled by the -Xlp:codecache:pagesize=<size> option. Specifying any other page size results in a warning that the page size is not available. The -verbose:sizes output reflects the current operating system setting. On other architectures, the VM uses the default operating system page size.","title":"Linux"},{"location":"xlpcodecache/#macos","text":"The default size for the code cache is 4 KB large pages.","title":"macOS"},{"location":"xlpcodecache/#zos","text":"1 MB pageable pages, when available, are the default size for the code cache. The -Xlp:codecache:pagesize=<size>,pageable option supports only a large page size of 1 MB pageable large pages. The use of 1 MB pageable large pages for the JIT code cache can improve the runtime performance of some Java\u2122 applications. A page size of 4 KB can also be used.","title":"z/OS"},{"location":"xlpcodecache/#see-also","text":"Configuring large page memory allocation .","title":"See also"},{"location":"xlpobjectheap/","text":"-Xlp:objectheap Requests the OpenJ9 VM to allocate the Java\u2122 object heap by using large page sizes. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output. Syntax AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:objectheap:pagesize=<size>[,strict|warn] z/OS\u00ae: -Xlp:objectheap:pagesize=<size>[,strict|warn][,pageable|nonpageable] See Using -X command-line options for more information about the <size> parameter. Parameters pagesize -Xlp:objectheap:pagesize=<size> The large page size that you require. If the operating system does not have sufficient resources to satisfy the request, the page size you requested might not be available when the VM starts up. By default, the VM starts and the Java object heap is allocated by using a different platform-defined page size. Alternatively, you can use the strict or warn suboptions to customize behavior. Default page sizes On Linux systems, the default size for the object heap depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages On other architectures, the VM uses the default operating system page size. On macOS, the default page size is 4 KB. strict | warn -Xlp:objectheap:strict -Xlp:objectheap:warn strict causes an error message to be generated if large pages are requested but cannot be obtained. This option causes the VM to end. warn causes a warning message to be generated if large pages are requested but cannot be obtained. This option allows the VM to continue. Note: If both strict and warn are specified, strict takes precedence. pageable | nonpageable -Xlp:objectheap:pageable -Xlp:objectheap:nonpageable On z/OS systems, defines the type of memory to allocate for the Java object heap. 1 MB pageable pages, when available, are the default size for the object heap. Supported large page sizes are 2 GB nonpageable, 1 MB nonpageable, and 1 MB pageable. A page size of 4 KB can also be used. See also Configuring large page memory allocation .","title":"-Xlp:objectheap"},{"location":"xlpobjectheap/#-xlpobjectheap","text":"Requests the OpenJ9 VM to allocate the Java\u2122 object heap by using large page sizes. To find out the large page sizes available and the current setting, use the -verbose:sizes option. Note that the current settings are the requested sizes and not the sizes obtained. For object heap size information, check the -verbose:gc output.","title":"-Xlp:objectheap"},{"location":"xlpobjectheap/#syntax","text":"AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122: -Xlp:objectheap:pagesize=<size>[,strict|warn] z/OS\u00ae: -Xlp:objectheap:pagesize=<size>[,strict|warn][,pageable|nonpageable] See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xlpobjectheap/#parameters","text":"","title":"Parameters"},{"location":"xlpobjectheap/#pagesize","text":"-Xlp:objectheap:pagesize=<size> The large page size that you require. If the operating system does not have sufficient resources to satisfy the request, the page size you requested might not be available when the VM starts up. By default, the VM starts and the Java object heap is allocated by using a different platform-defined page size. Alternatively, you can use the strict or warn suboptions to customize behavior.","title":"pagesize"},{"location":"xlpobjectheap/#default-page-sizes","text":"On Linux systems, the default size for the object heap depends on the architecture: Linux on x86 and AMD64/EM64T systems: 2 MB large pages Linux on IBM Z\u00ae: 1 MB large pages On other architectures, the VM uses the default operating system page size. On macOS, the default page size is 4 KB.","title":"Default page sizes"},{"location":"xlpobjectheap/#strict-warn","text":"-Xlp:objectheap:strict -Xlp:objectheap:warn strict causes an error message to be generated if large pages are requested but cannot be obtained. This option causes the VM to end. warn causes a warning message to be generated if large pages are requested but cannot be obtained. This option allows the VM to continue. Note: If both strict and warn are specified, strict takes precedence.","title":"strict | warn"},{"location":"xlpobjectheap/#pageablenonpageable","text":"-Xlp:objectheap:pageable -Xlp:objectheap:nonpageable On z/OS systems, defines the type of memory to allocate for the Java object heap. 1 MB pageable pages, when available, are the default size for the object heap. Supported large page sizes are 2 GB nonpageable, 1 MB nonpageable, and 1 MB pageable. A page size of 4 KB can also be used.","title":"pageable|nonpageable"},{"location":"xlpobjectheap/#see-also","text":"Configuring large page memory allocation .","title":"See also"},{"location":"xmca/","text":"-Xmca / -Xmco Sets the expansion step for the memory allocated to store the RAM ( -Xmca ) and ROM ( -Xmco ) portions of loaded classes. Each time more memory is required to store classes in RAM or ROM, the allocated memory is increased by the amount set. If the expansion step size you choose is too large, OutOfMemoryError is reported. The exact value of a \"too large\" expansion step size varies according to the platform and the specific machine configuration. You can use the -verbose:sizes option to find out the value that is being used by the VM. Syntax Setting Effect Default -Xmca<size> Set expansion step for RAM 32 KB -Xmco<size> Set expansion step for ROM 128 KB See Using -X command-line options for more information about the <size> parameter.","title":"-Xmco"},{"location":"xmca/#-xmca-xmco","text":"Sets the expansion step for the memory allocated to store the RAM ( -Xmca ) and ROM ( -Xmco ) portions of loaded classes. Each time more memory is required to store classes in RAM or ROM, the allocated memory is increased by the amount set. If the expansion step size you choose is too large, OutOfMemoryError is reported. The exact value of a \"too large\" expansion step size varies according to the platform and the specific machine configuration. You can use the -verbose:sizes option to find out the value that is being used by the VM.","title":"-Xmca / -Xmco"},{"location":"xmca/#syntax","text":"Setting Effect Default -Xmca<size> Set expansion step for RAM 32 KB -Xmco<size> Set expansion step for ROM 128 KB See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmcrs/","text":"-Xmcrs Sets an initial size for an area in memory that is reserved for any native classes, monitors, and threads that are used by compressed references within the lowest 4 GB memory area. You can use the -verbose:sizes option to find out the value that is being used by the VM. Notes: Native memory OutOfMemoryError exceptions might occur when using compressed references if the lowest 4 GB of address space becomes full, particularly when loading classes, starting threads, or using monitors. If you are not using compressed references and this option is set, the option is ignored and the output of -verbose:sizes shows -Xmcrs0 . Syntax -Xmcrs<size> See Using -X command-line options for more information about the <size> parameter.","title":"-Xmcrs"},{"location":"xmcrs/#-xmcrs","text":"Sets an initial size for an area in memory that is reserved for any native classes, monitors, and threads that are used by compressed references within the lowest 4 GB memory area. You can use the -verbose:sizes option to find out the value that is being used by the VM. Notes: Native memory OutOfMemoryError exceptions might occur when using compressed references if the lowest 4 GB of address space becomes full, particularly when loading classes, starting threads, or using monitors. If you are not using compressed references and this option is set, the option is ignored and the output of -verbose:sizes shows -Xmcrs0 .","title":"-Xmcrs"},{"location":"xmcrs/#syntax","text":"-Xmcrs<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmine/","text":"-Xmine / -Xmaxe Set the minimum and maximum amounts by which the garbage collector expands the heap. Syntax Setting Default -Xmine<size> 1 MB -Xmaxe<size> 0 (unlimited expansion) See Using -X command-line options for more information about the <size> parameter. Explanation Typically, the garbage collector expands the heap by the amount required to restore the free space to 30% (or the amount specified by -Xminf ). If heap expansion is required: -Xmine forces the expansion to be at least the specified value. For example, -Xmine10M sets the expansion size to a minimum of 10 MB. -Xmaxe limits the expansion to the specified value. For example -Xmaxe50M prevents expansion by more than 50 MB. ( -Xmaxe0 allows unlimited expansion.) See also Heap shrinkage Heap expansion","title":"-Xmine"},{"location":"xmine/#-xmine-xmaxe","text":"Set the minimum and maximum amounts by which the garbage collector expands the heap.","title":"-Xmine / -Xmaxe"},{"location":"xmine/#syntax","text":"Setting Default -Xmine<size> 1 MB -Xmaxe<size> 0 (unlimited expansion) See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmine/#explanation","text":"Typically, the garbage collector expands the heap by the amount required to restore the free space to 30% (or the amount specified by -Xminf ). If heap expansion is required: -Xmine forces the expansion to be at least the specified value. For example, -Xmine10M sets the expansion size to a minimum of 10 MB. -Xmaxe limits the expansion to the specified value. For example -Xmaxe50M prevents expansion by more than 50 MB. ( -Xmaxe0 allows unlimited expansion.)","title":"Explanation"},{"location":"xmine/#see-also","text":"Heap shrinkage Heap expansion","title":"See also"},{"location":"xminf/","text":"-Xminf / -Xmaxf Specifies the minimum and maximum proportion of the heap that must remain free after a global garbage collection (GC) cycle. If the free space is above or below these limits, the OpenJ9 VM attempts to adjust the heap size so that: -Xminf \u2264 free space \u2264 -Xmaxf . Syntax Setting Effect Default -Xminf<value> Set minimum free space 0.3 -Xmaxf<value> Set maximum free space 0.6 The value range is 0.0 - 1.0. For the gencon GC policy, the values apply only to the Tenure part of the heap and only at global GC points. For the optthruput and optavgpause GC policies, these values apply to the whole heap at every GC point. See also Heap shrinkage Heap expansion","title":"-Xminf"},{"location":"xminf/#-xminf-xmaxf","text":"Specifies the minimum and maximum proportion of the heap that must remain free after a global garbage collection (GC) cycle. If the free space is above or below these limits, the OpenJ9 VM attempts to adjust the heap size so that: -Xminf \u2264 free space \u2264 -Xmaxf .","title":"-Xminf / -Xmaxf"},{"location":"xminf/#syntax","text":"Setting Effect Default -Xminf<value> Set minimum free space 0.3 -Xmaxf<value> Set maximum free space 0.6 The value range is 0.0 - 1.0. For the gencon GC policy, the values apply only to the Tenure part of the heap and only at global GC points. For the optthruput and optavgpause GC policies, these values apply to the whole heap at every GC point.","title":"Syntax"},{"location":"xminf/#see-also","text":"Heap shrinkage Heap expansion","title":"See also"},{"location":"xmint/","text":"-Xmint / -Xmaxt Sets the minimum and maximum proportion of time to spend in the garbage collection (GC) process as a percentage of the overall running time that included the last three GC runs. If the percentage of time drops to less than the minimum, the OpenJ9 VM tries to shrink the heap. If the percentage of time exceeds the maximum, the OpenJ9 VM tries to expand the heap. Restrictions: This option applies only to GC policies that include stop-the-world (STW) operations, such as -Xgcpolicy:optthruput . Syntax Setting Effect Default -Xmint<value> Set minimum time in GC 5 -Xmaxt<value> Set maximum time in GC 13","title":"-Xmint"},{"location":"xmint/#-xmint-xmaxt","text":"Sets the minimum and maximum proportion of time to spend in the garbage collection (GC) process as a percentage of the overall running time that included the last three GC runs. If the percentage of time drops to less than the minimum, the OpenJ9 VM tries to shrink the heap. If the percentage of time exceeds the maximum, the OpenJ9 VM tries to expand the heap. Restrictions: This option applies only to GC policies that include stop-the-world (STW) operations, such as -Xgcpolicy:optthruput .","title":"-Xmint / -Xmaxt"},{"location":"xmint/#syntax","text":"Setting Effect Default -Xmint<value> Set minimum time in GC 5 -Xmaxt<value> Set maximum time in GC 13","title":"Syntax"},{"location":"xmn/","text":"-Xmn / -Xmns / -Xmnx Sets the initial and maximum size of the new area when using -Xgcpolicy:gencon . If the scavenger is disabled, this option is ignored. You can use the -verbose:sizes option to find out the value that is being used by the VM. Syntax Setting Effect Default -Xmn<size> Equivalent to setting both -Xmns and -Xmnx Not set -Xmns<size> Set initial size 25% of -Xms -Xmnx<size> Set maximum size 25% of -Xmx See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmn with either -Xmns or -Xmnx , the VM does not start, returning an error.","title":"-Xmnx"},{"location":"xmn/#-xmn-xmns-xmnx","text":"Sets the initial and maximum size of the new area when using -Xgcpolicy:gencon . If the scavenger is disabled, this option is ignored. You can use the -verbose:sizes option to find out the value that is being used by the VM.","title":"-Xmn / -Xmns / -Xmnx"},{"location":"xmn/#syntax","text":"Setting Effect Default -Xmn<size> Equivalent to setting both -Xmns and -Xmnx Not set -Xmns<size> Set initial size 25% of -Xms -Xmnx<size> Set maximum size 25% of -Xmx See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmn with either -Xmns or -Xmnx , the VM does not start, returning an error.","title":"Syntax"},{"location":"xmo/","text":"-Xmo / -Xmoi / -Xmos / -Xmox Sets the size and behavior of the old (tenure) heap when using -Xgcpolicy:gencon . You can use the -verbose:sizes option to find out the values that the VM is currently using. Syntax Setting Effect Default -Xmo<size> Equivalent to setting both -Xmos and -Xmox not set -Xmoi<size> Set increment size of old (tenure) heap See Note -Xmos<size> Set initial size of old (tenure) heap 75% of -Xms -Xmox<size> Set maximum size of old (tenure) heap Same as -Xmx Note: By default, the increment size ( -Xmoi ) is calculated on the expansion size, set by -Xmine and -Xminf . If you set -Xmoi to zero, no expansion is allowed. See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmo with either -Xmos or -Xmox , the VM does not start, returning an error.","title":"-Xmox"},{"location":"xmo/#-xmo-xmoi-xmos-xmox","text":"Sets the size and behavior of the old (tenure) heap when using -Xgcpolicy:gencon . You can use the -verbose:sizes option to find out the values that the VM is currently using.","title":"-Xmo / -Xmoi / -Xmos / -Xmox"},{"location":"xmo/#syntax","text":"Setting Effect Default -Xmo<size> Equivalent to setting both -Xmos and -Xmox not set -Xmoi<size> Set increment size of old (tenure) heap See Note -Xmos<size> Set initial size of old (tenure) heap 75% of -Xms -Xmox<size> Set maximum size of old (tenure) heap Same as -Xmx Note: By default, the increment size ( -Xmoi ) is calculated on the expansion size, set by -Xmine and -Xminf . If you set -Xmoi to zero, no expansion is allowed. See Using -X command-line options for more information about the <size> parameter. Restriction: If you try to set -Xmo with either -Xmos or -Xmox , the VM does not start, returning an error.","title":"Syntax"},{"location":"xmr/","text":"-Xmr / -Xmrx Sets the initial and maximum size of the the garbage collection \"remembered set\", which is a list of objects in the old (tenured) heap that have references to objects in the new area. Syntax Setting Effect Default -Xmr<size> Set initial size 16 K -Xmrx<size> Set maximium size See Using -X command-line options for more information about the <size> parameter.","title":"-Xmrx"},{"location":"xmr/#-xmr-xmrx","text":"Sets the initial and maximum size of the the garbage collection \"remembered set\", which is a list of objects in the old (tenured) heap that have references to objects in the new area.","title":"-Xmr / &nbsp; -Xmrx"},{"location":"xmr/#syntax","text":"Setting Effect Default -Xmr<size> Set initial size 16 K -Xmrx<size> Set maximium size See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xms/","text":"-Xms / -Xmx These Oracle\u00ae HotSpot\u2122 options set the initial/minimum Java\u2122 heap size, and the maximum heap size respectively. These options are recognized by the OpenJ9 VM. Notes: If you set -Xms > -Xmx , the OpenJ9 VM fails with the message -Xms too large for -Xmx . If you exceed the limit set by the -Xmx option, the OpenJ9 VM generates an OutofMemoryError . If you are allocating the Java heap with large pages, see also -Xlp and More effective heap usage using compressed references . You can also use the -Xmo option (not supported by the balanced garbage collection policy): If the scavenger is enabled, -Xms \u2265 -Xmn + -Xmo If the scavenger is disabled, -Xms \u2265 -Xmo Syntax Setting Effect Default -Xms<size> Set initial heap size 8 MB -Xmx<size> Set maximum heap size 25% of available memory (25 GB maximum) See Using -X command-line options for more information about the <size> parameter. See Default settings for the OpenJ9 VM for more about default values. Examples -Xms2m -Xmx64m Heap starts at 2 MB and grows to a maximum of 64 MB. -Xms100m -Xmx100m Heap starts at 100 MB and never grows. -Xms50m Heap starts at 50 MB and grows to the default maximum. -Xmx256m Heap starts at default initial value and grows to a maximum of 256 MB. See also -Xsoftmx (Set \"soft\" maximum Java heap size)","title":"-Xmx"},{"location":"xms/#-xms-xmx","text":"These Oracle\u00ae HotSpot\u2122 options set the initial/minimum Java\u2122 heap size, and the maximum heap size respectively. These options are recognized by the OpenJ9 VM. Notes: If you set -Xms > -Xmx , the OpenJ9 VM fails with the message -Xms too large for -Xmx . If you exceed the limit set by the -Xmx option, the OpenJ9 VM generates an OutofMemoryError . If you are allocating the Java heap with large pages, see also -Xlp and More effective heap usage using compressed references . You can also use the -Xmo option (not supported by the balanced garbage collection policy): If the scavenger is enabled, -Xms \u2265 -Xmn + -Xmo If the scavenger is disabled, -Xms \u2265 -Xmo","title":"-Xms / -Xmx"},{"location":"xms/#syntax","text":"Setting Effect Default -Xms<size> Set initial heap size 8 MB -Xmx<size> Set maximum heap size 25% of available memory (25 GB maximum) See Using -X command-line options for more information about the <size> parameter. See Default settings for the OpenJ9 VM for more about default values.","title":"Syntax"},{"location":"xms/#examples","text":"-Xms2m -Xmx64m Heap starts at 2 MB and grows to a maximum of 64 MB. -Xms100m -Xmx100m Heap starts at 100 MB and never grows. -Xms50m Heap starts at 50 MB and grows to the default maximum. -Xmx256m Heap starts at default initial value and grows to a maximum of 256 MB.","title":"Examples"},{"location":"xms/#see-also","text":"-Xsoftmx (Set \"soft\" maximum Java heap size)","title":"See also"},{"location":"xmso/","text":"-Xmso Sets the native stack size for operating system threads. You can use the -verbose:sizes option to find out the values that the VM is currently using. When a native method makes a call into the VM, the VM calculates whether the memory required for the call will exceed the -Xmso value. If so, a java/lang/StackOverflowError error is thrown. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; this option applies to the native stack only. For the Java stack option, see the link in the See also section. Syntax -Xmso<size> See Using -X command-line options for more information about the <size> parameter. Default setting Default values vary by platform. See Default settings for the OpenJ9 VM . Note: On 64-bit z/OS, the default size is the minimum that can be allocated by the operating system. So if you set a value that is smaller, that value is ignored by the VM. See also -Xiss/-Xss/-Xssi (stack size and increment for Java\u2122 threads)","title":"-Xmso"},{"location":"xmso/#-xmso","text":"Sets the native stack size for operating system threads. You can use the -verbose:sizes option to find out the values that the VM is currently using. When a native method makes a call into the VM, the VM calculates whether the memory required for the call will exceed the -Xmso value. If so, a java/lang/StackOverflowError error is thrown. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; this option applies to the native stack only. For the Java stack option, see the link in the See also section.","title":"-Xmso"},{"location":"xmso/#syntax","text":"-Xmso<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xmso/#default-setting","text":"Default values vary by platform. See Default settings for the OpenJ9 VM . Note: On 64-bit z/OS, the default size is the minimum that can be allocated by the operating system. So if you set a value that is smaller, that value is ignored by the VM.","title":"Default setting"},{"location":"xmso/#see-also","text":"-Xiss/-Xss/-Xssi (stack size and increment for Java\u2122 threads)","title":"See also"},{"location":"xnumanone/","text":"-Xnuma:none (AIX\u00ae, Linux\u00ae, and Windows\u2122 only) Use this option to turn off non-uniform memory architecture (NUMA) awareness when using the balanced garbage collection policy. For workloads that do most of their work in one thread, or workloads that maintain a full heap, turning off NUMA awareness can improve performance. Syntax -Xnuma:none Default behavior NUMA awareness is enabled by default.","title":"-Xnuma:none"},{"location":"xnumanone/#-xnumanone","text":"(AIX\u00ae, Linux\u00ae, and Windows\u2122 only) Use this option to turn off non-uniform memory architecture (NUMA) awareness when using the balanced garbage collection policy. For workloads that do most of their work in one thread, or workloads that maintain a full heap, turning off NUMA awareness can improve performance.","title":"-Xnuma:none"},{"location":"xnumanone/#syntax","text":"-Xnuma:none","title":"Syntax"},{"location":"xnumanone/#default-behavior","text":"NUMA awareness is enabled by default.","title":"Default behavior"},{"location":"xoptionsfile/","text":"-Xoptionsfile Specifies a file that contains VM options and definitions. The contents of the options file are recorded in the ENVINFO section of a Java\u2122 dump. Syntax -Xoptionsfile=<file_name> where <file_name> specifies a file that contains options that are processed as if they had been entered directly as command-line options. Explanation At startup, the VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. <path> is the VM directory, as shown in Directory conventions . <path> is the <java_home>/lib directory, where <java_home> is the directory for your runtime environment. The file options.default is empty but can be updated with any options that you want to specify at run time. The options file does not support these options: -assert -fullversion -help -showversion -version -Xcompressedrefs -Xcheck:memory -Xoptionsfile -XshowSettings Although you cannot use -Xoptionsfile recursively within an options file, you can use -Xoptionsfile multiple times on the same command line to load more than one options files. Some options use quoted strings as parameters. Do not split quoted strings over multiple lines using the forward slash line continuation character (\\). The Yen symbol (\u00a5) is not supported as a line continuation character. For example, the following example is not valid in an options file: -Xevents=vmstop,exec=\"cmd /c \\ echo %pid has finished.\" The following example is valid in an options file: -Xevents=vmstop, \\ exec=\"cmd /c echo %pid has finished.\" Example Here is an example of an options file: #My options file -X<option1> -X<option2>=\\ <value1>,\\ <value2> -D<sysprop1>=<value1> See also Specifying command-line options Javadump: TITLE, GPINFO, and ENVINFO sections","title":"-Xoptionsfile"},{"location":"xoptionsfile/#-xoptionsfile","text":"Specifies a file that contains VM options and definitions. The contents of the options file are recorded in the ENVINFO section of a Java\u2122 dump.","title":"-Xoptionsfile"},{"location":"xoptionsfile/#syntax","text":"-Xoptionsfile=<file_name> where <file_name> specifies a file that contains options that are processed as if they had been entered directly as command-line options.","title":"Syntax"},{"location":"xoptionsfile/#explanation","text":"At startup, the VM automatically adds -Xoptionsfile=<path>/options.default at the beginning of the command line, where <path> is the path to the VM directory. <path> is the VM directory, as shown in Directory conventions . <path> is the <java_home>/lib directory, where <java_home> is the directory for your runtime environment. The file options.default is empty but can be updated with any options that you want to specify at run time. The options file does not support these options: -assert -fullversion -help -showversion -version -Xcompressedrefs -Xcheck:memory -Xoptionsfile -XshowSettings Although you cannot use -Xoptionsfile recursively within an options file, you can use -Xoptionsfile multiple times on the same command line to load more than one options files. Some options use quoted strings as parameters. Do not split quoted strings over multiple lines using the forward slash line continuation character (\\). The Yen symbol (\u00a5) is not supported as a line continuation character. For example, the following example is not valid in an options file: -Xevents=vmstop,exec=\"cmd /c \\ echo %pid has finished.\" The following example is valid in an options file: -Xevents=vmstop, \\ exec=\"cmd /c echo %pid has finished.\"","title":"Explanation"},{"location":"xoptionsfile/#example","text":"Here is an example of an options file: #My options file -X<option1> -X<option2>=\\ <value1>,\\ <value2> -D<sysprop1>=<value1>","title":"Example"},{"location":"xoptionsfile/#see-also","text":"Specifying command-line options Javadump: TITLE, GPINFO, and ENVINFO sections","title":"See also"},{"location":"xquickstart/","text":"-Xquickstart This option causes the JIT compiler to run with a subset of optimizations, which can improve the performance of short-running applications. Note: For compatibility with other Java\u2122 virtual machines, you can also specify the -client option, which results in identical behavior to -Xquickstart . Syntax -Xquickstart Default behavior By default, -Xquickstart is disabled. Explanation The JIT compiler is tuned for long-running applications typically used on a server. When you specify this option, the compiler uses a subset of optimizations, which results in faster compilation times that improve startup time. However, longer running applications might run more slowly, especially applications that contain hot methods and other methods using a large amount of processing resource. When the AOT compiler is active (both shared classes and AOT compilation enabled), -Xquickstart causes all methods to be AOT compiled. The AOT compilation improves the startup time of subsequent runs, but might reduce performance for longer running applications, especially those that contain hot methods. Note: The implementation of -Xquickstart is subject to change in future releases.","title":"-Xquickstart"},{"location":"xquickstart/#-xquickstart","text":"This option causes the JIT compiler to run with a subset of optimizations, which can improve the performance of short-running applications. Note: For compatibility with other Java\u2122 virtual machines, you can also specify the -client option, which results in identical behavior to -Xquickstart .","title":"-Xquickstart"},{"location":"xquickstart/#syntax","text":"-Xquickstart","title":"Syntax"},{"location":"xquickstart/#default-behavior","text":"By default, -Xquickstart is disabled.","title":"Default behavior"},{"location":"xquickstart/#explanation","text":"The JIT compiler is tuned for long-running applications typically used on a server. When you specify this option, the compiler uses a subset of optimizations, which results in faster compilation times that improve startup time. However, longer running applications might run more slowly, especially applications that contain hot methods and other methods using a large amount of processing resource. When the AOT compiler is active (both shared classes and AOT compilation enabled), -Xquickstart causes all methods to be AOT compiled. The AOT compilation improves the startup time of subsequent runs, but might reduce performance for longer running applications, especially those that contain hot methods. Note: The implementation of -Xquickstart is subject to change in future releases.","title":"Explanation"},{"location":"xrs/","text":"-Xrs Prevents the OpenJ9 runtime environment from handling any internally or externally generated signals such as SIGSEGV and SIGABRT . Any signals that are raised are handled by the default operating system handlers, which you might want if you are using a debugger such as GDB or WinDbg to diagnose problems in JNI code. Disabling signal handling in the OpenJ9 VM reduces performance by approximately 2-4%, depending on the application. Note: Setting this option prevents dumps being generated by the OpenJ9 VM for signals such as SIGSEGV and SIGABRT , because the VM is no longer intercepting these signals. Do not use the -Xrs and -XX:+HandleSIGABRT options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled. Syntax -Xrs -Xrs:sync Parameters If you specify the sync parameter: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: Disables signal handling in the VM for SIGSEGV , SIGFPE , SIGBUS , SIGILL , SIGTRAP , and SIGABRT signals. However, the VM still handles the SIGQUIT and SIGTERM signals, among others. On Windows\u2122 systems: Hardware exceptions are not handled by the OpenJ9 VM when this option is specified. However, the Windows CTRL_BREAK_EVENT signal, triggered by the Ctrl-Break key combination, is still handled by the VM. Linux and macOS systems always use the SIGUSR1 signal. See also Signal handling","title":"-Xrs"},{"location":"xrs/#-xrs","text":"Prevents the OpenJ9 runtime environment from handling any internally or externally generated signals such as SIGSEGV and SIGABRT . Any signals that are raised are handled by the default operating system handlers, which you might want if you are using a debugger such as GDB or WinDbg to diagnose problems in JNI code. Disabling signal handling in the OpenJ9 VM reduces performance by approximately 2-4%, depending on the application. Note: Setting this option prevents dumps being generated by the OpenJ9 VM for signals such as SIGSEGV and SIGABRT , because the VM is no longer intercepting these signals. Do not use the -Xrs and -XX:+HandleSIGABRT options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled.","title":"-Xrs"},{"location":"xrs/#syntax","text":"-Xrs -Xrs:sync","title":"Syntax"},{"location":"xrs/#parameters","text":"If you specify the sync parameter: On AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae systems: Disables signal handling in the VM for SIGSEGV , SIGFPE , SIGBUS , SIGILL , SIGTRAP , and SIGABRT signals. However, the VM still handles the SIGQUIT and SIGTERM signals, among others. On Windows\u2122 systems: Hardware exceptions are not handled by the OpenJ9 VM when this option is specified. However, the Windows CTRL_BREAK_EVENT signal, triggered by the Ctrl-Break key combination, is still handled by the VM. Linux and macOS systems always use the SIGUSR1 signal.","title":"Parameters"},{"location":"xrs/#see-also","text":"Signal handling","title":"See also"},{"location":"xsamplingexpirationtime/","text":"-XsamplingExpirationTime Disables JIT sampling after a specified amount of time. When the JIT sampling thread is disabled, no processor cycles are used by an idle OpenJ9 VM. Use this option with care; after the sampling thread is disabled, you cannot reactivate it. However, because the profiling frequency is automatically reduced, you should not have to use this option. Allow the sampling thread to run for long enough to identify important optimizations. Syntax -XsamplingExpirationTime<time> where <time> is specified in seconds. Explanation The JIT sampling thread profiles the running Java\u2122 application to discover commonly used methods. The memory and processor usage of the sampling thread is negligible, and the frequency of profiling is automatically reduced when the OpenJ9 VM is idle, to once per second instead of once every 10ms, or once every 100 seconds if the idle state lasts more than 50 seconds.","title":"-XsamplingExpirationTime"},{"location":"xsamplingexpirationtime/#-xsamplingexpirationtime","text":"Disables JIT sampling after a specified amount of time. When the JIT sampling thread is disabled, no processor cycles are used by an idle OpenJ9 VM. Use this option with care; after the sampling thread is disabled, you cannot reactivate it. However, because the profiling frequency is automatically reduced, you should not have to use this option. Allow the sampling thread to run for long enough to identify important optimizations.","title":"-XsamplingExpirationTime"},{"location":"xsamplingexpirationtime/#syntax","text":"-XsamplingExpirationTime<time> where <time> is specified in seconds.","title":"Syntax"},{"location":"xsamplingexpirationtime/#explanation","text":"The JIT sampling thread profiles the running Java\u2122 application to discover commonly used methods. The memory and processor usage of the sampling thread is negligible, and the frequency of profiling is automatically reduced when the OpenJ9 VM is idle, to once per second instead of once every 10ms, or once every 100 seconds if the idle state lasts more than 50 seconds.","title":"Explanation"},{"location":"xscdmx/","text":"-Xscdmx Use the -Xscdmx option to control the size of the class debug area when you create a shared classes cache. Syntax -Xscdmx<size> See Using -X command-line options for more information about the <size> parameter. Explanation The -Xscdmx option works in a similar way to the -Xscmx option, which is used to control the overall size of the shared classes cache. The size of -Xscdmx must be smaller than the size of -Xscmx . By default, the size of the class debug area is a percentage of the free class data bytes in a newly created or empty cache. A class debug area is still created if you use the -Xnolinenumbers option with the -Xscdmx option on the command line.","title":"-Xscdmx"},{"location":"xscdmx/#-xscdmx","text":"Use the -Xscdmx option to control the size of the class debug area when you create a shared classes cache.","title":"-Xscdmx"},{"location":"xscdmx/#syntax","text":"-Xscdmx<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscdmx/#explanation","text":"The -Xscdmx option works in a similar way to the -Xscmx option, which is used to control the overall size of the shared classes cache. The size of -Xscdmx must be smaller than the size of -Xscmx . By default, the size of the class debug area is a percentage of the free class data bytes in a newly created or empty cache. A class debug area is still created if you use the -Xnolinenumbers option with the -Xscdmx option on the command line.","title":"Explanation"},{"location":"xscminaot/","text":"-Xscminaot / -Xscmaxaot When you create a shared classes cache, you can use these options to set the minimum and maximum number of bytes in the class cache to reserve for AOT data. Setting -Xscmaxaot is useful if you want a certain amount of cache space guaranteed for non-AOT data. Syntax Setting Effect Default -Xscminaot<size> Set minimum size for AOT class cache 0 -Xscmaxaot<size> Set maximum size for AOT class cache The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter. -Xscminaot If -Xscminaot is not specified, no space is reserved for AOT data. However, AOT data is still written to the cache until the cache is full or the -Xscmaxaot limit is reached. The value of -Xscminaot must not exceed the value of -Xscmx or -Xscmaxaot and should be considerably less than the total cache size, because AOT data can be created only for cached classes. If the value of -Xscminaot equals the value of -Xscmx , no class data or AOT data can be stored. You can also adjust the -Xscminaot value by using: -Xshareclasses:adjustminaot=<size> option MemoryMXBean.setSharedClassCacheMinAotBytes() method in the com.ibm.lang.management API You can also adjust the -Xscmaxaot value by using: -Xshareclasses:adjustmaxaot=<size> option MemoryMXBean.setSharedClassCacheMaxAotBytes() method in the com.ibm.lang.management API. -Xscmaxaot The value of this option must not be smaller than the value of -Xscminaot and must not be larger than the value of -Xscmx . When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of AOT data that is not stored due to the current setting of the maximum AOT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxAotUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum AOT data space size accordingly if you want to add the unstored AOT data to the shared cache. See also -Xshareclasses","title":"-Xscminaot"},{"location":"xscminaot/#-xscminaot-xscmaxaot","text":"When you create a shared classes cache, you can use these options to set the minimum and maximum number of bytes in the class cache to reserve for AOT data. Setting -Xscmaxaot is useful if you want a certain amount of cache space guaranteed for non-AOT data.","title":"-Xscminaot / -Xscmaxaot"},{"location":"xscminaot/#syntax","text":"Setting Effect Default -Xscminaot<size> Set minimum size for AOT class cache 0 -Xscmaxaot<size> Set maximum size for AOT class cache The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscminaot/#-xscminaot","text":"If -Xscminaot is not specified, no space is reserved for AOT data. However, AOT data is still written to the cache until the cache is full or the -Xscmaxaot limit is reached. The value of -Xscminaot must not exceed the value of -Xscmx or -Xscmaxaot and should be considerably less than the total cache size, because AOT data can be created only for cached classes. If the value of -Xscminaot equals the value of -Xscmx , no class data or AOT data can be stored. You can also adjust the -Xscminaot value by using: -Xshareclasses:adjustminaot=<size> option MemoryMXBean.setSharedClassCacheMinAotBytes() method in the com.ibm.lang.management API You can also adjust the -Xscmaxaot value by using: -Xshareclasses:adjustmaxaot=<size> option MemoryMXBean.setSharedClassCacheMaxAotBytes() method in the com.ibm.lang.management API.","title":"-Xscminaot"},{"location":"xscminaot/#-xscmaxaot","text":"The value of this option must not be smaller than the value of -Xscminaot and must not be larger than the value of -Xscmx . When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of AOT data that is not stored due to the current setting of the maximum AOT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxAotUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum AOT data space size accordingly if you want to add the unstored AOT data to the shared cache.","title":"-Xscmaxaot"},{"location":"xscminaot/#see-also","text":"-Xshareclasses","title":"See also"},{"location":"xscminjitdata/","text":"-Xscminjitdata / -Xscmaxjitdata When you create a shared classes cache, you can use these options to set a minimum and maximum number of bytes in the class cache that can be used for JIT data. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of JIT data that is not stored due to the current setting of the the maximum JIT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxJitDataUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum JIT data space size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store the JIT data. Subsequent VMs can store JIT data in the shared cache. Syntax Setting Effect Default -Xscminjitdata<size> Set minimum size for JIT data 0 (See Default behavior ) -Xscmaxjitdata<size> Set maximum size for JIT data The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter. Default behavior If -Xscminjitdata is not specified, no space is reserved for JIT data, although JIT data is still written to the cache until the cache is full or the -Xscmaxjitdata limit is reached. Explanation -Xscminjitdata The value of -Xscminjitdata must not exceed the value of -Xscmx or -Xscmaxjitdata . The value of -Xscminjitdata must always be considerably less than the total cache size, because JIT data can be created only for cached classes. If the value of -Xscminjitdata equals the value of -Xscmx , no class data or JIT data can be stored. You can also adjust the -Xscminjitdata value by using: -Xshareclasses:adjustminjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API. -Xscmaxjitdata Setting -Xscmaxjitdata is useful if you want a certain amount of cache space guaranteed for non-JIT data. If this option is not specified, the maximum limit for JIT data is the amount of free space in the cache. The value of this option must not be smaller than the value of -Xscminjitdata , and must not be larger than the value of -Xscmx . You can also adjust the -Xscmaxjitdata value by using: -Xshareclasses:adjustmaxjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API. See also -Xscmx","title":"-Xscminjitdata"},{"location":"xscminjitdata/#-xscminjitdata-xscmaxjitdata","text":"When you create a shared classes cache, you can use these options to set a minimum and maximum number of bytes in the class cache that can be used for JIT data. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the amount of JIT data that is not stored due to the current setting of the the maximum JIT data space. You can also get this information by using the MemoryMXBean.getSharedClassCacheMaxJitDataUnstoredBytes() method in the com.ibm.lang.management API. You can increase the maximum JIT data space size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store the JIT data. Subsequent VMs can store JIT data in the shared cache.","title":"-Xscminjitdata / -Xscmaxjitdata"},{"location":"xscminjitdata/#syntax","text":"Setting Effect Default -Xscminjitdata<size> Set minimum size for JIT data 0 (See Default behavior ) -Xscmaxjitdata<size> Set maximum size for JIT data The amount of free space in the cache See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscminjitdata/#default-behavior","text":"If -Xscminjitdata is not specified, no space is reserved for JIT data, although JIT data is still written to the cache until the cache is full or the -Xscmaxjitdata limit is reached.","title":"Default behavior"},{"location":"xscminjitdata/#explanation","text":"","title":"Explanation"},{"location":"xscminjitdata/#-xscminjitdata","text":"The value of -Xscminjitdata must not exceed the value of -Xscmx or -Xscmaxjitdata . The value of -Xscminjitdata must always be considerably less than the total cache size, because JIT data can be created only for cached classes. If the value of -Xscminjitdata equals the value of -Xscmx , no class data or JIT data can be stored. You can also adjust the -Xscminjitdata value by using: -Xshareclasses:adjustminjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API.","title":"-Xscminjitdata"},{"location":"xscminjitdata/#-xscmaxjitdata","text":"Setting -Xscmaxjitdata is useful if you want a certain amount of cache space guaranteed for non-JIT data. If this option is not specified, the maximum limit for JIT data is the amount of free space in the cache. The value of this option must not be smaller than the value of -Xscminjitdata , and must not be larger than the value of -Xscmx . You can also adjust the -Xscmaxjitdata value by using: -Xshareclasses:adjustmaxjitdata=<size> option MemoryMXBean.setSharedClassCacheMinJitDataBytes() method in the com.ibm.lang.management API.","title":"-Xscmaxjitdata"},{"location":"xscminjitdata/#see-also","text":"-Xscmx","title":"See also"},{"location":"xscmx/","text":"-Xscmx For a new shared classes cache, specifies either: the actual size of the cache, if the -XX:SharedCacheHardLimit option is not present the soft maximum size of the cache, if used with the -XX:SharedCacheHardLimit option (See -XX:SharedCacheHardLimit ) This option applies only if a cache is being created and no cache of the same name exists. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. You can also get this information by using the MemoryMXBean.getSharedClassCacheSoftmxUnstoredBytes() method in the com.ibm.lang.management API. You can increase the soft maximum size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store that data. Therefore, increasing the soft maximum size does not necessarily cause any more data to be stored in the shared cache by the current VM, but subsequent VMs can add data to the shared cache. Syntax -Xscmx<size> See Using -X command-line options for more information about the <size> parameter. Explanation Setting a soft maximum size If you specify the -Xscmx option with the -XX:SharedCacheHardLimit option, the -Xscmx option sets the soft maximum size of a new shared classes cache, and the -XX:SharedCacheHardLimit option sets the actual maximum size. The value of the -Xscmx option must therefore not exceed the value of -XX:SharedCacheHardLimit . When the soft maximum limit is reached, no more data can be added into the shared cache, unless there is reserved AOT or JIT data space. If such reserved space exists, AOT or JIT data can still be added into the reserved space. The reserved AOT and JIT data spaces are counted as used space within the soft maximum size, so the soft maximum size should not be less than the minimum reserved space for AOT and JIT data if you specify the -Xscminaot or -Xscminjitdata options. You can change the soft maximum size by using the -Xshareclasses:adjustsoftmx=<size> option or the MemoryMXBean.setSharedClassCacheSoftmxBytes() method in the com.ibm.lang.management API. By using this API, Java\u2122 applications can dynamically monitor and adjust the cache soft maximum size as required. This function can be useful in virtualized or cloud environments, for example, where the shared cache size might change dynamically to meet business needs. For example, you might create a 64 MB shared cache and set a smaller value, such as 16 MB, for the -Xscmx option, to limit the data stored in the cache: -XX:SharedCacheHardLimit=64m -Xscmx16m You can then use the com.ibm.lang.management API from within a Java application to increase the soft maximum value during run time, as load increases. This change allows the application to use more shared cache space than you specified initially. You can increase the soft maximum size if it is currently less than the actual cache size. If you attempt to reduce the soft maximum size to a value that is less than the number of bytes already used in the cache, the number of used bytes is set as the new soft maximum size. For more information about cache sizes, see Cache size limits . See also -Xscdmx (control the size of the class debug area)","title":"-Xscmx"},{"location":"xscmx/#-xscmx","text":"For a new shared classes cache, specifies either: the actual size of the cache, if the -XX:SharedCacheHardLimit option is not present the soft maximum size of the cache, if used with the -XX:SharedCacheHardLimit option (See -XX:SharedCacheHardLimit ) This option applies only if a cache is being created and no cache of the same name exists. When you run an application with the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. You can also get this information by using the MemoryMXBean.getSharedClassCacheSoftmxUnstoredBytes() method in the com.ibm.lang.management API. You can increase the soft maximum size accordingly if you want to add the unstored data to the shared cache. However, the VM that provided the information no longer has the opportunity to store that data. Therefore, increasing the soft maximum size does not necessarily cause any more data to be stored in the shared cache by the current VM, but subsequent VMs can add data to the shared cache.","title":"-Xscmx"},{"location":"xscmx/#syntax","text":"-Xscmx<size> See Using -X command-line options for more information about the <size> parameter.","title":"Syntax"},{"location":"xscmx/#explanation","text":"","title":"Explanation"},{"location":"xscmx/#setting-a-soft-maximum-size","text":"If you specify the -Xscmx option with the -XX:SharedCacheHardLimit option, the -Xscmx option sets the soft maximum size of a new shared classes cache, and the -XX:SharedCacheHardLimit option sets the actual maximum size. The value of the -Xscmx option must therefore not exceed the value of -XX:SharedCacheHardLimit . When the soft maximum limit is reached, no more data can be added into the shared cache, unless there is reserved AOT or JIT data space. If such reserved space exists, AOT or JIT data can still be added into the reserved space. The reserved AOT and JIT data spaces are counted as used space within the soft maximum size, so the soft maximum size should not be less than the minimum reserved space for AOT and JIT data if you specify the -Xscminaot or -Xscminjitdata options. You can change the soft maximum size by using the -Xshareclasses:adjustsoftmx=<size> option or the MemoryMXBean.setSharedClassCacheSoftmxBytes() method in the com.ibm.lang.management API. By using this API, Java\u2122 applications can dynamically monitor and adjust the cache soft maximum size as required. This function can be useful in virtualized or cloud environments, for example, where the shared cache size might change dynamically to meet business needs. For example, you might create a 64 MB shared cache and set a smaller value, such as 16 MB, for the -Xscmx option, to limit the data stored in the cache: -XX:SharedCacheHardLimit=64m -Xscmx16m You can then use the com.ibm.lang.management API from within a Java application to increase the soft maximum value during run time, as load increases. This change allows the application to use more shared cache space than you specified initially. You can increase the soft maximum size if it is currently less than the actual cache size. If you attempt to reduce the soft maximum size to a value that is less than the number of bytes already used in the cache, the number of used bytes is set as the new soft maximum size. For more information about cache sizes, see Cache size limits .","title":"Setting a soft maximum size"},{"location":"xscmx/#see-also","text":"-Xscdmx (control the size of the class debug area)","title":"See also"},{"location":"xshareclasses/","text":"-Xshareclasses Use the -Xshareclasses option to enable, disable, or modify class sharing behavior. Class data sharing is enabled by default for bootstrap classes only (the equivalent of specifying -Xshareclasses:bootClassesOnly,nonFatal,silent ), unless your application is running in a container. This option can take a number of parameters, some of which are cache utilities. Cache utilities perform the required operation on the specified cache, without starting the VM. You can combine multiple suboptions, which are separated by commas, but the cache utilities are mutually exclusive. When you are running cache utilities, the message Could not create the Java virtual machine is expected. Cache utilities do not create the virtual machine. Some cache utilities can work with caches from previous Java\u2122 versions or caches that are created by virtual machines (VMs) with different bit-widths. These caches are referred to as \"incompatible\" caches. See also the Class data sharing topic, which includes some best practices for using -Xshareclasses . Syntax -Xshareclasses:<parameter> When you specify -Xshareclasses without any parameters and without specifying either the -Xscmx or -XX:SharedCacheHardLimit options, a shared classes cache is created with a default size, as follows: For 64-bit platforms, the default size is 300 MB, with a \"soft\" maximum limit for the initial size of the cache ( -Xscmx ) of 64MB, with the following exceptions: For a persistent cache, if the free disk space is less than 6 GB, the default size is set to 64 MB and an -Xscmx size is not set. For a non-persistent cache on Linux\u00ae or macOS\u00ae systems, the cache size is limited by the maximum amount of memory that can be reserved by a process ( SHMMAX ). If SHMMAX is less than 300MB, the default shared cache size is set to equal SHMMAX . If SHMMAX is greater than 80 MB, -Xscmx is set to 64 MB. If SHMMAX is less than 80MB an -Xscmx size is not set. For other platforms, the default size is 16MB. Parameters adjustmaxaot (Cache utility) -Xshareclasses:adjustmaxaot=<size> Adjusts the maximum shared classes cache space that is allowed for AOT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxaot option. adjustminaot (Cache utility) -Xshareclasses:adjustminaot=<size> Adjusts the minimum shared classes cache space that is reserved for AOT data. Use the -Xscminaot option to set the initial minimum size. adjustmaxjitdata (Cache utility) -Xshareclasses:adjustmaxjitdata=<size> Adjusts the maximum shared classes cache space that is allowed for JIT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxjitdata option. adjustminjitdata (Cache utility) -Xshareclasses:adjustminjitdata=<size> Adjusts the minimum shared classes cache space that is reserved for JIT data. Use the -Xscminjitdata option to set the initial minimum size. adjustsoftmx (Cache utility) -Xshareclasses:adjustsoftmx=<size> Adjusts the soft maximum size of the cache. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. For more information about the soft maximum size, see -Xscmx . allowClasspaths -Xshareclasses:allowClasspaths Allows a VM to store classpaths into an existing shared cache that was created by using the restrictClasspaths option. bootClassesOnly -Xshareclasses:bootClassesOnly Disables caching of classes that are loaded by class loaders other than the bootstrap class loader. If you use this suboption, the nonfatal suboption is also set, so this suboption is the equivalent of specifying -Xshareclasses:bootClassesOnly,nonfatal . cacheDir -Xshareclasses:cacheDir=<directory> Sets the directory in which cache data is read and written. The following defaults apply: On Windows\u2122 systems, <directory> is the user's C:\\Documents and Settings\\<username>\\Local Settings\\Application Data\\javasharedresources directory. On other operating systems, <directory> is the user's home directory, unless the groupAccess parameter is specified, in which case it is /tmp/javasharedresources , because some members of the group might not have access to the user's home directory. You must have sufficient permissions in <directory> . On AIX\u00ae, Linux, macOS, and Windows systems, the VM writes persistent cache files directly into the directory specified. Persistent cache files can be safely moved and deleted from the file system. For persistent caches, the directory must not be on an NFS mount. Nonpersistent caches are stored in shared memory and have control files that describe the location of the memory. Control files are stored in a javasharedresources subdirectory of the cacheDir specified. Do not move or delete control files in this directory. The listAllCaches utility, the destroyAll utility, and the expire suboption work only in the scope of a given cacheDir . On AIX, Linux, and macOS systems, if you specify the cacheDir=<directory> option, persistent caches are created with the following permissions ( -rw-r--r-- ): User: read/write Group: read (read/write if you also specify -Xshareclasses:groupAccess ) Other: read only Otherwise, persistent caches are created with the same permissions as non-persistent caches. The permissions for non-persistent caches are -rw-r----- , or -rw-rw---- if you also specify -Xshareclasses:groupAccess . Note: It is good practice to set an application-specific cache directory to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory, and means that your application is therefore unaffected by a user running java -Xshareclasses:destroyAll . See Class data sharing: Best practices for using -Xshareclasses . cacheDirPerm (Not Windows) -Xshareclasses:cacheDirPerm=<permission> Sets Unix-style permissions when you are creating a cache directory. <permission> must be an octal number in the ranges 0700 - 0777 or 1700 - 1777. If <permission> is not valid, the VM ends with an appropriate error message. The permissions that are specified by this suboption are used only when you are creating a new cache directory. If the cache directory already exists, this suboption is ignored and the cache directory permissions are not changed. If you set this suboption to 0000, the default directory permissions are used. If you set this suboption to 1000, the machine default directory permissions are used, but the sticky bit is enabled. If the cache directory is the platform default directory, /tmp/javasharedresources , this suboption is ignored and the cache directory permissions are set to 0777. If you do not set this suboption, the default permissions are used according to the following conditions: Condition Permissions The cache directory is /tmp/javasharedresources . If this directory already exists with different permissions, the permissions are changed when the cache is opened.\u2020 0777 The cache directory is a new directory and you also specify the groupAcess suboption 0770 The cache directory is a new directory and you do not specify the groupAccess suboption 0700 The cache directory already exists and is not /tmp/javasharedresources Unchanged \u2020On z/OS\u00ae systems, permissions for existing cache directories are unchanged, to avoid generating RACF\u00ae errors, which generate log messages. Note: It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. See Class data sharing: Best practices for using -Xshareclasses . cacheRetransformed -Xshareclasses:cacheRetransformed Enables caching of classes that are transformed by using the JVMTI RetransformClasses function. For more information, see JVMTI redefinition and retransformation of classes . The option enableBCI is enabled by default. However, if you use the cacheRetransformed option, this option forces cache creation into -Xshareclasses:disableBCI mode. checkURLTimestamps -Xshareclasses:checkURLTimestamps Causes timestamps of jar or zip files to be checked every time a class is loaded. If a timestamp has changed, the class is loaded from the jar or zip file and not from the shared cache. This suboption is not enabled by default and reflects the legacy behavior of the shared classes cache. Note: The timestamp of a bootstrap jar or zip file is checked once when it is used for the first time to load a class. createLayer (64-bit only) -Xshareclasses:createLayer Creates layered caches. If there are multiple VMs in a race condition while creating a layered cache, more than one new layered cache can be created. To avoid this situation, use the -Xshareclasses:layer=<number> suboption to create a new layered cache with a specific layer number. See layer for more information about layered caches. destroy (Cache utility) -Xshareclasses:destroy Destroys a cache that is specified by the name , cacheDir , and nonpersistent suboptions. A cache can be destroyed only if all VMs that are using it have ended and the user has sufficient permissions. destroyAll (Cache utility) -Xshareclasses:destroyAll Tries to destroy all the caches that are specified by the cacheDir and nonpersistent suboptions. On Windows and z/OS systems, a cache can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Note: On z/OS, when the destroyAll option is invoked from a 31-bit VM, 64-bit caches are not destroyed. Similarly, when the destroyAll option is invoked from a 64-bit VM, 31-bit caches are not destroyed. The following message is displayed: JVMSHRC735I: Use a nn-bit VM to perform the requested operation on the nn-bit shared cache \"cachename\" as the nn-bit VM cannot verify that the shared memory was created by the VM. On AIX, Linux, and macOS systems: Non-persistent caches can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Persistent caches that are still in use continue to exist even when you use this option, but they are unlinked from the file system so they are not visible to new VM invocations. If you update the VM then restart an application for which a persistent shared cache already exists, the VM unlinks the existing cache and creates a new cache. Because the unlinked caches are not visible to new VMs, you cannot find them by using the -Xshareclasses:listAllCaches option, and you cannot use the -Xshareclasses:printStats option on them. You can therefore have multiple unlinked caches that consume file system space until they are no longer in use. destroyAllLayers (64-bit only) -Xshareclasses:destroyAllLayers Destroys all shared cache layers that are specified by the name suboption. For example, -Xshareclasses:name=Cache1,destroyAllLayers destroys all layers of the cache called Cache1 . If you use the destroy suboption on a layered cache, for example -Xshareclasses:name=Cache1,destroy , only the top layer of the cache is destroyed. For more information about layered caches, see the layer suboption. destroyAllSnapshots (Cache utility) (Not Windows) -Xshareclasses:destroyAllSnapshots Destroys all shared cache snapshots that are available as a result of the specified cacheDir suboption. destroySnapshot (Cache utility) (Not Windows) -Xshareclasses:destroySnapshot Destroys a snapshot that is specified by the name and cacheDir suboptions. disableBCI -Xshareclasses:disableBCI Turns off BCI support. This option can be used to override -XXShareClassesEnableBCI . enableBCI -Xshareclasses:enableBCI This option is enabled by default. Allows a JVMTI ClassFileLoadHook event to be triggered every time, for classes that are loaded from the cache. This mode also prevents caching of classes that are modified by JVMTI agents. For more information about this option, see Using the JVMTI ClassFileLoadHook with cached classes . This option is incompatible with the cacheRetransformed option. Using the two options together causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created without the enableBCI suboption cannot be reused with the enableBCI suboption. Attempting to do so causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created with the enableBCI suboption can be reused without specifying this suboption. In this case, the VM detects that the cache was created with the enableBCI suboption and uses the cache in this mode. expire (Cache utility) -Xshareclasses:expire=<time_in_minutes> Destroys all caches that are unused for the time that is specified before loading shared classes. This option is not a utility option because it does not cause the VM to exit. On Windows systems, which have NTFS file systems, the expire option is accurate to the nearest hour. fatal -Xshareclasses:fatal The VM does not start if class data sharing fails, for example because there was an error when accessing the cache directory. An error message is generated. This suboption is specified by default unless you use the bootClassesOnly suboption, which is equivalent to -Xshareclasses:bootClassesOnly,nonfatal . You can override this behavior by specifying -Xshareclasses:bootClassesOnly,fatal . See also nonfatal . findAotMethods (Cache utility) -Xshareclasses:findAotMethods=<method_specification> -Xshareclasses:findAotMethods=help Print the AOT methods in the shared classes cache that match the method specifications. Methods that are already invalidated are indicated in the output. Use this suboption to check which AOT methods in the shared classes cache would be invalidated by using the same method specifications with the invalidateAotMethods suboption. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax . groupAccess (Not Windows) -Xshareclasses:groupAccess Sets operating system permissions on a new cache to allow group access to the cache. Group access can be set only when permitted by the operating system umask setting. The default is user access only. On AIX, Linux, and macOS systems, if a user creates a cache by specifying the groupAccess suboption, other users in the same group must also specify this suboption to be granted access to the same cache. When groupAccess is specified, the default directory for a cache is /tmp/javasharedresources . Some systems might clear the content of the /tmp directory on a reboot, removing the shared cache. To avoid that problem, you are therefore recommended to use cacheDir to set a different location for the cache. If necessary, use cacheDirPerm to ensure that the cache directory permissions are set appropriately. In certain situations, warning messages might be generated when the groupAccess suboption is used. This message can occur when persistent caches are used: JVMSHRC756W Failed to set group access permission on the shared cache file as requested by the 'groupAccess' sub-option These messages can occur when non-persistent caches are used: JVMSHRC759W Failed to set group access permission as requested by the 'groupAccess' sub-option on the semaphore control file associated with shared classes cache. JVMSHRC760W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared memory control file associated with shared classes cache. This message can occur in combination with the snapshotCache suboption: JVMSHRC761W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared cache snapshot file. All of these warning messages mean that the user's umask setting does not allow either, or both, of the group read and write permission to be set on the file. The typical umask setting restricts only the write permission. To resolve the warning, either change the umask setting or remove the groupAccess suboption. help -Xshareclasses:help Lists all the command-line options. invalidateAotMethods (Cache utility) -Xshareclasses:invalidateAotMethods=<method_specification> -Xshareclasses:invalidateAotMethods=help Modify the existing shared cache to invalidate the AOT methods that match the method specifications. Use this suboption to invalidate AOT methods that cause a failure in the application, without having to destroy the shared cache. Invalidated AOT methods remain in the shared cache, but are then excluded from being loaded. VMs that have not processed the methods, or new VMs that use the cache are not affected by the invalidated methods. The AOT methods are invalidated for the lifetime of the cache, but do not prevent the AOT methods from being compiled again if a new shared cache is created. To prevent AOT method compilation into a new shared cache, use the -Xaot:exclude option. For more information, see -Xaot . To identify AOT problems, see Diagnosing a JIT or AOT problem . To revalidate an AOT method, see the revalidateAotMethods suboption. Use the findAotMethod suboption to determine which AOT methods match the method specifications. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax . layer (64-bit only) -Xshareclasses:layer=<number> Creates layered caches. This suboption has the same effect as the createLayer suboption, but with the added ability to specify the layer number. One scenario where you might want to use a layered cache is if you are building a Docker image. Normally, writing to an existing shared cache in a lower image layer results in Docker duplicating the shared cache to the top layer (following the Docker copy-on-write strategy ). With a layered cache, you can instead write into a new cache in the top layer. The new cache builds on the existing cache, so space is saved in the image. The following example shows a Docker container with four layers: The lowest layer is a Ubuntu Docker image. The next layer is an OpenJ9 Docker image that is built on the Ubuntu image. As part of this image, the -Xshareclasses:name=Cache1 suboption is used to create a cache called Cache1 . The layer number assigned to this cache is 0. The listAllCaches suboption shows the cache and the layer number: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches Cache1 Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 The next Docker layer up is an Open Liberty image that is built on the OpenJ9 image. As part of this image, the -Xshareclasses:name=Cache1,layer=1 suboption is used to create another cache called Cache1. Because the layer=1 suboption is specified, this new cache is a layered cache, which builds on Cache1 in the previous container layer. (Open Liberty starts two VMs, so if you instead use the createLayer suboption here, two layered caches are created, with layer numbers of 1 and 2.) Note that cache layers are different from, and independent of, container layers. In the same way, another Docker layer is added for an Open Liberty Java application, and another layered cache is created to add to Cache1 . The listAllCaches suboption now shows all the caches and their layers: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches Cache1 Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 Cache1 Java8 64-bit persistent cr 1 Mon Sep 23 11:46:25 2019 Cache1 Java8 64-bit persistent cr 2 In use The caches are created in the same directory. When you use the -Xshareclasses:name=Cache1 suboption in future Java commands, all the caches are started. The top-layer cache is started in read/write mode, and lower-layer caches are started in read-only mode. Modifying a lower-layer cache would invalidate all the caches in the layers above. listAllCaches (Cache utility) -Xshareclasses:listAllCaches Lists all the compatible and incompatible caches, and snapshots that exist in the specified cache directory. If you do not specify cacheDir , the default directory is used. Summary information, such as Java version and current usage, is displayed for each cache. mprotect AIX, z/OS 31-bit: -Xshareclasses:mprotect=[default|all|none] Linux, Windows, macOS: -Xshareclasses:mprotect=[default|all|partialpagesonstartup|onfind|nopartialpages|none] where: default : By default, the memory pages that contain the cache are always protected, unless a specific page is being updated. This protection helps prevent accidental or deliberate corruption to the cache. The cache header is not protected by default because this protection has a performance cost. On Linux, macOS, and Windows systems, after the startup phase, the Java virtual machine (VM) protects partially filled pages whenever new data is added to the shared classes cache in the following sequence: The VM changes the memory protection of any partially filled pages to read/write. The VM adds the data to the cache. The VM changes the memory protection of any partially filled pages to read only. all : This value ensures that all the cache pages are protected, including the header. See Note. partialpagesonstartup : This value causes the VM to protect partially filled pages during startup as well as after the startup phase. This value is available only on Linux, macOS, and Windows systems. onfind : When this option is specified, the VM protects partially filled pages when it reads new data in the cache that is added by another VM. This option is available only on Linux, macOS, and Windows systems. nopartialpages : Use this value to turn off the protection of partially filled pages. This value is available only on Linux, macOS, and Windows systems. none : Specifying this value disables the page protection. Note: Specifying all has a negative impact on performance. You should specify all only for problem diagnosis and not for production. Specifying values partialpagesonstartup or onfind can also have a negative impact on performance when the cache is being populated. There is no further impact when the cache is full or no longer being modified. modified -Xshareclasses:modified=<modified_context> Used when a JVMTI agent is installed that might modify bytecode at run time. If you do not specify this suboption and a bytecode modification agent is installed, classes are safely shared with an extra performance cost. The <modified context> is a descriptor that is chosen by the user; for example, myModification1 . This option partitions the cache so that only VMs that are using context myModification1 can share the same classes. So if, for example, you run an application with a modification context and then run it again with a different modification context, all classes are stored twice in the cache. For more information, see Dealing with runtime bytecode modification . If you are migrating from IBM\u00ae SDK, Java Technology Edition, Version 7, or earlier releases, you must set -Xshareclasses:disableBCI when you use this option to retain the same behavior. name -Xshareclasses:name=<name> Connects to a cache of a given name, creating the cache if it does not exist. This option is also used to indicate the cache that is to be modified by cache utilities; for example, destroy . Use the listAllCaches utility to show which named caches are currently available. If you do not specify a name, the default name \"sharedcc_%u\" is used. \"%u\" in the cache name inserts the current user name. On operating systems other than Windows, you can specify \"%g\" in the cache name to insert the current group name. Note: It is good practice to explicitly specify a cache for your application. This avoids the application sharing a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note that you cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. See Class data sharing: Best practices for using -Xshareclasses . noaot -Xshareclasses:noaot Disables caching and loading of AOT code. AOT code already in the shared data cache can be loaded. noBootclasspath -Xshareclasses:noBootclasspath Disables the storage of classes that are loaded by the bootstrap class loader in the shared classes cache. Often used with the SharedClassURLFilter API to control exactly which classes are cached. For more information about shared class filtering, see Using the SharedClassHelper API . noTimestampChecks -Xshareclasses:noTimestampChecks Turns off timestamp checking when finding classes in the shared cache. Use this option only when you know there are no updates to the classes from the class paths or module paths in your application. Otherwise, obsolete classes might be loaded from the shared cache. If this happens, remove the noTimestampChecks option. nocheckURLTimestamps -Xshareclasses:nocheckURLTimestamps Timestamps of jar or zip files are checked only when they are added to a class loader and used for the first time to look up a class. This is the default behavior, which can improve the performance of class loading from the shared classes cache, especially on Windows systems. To revert to the behavior of the shared classes cache in earlier releases, use the CheckURLTimeStamps suboption. Restriction: When the nocheckURLTimestamps suboption is used (default), if jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. If this scenario occurs, use the checkURLTimestamps option. nojitdata -Xshareclasses:nojitdata Disables caching of JIT data. JIT data already in the shared data cache can be loaded. none -Xshareclasses:none Added to the end of a command line, disables class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption disables the shared class utility APIs. To disable class data sharing without disabling the utility APIs, use the utilities suboption. For more information about the shared class utility APIs, see Obtaining information about shared caches . nonfatal -Xshareclasses:nonfatal Allows the VM to start even if class data sharing fails. Normal behavior for the VM is to refuse to start if class data sharing fails. If you select nonfatal and the shared classes cache fails to initialize, the VM attempts to connect to the cache in read-only mode. If this attempt fails, the VM starts without class data sharing. See also fatal . Note: Unless it is important that your application runs with class data sharing, it is good practice to set this parameter. See Class data sharing: Best practices for using -Xshareclasses . nonpersistent -Xshareclasses:nonpersistent Uses a nonpersistent cache. The cache is lost when the operating system shuts down. Nonpersistent and persistent caches can have the same name. On Linux, macOS, and Windows systems, you must always use the nonpersistent suboption when you run utilities such as destroy on a nonpersistent cache. z/OS supports only nonpersistent caches. Note: On macOS systems, you must set kern.sysv.shmmax and kern.sysv.shmall when using a nonpersistent cache. noPersistentDiskSpaceCheck -Xshareclasses:noPersistentDiskSpaceCheck Instructs the VM not to check for available storage on the file system before creating a persistent shared classes cache. This option prevents an error on file systems that do not support the checking of free space, where a value of 0 is returned and a shared cache cannot be created. Regardless of whether you choose to set this option, if there isn't enough disk space available when the VM writes to the shared cache memory, a SIGBUS or SIGSEGV signal occurs and the VM ends. If you are using the readonly suboption, the VM does not check the available disk space, so you do not need to set the noPersistentDiskSpaceCheck suboption. persistent -Xshareclasses:persistent Uses a persistent cache. The cache is created on disk, which persists beyond operating system restarts. Nonpersistent and persistent caches can have the same name. On AIX, you must always use the persistent suboption when you run utilities such as destroy on a persistent cache. Note: Persisent caches are not supported on z/OS systems. z/OS supports only nonpersistent caches. printAllStats (Cache utility) -Xshareclasses:printAllStats Displays detailed information about the contents of the cache that is specified in the name suboption. If the name is not specified, statistics are displayed about the default cache. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats=all ). Every class is listed in chronological order with a reference to the location from which it was loaded. For more information, see Diagnostic cache utilities . printStats (Cache utility) -Xshareclasses:printStats=<data_type>[+<data_type>] Displays summary information for the cache that is specified by the name , cacheDir , and nonpersistent suboptions. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats ). The most useful information that is displayed is how full the cache is and how many classes it contains. Stale classes are classes that are updated on the file system and which the cache has therefore marked as \"stale\". Stale classes are not purged from the cache and can be reused. Use the printStats=stale option to list all the stale entries and stale bytes. Specify one or more data types, which are separated by a plus symbol (+), to see more detailed information about the cache content. Data types include AOT data, class paths, and ROMMethods. For more information and for a full list of data types, see Diagnostic cache utilities . printTopLayerStats (Cache utility) -Xshareclasses:printTopLayerStats=<data_type>[+<data_type>] Equivalent to printStats but for the top layer cache only. readonly -Xshareclasses:readonly Opens an existing cache with read-only permissions. The Java virtual machine does not create a new cache with this suboption. Opening a cache read-only prevents the VM from making any updates to the cache. If you specify this suboption, the VM can connect to caches that were created by other users or groups without requiring write access. On AIX, Linux, and macOS systems, this access is permitted only if the cache was created by using the -Xshareclasses:cacheDir option to specify a directory with appropriate permissions. If you do not use the -Xshareclasses:cacheDir option, the cache is created with default permissions, which do not permit access by other users or groups. By default, this suboption is not specified. reset -Xshareclasses:reset Causes a cache to be destroyed and then re-created when the VM starts up. This option can be added to the end of a command line as -Xshareclasses:reset . restoreFromSnapshot (Cache utility) (Not Windows) -Xshareclasses:restoreFromSnapshot Restores a new non-persistent shared cache from a snapshot file. The snapshot and shared cache have the same name and location, as specified by the name and cacheDir suboptions. The non-persistent cache cannot already exist when the snapshot is restored. Restoring a snapshot does not remove the snapshot file; it can be restored multiple times. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to restore a snapshot. restrictClasspaths -Xshareclasses:restrictClasspaths Allows only the first VM that is initializing a shared cache to store classpaths in the cache. Subsequent VMs are not allowed to store classpaths in the cache unless the allowClasspaths option is specified. Use the restrictClasspaths option only if the application is designed to create class loaders of type java.net.URLClassloader or its subclass, such that their classpaths are unique to the instance of the application, but the classes that are loaded from these classpaths are the same. In such cases application classpaths that are stored by one VM cannot be used by another VM. For example, consider two VMs, VM1 and VM2, that are using class paths CP1 and CP2 respectively, where: CP1: url1;url2;url3;tempurl1;url4;url5 CP2: url1;url2;url3;tempurl2;url4;url5 These class paths differ only by one entry, which is the tempurl . The url1 , url2 , url3 , url4 , and url5 entries never change from run to run, whereas the tempurl entry is always different. This difference means that a class that is loaded from url4 or url5 , and stored into the shared cache by VM1, cannot be located by VM2. Therefore, an attempt by VM2 to load a class from url4 or url5 would cause it to store its own classpath CP2 into the shared cache, and also add new metadata for classes that are loaded from url4 or url5 . Addition of such unique class paths into the shared cache is not useful. Moreover, the additional metadata might adversely affect the performance of other VMs that connect to the shared cache. Because classes loaded from url4 or url5 are not loaded from the shared cache when the tempurl differs from the original, it is good practice to put the tempurl as the last entry in the class path. In situations such as that described in the example, the restrictClasspaths option can be used to restrict the addition of classpaths by ensuring that the first VM initializes the shared cache, and then prevents the addition of unique classpaths by subsequent VMs that attach to the shared cache. Note that use of the restrictClasspaths option in any other scenario is likely to negatively impact a VM's performance when it is using an existing cache. revalidateAotMethods (Cache utility) -Xshareclasses:revalidateAotMethods=<method_specification> -Xshareclasses:revalidateAotMethods=help Modify the shared cache to revalidate the AOT methods that match the method specifications. Use this suboption to revalidate AOT methods that were invalidated by using the invalidateAotMethods suboption. Revalidated AOT methods are then eligible for loading into a VM, but do not affect VMs where the methods have already been processed. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax . silent -Xshareclasses:silent Disables all shared class messages, including error messages. Unrecoverable error messages, which prevent the VM from initializing, are displayed. snapshotCache (Cache utility) (Not Windows) -Xshareclasses:snapshotCache Creates a snapshot file of an existing non-persistent shared cache. The snapshot has the same name and location as the shared cache, as specified by the name and cacheDir suboptions. The shared cache can be in use when the snapshot is taken, but VMs are blocked when they try to write to the shared cache, while the cache data is copied to the file. Typically, after a system is reinitialized, the snapshot file is used to restore the copy of the non-persistent cache into shared memory, via the restoreFromSnapshot suboption. Since this process removes all non-persistent caches from shared memory, restoring the cache from the snapshot file can result in better VM startup performance, because the contents of the shared cache, including classes and AOT code, do not have to be re-created. A snapshot can be created only if the user has sufficient permissions to create the destination snapshot file. If a snapshot of the same name exists already, it is overwritten. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to create a snapshot. For information about removing snapshot files, see the destroySnapshot and destroyAllSnapshots suboptions. utilities -Xshareclasses:utilities Can be added to the end of a command line to disable class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption is like none , but does not disable the shared class utility APIs. For more information about the shared class utility APIs, see Obtaining information about shared caches . verbose -Xshareclasses:verbose Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders ask their parents for a class if they can't find it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy. The standard option -verbose:class also enables class sharing verbose output if class sharing is enabled. verboseAOT -Xshareclasses:verboseAOT Enables verbose output when compiled AOT code is being found or stored in the cache. AOT code is generated heuristically. You might not see any AOT code that is generated at all for a small application. You can disable AOT caching by using the noaot suboption. See the VM Messages Guide for a list of the messages produced. verboseHelper -Xshareclasses:verboseHelper Enables verbose output for the Java Helper API. This output shows you how the Helper API is used by your class loader. verboseIO -Xshareclasses:verboseIO Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders must ask their parents for a class before they can load it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy. Method specification syntax The following examples show how to specify more than one method specification when you are using the findAotMethods , invalidateAotMethods , or revalidateAotMethods suboptions. Each method specification is defined as follows: <packagename>/<classname>[.<methodname>[(<parameters>)]] If you want to include more than one method specification in a single option, separate the specifications with a comma and enclose all the specifications in {braces}. For example: {<packagename/classname>}[.{<methodname>}[({<parameters>})]] You can use an asterisk (*) in most places as a wildcard. You can use an exclamation point (!) before the specification to mean \"everything except this\". Parameters are optional, but if specified, should be enclosed in parentheses and the following native signature formats must be used: B for byte C for char D for double F for float I for int J for long S for short Z for Boolean L<classname>; for objects [ before the signature means array If you want to specify parameters to distinguish between methods, you can use -Xshareclasses:findAotMethods=* (with a wildcard) to list all the parameter variations. Copy the signature for the method that you want from the output. For example, the signature for the parameters (byte[] bytes, int offset, int length, Charset charset) is ([BIILjava/nio/charset/Charset;) Here are some examples: Method signature Matches... * All AOT methods. java/lang/Object All AOT methods in the java.lang.Object class java/util/* All AOT classes and methods in the java.util package java/util/HashMap.putVal All putVal methods in the java.util.HashMap class java/util/HashMap.hash(Ljava/lang/Object;) The private java.util.HashMap.hash(java.lang.Object) method *.equals All equals methods in all classes {java/lang/Object,!java/lang/Object.clone} All methods in java.lang.Object except clone {java/util/*.*(),java/lang/Object.*(*)} All classes or methods with no input parameter in the java.util package, and all methods in java.lang.Object {java/util/*.*(),!java/util/*.*()} Nothing. See also -Xscmx -XX:SharedCacheHardLimit Class data sharing","title":"-Xshareclasses"},{"location":"xshareclasses/#-xshareclasses","text":"Use the -Xshareclasses option to enable, disable, or modify class sharing behavior. Class data sharing is enabled by default for bootstrap classes only (the equivalent of specifying -Xshareclasses:bootClassesOnly,nonFatal,silent ), unless your application is running in a container. This option can take a number of parameters, some of which are cache utilities. Cache utilities perform the required operation on the specified cache, without starting the VM. You can combine multiple suboptions, which are separated by commas, but the cache utilities are mutually exclusive. When you are running cache utilities, the message Could not create the Java virtual machine is expected. Cache utilities do not create the virtual machine. Some cache utilities can work with caches from previous Java\u2122 versions or caches that are created by virtual machines (VMs) with different bit-widths. These caches are referred to as \"incompatible\" caches. See also the Class data sharing topic, which includes some best practices for using -Xshareclasses .","title":"-Xshareclasses"},{"location":"xshareclasses/#syntax","text":"-Xshareclasses:<parameter> When you specify -Xshareclasses without any parameters and without specifying either the -Xscmx or -XX:SharedCacheHardLimit options, a shared classes cache is created with a default size, as follows: For 64-bit platforms, the default size is 300 MB, with a \"soft\" maximum limit for the initial size of the cache ( -Xscmx ) of 64MB, with the following exceptions: For a persistent cache, if the free disk space is less than 6 GB, the default size is set to 64 MB and an -Xscmx size is not set. For a non-persistent cache on Linux\u00ae or macOS\u00ae systems, the cache size is limited by the maximum amount of memory that can be reserved by a process ( SHMMAX ). If SHMMAX is less than 300MB, the default shared cache size is set to equal SHMMAX . If SHMMAX is greater than 80 MB, -Xscmx is set to 64 MB. If SHMMAX is less than 80MB an -Xscmx size is not set. For other platforms, the default size is 16MB.","title":"Syntax"},{"location":"xshareclasses/#parameters","text":"","title":"Parameters"},{"location":"xshareclasses/#adjustmaxaot-cache-utility","text":"-Xshareclasses:adjustmaxaot=<size> Adjusts the maximum shared classes cache space that is allowed for AOT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxaot option.","title":"adjustmaxaot (Cache utility)"},{"location":"xshareclasses/#adjustminaot-cache-utility","text":"-Xshareclasses:adjustminaot=<size> Adjusts the minimum shared classes cache space that is reserved for AOT data. Use the -Xscminaot option to set the initial minimum size.","title":"adjustminaot (Cache utility)"},{"location":"xshareclasses/#adjustmaxjitdata-cache-utility","text":"-Xshareclasses:adjustmaxjitdata=<size> Adjusts the maximum shared classes cache space that is allowed for JIT data. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the -Xscmaxjitdata option.","title":"adjustmaxjitdata (Cache utility)"},{"location":"xshareclasses/#adjustminjitdata-cache-utility","text":"-Xshareclasses:adjustminjitdata=<size> Adjusts the minimum shared classes cache space that is reserved for JIT data. Use the -Xscminjitdata option to set the initial minimum size.","title":"adjustminjitdata (Cache utility)"},{"location":"xshareclasses/#adjustsoftmx-cache-utility","text":"-Xshareclasses:adjustsoftmx=<size> Adjusts the soft maximum size of the cache. When you use the -Xshareclasses:verbose option, the VM writes to the console the number of bytes that are not stored due to the current setting of the soft maximum size. For more information about the soft maximum size, see -Xscmx .","title":"adjustsoftmx (Cache utility)"},{"location":"xshareclasses/#allowclasspaths","text":"-Xshareclasses:allowClasspaths Allows a VM to store classpaths into an existing shared cache that was created by using the restrictClasspaths option.","title":"allowClasspaths"},{"location":"xshareclasses/#bootclassesonly","text":"-Xshareclasses:bootClassesOnly Disables caching of classes that are loaded by class loaders other than the bootstrap class loader. If you use this suboption, the nonfatal suboption is also set, so this suboption is the equivalent of specifying -Xshareclasses:bootClassesOnly,nonfatal .","title":"bootClassesOnly"},{"location":"xshareclasses/#cachedir","text":"-Xshareclasses:cacheDir=<directory> Sets the directory in which cache data is read and written. The following defaults apply: On Windows\u2122 systems, <directory> is the user's C:\\Documents and Settings\\<username>\\Local Settings\\Application Data\\javasharedresources directory. On other operating systems, <directory> is the user's home directory, unless the groupAccess parameter is specified, in which case it is /tmp/javasharedresources , because some members of the group might not have access to the user's home directory. You must have sufficient permissions in <directory> . On AIX\u00ae, Linux, macOS, and Windows systems, the VM writes persistent cache files directly into the directory specified. Persistent cache files can be safely moved and deleted from the file system. For persistent caches, the directory must not be on an NFS mount. Nonpersistent caches are stored in shared memory and have control files that describe the location of the memory. Control files are stored in a javasharedresources subdirectory of the cacheDir specified. Do not move or delete control files in this directory. The listAllCaches utility, the destroyAll utility, and the expire suboption work only in the scope of a given cacheDir . On AIX, Linux, and macOS systems, if you specify the cacheDir=<directory> option, persistent caches are created with the following permissions ( -rw-r--r-- ): User: read/write Group: read (read/write if you also specify -Xshareclasses:groupAccess ) Other: read only Otherwise, persistent caches are created with the same permissions as non-persistent caches. The permissions for non-persistent caches are -rw-r----- , or -rw-rw---- if you also specify -Xshareclasses:groupAccess . Note: It is good practice to set an application-specific cache directory to avoid sharing the default cache directory with the default cache, or other application caches that don't set a cache directory, and means that your application is therefore unaffected by a user running java -Xshareclasses:destroyAll . See Class data sharing: Best practices for using -Xshareclasses .","title":"cacheDir"},{"location":"xshareclasses/#cachedirperm","text":"(Not Windows) -Xshareclasses:cacheDirPerm=<permission> Sets Unix-style permissions when you are creating a cache directory. <permission> must be an octal number in the ranges 0700 - 0777 or 1700 - 1777. If <permission> is not valid, the VM ends with an appropriate error message. The permissions that are specified by this suboption are used only when you are creating a new cache directory. If the cache directory already exists, this suboption is ignored and the cache directory permissions are not changed. If you set this suboption to 0000, the default directory permissions are used. If you set this suboption to 1000, the machine default directory permissions are used, but the sticky bit is enabled. If the cache directory is the platform default directory, /tmp/javasharedresources , this suboption is ignored and the cache directory permissions are set to 0777. If you do not set this suboption, the default permissions are used according to the following conditions: Condition Permissions The cache directory is /tmp/javasharedresources . If this directory already exists with different permissions, the permissions are changed when the cache is opened.\u2020 0777 The cache directory is a new directory and you also specify the groupAcess suboption 0770 The cache directory is a new directory and you do not specify the groupAccess suboption 0700 The cache directory already exists and is not /tmp/javasharedresources Unchanged \u2020On z/OS\u00ae systems, permissions for existing cache directories are unchanged, to avoid generating RACF\u00ae errors, which generate log messages. Note: It is good practice to explicitly set permissions for the cache directory when the defaults are not appropriate. See Class data sharing: Best practices for using -Xshareclasses .","title":"cacheDirPerm"},{"location":"xshareclasses/#cacheretransformed","text":"-Xshareclasses:cacheRetransformed Enables caching of classes that are transformed by using the JVMTI RetransformClasses function. For more information, see JVMTI redefinition and retransformation of classes . The option enableBCI is enabled by default. However, if you use the cacheRetransformed option, this option forces cache creation into -Xshareclasses:disableBCI mode.","title":"cacheRetransformed"},{"location":"xshareclasses/#checkurltimestamps","text":"-Xshareclasses:checkURLTimestamps Causes timestamps of jar or zip files to be checked every time a class is loaded. If a timestamp has changed, the class is loaded from the jar or zip file and not from the shared cache. This suboption is not enabled by default and reflects the legacy behavior of the shared classes cache. Note: The timestamp of a bootstrap jar or zip file is checked once when it is used for the first time to load a class.","title":"checkURLTimestamps"},{"location":"xshareclasses/#createlayer","text":"(64-bit only) -Xshareclasses:createLayer Creates layered caches. If there are multiple VMs in a race condition while creating a layered cache, more than one new layered cache can be created. To avoid this situation, use the -Xshareclasses:layer=<number> suboption to create a new layered cache with a specific layer number. See layer for more information about layered caches.","title":"createLayer"},{"location":"xshareclasses/#destroy-cache-utility","text":"-Xshareclasses:destroy Destroys a cache that is specified by the name , cacheDir , and nonpersistent suboptions. A cache can be destroyed only if all VMs that are using it have ended and the user has sufficient permissions.","title":"destroy (Cache utility)"},{"location":"xshareclasses/#destroyall-cache-utility","text":"-Xshareclasses:destroyAll Tries to destroy all the caches that are specified by the cacheDir and nonpersistent suboptions. On Windows and z/OS systems, a cache can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Note: On z/OS, when the destroyAll option is invoked from a 31-bit VM, 64-bit caches are not destroyed. Similarly, when the destroyAll option is invoked from a 64-bit VM, 31-bit caches are not destroyed. The following message is displayed: JVMSHRC735I: Use a nn-bit VM to perform the requested operation on the nn-bit shared cache \"cachename\" as the nn-bit VM cannot verify that the shared memory was created by the VM. On AIX, Linux, and macOS systems: Non-persistent caches can be destroyed only if all VMs that are using it have shut down and the user has sufficient permissions. Persistent caches that are still in use continue to exist even when you use this option, but they are unlinked from the file system so they are not visible to new VM invocations. If you update the VM then restart an application for which a persistent shared cache already exists, the VM unlinks the existing cache and creates a new cache. Because the unlinked caches are not visible to new VMs, you cannot find them by using the -Xshareclasses:listAllCaches option, and you cannot use the -Xshareclasses:printStats option on them. You can therefore have multiple unlinked caches that consume file system space until they are no longer in use.","title":"destroyAll (Cache utility)"},{"location":"xshareclasses/#destroyalllayers","text":"(64-bit only) -Xshareclasses:destroyAllLayers Destroys all shared cache layers that are specified by the name suboption. For example, -Xshareclasses:name=Cache1,destroyAllLayers destroys all layers of the cache called Cache1 . If you use the destroy suboption on a layered cache, for example -Xshareclasses:name=Cache1,destroy , only the top layer of the cache is destroyed. For more information about layered caches, see the layer suboption.","title":"destroyAllLayers"},{"location":"xshareclasses/#destroyallsnapshots-cache-utility","text":"(Not Windows) -Xshareclasses:destroyAllSnapshots Destroys all shared cache snapshots that are available as a result of the specified cacheDir suboption.","title":"destroyAllSnapshots (Cache utility)"},{"location":"xshareclasses/#destroysnapshot-cache-utility","text":"(Not Windows) -Xshareclasses:destroySnapshot Destroys a snapshot that is specified by the name and cacheDir suboptions.","title":"destroySnapshot (Cache utility)"},{"location":"xshareclasses/#disablebci","text":"-Xshareclasses:disableBCI Turns off BCI support. This option can be used to override -XXShareClassesEnableBCI .","title":"disableBCI"},{"location":"xshareclasses/#enablebci","text":"-Xshareclasses:enableBCI This option is enabled by default. Allows a JVMTI ClassFileLoadHook event to be triggered every time, for classes that are loaded from the cache. This mode also prevents caching of classes that are modified by JVMTI agents. For more information about this option, see Using the JVMTI ClassFileLoadHook with cached classes . This option is incompatible with the cacheRetransformed option. Using the two options together causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created without the enableBCI suboption cannot be reused with the enableBCI suboption. Attempting to do so causes the VM to end with an error message, unless -Xshareclasses:nonfatal is specified. In this case, the VM continues without using shared classes. A cache that is created with the enableBCI suboption can be reused without specifying this suboption. In this case, the VM detects that the cache was created with the enableBCI suboption and uses the cache in this mode.","title":"enableBCI"},{"location":"xshareclasses/#expire-cache-utility","text":"-Xshareclasses:expire=<time_in_minutes> Destroys all caches that are unused for the time that is specified before loading shared classes. This option is not a utility option because it does not cause the VM to exit. On Windows systems, which have NTFS file systems, the expire option is accurate to the nearest hour.","title":"expire (Cache utility)"},{"location":"xshareclasses/#fatal","text":"-Xshareclasses:fatal The VM does not start if class data sharing fails, for example because there was an error when accessing the cache directory. An error message is generated. This suboption is specified by default unless you use the bootClassesOnly suboption, which is equivalent to -Xshareclasses:bootClassesOnly,nonfatal . You can override this behavior by specifying -Xshareclasses:bootClassesOnly,fatal . See also nonfatal .","title":"fatal"},{"location":"xshareclasses/#findaotmethods-cache-utility","text":"-Xshareclasses:findAotMethods=<method_specification> -Xshareclasses:findAotMethods=help Print the AOT methods in the shared classes cache that match the method specifications. Methods that are already invalidated are indicated in the output. Use this suboption to check which AOT methods in the shared classes cache would be invalidated by using the same method specifications with the invalidateAotMethods suboption. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax .","title":"findAotMethods (Cache utility)"},{"location":"xshareclasses/#groupaccess","text":"(Not Windows) -Xshareclasses:groupAccess Sets operating system permissions on a new cache to allow group access to the cache. Group access can be set only when permitted by the operating system umask setting. The default is user access only. On AIX, Linux, and macOS systems, if a user creates a cache by specifying the groupAccess suboption, other users in the same group must also specify this suboption to be granted access to the same cache. When groupAccess is specified, the default directory for a cache is /tmp/javasharedresources . Some systems might clear the content of the /tmp directory on a reboot, removing the shared cache. To avoid that problem, you are therefore recommended to use cacheDir to set a different location for the cache. If necessary, use cacheDirPerm to ensure that the cache directory permissions are set appropriately. In certain situations, warning messages might be generated when the groupAccess suboption is used. This message can occur when persistent caches are used: JVMSHRC756W Failed to set group access permission on the shared cache file as requested by the 'groupAccess' sub-option These messages can occur when non-persistent caches are used: JVMSHRC759W Failed to set group access permission as requested by the 'groupAccess' sub-option on the semaphore control file associated with shared classes cache. JVMSHRC760W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared memory control file associated with shared classes cache. This message can occur in combination with the snapshotCache suboption: JVMSHRC761W Failed to set group access permission as requested by the 'groupAccess' sub-option on the shared cache snapshot file. All of these warning messages mean that the user's umask setting does not allow either, or both, of the group read and write permission to be set on the file. The typical umask setting restricts only the write permission. To resolve the warning, either change the umask setting or remove the groupAccess suboption.","title":"groupAccess"},{"location":"xshareclasses/#help","text":"-Xshareclasses:help Lists all the command-line options.","title":"help"},{"location":"xshareclasses/#invalidateaotmethods-cache-utility","text":"-Xshareclasses:invalidateAotMethods=<method_specification> -Xshareclasses:invalidateAotMethods=help Modify the existing shared cache to invalidate the AOT methods that match the method specifications. Use this suboption to invalidate AOT methods that cause a failure in the application, without having to destroy the shared cache. Invalidated AOT methods remain in the shared cache, but are then excluded from being loaded. VMs that have not processed the methods, or new VMs that use the cache are not affected by the invalidated methods. The AOT methods are invalidated for the lifetime of the cache, but do not prevent the AOT methods from being compiled again if a new shared cache is created. To prevent AOT method compilation into a new shared cache, use the -Xaot:exclude option. For more information, see -Xaot . To identify AOT problems, see Diagnosing a JIT or AOT problem . To revalidate an AOT method, see the revalidateAotMethods suboption. Use the findAotMethod suboption to determine which AOT methods match the method specifications. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax .","title":"invalidateAotMethods (Cache utility)"},{"location":"xshareclasses/#layer","text":"(64-bit only) -Xshareclasses:layer=<number> Creates layered caches. This suboption has the same effect as the createLayer suboption, but with the added ability to specify the layer number. One scenario where you might want to use a layered cache is if you are building a Docker image. Normally, writing to an existing shared cache in a lower image layer results in Docker duplicating the shared cache to the top layer (following the Docker copy-on-write strategy ). With a layered cache, you can instead write into a new cache in the top layer. The new cache builds on the existing cache, so space is saved in the image. The following example shows a Docker container with four layers: The lowest layer is a Ubuntu Docker image. The next layer is an OpenJ9 Docker image that is built on the Ubuntu image. As part of this image, the -Xshareclasses:name=Cache1 suboption is used to create a cache called Cache1 . The layer number assigned to this cache is 0. The listAllCaches suboption shows the cache and the layer number: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches Cache1 Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 The next Docker layer up is an Open Liberty image that is built on the OpenJ9 image. As part of this image, the -Xshareclasses:name=Cache1,layer=1 suboption is used to create another cache called Cache1. Because the layer=1 suboption is specified, this new cache is a layered cache, which builds on Cache1 in the previous container layer. (Open Liberty starts two VMs, so if you instead use the createLayer suboption here, two layered caches are created, with layer numbers of 1 and 2.) Note that cache layers are different from, and independent of, container layers. In the same way, another Docker layer is added for an Open Liberty Java application, and another layered cache is created to add to Cache1 . The listAllCaches suboption now shows all the caches and their layers: java -Xshareclasses:listAllCaches ... Cache name level cache-type feature layer OS shmid OS semid last detach time Compatible shared caches Cache1 Java8 64-bit persistent cr 0 Mon Sep 23 11:41:04 2019 Cache1 Java8 64-bit persistent cr 1 Mon Sep 23 11:46:25 2019 Cache1 Java8 64-bit persistent cr 2 In use The caches are created in the same directory. When you use the -Xshareclasses:name=Cache1 suboption in future Java commands, all the caches are started. The top-layer cache is started in read/write mode, and lower-layer caches are started in read-only mode. Modifying a lower-layer cache would invalidate all the caches in the layers above.","title":"layer"},{"location":"xshareclasses/#listallcaches-cache-utility","text":"-Xshareclasses:listAllCaches Lists all the compatible and incompatible caches, and snapshots that exist in the specified cache directory. If you do not specify cacheDir , the default directory is used. Summary information, such as Java version and current usage, is displayed for each cache.","title":"listAllCaches (Cache utility)"},{"location":"xshareclasses/#mprotect","text":"AIX, z/OS 31-bit: -Xshareclasses:mprotect=[default|all|none] Linux, Windows, macOS: -Xshareclasses:mprotect=[default|all|partialpagesonstartup|onfind|nopartialpages|none] where: default : By default, the memory pages that contain the cache are always protected, unless a specific page is being updated. This protection helps prevent accidental or deliberate corruption to the cache. The cache header is not protected by default because this protection has a performance cost. On Linux, macOS, and Windows systems, after the startup phase, the Java virtual machine (VM) protects partially filled pages whenever new data is added to the shared classes cache in the following sequence: The VM changes the memory protection of any partially filled pages to read/write. The VM adds the data to the cache. The VM changes the memory protection of any partially filled pages to read only. all : This value ensures that all the cache pages are protected, including the header. See Note. partialpagesonstartup : This value causes the VM to protect partially filled pages during startup as well as after the startup phase. This value is available only on Linux, macOS, and Windows systems. onfind : When this option is specified, the VM protects partially filled pages when it reads new data in the cache that is added by another VM. This option is available only on Linux, macOS, and Windows systems. nopartialpages : Use this value to turn off the protection of partially filled pages. This value is available only on Linux, macOS, and Windows systems. none : Specifying this value disables the page protection. Note: Specifying all has a negative impact on performance. You should specify all only for problem diagnosis and not for production. Specifying values partialpagesonstartup or onfind can also have a negative impact on performance when the cache is being populated. There is no further impact when the cache is full or no longer being modified.","title":"mprotect"},{"location":"xshareclasses/#modified","text":"-Xshareclasses:modified=<modified_context> Used when a JVMTI agent is installed that might modify bytecode at run time. If you do not specify this suboption and a bytecode modification agent is installed, classes are safely shared with an extra performance cost. The <modified context> is a descriptor that is chosen by the user; for example, myModification1 . This option partitions the cache so that only VMs that are using context myModification1 can share the same classes. So if, for example, you run an application with a modification context and then run it again with a different modification context, all classes are stored twice in the cache. For more information, see Dealing with runtime bytecode modification . If you are migrating from IBM\u00ae SDK, Java Technology Edition, Version 7, or earlier releases, you must set -Xshareclasses:disableBCI when you use this option to retain the same behavior.","title":"modified"},{"location":"xshareclasses/#name","text":"-Xshareclasses:name=<name> Connects to a cache of a given name, creating the cache if it does not exist. This option is also used to indicate the cache that is to be modified by cache utilities; for example, destroy . Use the listAllCaches utility to show which named caches are currently available. If you do not specify a name, the default name \"sharedcc_%u\" is used. \"%u\" in the cache name inserts the current user name. On operating systems other than Windows, you can specify \"%g\" in the cache name to insert the current group name. Note: It is good practice to explicitly specify a cache for your application. This avoids the application sharing a cache that is enabled by default or with another application that doesn't set a name, and ensures that the size of your application cache can be set appropriately and that cache space is used exclusively for your application. Note that you cannot change the size of a default cache that already exists by using the -Xscmx option, as that option has no effect on a pre-existing cache. See Class data sharing: Best practices for using -Xshareclasses .","title":"name"},{"location":"xshareclasses/#noaot","text":"-Xshareclasses:noaot Disables caching and loading of AOT code. AOT code already in the shared data cache can be loaded.","title":"noaot"},{"location":"xshareclasses/#nobootclasspath","text":"-Xshareclasses:noBootclasspath Disables the storage of classes that are loaded by the bootstrap class loader in the shared classes cache. Often used with the SharedClassURLFilter API to control exactly which classes are cached. For more information about shared class filtering, see Using the SharedClassHelper API .","title":"noBootclasspath"},{"location":"xshareclasses/#notimestampchecks","text":"-Xshareclasses:noTimestampChecks Turns off timestamp checking when finding classes in the shared cache. Use this option only when you know there are no updates to the classes from the class paths or module paths in your application. Otherwise, obsolete classes might be loaded from the shared cache. If this happens, remove the noTimestampChecks option.","title":"noTimestampChecks"},{"location":"xshareclasses/#nocheckurltimestamps","text":"-Xshareclasses:nocheckURLTimestamps Timestamps of jar or zip files are checked only when they are added to a class loader and used for the first time to look up a class. This is the default behavior, which can improve the performance of class loading from the shared classes cache, especially on Windows systems. To revert to the behavior of the shared classes cache in earlier releases, use the CheckURLTimeStamps suboption. Restriction: When the nocheckURLTimestamps suboption is used (default), if jar or zip files are updated after a class loader starts loading classes from them, an older version of the class might be loaded from the shared classes cache. If this scenario occurs, use the checkURLTimestamps option.","title":"nocheckURLTimestamps"},{"location":"xshareclasses/#nojitdata","text":"-Xshareclasses:nojitdata Disables caching of JIT data. JIT data already in the shared data cache can be loaded.","title":"nojitdata"},{"location":"xshareclasses/#none","text":"-Xshareclasses:none Added to the end of a command line, disables class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption disables the shared class utility APIs. To disable class data sharing without disabling the utility APIs, use the utilities suboption. For more information about the shared class utility APIs, see Obtaining information about shared caches .","title":"none"},{"location":"xshareclasses/#nonfatal","text":"-Xshareclasses:nonfatal Allows the VM to start even if class data sharing fails. Normal behavior for the VM is to refuse to start if class data sharing fails. If you select nonfatal and the shared classes cache fails to initialize, the VM attempts to connect to the cache in read-only mode. If this attempt fails, the VM starts without class data sharing. See also fatal . Note: Unless it is important that your application runs with class data sharing, it is good practice to set this parameter. See Class data sharing: Best practices for using -Xshareclasses .","title":"nonfatal"},{"location":"xshareclasses/#nonpersistent","text":"-Xshareclasses:nonpersistent Uses a nonpersistent cache. The cache is lost when the operating system shuts down. Nonpersistent and persistent caches can have the same name. On Linux, macOS, and Windows systems, you must always use the nonpersistent suboption when you run utilities such as destroy on a nonpersistent cache. z/OS supports only nonpersistent caches. Note: On macOS systems, you must set kern.sysv.shmmax and kern.sysv.shmall when using a nonpersistent cache.","title":"nonpersistent"},{"location":"xshareclasses/#nopersistentdiskspacecheck","text":"-Xshareclasses:noPersistentDiskSpaceCheck Instructs the VM not to check for available storage on the file system before creating a persistent shared classes cache. This option prevents an error on file systems that do not support the checking of free space, where a value of 0 is returned and a shared cache cannot be created. Regardless of whether you choose to set this option, if there isn't enough disk space available when the VM writes to the shared cache memory, a SIGBUS or SIGSEGV signal occurs and the VM ends. If you are using the readonly suboption, the VM does not check the available disk space, so you do not need to set the noPersistentDiskSpaceCheck suboption.","title":"noPersistentDiskSpaceCheck"},{"location":"xshareclasses/#persistent","text":"-Xshareclasses:persistent Uses a persistent cache. The cache is created on disk, which persists beyond operating system restarts. Nonpersistent and persistent caches can have the same name. On AIX, you must always use the persistent suboption when you run utilities such as destroy on a persistent cache. Note: Persisent caches are not supported on z/OS systems. z/OS supports only nonpersistent caches.","title":"persistent"},{"location":"xshareclasses/#printallstats-cache-utility","text":"-Xshareclasses:printAllStats Displays detailed information about the contents of the cache that is specified in the name suboption. If the name is not specified, statistics are displayed about the default cache. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats=all ). Every class is listed in chronological order with a reference to the location from which it was loaded. For more information, see Diagnostic cache utilities .","title":"printAllStats (Cache utility)"},{"location":"xshareclasses/#printstats-cache-utility","text":"-Xshareclasses:printStats=<data_type>[+<data_type>] Displays summary information for the cache that is specified by the name , cacheDir , and nonpersistent suboptions. For layered caches, information is shown for all layers (to see information for the top layer cache only, use printTopLayerStats ). The most useful information that is displayed is how full the cache is and how many classes it contains. Stale classes are classes that are updated on the file system and which the cache has therefore marked as \"stale\". Stale classes are not purged from the cache and can be reused. Use the printStats=stale option to list all the stale entries and stale bytes. Specify one or more data types, which are separated by a plus symbol (+), to see more detailed information about the cache content. Data types include AOT data, class paths, and ROMMethods. For more information and for a full list of data types, see Diagnostic cache utilities .","title":"printStats (Cache utility)"},{"location":"xshareclasses/#printtoplayerstats-cache-utility","text":"-Xshareclasses:printTopLayerStats=<data_type>[+<data_type>] Equivalent to printStats but for the top layer cache only.","title":"printTopLayerStats (Cache utility)"},{"location":"xshareclasses/#readonly","text":"-Xshareclasses:readonly Opens an existing cache with read-only permissions. The Java virtual machine does not create a new cache with this suboption. Opening a cache read-only prevents the VM from making any updates to the cache. If you specify this suboption, the VM can connect to caches that were created by other users or groups without requiring write access. On AIX, Linux, and macOS systems, this access is permitted only if the cache was created by using the -Xshareclasses:cacheDir option to specify a directory with appropriate permissions. If you do not use the -Xshareclasses:cacheDir option, the cache is created with default permissions, which do not permit access by other users or groups. By default, this suboption is not specified.","title":"readonly"},{"location":"xshareclasses/#reset","text":"-Xshareclasses:reset Causes a cache to be destroyed and then re-created when the VM starts up. This option can be added to the end of a command line as -Xshareclasses:reset .","title":"reset"},{"location":"xshareclasses/#restorefromsnapshot-cache-utility","text":"(Not Windows) -Xshareclasses:restoreFromSnapshot Restores a new non-persistent shared cache from a snapshot file. The snapshot and shared cache have the same name and location, as specified by the name and cacheDir suboptions. The non-persistent cache cannot already exist when the snapshot is restored. Restoring a snapshot does not remove the snapshot file; it can be restored multiple times. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to restore a snapshot.","title":"restoreFromSnapshot (Cache utility)"},{"location":"xshareclasses/#restrictclasspaths","text":"-Xshareclasses:restrictClasspaths Allows only the first VM that is initializing a shared cache to store classpaths in the cache. Subsequent VMs are not allowed to store classpaths in the cache unless the allowClasspaths option is specified. Use the restrictClasspaths option only if the application is designed to create class loaders of type java.net.URLClassloader or its subclass, such that their classpaths are unique to the instance of the application, but the classes that are loaded from these classpaths are the same. In such cases application classpaths that are stored by one VM cannot be used by another VM. For example, consider two VMs, VM1 and VM2, that are using class paths CP1 and CP2 respectively, where: CP1: url1;url2;url3;tempurl1;url4;url5 CP2: url1;url2;url3;tempurl2;url4;url5 These class paths differ only by one entry, which is the tempurl . The url1 , url2 , url3 , url4 , and url5 entries never change from run to run, whereas the tempurl entry is always different. This difference means that a class that is loaded from url4 or url5 , and stored into the shared cache by VM1, cannot be located by VM2. Therefore, an attempt by VM2 to load a class from url4 or url5 would cause it to store its own classpath CP2 into the shared cache, and also add new metadata for classes that are loaded from url4 or url5 . Addition of such unique class paths into the shared cache is not useful. Moreover, the additional metadata might adversely affect the performance of other VMs that connect to the shared cache. Because classes loaded from url4 or url5 are not loaded from the shared cache when the tempurl differs from the original, it is good practice to put the tempurl as the last entry in the class path. In situations such as that described in the example, the restrictClasspaths option can be used to restrict the addition of classpaths by ensuring that the first VM initializes the shared cache, and then prevents the addition of unique classpaths by subsequent VMs that attach to the shared cache. Note that use of the restrictClasspaths option in any other scenario is likely to negatively impact a VM's performance when it is using an existing cache.","title":"restrictClasspaths"},{"location":"xshareclasses/#revalidateaotmethods-cache-utility","text":"-Xshareclasses:revalidateAotMethods=<method_specification> -Xshareclasses:revalidateAotMethods=help Modify the shared cache to revalidate the AOT methods that match the method specifications. Use this suboption to revalidate AOT methods that were invalidated by using the invalidateAotMethods suboption. Revalidated AOT methods are then eligible for loading into a VM, but do not affect VMs where the methods have already been processed. To learn more about the syntax to use for <method_specification> , including how to specify more than one method, see Method specification syntax .","title":"revalidateAotMethods (Cache utility)"},{"location":"xshareclasses/#silent","text":"-Xshareclasses:silent Disables all shared class messages, including error messages. Unrecoverable error messages, which prevent the VM from initializing, are displayed.","title":"silent"},{"location":"xshareclasses/#snapshotcache-cache-utility","text":"(Not Windows) -Xshareclasses:snapshotCache Creates a snapshot file of an existing non-persistent shared cache. The snapshot has the same name and location as the shared cache, as specified by the name and cacheDir suboptions. The shared cache can be in use when the snapshot is taken, but VMs are blocked when they try to write to the shared cache, while the cache data is copied to the file. Typically, after a system is reinitialized, the snapshot file is used to restore the copy of the non-persistent cache into shared memory, via the restoreFromSnapshot suboption. Since this process removes all non-persistent caches from shared memory, restoring the cache from the snapshot file can result in better VM startup performance, because the contents of the shared cache, including classes and AOT code, do not have to be re-created. A snapshot can be created only if the user has sufficient permissions to create the destination snapshot file. If a snapshot of the same name exists already, it is overwritten. On platforms that support persistent caches, the nonpersistent suboption must be specified in order to create a snapshot. For information about removing snapshot files, see the destroySnapshot and destroyAllSnapshots suboptions.","title":"snapshotCache (Cache utility)"},{"location":"xshareclasses/#utilities","text":"-Xshareclasses:utilities Can be added to the end of a command line to disable class data sharing. This suboption overrides class sharing arguments found earlier on the command line. This suboption is like none , but does not disable the shared class utility APIs. For more information about the shared class utility APIs, see Obtaining information about shared caches .","title":"utilities"},{"location":"xshareclasses/#verbose","text":"-Xshareclasses:verbose Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders ask their parents for a class if they can't find it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy. The standard option -verbose:class also enables class sharing verbose output if class sharing is enabled.","title":"verbose"},{"location":"xshareclasses/#verboseaot","text":"-Xshareclasses:verboseAOT Enables verbose output when compiled AOT code is being found or stored in the cache. AOT code is generated heuristically. You might not see any AOT code that is generated at all for a small application. You can disable AOT caching by using the noaot suboption. See the VM Messages Guide for a list of the messages produced.","title":"verboseAOT"},{"location":"xshareclasses/#verbosehelper","text":"-Xshareclasses:verboseHelper Enables verbose output for the Java Helper API. This output shows you how the Helper API is used by your class loader.","title":"verboseHelper"},{"location":"xshareclasses/#verboseio","text":"-Xshareclasses:verboseIO Gives detailed output on the cache I/O activity, listing information about classes that are stored and found. Each class loader is given a unique ID (the bootstrap loader is always 0) and the output shows the class loader hierarchy at work, where class loaders must ask their parents for a class before they can load it themselves. It is typical to see many failed requests; this behavior is expected for the class loader hierarchy.","title":"verboseIO"},{"location":"xshareclasses/#method-specification-syntax","text":"The following examples show how to specify more than one method specification when you are using the findAotMethods , invalidateAotMethods , or revalidateAotMethods suboptions. Each method specification is defined as follows: <packagename>/<classname>[.<methodname>[(<parameters>)]] If you want to include more than one method specification in a single option, separate the specifications with a comma and enclose all the specifications in {braces}. For example: {<packagename/classname>}[.{<methodname>}[({<parameters>})]] You can use an asterisk (*) in most places as a wildcard. You can use an exclamation point (!) before the specification to mean \"everything except this\". Parameters are optional, but if specified, should be enclosed in parentheses and the following native signature formats must be used: B for byte C for char D for double F for float I for int J for long S for short Z for Boolean L<classname>; for objects [ before the signature means array If you want to specify parameters to distinguish between methods, you can use -Xshareclasses:findAotMethods=* (with a wildcard) to list all the parameter variations. Copy the signature for the method that you want from the output. For example, the signature for the parameters (byte[] bytes, int offset, int length, Charset charset) is ([BIILjava/nio/charset/Charset;) Here are some examples: Method signature Matches... * All AOT methods. java/lang/Object All AOT methods in the java.lang.Object class java/util/* All AOT classes and methods in the java.util package java/util/HashMap.putVal All putVal methods in the java.util.HashMap class java/util/HashMap.hash(Ljava/lang/Object;) The private java.util.HashMap.hash(java.lang.Object) method *.equals All equals methods in all classes {java/lang/Object,!java/lang/Object.clone} All methods in java.lang.Object except clone {java/util/*.*(),java/lang/Object.*(*)} All classes or methods with no input parameter in the java.util package, and all methods in java.lang.Object {java/util/*.*(),!java/util/*.*()} Nothing.","title":"Method specification syntax"},{"location":"xshareclasses/#see-also","text":"-Xscmx -XX:SharedCacheHardLimit Class data sharing","title":"See also"},{"location":"xsigcatch/","text":"-Xsigcatch / -Xnosigcatch Enables and disables VM signal handling code. Syntax Setting Effect Default -Xsigcatch Enable yes -Xnosigcatch Disable See also Signal handling","title":"-Xsigcatch"},{"location":"xsigcatch/#-xsigcatch-xnosigcatch","text":"Enables and disables VM signal handling code.","title":"-Xsigcatch / -Xnosigcatch"},{"location":"xsigcatch/#syntax","text":"Setting Effect Default -Xsigcatch Enable yes -Xnosigcatch Disable","title":"Syntax"},{"location":"xsigcatch/#see-also","text":"Signal handling","title":"See also"},{"location":"xsigchain/","text":"-Xsigchain / -Xnosigchain Enables and disables signal handler chaining. Syntax Setting Effect Default -Xsigchain Enable yes (except on z/OS\u00ae) -Xnosigchain Disable See also Signal handling","title":"-Xsigchain"},{"location":"xsigchain/#-xsigchain-xnosigchain","text":"Enables and disables signal handler chaining.","title":"-Xsigchain / -Xnosigchain"},{"location":"xsigchain/#syntax","text":"Setting Effect Default -Xsigchain Enable yes (except on z/OS\u00ae) -Xnosigchain Disable","title":"Syntax"},{"location":"xsigchain/#see-also","text":"Signal handling","title":"See also"},{"location":"xsignal/","text":"-Xsignal (z/OS\u00ae only) This option controls the behavior of OpenJ9 VM signal handlers. Syntax -Xsignal:<parameter>=<value> Parameters Restriction: You cannot use these parameters together. posixSignalHandler -Xsignal:posixSignalHandler=cooperativeShutdown When the VM signal handlers for SIGSEGV, SIGILL, SIGBUS, SIGFPE, SIGTRAP, and SIGABRT end a process, they call exit() , by default. In this case, the z/OS\u2122 Language Environment\u00ae is not aware that the VM ended abnormally. With -Xsignal:posixSignalHandler=cooperativeShutdown , the VM no longer uses exit() to end the process from the signal handlers. Instead, the VM behaves in one of the following ways: In response to a z/OS hardware exception, the VM uses return() . In response to signals raised or injected by software, the VM ends the enclave with abend 3565 . Language Environment detects that the VM is ending abnormally and initiates Resource Recovery Services. userConditionHandler (31-bit z/OS only) -Xsignal:userConditionHandler=percolate This option results in similar behavior to the -XCEEHDLR option: the VM registers user condition handlers to handle the z/OS exceptions that would otherwise be handled by the VM POSIX signal handlers for the SIGBUS, SIGFPE, SIGILL, SIGSEGV, and SIGTRAP signals. As with the -XCEEHDLR option, the VM does not install POSIX signal handlers for these signals. This option differs from the -XCEEHDLR option in that the VM percolates all Language Environment\u00ae conditions that were not triggered and expected by the VM during normal running, including conditions that are severity 2 or greater. The VM generates its own diagnostic information before percolating severity 2 or greater conditions. The VM is in an undefined state after percolating a severity 2 or greater condition. Applications cannot resume running then call back into, or return to, the VM. See also -XCEEHDLR Signal handling","title":"-Xsignal"},{"location":"xsignal/#-xsignal","text":"(z/OS\u00ae only) This option controls the behavior of OpenJ9 VM signal handlers.","title":"-Xsignal"},{"location":"xsignal/#syntax","text":"-Xsignal:<parameter>=<value>","title":"Syntax"},{"location":"xsignal/#parameters","text":"Restriction: You cannot use these parameters together.","title":"Parameters"},{"location":"xsignal/#posixsignalhandler","text":"-Xsignal:posixSignalHandler=cooperativeShutdown When the VM signal handlers for SIGSEGV, SIGILL, SIGBUS, SIGFPE, SIGTRAP, and SIGABRT end a process, they call exit() , by default. In this case, the z/OS\u2122 Language Environment\u00ae is not aware that the VM ended abnormally. With -Xsignal:posixSignalHandler=cooperativeShutdown , the VM no longer uses exit() to end the process from the signal handlers. Instead, the VM behaves in one of the following ways: In response to a z/OS hardware exception, the VM uses return() . In response to signals raised or injected by software, the VM ends the enclave with abend 3565 . Language Environment detects that the VM is ending abnormally and initiates Resource Recovery Services.","title":"posixSignalHandler"},{"location":"xsignal/#userconditionhandler","text":"(31-bit z/OS only) -Xsignal:userConditionHandler=percolate This option results in similar behavior to the -XCEEHDLR option: the VM registers user condition handlers to handle the z/OS exceptions that would otherwise be handled by the VM POSIX signal handlers for the SIGBUS, SIGFPE, SIGILL, SIGSEGV, and SIGTRAP signals. As with the -XCEEHDLR option, the VM does not install POSIX signal handlers for these signals. This option differs from the -XCEEHDLR option in that the VM percolates all Language Environment\u00ae conditions that were not triggered and expected by the VM during normal running, including conditions that are severity 2 or greater. The VM generates its own diagnostic information before percolating severity 2 or greater conditions. The VM is in an undefined state after percolating a severity 2 or greater condition. Applications cannot resume running then call back into, or return to, the VM.","title":"userConditionHandler"},{"location":"xsignal/#see-also","text":"-XCEEHDLR Signal handling","title":"See also"},{"location":"xsoftmx/","text":"-Xsoftmx This option sets a \"soft\" maximum limit for the initial size of the Java\u2122 heap. Syntax -Xsoftmx<size> Explanation Use the -Xmx option to set a \"hard\" limit for the maximum size of the heap. By default, -Xsoftmx is set to the same value as -Xmx . The value of -Xms must be less than, or equal to, the value of -Xsoftmx . See the introduction to this topic for more information about specifying <size> parameters. You can set this option on the command line, then modify it at run time by using the MemoryMXBean.setMaxHeapSize() method in the com.ibm.lang.management API. By using this API, Java applications can dynamically monitor and adjust the heap size as required. This function can be useful in virtualized or cloud environments, for example, where the available memory might change dynamically to meet business needs. When you use the API, you must specify the value in bytes, such as 2147483648 instead of 2g . For example, you might set the initial heap size to 1 GB and the maximum heap size to 8 GB. You might set a smaller value, such as 2 GB, for -Xsoftmx , to limit the heap size that is used initially: -Xms1g -Xsoftmx2g -Xmx8g You can then use the com.ibm.lang.management API from within a Java application to increase the -Xsoftmx value during run time, as load increases. This change allows the application to use more memory than you specified initially. If you reduce the -Xsoftmx value, the garbage collector attempts to respect the new limit. However, the ability to shrink the heap depends on a number of factors. There is no guarantee that a decrease in the heap size will occur. If or when the heap shrinks to less than the new limit, the heap will not grow beyond that limit. When the heap shrinks, the garbage collector might release memory. The ability of the operating system to reclaim and use this memory varies based on the capabilities of the operating system. Notes: When using -Xgcpolicy:gencon , -Xsoftmx applies only to the non-nursery portion of the heap. In some cases the heap grows to greater than the -Xsoftmx value because the nursery portion grows, making the heap size exceed the limit that is set. See -Xmn for limiting the nursery size. When using -Xgcpolicy:metronome , -Xsoftmx is ignored because the Metronome garbage collector does not support contraction or expansion of the heap. There might be little benefit in reducing the -Xsoftmx value when the Java heap is using large pages. Large pages are pinned in memory and are not reclaimed by the operating system, with the exception of 1M pageable pages on z/OS\u00ae. On certain platforms and processors the VM starts with large pages enabled by default for the Java heap when the operating system is configured to provide large pages. For more information, see Configuring large page memory allocation . A future version of the Java virtual machine might provide a hint to the operating system when large pages are no longer in use.","title":"-Xsoftmx"},{"location":"xsoftmx/#-xsoftmx","text":"This option sets a \"soft\" maximum limit for the initial size of the Java\u2122 heap.","title":"-Xsoftmx"},{"location":"xsoftmx/#syntax","text":"-Xsoftmx<size>","title":"Syntax"},{"location":"xsoftmx/#explanation","text":"Use the -Xmx option to set a \"hard\" limit for the maximum size of the heap. By default, -Xsoftmx is set to the same value as -Xmx . The value of -Xms must be less than, or equal to, the value of -Xsoftmx . See the introduction to this topic for more information about specifying <size> parameters. You can set this option on the command line, then modify it at run time by using the MemoryMXBean.setMaxHeapSize() method in the com.ibm.lang.management API. By using this API, Java applications can dynamically monitor and adjust the heap size as required. This function can be useful in virtualized or cloud environments, for example, where the available memory might change dynamically to meet business needs. When you use the API, you must specify the value in bytes, such as 2147483648 instead of 2g . For example, you might set the initial heap size to 1 GB and the maximum heap size to 8 GB. You might set a smaller value, such as 2 GB, for -Xsoftmx , to limit the heap size that is used initially: -Xms1g -Xsoftmx2g -Xmx8g You can then use the com.ibm.lang.management API from within a Java application to increase the -Xsoftmx value during run time, as load increases. This change allows the application to use more memory than you specified initially. If you reduce the -Xsoftmx value, the garbage collector attempts to respect the new limit. However, the ability to shrink the heap depends on a number of factors. There is no guarantee that a decrease in the heap size will occur. If or when the heap shrinks to less than the new limit, the heap will not grow beyond that limit. When the heap shrinks, the garbage collector might release memory. The ability of the operating system to reclaim and use this memory varies based on the capabilities of the operating system. Notes: When using -Xgcpolicy:gencon , -Xsoftmx applies only to the non-nursery portion of the heap. In some cases the heap grows to greater than the -Xsoftmx value because the nursery portion grows, making the heap size exceed the limit that is set. See -Xmn for limiting the nursery size. When using -Xgcpolicy:metronome , -Xsoftmx is ignored because the Metronome garbage collector does not support contraction or expansion of the heap. There might be little benefit in reducing the -Xsoftmx value when the Java heap is using large pages. Large pages are pinned in memory and are not reclaimed by the operating system, with the exception of 1M pageable pages on z/OS\u00ae. On certain platforms and processors the VM starts with large pages enabled by default for the Java heap when the operating system is configured to provide large pages. For more information, see Configuring large page memory allocation . A future version of the Java virtual machine might provide a hint to the operating system when large pages are no longer in use.","title":"Explanation"},{"location":"xsoftrefthreshold/","text":"-Xsoftrefthreshold Sets the value used by the garbage collector to determine the number of garbage collections after which a soft reference is cleared if its referent has not been marked. Syntax -Xsoftrefthreshold<value> Default behavior The default value is 32. Explanation A soft reference (where its referent is not marked) is cleared after a number of garbage collection cycles calculated as: <value> * (proportion of free heap space) For example, if -Xsoftrefthreshold is set to 32, and the heap is 25% free, soft references are cleared after 8 garbage collection cycles.","title":"-Xsoftrefthreshold"},{"location":"xsoftrefthreshold/#-xsoftrefthreshold","text":"Sets the value used by the garbage collector to determine the number of garbage collections after which a soft reference is cleared if its referent has not been marked.","title":"-Xsoftrefthreshold"},{"location":"xsoftrefthreshold/#syntax","text":"-Xsoftrefthreshold<value>","title":"Syntax"},{"location":"xsoftrefthreshold/#default-behavior","text":"The default value is 32.","title":"Default behavior"},{"location":"xsoftrefthreshold/#explanation","text":"A soft reference (where its referent is not marked) is cleared after a number of garbage collection cycles calculated as: <value> * (proportion of free heap space) For example, if -Xsoftrefthreshold is set to 32, and the heap is 25% free, soft references are cleared after 8 garbage collection cycles.","title":"Explanation"},{"location":"xss/","text":"-Xiss / -Xss / -Xssi Sets the stack size and increment for Java\u2122 threads. If you exceed the maximum Java thread stack size, a java/lang/OutOfMemoryError message is reported. You can use the -verbose:sizes option to find out the values that the VM is currently using. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; these options apply to the Java stack only. For the native stack option, see the link in the See also section. Syntax Setting Effect Default -Xiss<size> Set initial Java thread stack size 2 KB -Xss<size> Set maximum Java thread stack size 320 KB (31/32-bit); 1024 KB (64-bit) -Xssi<size> Set Java thread stack size increment 16 KB See Using -X command-line options for more information about the <size> parameter. See Default settings for the OpenJ9 VM for more about default values. See also -Xmso (Native stack size for operating system threads)","title":"-Xssi"},{"location":"xss/#-xiss-xss-xssi","text":"Sets the stack size and increment for Java\u2122 threads. If you exceed the maximum Java thread stack size, a java/lang/OutOfMemoryError message is reported. You can use the -verbose:sizes option to find out the values that the VM is currently using. Note: Java methods and native methods run on two different stacks and the VM handles switching between them for JNI calls. Each stack is sized using separate options; these options apply to the Java stack only. For the native stack option, see the link in the See also section.","title":"-Xiss / -Xss / -Xssi"},{"location":"xss/#syntax","text":"Setting Effect Default -Xiss<size> Set initial Java thread stack size 2 KB -Xss<size> Set maximum Java thread stack size 320 KB (31/32-bit); 1024 KB (64-bit) -Xssi<size> Set Java thread stack size increment 16 KB See Using -X command-line options for more information about the <size> parameter. See Default settings for the OpenJ9 VM for more about default values.","title":"Syntax"},{"location":"xss/#see-also","text":"-Xmso (Native stack size for operating system threads)","title":"See also"},{"location":"xtgc/","text":"-Xtgc Provides garbage collection tracing options. Syntax -Xtgc:<parameter>{,<parameter>} Parameters Specify one one or more of the following parameters in a comma-separated list: backtrace -Xtgc:backtrace Before a garbage collection, a single line is printed containing the name of the master thread for garbage collection, as well as the value of the osThread slot in the J9VMThread structure. compaction -Xtgc:compaction Prints extra information showing the relative time spent by threads in the \"move\" and \"fixup\" phases of compaction concurrent -Xtgc:concurrent Prints extra information showing the activity of the concurrent mark background thread dump -Xtgc:dump Prints a line of output for every free chunk of memory in the system, including \"dark matter\" (free chunks that are not on the free list for some reason, typically because they are too small). Each line contains the base address and the size in bytes of the chunk. If the chunk is followed in the heap by an object, the size and class name of the object is also printed. This argument has a similar effect to the terse argument. freeList -Xtgc:freeList Before a garbage collection, prints information about the free list and allocation statistics since the last garbage collection. Prints the number of items on the free list, including \"deferred\" entries (with the scavenger, the unused space is a deferred free list entry). For TLH and non-TLH allocations, prints the total number of allocations, the average allocation size, and the total number of bytes discarded during allocation. For non-TLH allocations, also included is the average number of entries that were searched before a sufficiently large entry was found. parallel -Xtgc:parallel Produces statistics on the activity of the parallel threads during the mark and sweep phases of a global garbage collection. scavenger -Xtgc:scavenger Prints extra information after each scavenger collection. A histogram is produced showing the number of instances of each class, and their relative ages, present in the survivor space. The information is obtained by performing a linear walk-through of the space. terse -Xtgc:terse Dumps the contents of the entire heap before and after a garbage collection. For each object or free chunk in the heap, a line of trace output is produced. Each line contains the base address, \"a\" if it is an allocated object, and \"f\" if it is a free chunk, the size of the chunk in bytes, and, if it is an object, its class name.","title":"-Xtgc"},{"location":"xtgc/#-xtgc","text":"Provides garbage collection tracing options.","title":"-Xtgc"},{"location":"xtgc/#syntax","text":"-Xtgc:<parameter>{,<parameter>}","title":"Syntax"},{"location":"xtgc/#parameters","text":"Specify one one or more of the following parameters in a comma-separated list:","title":"Parameters"},{"location":"xtgc/#backtrace","text":"-Xtgc:backtrace Before a garbage collection, a single line is printed containing the name of the master thread for garbage collection, as well as the value of the osThread slot in the J9VMThread structure.","title":"backtrace"},{"location":"xtgc/#compaction","text":"-Xtgc:compaction Prints extra information showing the relative time spent by threads in the \"move\" and \"fixup\" phases of compaction","title":"compaction"},{"location":"xtgc/#concurrent","text":"-Xtgc:concurrent Prints extra information showing the activity of the concurrent mark background thread","title":"concurrent"},{"location":"xtgc/#dump","text":"-Xtgc:dump Prints a line of output for every free chunk of memory in the system, including \"dark matter\" (free chunks that are not on the free list for some reason, typically because they are too small). Each line contains the base address and the size in bytes of the chunk. If the chunk is followed in the heap by an object, the size and class name of the object is also printed. This argument has a similar effect to the terse argument.","title":"dump"},{"location":"xtgc/#freelist","text":"-Xtgc:freeList Before a garbage collection, prints information about the free list and allocation statistics since the last garbage collection. Prints the number of items on the free list, including \"deferred\" entries (with the scavenger, the unused space is a deferred free list entry). For TLH and non-TLH allocations, prints the total number of allocations, the average allocation size, and the total number of bytes discarded during allocation. For non-TLH allocations, also included is the average number of entries that were searched before a sufficiently large entry was found.","title":"freeList"},{"location":"xtgc/#parallel","text":"-Xtgc:parallel Produces statistics on the activity of the parallel threads during the mark and sweep phases of a global garbage collection.","title":"parallel"},{"location":"xtgc/#scavenger","text":"-Xtgc:scavenger Prints extra information after each scavenger collection. A histogram is produced showing the number of instances of each class, and their relative ages, present in the survivor space. The information is obtained by performing a linear walk-through of the space.","title":"scavenger"},{"location":"xtgc/#terse","text":"-Xtgc:terse Dumps the contents of the entire heap before and after a garbage collection. For each object or free chunk in the heap, a line of trace output is produced. Each line contains the base address, \"a\" if it is an allocated object, and \"f\" if it is a free chunk, the size of the chunk in bytes, and, if it is an object, its class name.","title":"terse"},{"location":"xthr/","text":"-Xthr Syntax -Xthr:<parameter> Parameters AdaptSpin | noAdaptSpin -Xthr:AdaptSpin -Xthr:noAdaptSpin This tuning option is available to test whether performance optimizations are negatively impacting an application. fastNotify | noFastNotify -Xthr:fastNotify -Xthr:noFastNotify When a large number of threads try to acquire a Java\u2122 monitor, throughput of an application can be reduced. This issue is known as high contention. If high contention occurs when the Java wait and notify features are regularly used, you can use -Xthr:fastNotify to increase throughput. However, -Xthr:noFastNotify is the default setting, because it is faster in all other scenarios. cfsYield | noCfsYield (Linux\u00ae only) -Xthr:cfsYield -Xthr:noCfsYield The default value, cfsYield , enables threading optimizations for running on Linux with the Completely Fair Scheduler (CFS) in the default mode ( sched_compat_yield=0 ). The noCfsYield value disables these threading optimizations. You might want to use the noCfsYield value if your application uses the Thread.yield() method extensively, because otherwise you might see a performance decrease in cases where yielding is not beneficial. minimizeUserCPU -Xthr:minimizeUserCPU Minimizes user-mode CPU usage in thread synchronization where possible. The reduction in CPU usage might be a trade-off in exchange for decreased performance. secondarySpinForObjectMonitors | noSecondarySpinForObjectMonitors -Xthr:secondarySpinForObjectMonitors -Xthr:noSecondarySpinForObjectMonitors This tuning option is available to test whether performance optimizations are negatively impacting an application.","title":"-Xthr"},{"location":"xthr/#-xthr","text":"","title":"-Xthr"},{"location":"xthr/#syntax","text":"-Xthr:<parameter>","title":"Syntax"},{"location":"xthr/#parameters","text":"","title":"Parameters"},{"location":"xthr/#adaptspin-noadaptspin","text":"-Xthr:AdaptSpin -Xthr:noAdaptSpin This tuning option is available to test whether performance optimizations are negatively impacting an application.","title":"AdaptSpin | noAdaptSpin"},{"location":"xthr/#fastnotify-nofastnotify","text":"-Xthr:fastNotify -Xthr:noFastNotify When a large number of threads try to acquire a Java\u2122 monitor, throughput of an application can be reduced. This issue is known as high contention. If high contention occurs when the Java wait and notify features are regularly used, you can use -Xthr:fastNotify to increase throughput. However, -Xthr:noFastNotify is the default setting, because it is faster in all other scenarios.","title":"fastNotify | noFastNotify"},{"location":"xthr/#cfsyield-nocfsyield-linux-only","text":"-Xthr:cfsYield -Xthr:noCfsYield The default value, cfsYield , enables threading optimizations for running on Linux with the Completely Fair Scheduler (CFS) in the default mode ( sched_compat_yield=0 ). The noCfsYield value disables these threading optimizations. You might want to use the noCfsYield value if your application uses the Thread.yield() method extensively, because otherwise you might see a performance decrease in cases where yielding is not beneficial.","title":"cfsYield | noCfsYield (Linux&reg; only)"},{"location":"xthr/#minimizeusercpu","text":"-Xthr:minimizeUserCPU Minimizes user-mode CPU usage in thread synchronization where possible. The reduction in CPU usage might be a trade-off in exchange for decreased performance.","title":"minimizeUserCPU"},{"location":"xthr/#secondaryspinforobjectmonitors-nosecondaryspinforobjectmonitors","text":"-Xthr:secondarySpinForObjectMonitors -Xthr:noSecondarySpinForObjectMonitors This tuning option is available to test whether performance optimizations are negatively impacting an application.","title":"secondarySpinForObjectMonitors | noSecondarySpinForObjectMonitors"},{"location":"xtlhprefetch/","text":"-XtlhPrefetch (AIX\u00ae, Windows\u2122 only) Speculatively prefetches bytes in the thread local heap (TLH) ahead of the current allocation pointer during object allocation. This option helps reduce the performance cost of subsequent allocations. Syntax -XtlhPrefetch","title":"-XtlhPrefetch"},{"location":"xtlhprefetch/#-xtlhprefetch","text":"(AIX\u00ae, Windows\u2122 only) Speculatively prefetches bytes in the thread local heap (TLH) ahead of the current allocation pointer during object allocation. This option helps reduce the performance cost of subsequent allocations.","title":"-XtlhPrefetch"},{"location":"xtlhprefetch/#syntax","text":"-XtlhPrefetch","title":"Syntax"},{"location":"xtrace/","text":"-Xtrace OpenJ9 VM tracing is a powerful feature to help you diagnose problems with minimal effect on performance. Tracing is enabled by default, together with a small set of trace points going to memory buffers. You can enable tracepoints at run time by using levels, components, group names, or individual tracepoint identifiers to trace VM internal operations and instrumented Java\u2122 applications. You can also trace Java methods. See the About trace section that follows for more detail. Trace data can be output in human-readable or in compressed binary formats. The VM provides a tool to process and convert the compressed binary data into a readable format. See Trace formatter . Note: You can also control trace by using the com.ibm.jvm.Trace API or by using JVMTI from an external agent. Xtrace Option Builder Use the Xtrace Option Builder tool to help you specify the correct options and avoid incompatibilities. Syntax -Xtrace:<parameter> You can get help with -Xtrace by using the following options: -Xtrace:help Displays general trace help -Xtrace:what Shows the current trace settings Configuring trace The following parameters can be used to configure trace. (Follow links for more information about individual options.) Command Result -Xtrace:properties[=<filename>] Configures trace options based on a file -Xtrace:buffers=<size>[dynamic\\|nodynamic] Modifies the size of buffers that are used to store trace data -Xtrace:exception.output=<filename>[,<size>] Redirects exceptions trace data to a file. -Xtrace:methods=<method_specification> Traces methods -Xtrace:output=<filename>[,<size>[,<generations>]] Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:resume Resumes tracing globally. -Xtrace:resumecount=<count> Enables tracing at a thread level after a specified count. -Xtrace:sleeptime=<time> Pauses trace operations for a specified length of time. -Xtrace:stackdepth=<n> Limits the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:suspend Suspends tracing globally. -Xtrace:suspendcount=<count> Suspends tracing at a thread level after a specified count. -Xtrace:trigger=<clause> Determines when various triggered trace actions occur, including turning trace on or off. Note: If an option value contains commas, it must be enclosed in braces. For example: methods={java/lang/*,com/ibm/*} Controlling tracepoint activation The following parameters can be used to control tracepoint activation. (Follow links for more information about individual options.) Command Result -Xtrace:maximal=<tracepoint_specification> Records all associated data. -Xtrace:minimal=<tracepoint_specification> Records only the time stamp and tracepoint identifier. -Xtrace:count=<tracepoint_specification> Counts the tracepoints that are used in a trace configuration. -Xtrace:print=<tracepoint_specification> Prints the specified tracepoints to stderr in real time. -Xtrace:iprint=<tracepoint_specification> Prints the specified tracepoints to stderr in real time with indentation. -Xtrace:exception=<tracepoint_specification> Enables exception tracing. -Xtrace:external<tracepoint_specification> Routes trace data to trace listeners, which are registered by using the JVMTI APIs. -Xtrace:none[=<tracepoint_specification>] Prevents the trace engine from loading if it is the only trace option specified. Note: These options control which individual tracepoints are activated at run time and the implicit destination of the trace data. All these properties are independent of each other and can be mixed and matched in any way that you choose. For more information, see Tracepoint activation . About trace With the OpenJ9 trace feature, you can trace VM internal operations, Java applications, and Java methods, or any combination of these. VM internal operations The OpenJ9 virtual machine (VM) is extensively instrumented with tracepoints for tracing operations. Interpreting this trace data requires detailed knowledge of the VM, and is intended to diagnose VM problems. No guarantee is given that tracepoints will not vary from release to release and from platform to platform. Applications VM trace contains an application trace facility that allows tracepoints to be placed in Java code, enabling you to combine trace data with the other forms of trace. This capability is supported by the com.ibm.jvm.Trace API. Note that an instrumented Java application runs only on an OpenJ9 VM. For more information, see Application trace . Java methods Use method trace to debug and trace application code and the system classes provided with the VM. You can trace entry to and exit from Java methods run by the VM. You can select method trace by classname, method name, or both. You can also use wildcards to create complex method selections. For more information about command syntax, see methods . Trace can produce large amounts of data in a very short time. Before running trace, think carefully about what information you need in order to solve the problem. Here are some considerations: If you need only the trace information that is produced shortly before the problem occurs, consider wrapping the file by using the output option. In many cases, just use internal trace with an increased buffer size and snap the trace when the problem occurs. If the problem results in a thread stack dump or operating system signal or exception, trace buffers are snapped automatically to a file that is in the current directory. The file is called: Snapnnnn. yyyymmdd.hhmmssth.process.trc . You must also think carefully about which components need to be traced and what level of tracing is required. For example, if you are tracing a suspected shared classes problem, it might be enough to trace all components at level 1, and j9shr at level 9, while maximal can be used to show parameters and other information for the failing component. Tracepoint components and trace levels are described in the following sections: Tracepoint specification and Trace levels . There are two types of tracepoints inside the VM: Regular tracepoints include method tracepoints, application tracepoints, data tracepoints inside the VM and data tracepoints inside class libraries. You can display regular tracepoint data on the screen or save the data to a file. You can also use command line options to trigger specific actions when regular tracepoints fire. Auxiliary tracepoints are a special type of tracepoint that can be fired only when another tracepoint is being processed. For example, the stack frame information produced by the jstacktrace -Xtrace:trigger command. You cannot control where auxiliary tracepoint data is sent and you cannot set triggers on auxiliary tracepoints. Auxiliary tracepoint data is sent to the same destination as the tracepoint that caused them to be generated. Trace data can be written to one of the following locations: Memory buffers that can be dumped or snapped when a problem occurs. Use the -Xtrace:buffers=<size> option to control the size of the buffer allocated to each thread. Buffers allocated to a thread are discarded when that thread terminates. To examine the trace data captured in these memory buffers, you must snap or dump the data, then format the buffers. One or more files that are using buffered I/O. Use the -Xtrace:output option. An external agent in real time, using the -Xtrace:external option. stderr in real time. Any combination of the other items in this list. Default tracing By default, the equivalent of the following trace command line is always available in the VM: -Xtrace:maximal=all{level1},exception=j9mm{gclogger} When startup is complete, the equivalent of the following command line is added to enable level 2 trace points: -Xtrace:maximal=all{level2} Level 2 is used for default tracing that would produce too much data during the startup of the VM. If you set other trace options on the command line, or before the VM finishes startup (through use of JVMTI or the com.ibm.jvm.Trace API), the level 2 trace points are enabled just before your trace options are processed. This behavior ensures that the default level 2 trace points do not override any changes that you specify. The data generated by the tracepoints is continuously captured in wrapping memory buffers for each thread. You can find tracepoint information in the following diagnostics data: System memory dumps, extracted by using jdmpview. Snap traces, generated when the VM encounters a problem or an output file is specified. Using dump agents describes more ways to create a snap trace. For exception trace only, in Javadumps. Default memory management tracing The default trace options are designed to ensure that Javadumps always contain a record of the most recent memory management history, regardless of how much work the VM has performed since the garbage collection cycle was last called. The exception=j9mm{gclogger} clause of the default trace set specifies that a history of garbage collection cycles that have occurred in the VM is continuously recorded. The gclogger group of tracepoints in the j9mm component constitutes a set of tracepoints that record a snapshot of each garbage collection cycle. These tracepoints are recorded in their own separate buffer, called the exception buffer. The effect is that the tracepoints are not overwritten by the higher frequency tracepoints of the VM. The GC History section of the Javadump is based on the information in the exception buffer. If a garbage collection cycle has occurred in a traced VM, the Java dump probably contains a GC History section. Default assertion tracing The VM includes assertions, implemented as special trace points. By default, internal assertions are detected and diagnostics logs are produced to help assess the error. Assertion failures often indicate a serious problem, and the VM usually stops immediately. In these circumstances, raise an issue, including the standard error output and any diagnostic files that are produced. When an assertion trace point is reached, a message like the following output is produced on the standard error stream: 16:43:48.671 0x10a4800 j9vm.209 * ** ASSERTION FAILED ** at jniinv.c:251: ((javaVM == ((void *)0))) This error stream is followed with information about the diagnostic logs produced: JVMDUMP007I JVM Requesting System Dump using 'core.20060426.124348.976.dmp' JVMDUMP010I System Dump written to core.20060426.124348.976.dmp JVMDUMP007I JVM Requesting Snap Dump using 'Snap0001.20060426.124648.976.trc' JVMDUMP010I Snap Dump written to Snap0001.20060426.124648.976.trc Assertions are special trace points. They can be enabled or disabled by using the standard trace command-line options. Assertion failures might occur early during VM startup, before trace is enabled. In this case, the assert message has a different format, and is not prefixed by a timestamp or thread ID. For example: ** ASSERTION FAILED ** j9vmutil.15 at thrinfo.c:371 Assert_VMUtil_true(( publicFlags & 0x200)) Assertion failures that occur early during startup cannot be disabled. These failures do not produce diagnostic dumps, and do not cause the VM to stop. Tracepoint activation The options that control which individual tracepoints are activated at run time and the implicit destination of the trace data are listed under Syntax: Controlling tracepoint activation In some cases, you must use them with other options. For example, if you specify maximal or minimal tracepoints, the trace data is put into memory buffers. If you are going to send the data to a file, you must use an output option to specify the destination file name. With the exception of none , all options require at least one <tracepoint_specification> , which is described in the following section. Multiple statements of each type of trace are allowed and their effect is cumulative. If you want to use multiple trace options of the same name, use a properties file. (See properties .) Tracepoint specification Tracepoints are enabled by specifying component and tracepoint . If no qualifier parameters are entered, all tracepoints are enabled, except for <exception.output> trace, where the default is all {exception}. The <tracepoint_specification> syntax can be further broken down as follows: [!]<component>[{<group>}] or [!]<component>[{<type>}] or [!]<tracepoint_id>[,<tracepoint_id>] Where: The ! symbol is a logical not . That is, the tracepoints that are in a specification starting with ! are turned off. <component> is a Java component. <group> is a tracepoint group, which is a set of tracepoints that are defined within a component. <type> is the tracepoint type: entry , exit , event , exception , and eem . <tracepoint_id> is the tracepoint identifier. The tracepoint identifier constitutes the component name of the tracepoint, followed by its integer number inside that component. For example, j9mm.49 , j9shr.20-29 , j9vm.15 . To understand these numbers, see Determining the tracepoint ID of a tracepoint. Some tracepoints can be both an exit and an exception ; that is, the function ended with an error. If you specify either exit or exception , these tracepoints are included. Lists of Java components and tracepoint groups can be found in the tables that follow. The following table lists the possible Java components ( <component> ). To include all Java components, specify all . Component name Description avl VM AVL tree support io Class library java.io native code j9bcu VM byte code utilities j9bcverify VM byte code verification j9codertvm VM byte code run time j9dmp VM dump j9jcl VM class libraries j9jit VM JIT interface j9jni VM JNI support j9jvmti VM JVMTI support j9mm VM memory management j9prt VM port library j9scar VM class library interface j9shr VM shared classes j9trc VM trace j9util VM utilities j9vm VM general j9vmutil VM utilities j9vrb VM verbose stack walker map VM mapped memory support mt Java methods (see Note ) net Class library TCP/IP networking native code pool VM storage pool support rpc VM RPC support simplepool VM storage pool support sunvmi VM class library interface Note: When specifying the mt component you must also specify the methods option. The following table lists all the tracepoint groups ( <group> ). Each group is associated with one or more Java components: Component name or names Group name Description j9mm gclogger A set of tracepoints that record each garbage collection cycle. Equivalent to -verbose:gc output j9prt nlsmessage A set of tracepoints that record each NLS message that is issued by the VM. j9jcl , j9vm verboseclass A set of tracepoints that record each class as it is loaded. Equivalent to -verbose:class output. j9jni , j9vm checkjni A set of tracepoints that record JNI function checks. Equivalent to -Xcheck:jni output. j9vm checkmemory A set of tracepoints that record memory checks. Equivalent to -Xcheck:memory output. j9vm checkvm A set of tracepoints that record VM checks. Equivalent to -Xcheck:vm output. j9jit verbose A set of tracepoints that record JIT compiler configuration and method compilation. Equivalent to -Xjit:verbose output. mt compiledMethods A set of tracepoints that record compiled Java methods. mt nativeMethods A set of tracepoints that record Java native methods. mt staticMethods A set of tracepoints that record Java static methods. Here are some examples: To trace all tracepoints, specify the following command: -Xtrace:maximal=all To trace all tracepoints except **j9vrb** and **j9trc**, specify the following command: -Xtrace:minimal={all},minimal={!j9vrb,j9trc} To trace all entry and exit tracepoints in j9bcu , specify the following command: -Xtrace:maximal={j9bcu{entry},j9bcu{exit}} To trace all tracepoints in **j9mm** except tracepoints 20-30, specify the following command: -Xtrace:maximal=j9mm,maximal=!j9mm.20-30 To trace tracepoints j9prt.5 through j9prt.15 , specify the following command: -Xtrace:print=j9prt.5-15 To trace all **j9trc** tracepoints, specify the following command: -Xtrace:count=j9trc To trace all entry and exit tracepoints, specify the following command: -Xtrace:external={all{entry},all{exit}} Trace levels Tracepoints have been assigned levels 0 through 9 that are based on the importance of the tracepoint. A level 0 tracepoint is the most important. It is reserved for extraordinary events and errors. A level 9 tracepoint is in-depth component detail. To specify a given level of tracing, the level0 through level9 keywords are used. You can abbreviate these keywords to l0 through l9. For example, if level5 is selected, all tracepoints that have levels 0 through 5 are included. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. The level is provided as a modifier to a component specification, for example: -Xtrace:maximal={all{level5}} or -Xtrace:maximal={j9mm{L2},j9trc,j9bcu{level9},all{level1}} In the first example, tracepoints that have a level of 5 or less are enabled for all components. In the second example, all level 1 tracepoints are enabled. All level 2 tracepoints in j9mm are enabled. All tracepoints up to level 9 are enabled in j9bcu . Note: The level applies only to the current component. If multiple trace selection components are found in a trace properties file, the level is reset to the default for each new component. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. When the not operator is specified, the level is inverted; that is, !j9mm{level5} disables all tracepoints of level 6 or greater for the j9mm component. The following example enables trace for all components at level 9 (the default), but disables level 6 and higher for the locking component, and level 7 and higher for the storage component: -Xtrace:print={all},print={!j9trc{l5},j9mm{l6}} Here are some examples: To count the level zero and level one tracepoints matched, specify the following command: -Xtrace:count=all{L1} To produce maximal trace of all components at level 5 and j9mm at level 9, specify the following command: -Xtrace:maximal={all{level5},j9mm{L9}} To trace all components at level 6, but do not trace j9vrb at all, and do not trace the entry and exit tracepoints in the j9trc component, specify the following command: -Xtrace:minimal={all{l6}},minimal={!j9vrb,j9trc{entry},j9trc{exit}} Parameters Parameters to use with the -Xtrace option: buffers You can modify the size of the buffers to change how much diagnostic output is provided in a snap dump. This buffer is allocated for each thread that makes trace entries. The following table shows how this parameter can be set: Command Effect -Xtrace:buffers=<size> Creates buffers of the specified <size> in k (KB) or m (MB), allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>dynamic Creates buffers of the specified <size> , allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>nodynamic Creates buffers of the specified <size> , with a maximum allocation of two buffers per thread. If external trace is enabled, the number of buffers is doubled; that is, each thread allocates two or more buffers. The same buffer size is used for state and exception tracing, but, in this case, buffers are allocated globally. The default is 8 KB per thread. The dynamic and nodynamic suboptions have meaning only when tracing to an output file. Note: If nodynamic is specified, you might lose trace data if the volume of trace data exceeds the bandwidth of the trace output file. Message UTE115 is issued when the first trace entry is lost, and message UTE018 is issued when the VM ends. Here are some command line examples: To set a buffer size of 2 MB per thread, with dynamic buffering, use: -Xtrace:buffers=2m To limit each thread to 2 trace buffers, each of 128 KB: -Xtrace:buffers={128k,nodynamic} count (tracepoint) -Xtrace:count=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The count option requests that only a count of the selected tracepoints is kept. When the VM ends, all nonzero totals of tracepoints (sorted by tracepoint id) are written to a file, called utTrcCounters , in the current directory. This information is useful if you want to determine the overhead of particular tracepoints, but do not want to produce a large amount (GB) of trace data. For example, to count the tracepoints that are used in the default trace configuration, use the following command: -Xtrace:count=all{level1},count=j9mm{gclogger} exception (tracepoint) -Xtrace:exception=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When exception trace is enabled, the trace data is collected in internal buffers that are separate from the normal buffers. These internal buffers can then be written to a snap file or written to the file that is specified in an exception.output option. The exception option allows low-volume tracing in buffers and files that are distinct from the higher-volume information that minimal and maximal tracing have provided. In most cases, this information is exception-type data, but you can use this option to capture any trace data that you want. This form of tracing is channeled through a single set of buffers, as opposed to the buffer-per-thread approach for normal trace. Buffer contention might occur if high volumes of trace data are collected. A difference exists in the <tracepoint_specification> defaults for exception tracing; see Tracepoint specification . Notes: The exception trace buffers are intended for low-volume tracing. By default, the exception trace buffers log garbage collection (GC) event tracepoints, see Default tracing. You can send additional tracepoints to the exception buffers or turn off the GC tracepoints. Changing the exception trace buffers alters the contents of the GC History section in any Javadumps. When exception trace is entered for an active tracepoint, the current thread ID is checked against the previous caller's thread ID. If it is a different thread, or this is the first call to exception trace, a context tracepoint is put into the trace buffer first. This context tracepoint consists only of the current thread ID, which is necessary because of the single set of buffers for exception trace. (The formatter identifies all trace entries as coming from the Exception trace pseudo thread when it formats exception trace files.) exception.output Use exception output to redirect exceptions trace data to a file. -Xtrace:exception.output=<filename>[,<size>] Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d% (today's date in \" yyyymmdd\" format), %p (process ID number of the process generating the trace), or %t% (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps nondestructively to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Here are some examples: Exception trace output goes to file /u/traces/exception.trc with no size limit: -Xtrace:exception.output=/u/traces/exception.trc,maximal Exception trace output goes to file except and wraps at 2 MB: -Xtrace:exception.output={except,2m},maximal Exception trace output goes to a file whose filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:exception.output=traceout.%d.trc,maximal Exception trace output goes to a file whose filename contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:exception.output=tracefrompid%p.trc,maximal Exception trace output goes to a file whose filename contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:exception.output=traceout.%t.trc,maximal external (tracepoint) -Xtrace:external<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The external option routes trace data to trace listeners, which are registered by using the JVMTI RegisterTracePointSubscriber() and DeregisterTracePointSubscriber() APIs. help -Xtrace:help Displays general trace help iprint (tracepoint) -Xtrace:iprint=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The iprint option is the same as the print option, but uses indenting to format the trace. maximal (tracepoint) -Xtrace:maximal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. All associated data is traced. minimal and maximal traces are independent from any types that follow them. For example, if the maximal option is specified, it does not affect a later option such as print . methods Using method trace provides a complete and potentially large diagnosis of code paths inside your application and the system classes. Use wild cards and filtering to control method trace so that you can focus on the sections of code that interest you. To specify one or more method specifications, use the following syntax: -Xtrace:methods=<method_specification>[,<method_specification>] The syntax for <method_specification> can be further broken down to the following suboptions: -Xtrace:methods={[!][*][<package>/]<class>[*],[[*]<method>[*]|[()]]} Where: The delimiter between parts of the package name is a forward slash, \"/\". The ! in the methods parameter is a NOT operator that allows you to tell the VM not to trace the specified method or methods. The parentheses, (), define whether or not to include method parameters in the trace. If a method specification includes any commas, the whole specification must be enclosed in braces, for example: -Xtrace:methods={java/lang/*,java/util/*},print=mt It might be necessary to enclose your command line in quotation marks to prevent the shell intercepting and fragmenting comma-separated command lines, for example: \"-Xtrace:methods={java/lang/*,java/util/*},print=mt\" To output all method trace information to stderr, use either the print or iprint suboptions: -Xtrace:print=mt,methods=*.* -Xtrace:iprint=mt,methods=*.* The iprint suboption prints to stderr with indentation. To output method trace information in binary format, see the output option. Here are some examples: Tracing entry and exit of all methods in a given class: To trace all method entry and exit of the ReaderMain class in the default package and the java.lang.String class, specify the following command: -Xtrace:methods={ReaderMain.*,java/lang/String.*},print=mt Tracing entry, exit and input parameters of all methods in a class: To trace all method entry, exit, and input of the ReaderMain class in the default package, specify the following command: -Xtrace:methods=ReaderMain.*(),print=mt Tracing all methods in a given package: To trace all method entry, exit, and input of all classes in the package com.ibm.socket , specify the following command: -Xtrace:methods=com/ibm/socket/*.*(),print=mt Multiple method trace: To trace all method entry, exit, and input in the Widget class in the default package and all method entry and exit in the common package, specify the following command: -Xtrace:methods={Widget.*(),common/*},print=mt Using the ! operator: To trace all methods in the ArticleUI class in the default package except those beginning with \"get\", specify the following command: -Xtrace:methods={ArticleUI.*,!ArticleUI.get*},print=mt Tracing a specific method in a class: This example traces entry and exit of the substring method of the java.lang.String class . If there is more than one method with the same name, they are all traced. You cannot filter method trace by the signature of the method. -Xtrace:print=mt,methods={java/lang/String.substring} Tracing the constructor of a class: This example traces entry and exit of the constructors of the java.lang.String class. -Xtrace:print=mt,methods={java/lang/String.<init>} Here is some example output: java \"-Xtrace:methods={java/lang*.*},iprint=mt\" HW 10:02:42.281*0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/String.<clinit>()V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method The output lines comprise of: 0x9e900 , the current execenv (execution environment). Because every VM thread has its own execenv , you can regard execenv as a thread-id . All trace with the same execenv relates to a single thread. The individual tracepoint ID in the mt component that collects and emits the data. The remaining fields show whether a method is being entered (>) or exited (<), followed by details of the method. minimal (tracepoint) -Xtrace:minimal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. Only the time stamp and tracepoint identifier are recorded. When the trace is formatted, missing trace data is replaced with the characters \"???\" in the output file. minimal and maximal traces are independent from any types that follow them. For example, if the minimal option is specified, it does not affect a later option such as print . none (tracepoint) -Xtrace:none[=<tracepoint_specification>] For further information about <tracepoint_specification> syntax, see Tracepoint specification . -Xtrace:none prevents the trace engine from loading if it is the only trace option specified. However, if other -Xtrace options are on the command line, it is treated as the equivalent of -Xtrace:none=all and the trace engine still loads. If you specify other tracepoints without specifying -Xtrace:none , the tracepoints are added to the default set. output Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:output=<filename>[,<size>[,<generations>]]` Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d% (today's date in \" yyyymmdd\" format), %p% (process ID number of the process generating the trace), or %t% (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Optionally, <generations> is a value 2 through 36. These values cause up to 36 files to be used sequentially as each file reaches its <size> threshold. When a file needs to be reused, it is overwritten. If <generations> is specified, the filename must contain a # (hash, pound symbol), which will be substituted with its generation identifier, the sequence of which is 0 through 9 followed by A through Z. Note: When tracing to a file, buffers for each thread are written when the buffer is full or when the VM ends. If a thread has been inactive for a period of time before the VM ends, what seems to be 'old' trace data is written to the file. When formatted, it then seems that trace data is missing from the other threads, but this is an unavoidable side-effect of the buffer-per-thread design. This effect becomes especially noticeable when you use the generation facility, and format individual earlier generations. Here are some examples: Trace output goes to file /u/traces/gc.problem with no size limit: -Xtrace:output=/u/traces/gc.problem,maximal=j9gc Trace output goes to file trace , which will wrap at 2 MB: -Xtrace:output={trace,2m},maximal=j9gc Trace output goes to files gc0.trc , gc1.trc , and gc2.trc , each 10 MB in size: -Xtrace:output={gc#.trc,10m,3},maximal=j9gc Trace output goes to a file, where the filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:output=traceout.%d.trc,maximal=j9gc Trace output goes to a file whose name contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:output=tracefrompid%p.trc,maximal=j9gc Trace output goes to a file whose name contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:output=traceout.%t.trc,maximal=j9gc print (tracepoint) -Xtrace:print=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The print option causes the specified tracepoints to be routed to stderr in real time. The VM tracepoints are formatted by using J9TraceFormat.dat . The class library tracepoints are formatted by J9TraceFormat.dat and TraceFormat.dat . properties You can use properties files to control trace. A properties file saves typing and allows you to create a library of files that are tailored to solving problems in a particular area. -Xtrace:properties[=<filename>] If <filename> is not specified, the VM searches for a default name of IBMTRACE.properties in the current directory. All the options that are in the file are processed in the sequence in which they are stored in the file, before the next option that is obtained through the normal mechanism is processed. Therefore, a command-line property always overrides a property that is in the file. Here is an example of a properties file: minimal=all // maximal=j9mm maximal=j9shr buffers=128k,nodynamic output=c:\\traces\\classloader.trc print=tpnid(j9vm.23-25) The following restrictions apply to the file: The file must be a flat ASCII file. Nesting is not supported; that is, the file cannot contain a properties option. You cannot leave properties that have the form <name>=<value> to default if they are specified in the property file; that is, you must specify a value, for example maximal=all . Do not add white space before, after, or within the trace options. If any error is found when the file is accessed, VM initialization fails with an explanatory error message and return code. To use a file trace.props stored in the c:\\trc\\gc directory, specify the following command: -Xtrace:properties=c:\\trc\\gc\\trace.props resume The resume option resumes tracing globally. -Xtrace:resume The suspend and resume options are not recursive. That is, two suspends that are followed by a single resume cause trace to be resumed. resumecount This trace option determines whether tracing is enabled for each thread. -Xtrace:resumecount=<count> If <count> is greater than zero, each thread initially has its tracing disabled and must receive <count> resumethis actions before it starts tracing. This option is used with the trigger option. Note: You cannot use resumecount and suspendcount together because they use the same internal counter. The following example starts with all tracing turned off. Each thread starts tracing when it has had three resumethis actions performed on it: -Xtrace:resumecount=3 sleeptime You can specify how long the sleep lasts when using the sleep trigger action. -Xtrace:sleeptime=nnn|aaams|bbbs Where: nnn sleeps for nnn milliseconds. aaams sleeps for aaa milliseconds. bbbs sleeps for bbb seconds. The default length of time is 30 seconds. If no units are specified, the default time unit is milliseconds. stackdepth Use this option to limit the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:stackdepth=<n> Where <n> is the maximum number of stack frames reported. suspend -Xtrace:suspend Suspends tracing globally for all threads and all forms of tracing but leaves tracepoints activated. suspendcount This trace option determines whether tracing is enabled for each thread. -Xtrace:suspendcount=<count> If <count> is greater than zero, each thread initially has its tracing enabled and must receive <count> suspendthis actions before it stops tracing. You cannot use resumecount and suspendcount together because they both set the same internal counter. This trace option is for use with the trigger option. The following example starts with tracing turned on. Each thread stops tracing when it has had three suspendthis actions performed on it: -Xtrace:suspendcount=3 trigger The trigger parameter determines when various triggered trace actions occur. Supported actions include turning tracing on and off for all threads, turning tracing on or off for the current thread, or producing various dumps. -Xtrace:trigger=<clause>[,<clause>] This trace option does not control what is traced. It controls only whether the information that has been selected by the other trace options is produced as normal or is blocked. Types Each clause of the trigger parameter can be one of the following types: a method ( -Xtrace:trigger=method{...} ) a tracepoint ID ( -Xtrace:trigger=tpnid{...} ) a group ( -Xtrace:trigger=group{...} ) You can specify multiple clauses of the same type if required, but you do not need to specify all types. method -Xtrace:trigger=method{<methodspec>[,<entryAction>[,<exitAction>[,<delayCount>[,<matchcount>]]]]} On entering a method that matches <methodspec> , the specified <entryAction> is run. On leaving a method that matches <methodspec> , the specified <exitAction> is run. If you specify a <delayCount> , the actions are performed only after a matching <methodspec> has been entered that many times. If you specify a <matchCount> , <entryAction> and <exitAction> are performed at most that many times. <methodspec> is the specification of a Java method, consisting of a class and a method name separated by a dot. For example, specify HelloWorld.main . If the class is in a package, the package name must be included, separated by slashes. For example, specify java/lang/String.getBytes . A wildcard \"*\" can be used at the start or end of the class and method names, or both. For example, you can specify */String.get* . To specify a constructor method, use <init> as the method name. Method signatures cannot be specified, so a method specification applies to all overloaded methods. tracepoint ID -Xtrace:trigger=tpnid{<tpnid>|<tpnidRange>,<action>[,<delayCount>[,<matchcount>]]} On finding the specified active tracepoint ID ( <tpnid> ) or a tracepoint ID) that falls inside the specified <tpnidRange> , the specified action is run . If you specify a <delayCount> , the action is performed only after the VM finds such an active <tpnid> that many times. If you specify a <matchCount> , <action> is performed at most that many times. group -Xtrace:trigger=group{<groupname>,<action>[,<delayCount>[,<matchcount>]]} On finding any active tracepoint that is defined as being in trace group <groupname> , for example Entry or Exit , the specified action is run . If you specify a <delayCount> , the action is performed only after that many active tracepoints from group <groupname> have been found. If you specify a <matchCount> , <action> is performed at most that many times. Actions Wherever an action ( <action> , <entryAction> , or <exitAction> ) must be specified in one of the trigger parameter clauses, you must select from these options: <action> Effect abort Halt the VM. ceedump This action is applicable to z/OS\u00ae only. For more information, see z/OS LE CEEDUMPs. coredump See sysdump . heapdump Produce a Heapdump. See Using Heapdump . javadump Produce a Javadump. See Using Javadump . jstacktrace Examine the Java stack of the current thread and generate auxiliary tracepoints for each stack frame. The auxiliary tracepoints are written to the same destination as the tracepoint or method trace that triggered the action. You can control the number of stack frames examined with the stackdepth=n option. See the stackdepth option. resume Resume all tracing (except for threads that are suspended by the action of the resumecount property and Trace.suspendThis() calls). resumethis Decrement the suspend count for this thread. If the suspend count is zero or less, resume tracing for this thread. sigsev Cause a segmentation violation. (Intended for use in debugging.) sleep Delay the current thread for a length of time controlled by the sleeptime option. The default is 30 seconds. See sleeptime option. snap Snap all active trace buffers to a file in the current working directory. The file name has the format: Snapnnnn.yyyymmdd.hhmmssth.ppppp.trc , where nnnn is the sequence number of the snap file since VM startup, yyyymmdd is the date, hhmmssth is the time, and ppppp is the process ID in decimal with leading zeros removed. suspend Suspend all tracing (except for special trace points). suspendthis Increment the suspend count for this thread. If the suspend-count is greater than zero, prevent all tracing for this thread. sysdump (or coredump ) Produce a system dump. See Dump agents( -Xdump:system ) . Here are some examples of using the trigger option: To produce a Java dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump} To produce a system dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,sysdump} To produce a Java dump when a class constructor is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<init>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a class static initializer is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<clinit>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a method is entered 1000 times and 1001 times, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump,,1000,2} To start tracing this thread when it enters any method in java/lang/String , and to stop tracing the thread after exiting the method, specify the following command: -Xtrace:resumecount=1 -Xtrace:trigger=method{java/lang/String.*,resumethis,suspendthis} To resume all tracing when any thread enters a method in any class that starts with error , specify the following command: -Xtrace:trigger=method{*.error*,resume} To trace (all threads) while the application is active; that is, not starting or shut down. (The application name is HelloWorld ), specify the following command: -Xtrace:suspend,trigger=method{HelloWorld.main,resume,suspend} To print a Java stack trace to the console when the mycomponent.1 tracepoint is reached, specify the following command: -Xtrace:print=mycomponent.1,trigger=tpnid{mycomponent.1,jstacktrace} To write a Java stack trace to the trace output file when the Sample.code() method is called, specify the following command: -Xtrace:maximal=mt,output=trc.out,methods={mycompany/mypackage/Sample.code},trigger=method{mycompany/mypackage/Sample.code,jstacktrace} what -Xtrace:what Shows the current trace settings See also Application trace Using Heapdump Using Javadump Dump viewer","title":"-Xtrace"},{"location":"xtrace/#-xtrace","text":"OpenJ9 VM tracing is a powerful feature to help you diagnose problems with minimal effect on performance. Tracing is enabled by default, together with a small set of trace points going to memory buffers. You can enable tracepoints at run time by using levels, components, group names, or individual tracepoint identifiers to trace VM internal operations and instrumented Java\u2122 applications. You can also trace Java methods. See the About trace section that follows for more detail. Trace data can be output in human-readable or in compressed binary formats. The VM provides a tool to process and convert the compressed binary data into a readable format. See Trace formatter . Note: You can also control trace by using the com.ibm.jvm.Trace API or by using JVMTI from an external agent.","title":"-Xtrace"},{"location":"xtrace/#xtrace-option-builder","text":"Use the Xtrace Option Builder tool to help you specify the correct options and avoid incompatibilities.","title":"Xtrace Option Builder"},{"location":"xtrace/#syntax","text":"-Xtrace:<parameter> You can get help with -Xtrace by using the following options: -Xtrace:help Displays general trace help -Xtrace:what Shows the current trace settings","title":"Syntax"},{"location":"xtrace/#configuring-trace","text":"The following parameters can be used to configure trace. (Follow links for more information about individual options.) Command Result -Xtrace:properties[=<filename>] Configures trace options based on a file -Xtrace:buffers=<size>[dynamic\\|nodynamic] Modifies the size of buffers that are used to store trace data -Xtrace:exception.output=<filename>[,<size>] Redirects exceptions trace data to a file. -Xtrace:methods=<method_specification> Traces methods -Xtrace:output=<filename>[,<size>[,<generations>]] Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:resume Resumes tracing globally. -Xtrace:resumecount=<count> Enables tracing at a thread level after a specified count. -Xtrace:sleeptime=<time> Pauses trace operations for a specified length of time. -Xtrace:stackdepth=<n> Limits the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:suspend Suspends tracing globally. -Xtrace:suspendcount=<count> Suspends tracing at a thread level after a specified count. -Xtrace:trigger=<clause> Determines when various triggered trace actions occur, including turning trace on or off. Note: If an option value contains commas, it must be enclosed in braces. For example: methods={java/lang/*,com/ibm/*}","title":"Configuring trace"},{"location":"xtrace/#controlling-tracepoint-activation","text":"The following parameters can be used to control tracepoint activation. (Follow links for more information about individual options.) Command Result -Xtrace:maximal=<tracepoint_specification> Records all associated data. -Xtrace:minimal=<tracepoint_specification> Records only the time stamp and tracepoint identifier. -Xtrace:count=<tracepoint_specification> Counts the tracepoints that are used in a trace configuration. -Xtrace:print=<tracepoint_specification> Prints the specified tracepoints to stderr in real time. -Xtrace:iprint=<tracepoint_specification> Prints the specified tracepoints to stderr in real time with indentation. -Xtrace:exception=<tracepoint_specification> Enables exception tracing. -Xtrace:external<tracepoint_specification> Routes trace data to trace listeners, which are registered by using the JVMTI APIs. -Xtrace:none[=<tracepoint_specification>] Prevents the trace engine from loading if it is the only trace option specified. Note: These options control which individual tracepoints are activated at run time and the implicit destination of the trace data. All these properties are independent of each other and can be mixed and matched in any way that you choose. For more information, see Tracepoint activation .","title":"Controlling tracepoint activation"},{"location":"xtrace/#about-trace","text":"With the OpenJ9 trace feature, you can trace VM internal operations, Java applications, and Java methods, or any combination of these. VM internal operations The OpenJ9 virtual machine (VM) is extensively instrumented with tracepoints for tracing operations. Interpreting this trace data requires detailed knowledge of the VM, and is intended to diagnose VM problems. No guarantee is given that tracepoints will not vary from release to release and from platform to platform. Applications VM trace contains an application trace facility that allows tracepoints to be placed in Java code, enabling you to combine trace data with the other forms of trace. This capability is supported by the com.ibm.jvm.Trace API. Note that an instrumented Java application runs only on an OpenJ9 VM. For more information, see Application trace . Java methods Use method trace to debug and trace application code and the system classes provided with the VM. You can trace entry to and exit from Java methods run by the VM. You can select method trace by classname, method name, or both. You can also use wildcards to create complex method selections. For more information about command syntax, see methods . Trace can produce large amounts of data in a very short time. Before running trace, think carefully about what information you need in order to solve the problem. Here are some considerations: If you need only the trace information that is produced shortly before the problem occurs, consider wrapping the file by using the output option. In many cases, just use internal trace with an increased buffer size and snap the trace when the problem occurs. If the problem results in a thread stack dump or operating system signal or exception, trace buffers are snapped automatically to a file that is in the current directory. The file is called: Snapnnnn. yyyymmdd.hhmmssth.process.trc . You must also think carefully about which components need to be traced and what level of tracing is required. For example, if you are tracing a suspected shared classes problem, it might be enough to trace all components at level 1, and j9shr at level 9, while maximal can be used to show parameters and other information for the failing component. Tracepoint components and trace levels are described in the following sections: Tracepoint specification and Trace levels . There are two types of tracepoints inside the VM: Regular tracepoints include method tracepoints, application tracepoints, data tracepoints inside the VM and data tracepoints inside class libraries. You can display regular tracepoint data on the screen or save the data to a file. You can also use command line options to trigger specific actions when regular tracepoints fire. Auxiliary tracepoints are a special type of tracepoint that can be fired only when another tracepoint is being processed. For example, the stack frame information produced by the jstacktrace -Xtrace:trigger command. You cannot control where auxiliary tracepoint data is sent and you cannot set triggers on auxiliary tracepoints. Auxiliary tracepoint data is sent to the same destination as the tracepoint that caused them to be generated. Trace data can be written to one of the following locations: Memory buffers that can be dumped or snapped when a problem occurs. Use the -Xtrace:buffers=<size> option to control the size of the buffer allocated to each thread. Buffers allocated to a thread are discarded when that thread terminates. To examine the trace data captured in these memory buffers, you must snap or dump the data, then format the buffers. One or more files that are using buffered I/O. Use the -Xtrace:output option. An external agent in real time, using the -Xtrace:external option. stderr in real time. Any combination of the other items in this list.","title":"About trace"},{"location":"xtrace/#default-tracing","text":"By default, the equivalent of the following trace command line is always available in the VM: -Xtrace:maximal=all{level1},exception=j9mm{gclogger} When startup is complete, the equivalent of the following command line is added to enable level 2 trace points: -Xtrace:maximal=all{level2} Level 2 is used for default tracing that would produce too much data during the startup of the VM. If you set other trace options on the command line, or before the VM finishes startup (through use of JVMTI or the com.ibm.jvm.Trace API), the level 2 trace points are enabled just before your trace options are processed. This behavior ensures that the default level 2 trace points do not override any changes that you specify. The data generated by the tracepoints is continuously captured in wrapping memory buffers for each thread. You can find tracepoint information in the following diagnostics data: System memory dumps, extracted by using jdmpview. Snap traces, generated when the VM encounters a problem or an output file is specified. Using dump agents describes more ways to create a snap trace. For exception trace only, in Javadumps.","title":"Default tracing"},{"location":"xtrace/#default-memory-management-tracing","text":"The default trace options are designed to ensure that Javadumps always contain a record of the most recent memory management history, regardless of how much work the VM has performed since the garbage collection cycle was last called. The exception=j9mm{gclogger} clause of the default trace set specifies that a history of garbage collection cycles that have occurred in the VM is continuously recorded. The gclogger group of tracepoints in the j9mm component constitutes a set of tracepoints that record a snapshot of each garbage collection cycle. These tracepoints are recorded in their own separate buffer, called the exception buffer. The effect is that the tracepoints are not overwritten by the higher frequency tracepoints of the VM. The GC History section of the Javadump is based on the information in the exception buffer. If a garbage collection cycle has occurred in a traced VM, the Java dump probably contains a GC History section.","title":"Default memory management tracing"},{"location":"xtrace/#default-assertion-tracing","text":"The VM includes assertions, implemented as special trace points. By default, internal assertions are detected and diagnostics logs are produced to help assess the error. Assertion failures often indicate a serious problem, and the VM usually stops immediately. In these circumstances, raise an issue, including the standard error output and any diagnostic files that are produced. When an assertion trace point is reached, a message like the following output is produced on the standard error stream: 16:43:48.671 0x10a4800 j9vm.209 * ** ASSERTION FAILED ** at jniinv.c:251: ((javaVM == ((void *)0))) This error stream is followed with information about the diagnostic logs produced: JVMDUMP007I JVM Requesting System Dump using 'core.20060426.124348.976.dmp' JVMDUMP010I System Dump written to core.20060426.124348.976.dmp JVMDUMP007I JVM Requesting Snap Dump using 'Snap0001.20060426.124648.976.trc' JVMDUMP010I Snap Dump written to Snap0001.20060426.124648.976.trc Assertions are special trace points. They can be enabled or disabled by using the standard trace command-line options. Assertion failures might occur early during VM startup, before trace is enabled. In this case, the assert message has a different format, and is not prefixed by a timestamp or thread ID. For example: ** ASSERTION FAILED ** j9vmutil.15 at thrinfo.c:371 Assert_VMUtil_true(( publicFlags & 0x200)) Assertion failures that occur early during startup cannot be disabled. These failures do not produce diagnostic dumps, and do not cause the VM to stop.","title":"Default assertion tracing"},{"location":"xtrace/#tracepoint-activation","text":"The options that control which individual tracepoints are activated at run time and the implicit destination of the trace data are listed under Syntax: Controlling tracepoint activation In some cases, you must use them with other options. For example, if you specify maximal or minimal tracepoints, the trace data is put into memory buffers. If you are going to send the data to a file, you must use an output option to specify the destination file name. With the exception of none , all options require at least one <tracepoint_specification> , which is described in the following section. Multiple statements of each type of trace are allowed and their effect is cumulative. If you want to use multiple trace options of the same name, use a properties file. (See properties .)","title":"Tracepoint activation"},{"location":"xtrace/#tracepoint-specification","text":"Tracepoints are enabled by specifying component and tracepoint . If no qualifier parameters are entered, all tracepoints are enabled, except for <exception.output> trace, where the default is all {exception}. The <tracepoint_specification> syntax can be further broken down as follows: [!]<component>[{<group>}] or [!]<component>[{<type>}] or [!]<tracepoint_id>[,<tracepoint_id>] Where: The ! symbol is a logical not . That is, the tracepoints that are in a specification starting with ! are turned off. <component> is a Java component. <group> is a tracepoint group, which is a set of tracepoints that are defined within a component. <type> is the tracepoint type: entry , exit , event , exception , and eem . <tracepoint_id> is the tracepoint identifier. The tracepoint identifier constitutes the component name of the tracepoint, followed by its integer number inside that component. For example, j9mm.49 , j9shr.20-29 , j9vm.15 . To understand these numbers, see Determining the tracepoint ID of a tracepoint. Some tracepoints can be both an exit and an exception ; that is, the function ended with an error. If you specify either exit or exception , these tracepoints are included. Lists of Java components and tracepoint groups can be found in the tables that follow. The following table lists the possible Java components ( <component> ). To include all Java components, specify all . Component name Description avl VM AVL tree support io Class library java.io native code j9bcu VM byte code utilities j9bcverify VM byte code verification j9codertvm VM byte code run time j9dmp VM dump j9jcl VM class libraries j9jit VM JIT interface j9jni VM JNI support j9jvmti VM JVMTI support j9mm VM memory management j9prt VM port library j9scar VM class library interface j9shr VM shared classes j9trc VM trace j9util VM utilities j9vm VM general j9vmutil VM utilities j9vrb VM verbose stack walker map VM mapped memory support mt Java methods (see Note ) net Class library TCP/IP networking native code pool VM storage pool support rpc VM RPC support simplepool VM storage pool support sunvmi VM class library interface Note: When specifying the mt component you must also specify the methods option. The following table lists all the tracepoint groups ( <group> ). Each group is associated with one or more Java components: Component name or names Group name Description j9mm gclogger A set of tracepoints that record each garbage collection cycle. Equivalent to -verbose:gc output j9prt nlsmessage A set of tracepoints that record each NLS message that is issued by the VM. j9jcl , j9vm verboseclass A set of tracepoints that record each class as it is loaded. Equivalent to -verbose:class output. j9jni , j9vm checkjni A set of tracepoints that record JNI function checks. Equivalent to -Xcheck:jni output. j9vm checkmemory A set of tracepoints that record memory checks. Equivalent to -Xcheck:memory output. j9vm checkvm A set of tracepoints that record VM checks. Equivalent to -Xcheck:vm output. j9jit verbose A set of tracepoints that record JIT compiler configuration and method compilation. Equivalent to -Xjit:verbose output. mt compiledMethods A set of tracepoints that record compiled Java methods. mt nativeMethods A set of tracepoints that record Java native methods. mt staticMethods A set of tracepoints that record Java static methods. Here are some examples: To trace all tracepoints, specify the following command: -Xtrace:maximal=all To trace all tracepoints except **j9vrb** and **j9trc**, specify the following command: -Xtrace:minimal={all},minimal={!j9vrb,j9trc} To trace all entry and exit tracepoints in j9bcu , specify the following command: -Xtrace:maximal={j9bcu{entry},j9bcu{exit}} To trace all tracepoints in **j9mm** except tracepoints 20-30, specify the following command: -Xtrace:maximal=j9mm,maximal=!j9mm.20-30 To trace tracepoints j9prt.5 through j9prt.15 , specify the following command: -Xtrace:print=j9prt.5-15 To trace all **j9trc** tracepoints, specify the following command: -Xtrace:count=j9trc To trace all entry and exit tracepoints, specify the following command: -Xtrace:external={all{entry},all{exit}}","title":"Tracepoint specification"},{"location":"xtrace/#trace-levels","text":"Tracepoints have been assigned levels 0 through 9 that are based on the importance of the tracepoint. A level 0 tracepoint is the most important. It is reserved for extraordinary events and errors. A level 9 tracepoint is in-depth component detail. To specify a given level of tracing, the level0 through level9 keywords are used. You can abbreviate these keywords to l0 through l9. For example, if level5 is selected, all tracepoints that have levels 0 through 5 are included. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. The level is provided as a modifier to a component specification, for example: -Xtrace:maximal={all{level5}} or -Xtrace:maximal={j9mm{L2},j9trc,j9bcu{level9},all{level1}} In the first example, tracepoints that have a level of 5 or less are enabled for all components. In the second example, all level 1 tracepoints are enabled. All level 2 tracepoints in j9mm are enabled. All tracepoints up to level 9 are enabled in j9bcu . Note: The level applies only to the current component. If multiple trace selection components are found in a trace properties file, the level is reset to the default for each new component. Level specifications do not apply to explicit tracepoint specifications that use the TPNID keyword. When the not operator is specified, the level is inverted; that is, !j9mm{level5} disables all tracepoints of level 6 or greater for the j9mm component. The following example enables trace for all components at level 9 (the default), but disables level 6 and higher for the locking component, and level 7 and higher for the storage component: -Xtrace:print={all},print={!j9trc{l5},j9mm{l6}} Here are some examples: To count the level zero and level one tracepoints matched, specify the following command: -Xtrace:count=all{L1} To produce maximal trace of all components at level 5 and j9mm at level 9, specify the following command: -Xtrace:maximal={all{level5},j9mm{L9}} To trace all components at level 6, but do not trace j9vrb at all, and do not trace the entry and exit tracepoints in the j9trc component, specify the following command: -Xtrace:minimal={all{l6}},minimal={!j9vrb,j9trc{entry},j9trc{exit}}","title":"Trace levels"},{"location":"xtrace/#parameters","text":"Parameters to use with the -Xtrace option:","title":"Parameters"},{"location":"xtrace/#buffers","text":"You can modify the size of the buffers to change how much diagnostic output is provided in a snap dump. This buffer is allocated for each thread that makes trace entries. The following table shows how this parameter can be set: Command Effect -Xtrace:buffers=<size> Creates buffers of the specified <size> in k (KB) or m (MB), allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>dynamic Creates buffers of the specified <size> , allocated as needed to match the rate of trace data generation to the output media. -Xtrace:buffers=<size>nodynamic Creates buffers of the specified <size> , with a maximum allocation of two buffers per thread. If external trace is enabled, the number of buffers is doubled; that is, each thread allocates two or more buffers. The same buffer size is used for state and exception tracing, but, in this case, buffers are allocated globally. The default is 8 KB per thread. The dynamic and nodynamic suboptions have meaning only when tracing to an output file. Note: If nodynamic is specified, you might lose trace data if the volume of trace data exceeds the bandwidth of the trace output file. Message UTE115 is issued when the first trace entry is lost, and message UTE018 is issued when the VM ends. Here are some command line examples: To set a buffer size of 2 MB per thread, with dynamic buffering, use: -Xtrace:buffers=2m To limit each thread to 2 trace buffers, each of 128 KB: -Xtrace:buffers={128k,nodynamic}","title":"buffers"},{"location":"xtrace/#count-tracepoint","text":"-Xtrace:count=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The count option requests that only a count of the selected tracepoints is kept. When the VM ends, all nonzero totals of tracepoints (sorted by tracepoint id) are written to a file, called utTrcCounters , in the current directory. This information is useful if you want to determine the overhead of particular tracepoints, but do not want to produce a large amount (GB) of trace data. For example, to count the tracepoints that are used in the default trace configuration, use the following command: -Xtrace:count=all{level1},count=j9mm{gclogger}","title":"count (tracepoint)"},{"location":"xtrace/#exception-tracepoint","text":"-Xtrace:exception=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When exception trace is enabled, the trace data is collected in internal buffers that are separate from the normal buffers. These internal buffers can then be written to a snap file or written to the file that is specified in an exception.output option. The exception option allows low-volume tracing in buffers and files that are distinct from the higher-volume information that minimal and maximal tracing have provided. In most cases, this information is exception-type data, but you can use this option to capture any trace data that you want. This form of tracing is channeled through a single set of buffers, as opposed to the buffer-per-thread approach for normal trace. Buffer contention might occur if high volumes of trace data are collected. A difference exists in the <tracepoint_specification> defaults for exception tracing; see Tracepoint specification . Notes: The exception trace buffers are intended for low-volume tracing. By default, the exception trace buffers log garbage collection (GC) event tracepoints, see Default tracing. You can send additional tracepoints to the exception buffers or turn off the GC tracepoints. Changing the exception trace buffers alters the contents of the GC History section in any Javadumps. When exception trace is entered for an active tracepoint, the current thread ID is checked against the previous caller's thread ID. If it is a different thread, or this is the first call to exception trace, a context tracepoint is put into the trace buffer first. This context tracepoint consists only of the current thread ID, which is necessary because of the single set of buffers for exception trace. (The formatter identifies all trace entries as coming from the Exception trace pseudo thread when it formats exception trace files.)","title":"exception (tracepoint)"},{"location":"xtrace/#exceptionoutput","text":"Use exception output to redirect exceptions trace data to a file. -Xtrace:exception.output=<filename>[,<size>] Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d% (today's date in \" yyyymmdd\" format), %p (process ID number of the process generating the trace), or %t% (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps nondestructively to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Here are some examples: Exception trace output goes to file /u/traces/exception.trc with no size limit: -Xtrace:exception.output=/u/traces/exception.trc,maximal Exception trace output goes to file except and wraps at 2 MB: -Xtrace:exception.output={except,2m},maximal Exception trace output goes to a file whose filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:exception.output=traceout.%d.trc,maximal Exception trace output goes to a file whose filename contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:exception.output=tracefrompid%p.trc,maximal Exception trace output goes to a file whose filename contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:exception.output=traceout.%t.trc,maximal","title":"exception.output"},{"location":"xtrace/#external-tracepoint","text":"-Xtrace:external<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The external option routes trace data to trace listeners, which are registered by using the JVMTI RegisterTracePointSubscriber() and DeregisterTracePointSubscriber() APIs.","title":"external (tracepoint)"},{"location":"xtrace/#help","text":"-Xtrace:help Displays general trace help","title":"help"},{"location":"xtrace/#iprint-tracepoint","text":"-Xtrace:iprint=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The iprint option is the same as the print option, but uses indenting to format the trace.","title":"iprint (tracepoint)"},{"location":"xtrace/#maximal-tracepoint","text":"-Xtrace:maximal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. All associated data is traced. minimal and maximal traces are independent from any types that follow them. For example, if the maximal option is specified, it does not affect a later option such as print .","title":"maximal (tracepoint)"},{"location":"xtrace/#methods","text":"Using method trace provides a complete and potentially large diagnosis of code paths inside your application and the system classes. Use wild cards and filtering to control method trace so that you can focus on the sections of code that interest you. To specify one or more method specifications, use the following syntax: -Xtrace:methods=<method_specification>[,<method_specification>] The syntax for <method_specification> can be further broken down to the following suboptions: -Xtrace:methods={[!][*][<package>/]<class>[*],[[*]<method>[*]|[()]]} Where: The delimiter between parts of the package name is a forward slash, \"/\". The ! in the methods parameter is a NOT operator that allows you to tell the VM not to trace the specified method or methods. The parentheses, (), define whether or not to include method parameters in the trace. If a method specification includes any commas, the whole specification must be enclosed in braces, for example: -Xtrace:methods={java/lang/*,java/util/*},print=mt It might be necessary to enclose your command line in quotation marks to prevent the shell intercepting and fragmenting comma-separated command lines, for example: \"-Xtrace:methods={java/lang/*,java/util/*},print=mt\" To output all method trace information to stderr, use either the print or iprint suboptions: -Xtrace:print=mt,methods=*.* -Xtrace:iprint=mt,methods=*.* The iprint suboption prints to stderr with indentation. To output method trace information in binary format, see the output option. Here are some examples: Tracing entry and exit of all methods in a given class: To trace all method entry and exit of the ReaderMain class in the default package and the java.lang.String class, specify the following command: -Xtrace:methods={ReaderMain.*,java/lang/String.*},print=mt Tracing entry, exit and input parameters of all methods in a class: To trace all method entry, exit, and input of the ReaderMain class in the default package, specify the following command: -Xtrace:methods=ReaderMain.*(),print=mt Tracing all methods in a given package: To trace all method entry, exit, and input of all classes in the package com.ibm.socket , specify the following command: -Xtrace:methods=com/ibm/socket/*.*(),print=mt Multiple method trace: To trace all method entry, exit, and input in the Widget class in the default package and all method entry and exit in the common package, specify the following command: -Xtrace:methods={Widget.*(),common/*},print=mt Using the ! operator: To trace all methods in the ArticleUI class in the default package except those beginning with \"get\", specify the following command: -Xtrace:methods={ArticleUI.*,!ArticleUI.get*},print=mt Tracing a specific method in a class: This example traces entry and exit of the substring method of the java.lang.String class . If there is more than one method with the same name, they are all traced. You cannot filter method trace by the signature of the method. -Xtrace:print=mt,methods={java/lang/String.substring} Tracing the constructor of a class: This example traces entry and exit of the constructors of the java.lang.String class. -Xtrace:print=mt,methods={java/lang/String.<init>} Here is some example output: java \"-Xtrace:methods={java/lang*.*},iprint=mt\" HW 10:02:42.281*0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.281 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.281 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/String.<clinit>()V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.296 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.verify(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method 10:02:42.328 0x9e900 mt.4 > java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.setInitStatus(Ljava/lang/Class;I) V Compiled static method 10:02:42.328 0x9e900 mt.10 < java/lang/J9VMInternals.initialize(Ljava/lang/Class;) V Compiled static method The output lines comprise of: 0x9e900 , the current execenv (execution environment). Because every VM thread has its own execenv , you can regard execenv as a thread-id . All trace with the same execenv relates to a single thread. The individual tracepoint ID in the mt component that collects and emits the data. The remaining fields show whether a method is being entered (>) or exited (<), followed by details of the method.","title":"methods"},{"location":"xtrace/#minimal-tracepoint","text":"-Xtrace:minimal=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . When specified, trace data is placed into internal trace buffers that can then be written to a snap file or written to the files that are specified in an output trace option. Only the time stamp and tracepoint identifier are recorded. When the trace is formatted, missing trace data is replaced with the characters \"???\" in the output file. minimal and maximal traces are independent from any types that follow them. For example, if the minimal option is specified, it does not affect a later option such as print .","title":"minimal (tracepoint)"},{"location":"xtrace/#none-tracepoint","text":"-Xtrace:none[=<tracepoint_specification>] For further information about <tracepoint_specification> syntax, see Tracepoint specification . -Xtrace:none prevents the trace engine from loading if it is the only trace option specified. However, if other -Xtrace options are on the command line, it is treated as the equivalent of -Xtrace:none=all and the trace engine still loads. If you specify other tracepoints without specifying -Xtrace:none , the tracepoints are added to the default set.","title":"none (tracepoint)"},{"location":"xtrace/#output","text":"Sends trace data to a file, optionally of a specific size and number of generations. -Xtrace:output=<filename>[,<size>[,<generations>]]` Where: <filename> is a file name, which is created automatically if it does not exist. Otherwise, it is overwritten. To embed specific values in the file name use any of the following variables: %d% (today's date in \" yyyymmdd\" format), %p% (process ID number of the process generating the trace), or %t% (time in 24-hour hhmmss format). Optionally, <size> is a value in megabytes (MB), for example, use 4m to specify 4 MB. When full, it wraps to the beginning. If you do not limit the file, it grows indefinitely, until limited by disk space. Optionally, <generations> is a value 2 through 36. These values cause up to 36 files to be used sequentially as each file reaches its <size> threshold. When a file needs to be reused, it is overwritten. If <generations> is specified, the filename must contain a # (hash, pound symbol), which will be substituted with its generation identifier, the sequence of which is 0 through 9 followed by A through Z. Note: When tracing to a file, buffers for each thread are written when the buffer is full or when the VM ends. If a thread has been inactive for a period of time before the VM ends, what seems to be 'old' trace data is written to the file. When formatted, it then seems that trace data is missing from the other threads, but this is an unavoidable side-effect of the buffer-per-thread design. This effect becomes especially noticeable when you use the generation facility, and format individual earlier generations. Here are some examples: Trace output goes to file /u/traces/gc.problem with no size limit: -Xtrace:output=/u/traces/gc.problem,maximal=j9gc Trace output goes to file trace , which will wrap at 2 MB: -Xtrace:output={trace,2m},maximal=j9gc Trace output goes to files gc0.trc , gc1.trc , and gc2.trc , each 10 MB in size: -Xtrace:output={gc#.trc,10m,3},maximal=j9gc Trace output goes to a file, where the filename contains today's date in * yyyymmdd* format (for example, traceout.20181025.trc ): -Xtrace:output=traceout.%d.trc,maximal=j9gc Trace output goes to a file whose name contains the number of the process (the PID number) that generated it (for example, tracefrompid2112.trc ): -Xtrace:output=tracefrompid%p.trc,maximal=j9gc Trace output goes to a file whose name contains the time in hhmmss format (for example, traceout.080312.trc ): -Xtrace:output=traceout.%t.trc,maximal=j9gc","title":"output"},{"location":"xtrace/#print-tracepoint","text":"-Xtrace:print=<tracepoint_specification> For further information about <tracepoint_specification> syntax, see Tracepoint specification . The print option causes the specified tracepoints to be routed to stderr in real time. The VM tracepoints are formatted by using J9TraceFormat.dat . The class library tracepoints are formatted by J9TraceFormat.dat and TraceFormat.dat .","title":"print (tracepoint)"},{"location":"xtrace/#properties","text":"You can use properties files to control trace. A properties file saves typing and allows you to create a library of files that are tailored to solving problems in a particular area. -Xtrace:properties[=<filename>] If <filename> is not specified, the VM searches for a default name of IBMTRACE.properties in the current directory. All the options that are in the file are processed in the sequence in which they are stored in the file, before the next option that is obtained through the normal mechanism is processed. Therefore, a command-line property always overrides a property that is in the file. Here is an example of a properties file: minimal=all // maximal=j9mm maximal=j9shr buffers=128k,nodynamic output=c:\\traces\\classloader.trc print=tpnid(j9vm.23-25) The following restrictions apply to the file: The file must be a flat ASCII file. Nesting is not supported; that is, the file cannot contain a properties option. You cannot leave properties that have the form <name>=<value> to default if they are specified in the property file; that is, you must specify a value, for example maximal=all . Do not add white space before, after, or within the trace options. If any error is found when the file is accessed, VM initialization fails with an explanatory error message and return code. To use a file trace.props stored in the c:\\trc\\gc directory, specify the following command: -Xtrace:properties=c:\\trc\\gc\\trace.props","title":"properties"},{"location":"xtrace/#resume","text":"The resume option resumes tracing globally. -Xtrace:resume The suspend and resume options are not recursive. That is, two suspends that are followed by a single resume cause trace to be resumed.","title":"resume"},{"location":"xtrace/#resumecount","text":"This trace option determines whether tracing is enabled for each thread. -Xtrace:resumecount=<count> If <count> is greater than zero, each thread initially has its tracing disabled and must receive <count> resumethis actions before it starts tracing. This option is used with the trigger option. Note: You cannot use resumecount and suspendcount together because they use the same internal counter. The following example starts with all tracing turned off. Each thread starts tracing when it has had three resumethis actions performed on it: -Xtrace:resumecount=3","title":"resumecount"},{"location":"xtrace/#sleeptime","text":"You can specify how long the sleep lasts when using the sleep trigger action. -Xtrace:sleeptime=nnn|aaams|bbbs Where: nnn sleeps for nnn milliseconds. aaams sleeps for aaa milliseconds. bbbs sleeps for bbb seconds. The default length of time is 30 seconds. If no units are specified, the default time unit is milliseconds.","title":"sleeptime"},{"location":"xtrace/#stackdepth","text":"Use this option to limit the maximum number of stack frames reported by the jstacktrace trace trigger action. -Xtrace:stackdepth=<n> Where <n> is the maximum number of stack frames reported.","title":"stackdepth"},{"location":"xtrace/#suspend","text":"-Xtrace:suspend Suspends tracing globally for all threads and all forms of tracing but leaves tracepoints activated.","title":"suspend"},{"location":"xtrace/#suspendcount","text":"This trace option determines whether tracing is enabled for each thread. -Xtrace:suspendcount=<count> If <count> is greater than zero, each thread initially has its tracing enabled and must receive <count> suspendthis actions before it stops tracing. You cannot use resumecount and suspendcount together because they both set the same internal counter. This trace option is for use with the trigger option. The following example starts with tracing turned on. Each thread stops tracing when it has had three suspendthis actions performed on it: -Xtrace:suspendcount=3","title":"suspendcount"},{"location":"xtrace/#trigger","text":"The trigger parameter determines when various triggered trace actions occur. Supported actions include turning tracing on and off for all threads, turning tracing on or off for the current thread, or producing various dumps. -Xtrace:trigger=<clause>[,<clause>] This trace option does not control what is traced. It controls only whether the information that has been selected by the other trace options is produced as normal or is blocked.","title":"trigger"},{"location":"xtrace/#types","text":"Each clause of the trigger parameter can be one of the following types: a method ( -Xtrace:trigger=method{...} ) a tracepoint ID ( -Xtrace:trigger=tpnid{...} ) a group ( -Xtrace:trigger=group{...} ) You can specify multiple clauses of the same type if required, but you do not need to specify all types. method -Xtrace:trigger=method{<methodspec>[,<entryAction>[,<exitAction>[,<delayCount>[,<matchcount>]]]]} On entering a method that matches <methodspec> , the specified <entryAction> is run. On leaving a method that matches <methodspec> , the specified <exitAction> is run. If you specify a <delayCount> , the actions are performed only after a matching <methodspec> has been entered that many times. If you specify a <matchCount> , <entryAction> and <exitAction> are performed at most that many times. <methodspec> is the specification of a Java method, consisting of a class and a method name separated by a dot. For example, specify HelloWorld.main . If the class is in a package, the package name must be included, separated by slashes. For example, specify java/lang/String.getBytes . A wildcard \"*\" can be used at the start or end of the class and method names, or both. For example, you can specify */String.get* . To specify a constructor method, use <init> as the method name. Method signatures cannot be specified, so a method specification applies to all overloaded methods. tracepoint ID -Xtrace:trigger=tpnid{<tpnid>|<tpnidRange>,<action>[,<delayCount>[,<matchcount>]]} On finding the specified active tracepoint ID ( <tpnid> ) or a tracepoint ID) that falls inside the specified <tpnidRange> , the specified action is run . If you specify a <delayCount> , the action is performed only after the VM finds such an active <tpnid> that many times. If you specify a <matchCount> , <action> is performed at most that many times. group -Xtrace:trigger=group{<groupname>,<action>[,<delayCount>[,<matchcount>]]} On finding any active tracepoint that is defined as being in trace group <groupname> , for example Entry or Exit , the specified action is run . If you specify a <delayCount> , the action is performed only after that many active tracepoints from group <groupname> have been found. If you specify a <matchCount> , <action> is performed at most that many times.","title":"Types"},{"location":"xtrace/#actions","text":"Wherever an action ( <action> , <entryAction> , or <exitAction> ) must be specified in one of the trigger parameter clauses, you must select from these options: <action> Effect abort Halt the VM. ceedump This action is applicable to z/OS\u00ae only. For more information, see z/OS LE CEEDUMPs. coredump See sysdump . heapdump Produce a Heapdump. See Using Heapdump . javadump Produce a Javadump. See Using Javadump . jstacktrace Examine the Java stack of the current thread and generate auxiliary tracepoints for each stack frame. The auxiliary tracepoints are written to the same destination as the tracepoint or method trace that triggered the action. You can control the number of stack frames examined with the stackdepth=n option. See the stackdepth option. resume Resume all tracing (except for threads that are suspended by the action of the resumecount property and Trace.suspendThis() calls). resumethis Decrement the suspend count for this thread. If the suspend count is zero or less, resume tracing for this thread. sigsev Cause a segmentation violation. (Intended for use in debugging.) sleep Delay the current thread for a length of time controlled by the sleeptime option. The default is 30 seconds. See sleeptime option. snap Snap all active trace buffers to a file in the current working directory. The file name has the format: Snapnnnn.yyyymmdd.hhmmssth.ppppp.trc , where nnnn is the sequence number of the snap file since VM startup, yyyymmdd is the date, hhmmssth is the time, and ppppp is the process ID in decimal with leading zeros removed. suspend Suspend all tracing (except for special trace points). suspendthis Increment the suspend count for this thread. If the suspend-count is greater than zero, prevent all tracing for this thread. sysdump (or coredump ) Produce a system dump. See Dump agents( -Xdump:system ) . Here are some examples of using the trigger option: To produce a Java dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump} To produce a system dump when a method is entered, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,sysdump} To produce a Java dump when a class constructor is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<init>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a class static initializer is called, specify the following command: \"-Xtrace:trigger=method{java/lang/Thread.<clinit>,javadump}\" Note: This trace option is enclosed in quotation marks to avoid unwanted shell expansion of some of the characters. To produce a Java dump when a method is entered 1000 times and 1001 times, specify the following command: -Xtrace:trigger=method{java/lang/String.getBytes,javadump,,1000,2} To start tracing this thread when it enters any method in java/lang/String , and to stop tracing the thread after exiting the method, specify the following command: -Xtrace:resumecount=1 -Xtrace:trigger=method{java/lang/String.*,resumethis,suspendthis} To resume all tracing when any thread enters a method in any class that starts with error , specify the following command: -Xtrace:trigger=method{*.error*,resume} To trace (all threads) while the application is active; that is, not starting or shut down. (The application name is HelloWorld ), specify the following command: -Xtrace:suspend,trigger=method{HelloWorld.main,resume,suspend} To print a Java stack trace to the console when the mycomponent.1 tracepoint is reached, specify the following command: -Xtrace:print=mycomponent.1,trigger=tpnid{mycomponent.1,jstacktrace} To write a Java stack trace to the trace output file when the Sample.code() method is called, specify the following command: -Xtrace:maximal=mt,output=trc.out,methods={mycompany/mypackage/Sample.code},trigger=method{mycompany/mypackage/Sample.code,jstacktrace}","title":"Actions"},{"location":"xtrace/#what","text":"-Xtrace:what Shows the current trace settings","title":"what"},{"location":"xtrace/#see-also","text":"Application trace Using Heapdump Using Javadump Dump viewer","title":"See also"},{"location":"xtunevirtualized/","text":"-Xtune:virtualized Optimizes OpenJ9 VM function for virtualized environments, such as a cloud, by reducing OpenJ9 VM CPU consumption when idle. Note: Performance is optimized if there is a large shared classes cache (SCC) and AOT space in the SCC is not capped. Syntax -Xtune:virtualized This option is recommended for CPU-constrained environments, such as those found in cloud deployments that use containers. Internally, the option makes the JIT compiler more conservative with inlining and recompilation decisions, which saves CPU resources. The Garbage Collector also reduces the rate of heap expansion, which reduces the memory footprint. These changes to reduce the amount of CPU that is consumed are at the expense of a small loss in throughput. When -Xtune:virtualized is used in conjunction with the -Xshareclasses option, the JIT compiler is more aggressive with its use of AOT-compiled code compared to setting only -Xshareclasses . This action provides additional CPU savings during application start-up and ramp-up, but comes at the expense of an additional small loss in throughput. See also For an example of the effect of using this option, see: Measuring the strengths of OpenJDK with Eclipse OpenJ9","title":"-Xtune:virtualized"},{"location":"xtunevirtualized/#-xtunevirtualized","text":"Optimizes OpenJ9 VM function for virtualized environments, such as a cloud, by reducing OpenJ9 VM CPU consumption when idle. Note: Performance is optimized if there is a large shared classes cache (SCC) and AOT space in the SCC is not capped.","title":"-Xtune:virtualized"},{"location":"xtunevirtualized/#syntax","text":"-Xtune:virtualized This option is recommended for CPU-constrained environments, such as those found in cloud deployments that use containers. Internally, the option makes the JIT compiler more conservative with inlining and recompilation decisions, which saves CPU resources. The Garbage Collector also reduces the rate of heap expansion, which reduces the memory footprint. These changes to reduce the amount of CPU that is consumed are at the expense of a small loss in throughput. When -Xtune:virtualized is used in conjunction with the -Xshareclasses option, the JIT compiler is more aggressive with its use of AOT-compiled code compared to setting only -Xshareclasses . This action provides additional CPU savings during application start-up and ramp-up, but comes at the expense of an additional small loss in throughput.","title":"Syntax"},{"location":"xtunevirtualized/#see-also","text":"For an example of the effect of using this option, see: Measuring the strengths of OpenJDK with Eclipse OpenJ9","title":"See also"},{"location":"xverbosegclog/","text":"-Xverbosegclog Causes garbage collection (GC) output from the -verbose:gc option to be written to a specified file. Syntax -Xverbosegclog[:<filename>[,<x>,<y>]] where <filename> is the name of the file to which output is written. Dump agent tokens can be used in the filename. If the file cannot be found, the file is created, and output is written to the new file. If the file cannot be created (for example, if an invalid filename is specified), output is redirected to stderr . If you do not specify a file name, verbosegc.%Y%m%d.%H%M%S.%pid.txt is used (for example, verbosegc.20180124.093210.1234.txt ). If you specify <x> and <y> , output is redirected to x files, each containing y GC cycles. Default behavior By default, no verbose GC logging occurs. See also Dump agent tokens for more information.","title":"-Xverbosegclog"},{"location":"xverbosegclog/#-xverbosegclog","text":"Causes garbage collection (GC) output from the -verbose:gc option to be written to a specified file.","title":"-Xverbosegclog"},{"location":"xverbosegclog/#syntax","text":"-Xverbosegclog[:<filename>[,<x>,<y>]] where <filename> is the name of the file to which output is written. Dump agent tokens can be used in the filename. If the file cannot be found, the file is created, and output is written to the new file. If the file cannot be created (for example, if an invalid filename is specified), output is redirected to stderr . If you do not specify a file name, verbosegc.%Y%m%d.%H%M%S.%pid.txt is used (for example, verbosegc.20180124.093210.1234.txt ). If you specify <x> and <y> , output is redirected to x files, each containing y GC cycles.","title":"Syntax"},{"location":"xverbosegclog/#default-behavior","text":"By default, no verbose GC logging occurs.","title":"Default behavior"},{"location":"xverbosegclog/#see-also","text":"Dump agent tokens for more information.","title":"See also"},{"location":"xverify/","text":"-Xverify As described in the Oracle documentation , this HotSpot option enables or disables the verifier. For compatibility, this option is also supported by the OpenJ9 VM. Syntax Setting Effect Default -Xverify Enables verification for all non-bootstrap classes. -Xfuture verification is not enabled. yes -Xverify:all Enables verification for all classes and enables -Xfuture verification. You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier . Note: This setting might have an impact on performance. -Xverify:remote For compatibility, this parameter is accepted, but is equivalent to the default -Xverify . -Xverify:none Disables the verifier. Note: This is not a supported configuration and, as noted, was deprecated from Java 13. If you encounter problems with the verifier turned off, remove this option and try to reproduce the problem. Note: The option -Xverify:none (and its equivalent -noverify ) was deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions.","title":"-Xverify"},{"location":"xverify/#-xverify","text":"As described in the Oracle documentation , this HotSpot option enables or disables the verifier. For compatibility, this option is also supported by the OpenJ9 VM.","title":"-Xverify"},{"location":"xverify/#syntax","text":"Setting Effect Default -Xverify Enables verification for all non-bootstrap classes. -Xfuture verification is not enabled. yes -Xverify:all Enables verification for all classes and enables -Xfuture verification. You cannot use this setting in conjunction with -XX:+ClassRelationshipVerifier . Note: This setting might have an impact on performance. -Xverify:remote For compatibility, this parameter is accepted, but is equivalent to the default -Xverify . -Xverify:none Disables the verifier. Note: This is not a supported configuration and, as noted, was deprecated from Java 13. If you encounter problems with the verifier turned off, remove this option and try to reproduce the problem. Note: The option -Xverify:none (and its equivalent -noverify ) was deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions.","title":"Syntax"},{"location":"xx_jvm_commands/","text":"Using -XX command-line options Java\u2122 VM command-line options that are specified with -XX: are not checked for validity. If the VM does not recognize the option, the option is ignored. These options can therefore be used across different VM versions without ensuring a particular level of the VM. If you want to turn off this behavior to test whether your -XX options are valid, use the -XX:-IgnoreUnrecognizedXXColonOptions option. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -XX:MaxDirectMemorySize value to 16 MB, you can specify -XX:MaxDirectMemorySize16M , -XX:MaxDirectMemorySize16m , -XX:MaxDirectMemorySize16384K , or XX:MaxDirectMemorySize16384k on the command line.","title":"Using -XX options"},{"location":"xx_jvm_commands/#using-xx-command-line-options","text":"Java\u2122 VM command-line options that are specified with -XX: are not checked for validity. If the VM does not recognize the option, the option is ignored. These options can therefore be used across different VM versions without ensuring a particular level of the VM. If you want to turn off this behavior to test whether your -XX options are valid, use the -XX:-IgnoreUnrecognizedXXColonOptions option. For options that take a <size> parameter, add a suffix to the size value: \"k\" or \"K\" to indicate kilobytes, \"m\" or \"M\" to indicate megabytes, \"g\" or \"G\" to indicate gigabytes, or \"t\" or \"T\" to indicate terabytes. For example, to set the -XX:MaxDirectMemorySize value to 16 MB, you can specify -XX:MaxDirectMemorySize16M , -XX:MaxDirectMemorySize16m , -XX:MaxDirectMemorySize16384K , or XX:MaxDirectMemorySize16384k on the command line.","title":"Using -XX command-line options"},{"location":"xxactiveprocessorcount/","text":"-XX:ActiveProcessorCount This HotSpot option is recognized by OpenJ9 for compatibility. Use this option to override the number of CPUs that the VM automatically detects and uses when creating threads for various subsystems. Syntax -XX:ActiveProcessorCount=<n> Where <n> is the number of CPUs. Setting Value Default <n> 1 or greater There is no default value. This option is not enabled by default. If set to 0 , there is no effect. When you set this option the following line in a Java dump file is updated to indicate the number of CPUs specified: 2CIACTIVECPU Active CPUs If this option is not set, the value for this line is 0 Active CPUs.","title":"-XXActiveProcessorCount"},{"location":"xxactiveprocessorcount/#-xxactiveprocessorcount","text":"This HotSpot option is recognized by OpenJ9 for compatibility. Use this option to override the number of CPUs that the VM automatically detects and uses when creating threads for various subsystems.","title":"-XX:ActiveProcessorCount"},{"location":"xxactiveprocessorcount/#syntax","text":"-XX:ActiveProcessorCount=<n> Where <n> is the number of CPUs. Setting Value Default <n> 1 or greater There is no default value. This option is not enabled by default. If set to 0 , there is no effect. When you set this option the following line in a Java dump file is updated to indicate the number of CPUs specified: 2CIACTIVECPU Active CPUs If this option is not set, the value for this line is 0 Active CPUs.","title":"Syntax"},{"location":"xxallowvmshutdown/","text":"-XXallowvmshutdown This option is provided as a workaround for applications that cannot shut down cleanly, as described in APAR IZ59734 . Syntax -XX:allowvmshutdown:[false|true] Setting Effect Default false Disable true Enable yes","title":"-XXallowvmshutdown"},{"location":"xxallowvmshutdown/#-xxallowvmshutdown","text":"This option is provided as a workaround for applications that cannot shut down cleanly, as described in APAR IZ59734 .","title":"-XXallowvmshutdown"},{"location":"xxallowvmshutdown/#syntax","text":"-XX:allowvmshutdown:[false|true] Setting Effect Default false Disable true Enable yes","title":"Syntax"},{"location":"xxclassrelationshipverifier/","text":"-XX:[+|-]ClassRelationshipVerifier This option enables and disables the recording of class relationships in the verifier to delay validation until triggered by class loading. Note: You cannot use this setting in conjunction with -Xfuture or -Xverify:all , which itself enables -Xfuture . Syntax -XX:[+|-]ClassRelationshipVerifier Setting Effect Default -XX:+ClassRelationshipVerifier Enable -XX:-ClassRelationshipVerifier Disable yes Explanation When enabled, this option delays validating the relationships between classes until the classes are required to be loaded during program execution. In this way, classes that are not required, are never loaded thus reducing VM startup time. A verify error is thrown if validation fails.","title":"-XX:[+|-]ClassRelationshipVerifier"},{"location":"xxclassrelationshipverifier/#-xx-classrelationshipverifier","text":"This option enables and disables the recording of class relationships in the verifier to delay validation until triggered by class loading. Note: You cannot use this setting in conjunction with -Xfuture or -Xverify:all , which itself enables -Xfuture .","title":"-XX:[+|-]ClassRelationshipVerifier"},{"location":"xxclassrelationshipverifier/#syntax","text":"-XX:[+|-]ClassRelationshipVerifier Setting Effect Default -XX:+ClassRelationshipVerifier Enable -XX:-ClassRelationshipVerifier Disable yes","title":"Syntax"},{"location":"xxclassrelationshipverifier/#explanation","text":"When enabled, this option delays validating the relationships between classes until the classes are required to be loaded during program execution. In this way, classes that are not required, are never loaded thus reducing VM startup time. A verify error is thrown if validation fails.","title":"Explanation"},{"location":"xxcodecachetotal/","text":"-XX:codecachetotal This option is an alias for the -Xcodecachetotal option. Syntax -XX:codecachetotal=<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"-XX:codecachetotal"},{"location":"xxcodecachetotal/#-xxcodecachetotal","text":"This option is an alias for the -Xcodecachetotal option.","title":"-XX:codecachetotal"},{"location":"xxcodecachetotal/#syntax","text":"-XX:codecachetotal=<size> See Using -X command-line options for more information about specifying the <size> parameter.","title":"Syntax"},{"location":"xxcompactstrings/","text":"-XX:[+|-]CompactStrings This HotSpot option is reimplemented by OpenJ9 and when enabled causes an ISO8859-1 (also known as Latin-1) character representation to be used internally for String objects, while preserving full API compatibility. This feature provides heap space savings by using an 8-bit character set internally. Most benefit is gained when the majority of the String objects that your application uses can be encoded using the ISO8859-1 character encoding. If the option is not enabled, the JIT compiler is nevertheless optimized so that although there is no saving in heap space, there is also no performance penalty. Further details are available at JEP 254: Compact Strings . Note: With OpenJ9, this option is supported on OpenJDK version 8 and later versions, whereas HotSpot supports it only from Java version 9. Syntax Setting Effect Default -XX:+CompactStrings Enable String compression -XX:-CompactStrings Disable String compression yes","title":"-XX:[+|-]CompactStrings"},{"location":"xxcompactstrings/#-xx-compactstrings","text":"This HotSpot option is reimplemented by OpenJ9 and when enabled causes an ISO8859-1 (also known as Latin-1) character representation to be used internally for String objects, while preserving full API compatibility. This feature provides heap space savings by using an 8-bit character set internally. Most benefit is gained when the majority of the String objects that your application uses can be encoded using the ISO8859-1 character encoding. If the option is not enabled, the JIT compiler is nevertheless optimized so that although there is no saving in heap space, there is also no performance penalty. Further details are available at JEP 254: Compact Strings . Note: With OpenJ9, this option is supported on OpenJDK version 8 and later versions, whereas HotSpot supports it only from Java version 9.","title":"-XX:[+|-]CompactStrings"},{"location":"xxcompactstrings/#syntax","text":"Setting Effect Default -XX:+CompactStrings Enable String compression -XX:-CompactStrings Disable String compression yes","title":"Syntax"},{"location":"xxconcgcthreads/","text":"-XX:ConcGCThreads This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by OpenJ9 and provided for compatibility. Syntax -XX:ConcGCThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"-XX:ConcGCThreads"},{"location":"xxconcgcthreads/#-xxconcgcthreads","text":"This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by OpenJ9 and provided for compatibility.","title":"-XX:ConcGCThreads"},{"location":"xxconcgcthreads/#syntax","text":"-XX:ConcGCThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"Syntax"},{"location":"xxdisableexplicitgc/","text":"-XX:[+|-]DisableExplicitGC This HotSpot option is recognized by OpenJ9 for compatibility. See \u2011Xenableexplicitgc.md / \u2011Xdisableexplicitgc for details. Syntax Setting Effect Default -XX:+DisableExplicitGC Enable GC yes -XX:-DisableExplicitGC Disable GC","title":"-XX:[+|-]DisableExplicitGC"},{"location":"xxdisableexplicitgc/#-xx-disableexplicitgc","text":"This HotSpot option is recognized by OpenJ9 for compatibility. See \u2011Xenableexplicitgc.md / \u2011Xdisableexplicitgc for details.","title":"-XX:[+|-]DisableExplicitGC"},{"location":"xxdisableexplicitgc/#syntax","text":"Setting Effect Default -XX:+DisableExplicitGC Enable GC yes -XX:-DisableExplicitGC Disable GC","title":"Syntax"},{"location":"xxdisclaimjitscratch/","text":"-XX:[+|-]DisclaimJitScratch Restriction: This option is deprecated; the option is accepted but ignored. (Linux\u00ae only) The -XX:+DisclaimJitScratch option signals to the operating system to discard temporary physical memory that is consumed by the JIT compilation threads. Syntax -XX:[+|-]DisclaimJitScratch Setting Effect Default -XX:+DisclaimJitScratch Enable -XX:-DisclaimJitScratch Disable yes Explanation Discarding temporary physical memory can reduce the physical memory reported in use by the Java\u2122 application. The physical memory that is released is available to other processes without the operating system needing to search for the least recently used frames. The -XX:-DisclaimJitScratch option turns off a previously enabled -XX:+DisclaimJitScratch option.","title":"-XX:[+|-]DisclaimJitScratch"},{"location":"xxdisclaimjitscratch/#-xx91-93disclaimjitscratch","text":"Restriction: This option is deprecated; the option is accepted but ignored. (Linux\u00ae only) The -XX:+DisclaimJitScratch option signals to the operating system to discard temporary physical memory that is consumed by the JIT compilation threads.","title":"-XX:[+|-]DisclaimJitScratch"},{"location":"xxdisclaimjitscratch/#syntax","text":"-XX:[+|-]DisclaimJitScratch Setting Effect Default -XX:+DisclaimJitScratch Enable -XX:-DisclaimJitScratch Disable yes","title":"Syntax"},{"location":"xxdisclaimjitscratch/#explanation","text":"Discarding temporary physical memory can reduce the physical memory reported in use by the Java\u2122 application. The physical memory that is released is available to other processes without the operating system needing to search for the least recently used frames. The -XX:-DisclaimJitScratch option turns off a previously enabled -XX:+DisclaimJitScratch option.","title":"Explanation"},{"location":"xxenablecpumonitor/","text":"-XX:[+|-]EnableCPUMonitor This option relates to the information about the CPU usage of thread categories that is available with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. Restriction: This option might not be supported in subsequent releases. Syntax -XX:[+|-]EnableCPUMonitor Setting Effect Default -XX:+EnableCPUMonitor Enable yes -XX:-EnableCPUMonitor Disable Explanation The -XX:+EnableCPUMonitor option enables CPU monitoring, which allows a JMX bean to track CPU usage on a per thread basis and attributes the usage against different categories. For more information, see the JvmCpuMonitorMXBean interface in the com.ibm.lang.management API documentation. To turn off CPU monitoring, set the -XX:-EnableCPUMonitor option on the command line. See also -XX:[+|-]ReduceCPUMonitorOverhead","title":"-XX:[+|-]EnableCPUMonitor"},{"location":"xxenablecpumonitor/#-xx91-93enablecpumonitor","text":"This option relates to the information about the CPU usage of thread categories that is available with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. Restriction: This option might not be supported in subsequent releases.","title":"-XX:[+|-]EnableCPUMonitor"},{"location":"xxenablecpumonitor/#syntax","text":"-XX:[+|-]EnableCPUMonitor Setting Effect Default -XX:+EnableCPUMonitor Enable yes -XX:-EnableCPUMonitor Disable","title":"Syntax"},{"location":"xxenablecpumonitor/#explanation","text":"The -XX:+EnableCPUMonitor option enables CPU monitoring, which allows a JMX bean to track CPU usage on a per thread basis and attributes the usage against different categories. For more information, see the JvmCpuMonitorMXBean interface in the com.ibm.lang.management API documentation. To turn off CPU monitoring, set the -XX:-EnableCPUMonitor option on the command line.","title":"Explanation"},{"location":"xxenablecpumonitor/#see-also","text":"-XX:[+|-]ReduceCPUMonitorOverhead","title":"See also"},{"location":"xxexitonoutofmemoryerror/","text":"-XX:[+|-]ExitOnOutOfMemoryError This HotSpot option is recognized by OpenJ9. You can use the option to trigger a shut down on VM out-of-memory conditions. Note: Java\u2122, heap, snap, and system dumps are enabled by default but can be disabled by including -XX:-HeapDumpOnOutOfMemoryError . Syntax -XX:[+|-]ExitOnOutOfMemoryError Setting Effect Default -XX:+ExitOnOutOfMemoryError Enable -XX:-ExitOnOutOfMemoryError Disable yes","title":"-XX:[+|-]ExitOnOutOfMemoryError"},{"location":"xxexitonoutofmemoryerror/#-xx91-93exitonoutofmemoryerror","text":"This HotSpot option is recognized by OpenJ9. You can use the option to trigger a shut down on VM out-of-memory conditions. Note: Java\u2122, heap, snap, and system dumps are enabled by default but can be disabled by including -XX:-HeapDumpOnOutOfMemoryError .","title":"-XX:[+|-]ExitOnOutOfMemoryError"},{"location":"xxexitonoutofmemoryerror/#syntax","text":"-XX:[+|-]ExitOnOutOfMemoryError Setting Effect Default -XX:+ExitOnOutOfMemoryError Enable -XX:-ExitOnOutOfMemoryError Disable yes","title":"Syntax"},{"location":"xxgloballockreservation/","text":"-XX:[+|-]GlobalLockReservation (AIX and Linux on Power systems only) The -XX:+GlobalLockReservation option enables an optimization targeted towards more efficient handling of locking and unlocking Java\u2122 objects. Syntax -XX:[+|-]GlobalLockReservation -XX:+GlobalLockReservation:<parameter> Setting Effect Default -XX:+GlobalLockReservation Enable -XX:-GlobalLockReservation Disable yes This optimization is targeted towards applications with lots of uncontended locked objects that are being locked just to be safe. When enabled, heuristics are used to try and determine when an object will be exclusively locked by a single thread so that faster, more specialized code can be used for locking the object. If the heuristics incorrectly identify an object as a target for the optimization, performance might be adversely affected. The -XX:-GlobalLockReservation option turns off a previously enabled -XX:+GlobalLockReservation option. Parameters Advanced tuning parameters are shown in the following table: Parameter Effect reservedTransitionThreshold Changes amount of time spent analyzing an object. reservedAbsoluteThreshold Changes amount of time spent analyzing a class for compatibility. minimumReservedRatio Changes aggression level for marking a class as highly compatible. cancelAbsoluteThreshold Changes amount of time spent analyzing a class for incompatibility. minimumLearningRatio Changes aggression level for marking a class as highly incompatible. reservedTransitionThreshold -XX:+GlobalLockReservation:reservedTransitionThreshold=<value> Setting Value Default <value> number 1 Number of times an object is locked by the same thread before it is considered reserved minus a value of 2. So, with a default value of 1, an object can be reserved the third time it is locked. <value> can be 0-3 inclusive. Values of 4 or higher are treated as infinity. reservedAbsoluteThreshold -XX:+GlobalLockReservation:reservedAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get reserved before the class can be considered highly compatible. Objects of that class are reserved the first time they are locked. Values of 65536 or higher are treated as infinity. minimumReservedRatio -XX:+GlobalLockReservation:minimumReservedRatio=<value> Setting Value Default <value> number 1024 Minimum ratio of reserved objects to flat objects before a class can be considered highly compatible. Values of 65536 or higher are treated as infinity. cancelAbsoluteThreshold -XX:+GlobalLockReservation:cancelAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get converted to flat before the class can be considered highly incompatible. Objects of that class are never reserved. Values of 65536 or higher are treated as infinity. minimumLearningRatio -XX:+GlobalLockReservation:minimumLearningRatio=<value> Setting Value Default <value> number 256 Minimum ratio of reserved objects to flat objects to prevent class from being considered highly incompatible. Values of 65536 or higher are treated as infinity.","title":"-XX:[+|-]GlobalLockReservation"},{"location":"xxgloballockreservation/#-xx91-93globallockreservation","text":"(AIX and Linux on Power systems only) The -XX:+GlobalLockReservation option enables an optimization targeted towards more efficient handling of locking and unlocking Java\u2122 objects.","title":"-XX:[+|-]GlobalLockReservation"},{"location":"xxgloballockreservation/#syntax","text":"-XX:[+|-]GlobalLockReservation -XX:+GlobalLockReservation:<parameter> Setting Effect Default -XX:+GlobalLockReservation Enable -XX:-GlobalLockReservation Disable yes This optimization is targeted towards applications with lots of uncontended locked objects that are being locked just to be safe. When enabled, heuristics are used to try and determine when an object will be exclusively locked by a single thread so that faster, more specialized code can be used for locking the object. If the heuristics incorrectly identify an object as a target for the optimization, performance might be adversely affected. The -XX:-GlobalLockReservation option turns off a previously enabled -XX:+GlobalLockReservation option.","title":"Syntax"},{"location":"xxgloballockreservation/#parameters","text":"Advanced tuning parameters are shown in the following table: Parameter Effect reservedTransitionThreshold Changes amount of time spent analyzing an object. reservedAbsoluteThreshold Changes amount of time spent analyzing a class for compatibility. minimumReservedRatio Changes aggression level for marking a class as highly compatible. cancelAbsoluteThreshold Changes amount of time spent analyzing a class for incompatibility. minimumLearningRatio Changes aggression level for marking a class as highly incompatible.","title":"Parameters"},{"location":"xxgloballockreservation/#reservedtransitionthreshold","text":"-XX:+GlobalLockReservation:reservedTransitionThreshold=<value> Setting Value Default <value> number 1 Number of times an object is locked by the same thread before it is considered reserved minus a value of 2. So, with a default value of 1, an object can be reserved the third time it is locked. <value> can be 0-3 inclusive. Values of 4 or higher are treated as infinity.","title":"reservedTransitionThreshold"},{"location":"xxgloballockreservation/#reservedabsolutethreshold","text":"-XX:+GlobalLockReservation:reservedAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get reserved before the class can be considered highly compatible. Objects of that class are reserved the first time they are locked. Values of 65536 or higher are treated as infinity.","title":"reservedAbsoluteThreshold"},{"location":"xxgloballockreservation/#minimumreservedratio","text":"-XX:+GlobalLockReservation:minimumReservedRatio=<value> Setting Value Default <value> number 1024 Minimum ratio of reserved objects to flat objects before a class can be considered highly compatible. Values of 65536 or higher are treated as infinity.","title":"minimumReservedRatio"},{"location":"xxgloballockreservation/#cancelabsolutethreshold","text":"-XX:+GlobalLockReservation:cancelAbsoluteThreshold=<value> Setting Value Default <value> number 10 Minimum number of objects of a class that get converted to flat before the class can be considered highly incompatible. Objects of that class are never reserved. Values of 65536 or higher are treated as infinity.","title":"cancelAbsoluteThreshold"},{"location":"xxgloballockreservation/#minimumlearningratio","text":"-XX:+GlobalLockReservation:minimumLearningRatio=<value> Setting Value Default <value> number 256 Minimum ratio of reserved objects to flat objects to prevent class from being considered highly incompatible. Values of 65536 or higher are treated as infinity.","title":"minimumLearningRatio"},{"location":"xxhandlesigabrt/","text":"-XX:[+|-]HandleSIGABRT This option affects the handling of the operating system signal SIGABRT . This signal represents abnormal termination, and it can either be generated by the abort function or the kill command. Syntax -XX:[+|-]HandleSIGABRT Setting Effect Default -XX:+HandleSIGABRT Enable yes -XX:-HandleSIGABRT Disable Explanation When enabled, the VM handles the signal SIGABRT and generates the various dump files. When the option is disabled, the VM does not handle the signal SIGABRT . Generally, this signal is handled by the default operating system handler. Note: Do not use the -XX:+HandleSIGABRT and -Xrs options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled.","title":"-XX:[+|-]HandleSIGABRT"},{"location":"xxhandlesigabrt/#-xx91-93handlesigabrt","text":"This option affects the handling of the operating system signal SIGABRT . This signal represents abnormal termination, and it can either be generated by the abort function or the kill command.","title":"-XX:[+|-]HandleSIGABRT"},{"location":"xxhandlesigabrt/#syntax","text":"-XX:[+|-]HandleSIGABRT Setting Effect Default -XX:+HandleSIGABRT Enable yes -XX:-HandleSIGABRT Disable","title":"Syntax"},{"location":"xxhandlesigabrt/#explanation","text":"When enabled, the VM handles the signal SIGABRT and generates the various dump files. When the option is disabled, the VM does not handle the signal SIGABRT . Generally, this signal is handled by the default operating system handler. Note: Do not use the -XX:+HandleSIGABRT and -Xrs options together. An error is thrown if both options are enabled. To resolve this error, one of the options should be disabled.","title":"Explanation"},{"location":"xxhandlesigxfsz/","text":"-XX:[+|-]HandleSIGXFSZ (AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae only) This option affects the handling of the operating system signal SIGXFSZ . This signal is generated when a process attempts to write to a file that causes the maximum file size ulimit to be exceeded. Syntax -XX:[+|-]HandleSIGXFSZ Setting Effect Default -XX:+HandleSIGXFSZ Enable yes -XX:-HandleSIGXFSZ Disable Explanation When enabled, the VM handles the signal SIGXFSZ and continues, without ending. When a file is written from a Java\u2122 API class that exceeds the maximum file size ulimit , an exception is raised. Log files that are created by the VM are silently truncated when they reach the maximum file size ulimit . When the option is disabled, the VM does not handle the signal SIGXFSZ . In this situation, if the maximum file size ulimit for any file is reached, the operating system ends the process with a core dump.","title":"-XX:[+|-]HandleSIGXFSZ"},{"location":"xxhandlesigxfsz/#-xx91-93handlesigxfsz","text":"(AIX\u00ae, Linux\u00ae, macOS\u00ae, and z/OS\u00ae only) This option affects the handling of the operating system signal SIGXFSZ . This signal is generated when a process attempts to write to a file that causes the maximum file size ulimit to be exceeded.","title":"-XX:[+|-]HandleSIGXFSZ"},{"location":"xxhandlesigxfsz/#syntax","text":"-XX:[+|-]HandleSIGXFSZ Setting Effect Default -XX:+HandleSIGXFSZ Enable yes -XX:-HandleSIGXFSZ Disable","title":"Syntax"},{"location":"xxhandlesigxfsz/#explanation","text":"When enabled, the VM handles the signal SIGXFSZ and continues, without ending. When a file is written from a Java\u2122 API class that exceeds the maximum file size ulimit , an exception is raised. Log files that are created by the VM are silently truncated when they reach the maximum file size ulimit . When the option is disabled, the VM does not handle the signal SIGXFSZ . In this situation, if the maximum file size ulimit for any file is reached, the operating system ends the process with a core dump.","title":"Explanation"},{"location":"xxheapdumponoutofmemory/","text":"-XX:[+|-]HeapDumpOnOutOfMemory This HotSpot option is recognized by OpenJ9. You can use the option to to disable Java\u2122, heap, snap, and system dumps on out-of-memory conditions, which are enabled by default. Syntax -XX:[+|-]HeapDumpOnOutOfMemory Setting Effect Default -XX:+HeapDumpOnOutOfMemory Enable yes -XX:-HeapDumpOnOutOfMemory Disable","title":"-XX:[+|-]HeapDumpOnOutOfMemory"},{"location":"xxheapdumponoutofmemory/#-xx91-93heapdumponoutofmemory","text":"This HotSpot option is recognized by OpenJ9. You can use the option to to disable Java\u2122, heap, snap, and system dumps on out-of-memory conditions, which are enabled by default.","title":"-XX:[+|-]HeapDumpOnOutOfMemory"},{"location":"xxheapdumponoutofmemory/#syntax","text":"-XX:[+|-]HeapDumpOnOutOfMemory Setting Effect Default -XX:+HeapDumpOnOutOfMemory Enable yes -XX:-HeapDumpOnOutOfMemory Disable","title":"Syntax"},{"location":"xxheapdumppath/","text":"-XX:HeapDumpPath This HotSpot option is recognized by OpenJ9 for compatibility, and you can use it as an alias for -Xdump:directory=<path> . This option sets the directory for all VM dumps including heap dumps, Java\u2122 dumps, and system dumps. Syntax -XX:HeapDumpPath=<path> where <path> is the directory to which all dump types are written. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents.","title":"-XX:HeapDumpPath"},{"location":"xxheapdumppath/#-xxheapdumppath","text":"This HotSpot option is recognized by OpenJ9 for compatibility, and you can use it as an alias for -Xdump:directory=<path> . This option sets the directory for all VM dumps including heap dumps, Java\u2122 dumps, and system dumps.","title":"-XX:HeapDumpPath"},{"location":"xxheapdumppath/#syntax","text":"-XX:HeapDumpPath=<path> where <path> is the directory to which all dump types are written. This directory path is prefixed to the path of all non-absolute dump file names, including the file names for the default dump agents.","title":"Syntax"},{"location":"xxheapmanagementmxbeancompatibility/","text":"-XX:[+|-]HeapManagementMXBeanCompatibility The MXBean interface now reports more detailed information about memory pools and garbage collectors for a garbage collection policy. In addition, the names of memory pools and garbage collectors are changed to match the naming convention that is used for verbose garbage collection logging. This option provides compatibility with earlier versions of the VM. Syntax -XX:[+|-]HeapManagementMXBeanCompatibility Setting Effect Default -XX:+HeapManagementMXBeanCompatibility Enable -XX:-HeapManagementMXBeanCompatibility Disable yes Setting -XX:+HeapManagementMXBeanCompatibility on the command line turns on compatibility with earlier versions of the VM. Information about memory pools and garbage collectors are reported in the older format. When compatibility is turned off, the VM reports more detailed information and matches the naming of memory pools and garbage collectors to the naming convention that is used for verbose garbage collection logging. Explanation The additional information that is available from the MXBean interface for later versions is shown in the following table: Garbage collection policy MemoryPool names GarbageCollector names gencon nursery-allocate, nursery-survivor, tenured-LOA, tenured-SOA, tenured scavenge, global optthruput or optavgpause tenured-LOA, tenured-SOA, tenured global balanced balanced-reserved, balanced-eden, balanced-survivor, balanced-old partial gc, global garbage collect metronome JavaHeap global The MemoryPoolMXBean API reports values for 4 detailed memory pools instead of a single value for the overall Java\u2122 heap. In some cases the total sum of the 4 pools is more than the maximum heap size. This irregularity can be caused if data for each pool is collected between garbage collection cycles, where objects have been moved or reclaimed. If you want to collect memory usage data that is synchronized across the memory pools, use the GarbageCollectionNotificationInfo or GarbageCollectorMXBean.getLastGcInfo extensions. Earlier releases included only the following names: MemoryPool pool name: Java heap GarbageCollector name: Copy and MarkSweepCompact . See also Verbose garbage collection logging . For more information about IBM\u00ae MXBeans, see the com.ibm.lang.management API documentation.","title":"-XX:[+|-]HeapManagementMXBeanCompatibility"},{"location":"xxheapmanagementmxbeancompatibility/#-xx91-93heapmanagementmxbeancompatibility","text":"The MXBean interface now reports more detailed information about memory pools and garbage collectors for a garbage collection policy. In addition, the names of memory pools and garbage collectors are changed to match the naming convention that is used for verbose garbage collection logging. This option provides compatibility with earlier versions of the VM.","title":"-XX:[+|-]HeapManagementMXBeanCompatibility"},{"location":"xxheapmanagementmxbeancompatibility/#syntax","text":"-XX:[+|-]HeapManagementMXBeanCompatibility Setting Effect Default -XX:+HeapManagementMXBeanCompatibility Enable -XX:-HeapManagementMXBeanCompatibility Disable yes Setting -XX:+HeapManagementMXBeanCompatibility on the command line turns on compatibility with earlier versions of the VM. Information about memory pools and garbage collectors are reported in the older format. When compatibility is turned off, the VM reports more detailed information and matches the naming of memory pools and garbage collectors to the naming convention that is used for verbose garbage collection logging.","title":"Syntax"},{"location":"xxheapmanagementmxbeancompatibility/#explanation","text":"The additional information that is available from the MXBean interface for later versions is shown in the following table: Garbage collection policy MemoryPool names GarbageCollector names gencon nursery-allocate, nursery-survivor, tenured-LOA, tenured-SOA, tenured scavenge, global optthruput or optavgpause tenured-LOA, tenured-SOA, tenured global balanced balanced-reserved, balanced-eden, balanced-survivor, balanced-old partial gc, global garbage collect metronome JavaHeap global The MemoryPoolMXBean API reports values for 4 detailed memory pools instead of a single value for the overall Java\u2122 heap. In some cases the total sum of the 4 pools is more than the maximum heap size. This irregularity can be caused if data for each pool is collected between garbage collection cycles, where objects have been moved or reclaimed. If you want to collect memory usage data that is synchronized across the memory pools, use the GarbageCollectionNotificationInfo or GarbageCollectorMXBean.getLastGcInfo extensions. Earlier releases included only the following names: MemoryPool pool name: Java heap GarbageCollector name: Copy and MarkSweepCompact .","title":"Explanation"},{"location":"xxheapmanagementmxbeancompatibility/#see-also","text":"Verbose garbage collection logging . For more information about IBM\u00ae MXBeans, see the com.ibm.lang.management API documentation.","title":"See also"},{"location":"xxidletuningcompactonidle/","text":"-XX:[+|-]IdleTuningCompactOnIdle (Linux\u00ae only) This option controls garbage collection processing with compaction when the state of the OpenJ9 VM is set to idle. Restrictions: This option was deprecated in release 0.15.0 and will be removed in the future. This option applies only to Linux\u00ae architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. This option is not effective if XX:+IdleTuningGcOnIdle is not specified. Syntax -XX:[+|-]IdleTuningCompactOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningCompactOnIdle Enable yes -XX:-IdleTuningCompactOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a container. As indicated in the table, when the VM is running in a container and the state is set to idle, the VM attempts to compact the object heap following a garbage collection cycle. The garbage collection cycle is controlled by the -XX:+IdleTuningGcOnIdle option, which is also enabled by default when the OpenJ9 VM is running inside a container. If your application is not running in a container and you want compaction to be attempted every time idle GC happens as part of the idle-tuning process, set the -XX:+IdleTuningCompactOnIdle option on the command line when you start your application. The -XX:+IdleTuningCompactOnIdle option can be used with the -XX:+IdleTuningMinIdleWaitTime , which controls the amount of time that the VM must be idle before an idle state is set. If a value for the -XX:+IdleTuningMinIdleWaitTime option is not explicitly specified, the VM sets a default value of 180 seconds. See also -XX:IdleTuningMinFreeHeapOnIdle -XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle","title":"-XX:[+|-]IdleTuningCompactOnIdle"},{"location":"xxidletuningcompactonidle/#-xx91-93idletuningcompactonidle","text":"(Linux\u00ae only) This option controls garbage collection processing with compaction when the state of the OpenJ9 VM is set to idle. Restrictions: This option was deprecated in release 0.15.0 and will be removed in the future. This option applies only to Linux\u00ae architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. This option is not effective if XX:+IdleTuningGcOnIdle is not specified.","title":"-XX:[+|-]IdleTuningCompactOnIdle"},{"location":"xxidletuningcompactonidle/#syntax","text":"-XX:[+|-]IdleTuningCompactOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningCompactOnIdle Enable yes -XX:-IdleTuningCompactOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a container. As indicated in the table, when the VM is running in a container and the state is set to idle, the VM attempts to compact the object heap following a garbage collection cycle. The garbage collection cycle is controlled by the -XX:+IdleTuningGcOnIdle option, which is also enabled by default when the OpenJ9 VM is running inside a container. If your application is not running in a container and you want compaction to be attempted every time idle GC happens as part of the idle-tuning process, set the -XX:+IdleTuningCompactOnIdle option on the command line when you start your application. The -XX:+IdleTuningCompactOnIdle option can be used with the -XX:+IdleTuningMinIdleWaitTime , which controls the amount of time that the VM must be idle before an idle state is set. If a value for the -XX:+IdleTuningMinIdleWaitTime option is not explicitly specified, the VM sets a default value of 180 seconds.","title":"Syntax"},{"location":"xxidletuningcompactonidle/#see-also","text":"-XX:IdleTuningMinFreeHeapOnIdle -XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle","title":"See also"},{"location":"xxidletuninggconidle/","text":"-XX:[+|-]IdleTuningGcOnIdle (Linux\u00ae only) This option controls whether a garbage collection cycle takes place when the state of the OpenJ9 VM is set to idle. Compaction of the heap is also attempted during the idle GC when certain triggers are met. Restrictions: This option applies only to Linux\u00ae architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. Syntax -XX:[+|-]IdleTuningGcOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningGcOnIdle Enable yes -XX:-IdleTuningGcOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a docker container. As indicated in the table, when the VM is running in a container and the state is set to idle, this option causes the VM to release free memory pages in the object heap without resizing the Java\u2122 heap and attempts to compact the heap after the garbage collection cycle if certain heuristics are triggered. The pages are reclaimed by the operating system, which reduces the physical memory footprint of the VM. If your application is not running in a container and you want to enable idle-tuning, set the -XX:+IdleTuningGcOnIdle option on the command line when you start your application. When enabled, the -XX:+IdleTuningGcOnIdle option is used with the -XX:IdleTuningMinIdleWaitTime and -XX:IdleTuningMinFreeHeapOnIdle options. If values for these options are not explicitly specified, the VM sets the following defaults: -XX:IdleTuningMinIdleWaitTime =180 -XX:IdleTuningMinFreeHeapOnIdle =0 See also -XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (deprecated)","title":"-XX:[+|-]IdleTuningGcOnIdle"},{"location":"xxidletuninggconidle/#-xx91-93idletuninggconidle","text":"(Linux\u00ae only) This option controls whether a garbage collection cycle takes place when the state of the OpenJ9 VM is set to idle. Compaction of the heap is also attempted during the idle GC when certain triggers are met. Restrictions: This option applies only to Linux\u00ae architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages.","title":"-XX:[+|-]IdleTuningGcOnIdle"},{"location":"xxidletuninggconidle/#syntax","text":"-XX:[+|-]IdleTuningGcOnIdle Setting Effect Default Default when running in a docker container -XX:+IdleTuningGcOnIdle Enable yes -XX:-IdleTuningGcOnIdle Disable yes The default depends on whether or not the OpenJ9 VM is running in a docker container. As indicated in the table, when the VM is running in a container and the state is set to idle, this option causes the VM to release free memory pages in the object heap without resizing the Java\u2122 heap and attempts to compact the heap after the garbage collection cycle if certain heuristics are triggered. The pages are reclaimed by the operating system, which reduces the physical memory footprint of the VM. If your application is not running in a container and you want to enable idle-tuning, set the -XX:+IdleTuningGcOnIdle option on the command line when you start your application. When enabled, the -XX:+IdleTuningGcOnIdle option is used with the -XX:IdleTuningMinIdleWaitTime and -XX:IdleTuningMinFreeHeapOnIdle options. If values for these options are not explicitly specified, the VM sets the following defaults: -XX:IdleTuningMinIdleWaitTime =180 -XX:IdleTuningMinFreeHeapOnIdle =0","title":"Syntax"},{"location":"xxidletuninggconidle/#see-also","text":"-XX:IdleTuningMinIdleWaitTime -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (deprecated)","title":"See also"},{"location":"xxidletuningminfreeheaponidle/","text":"-XX:IdleTuningMinFreeHeapOnIdle (Linux\u00ae only) This option controls the percentage of free memory pages in the object heap that can be released when the OpenJ9 VM is in an idle state. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. Syntax -XX:IdleTuningMinFreeHeapOnIdle=<percentage> Setting Value Default <percentage> [0 - 100] 0 When used with -XX:+IdleTuningGcOnIdle , this option can be used to place an upper bound on the percentage of free memory pages in the object heap that can be released when the VM is in an idle state. If -XX:IdleTuningMinFreeHeapOnIdle is not specified, the VM uses a default value of 0. Example If you set -XX:IdleTuningMinFreeHeapOnIdle=10 , no more than 90% of the free memory pages in the object heap can be released by the VM when it is in an idle state. See also -XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle -XX:[+|-]IdleTuningCompactOnIdle (deprecated)","title":"-XX:IdleTuningMinFreeHeapOnIdle"},{"location":"xxidletuningminfreeheaponidle/#-xxidletuningminfreeheaponidle","text":"(Linux\u00ae only) This option controls the percentage of free memory pages in the object heap that can be released when the OpenJ9 VM is in an idle state. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages.","title":"-XX:IdleTuningMinFreeHeapOnIdle"},{"location":"xxidletuningminfreeheaponidle/#syntax","text":"-XX:IdleTuningMinFreeHeapOnIdle=<percentage> Setting Value Default <percentage> [0 - 100] 0 When used with -XX:+IdleTuningGcOnIdle , this option can be used to place an upper bound on the percentage of free memory pages in the object heap that can be released when the VM is in an idle state. If -XX:IdleTuningMinFreeHeapOnIdle is not specified, the VM uses a default value of 0.","title":"Syntax"},{"location":"xxidletuningminfreeheaponidle/#example","text":"If you set -XX:IdleTuningMinFreeHeapOnIdle=10 , no more than 90% of the free memory pages in the object heap can be released by the VM when it is in an idle state.","title":"Example"},{"location":"xxidletuningminfreeheaponidle/#see-also","text":"-XX:IdleTuningMinIdleWaitTime -XX:[+|-]IdleTuningGcOnIdle -XX:[+|-]IdleTuningCompactOnIdle (deprecated)","title":"See also"},{"location":"xxidletuningminidlewaittime/","text":"-XX:IdleTuningMinIdleWaitTime (Linux\u00ae only) When the OpenJ9 VM is idle, this option controls the minimum length of time that the VM must be idle before the state of the VM is set to idle. When the state changes to idle, a garbage collection cycle runs, the object heap is compacted, and free memory pages are released back to the operating system, which reduces the footprint of the VM. Garbage collection and compaction are controlled by the -XX:+IdleTuningGcOnIdle and -XX:+IdleTuningCompactOnIdle options, which are enabled by default when the OpenJ9 VM is running inside a docker container. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages. Syntax -XX:IdleTuningMinIdleWaitTime=<secs> Setting Value Default Default when running in a docker container <secs> [0 or greater] 0 180 The value used for <secs> specifies the minimum length of time in seconds that the VM is idle before the state is set to idle. Idle tuning is enabled by default when the OpenJ9 VM is running in a docker container and the VM is detected as idle for 180 seconds. Setting the value to 0 disables this feature, which causes the following idle tuning options to have no effect: -XX:+IdleTuningCompactOnIdle -XX:+IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle See also -XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (deprecated)","title":"-XX:IdleTuningMinIdleWaitTime"},{"location":"xxidletuningminidlewaittime/#-xxidletuningminidlewaittime","text":"(Linux\u00ae only) When the OpenJ9 VM is idle, this option controls the minimum length of time that the VM must be idle before the state of the VM is set to idle. When the state changes to idle, a garbage collection cycle runs, the object heap is compacted, and free memory pages are released back to the operating system, which reduces the footprint of the VM. Garbage collection and compaction are controlled by the -XX:+IdleTuningGcOnIdle and -XX:+IdleTuningCompactOnIdle options, which are enabled by default when the OpenJ9 VM is running inside a docker container. Restrictions: This option applies only to Linux architectures when the Generational Concurrent ( gencon ) garbage collection policy is in use. This option is not effective if the object heap is configured to use large pages.","title":"-XX:IdleTuningMinIdleWaitTime"},{"location":"xxidletuningminidlewaittime/#syntax","text":"-XX:IdleTuningMinIdleWaitTime=<secs> Setting Value Default Default when running in a docker container <secs> [0 or greater] 0 180 The value used for <secs> specifies the minimum length of time in seconds that the VM is idle before the state is set to idle. Idle tuning is enabled by default when the OpenJ9 VM is running in a docker container and the VM is detected as idle for 180 seconds. Setting the value to 0 disables this feature, which causes the following idle tuning options to have no effect: -XX:+IdleTuningCompactOnIdle -XX:+IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle","title":"Syntax"},{"location":"xxidletuningminidlewaittime/#see-also","text":"-XX:[+|-]IdleTuningGcOnIdle -XX:IdleTuningMinFreeHeapOnIdle -XX:[+|-]IdleTuningCompactOnIdle (deprecated)","title":"See also"},{"location":"xxignoreunrecognizedvmoptions/","text":"-XX:[+|-]IgnoreUnrecognizedVMOptions This Oracle option affects the behavior of the HotSpot JVM when it finds an unrecognized top-level option at startup. This option is implemented in the OpenJ9 VM for compatibility. Syntax -XX:[+|-]IgnoreUnrecognizedVMOptions Setting Effect Default -XX:+IgnoreUnrecognizedVMOptions Enable -XX:-IgnoreUnrecognizedVMOptions Disable yes","title":"-XX:[+|-]IgnoreUnrecognizedVMOptions"},{"location":"xxignoreunrecognizedvmoptions/#-xx91-93ignoreunrecognizedvmoptions","text":"This Oracle option affects the behavior of the HotSpot JVM when it finds an unrecognized top-level option at startup. This option is implemented in the OpenJ9 VM for compatibility.","title":"-XX:[+|-]IgnoreUnrecognizedVMOptions"},{"location":"xxignoreunrecognizedvmoptions/#syntax","text":"-XX:[+|-]IgnoreUnrecognizedVMOptions Setting Effect Default -XX:+IgnoreUnrecognizedVMOptions Enable -XX:-IgnoreUnrecognizedVMOptions Disable yes","title":"Syntax"},{"location":"xxignoreunrecognizedxxcolonoptions/","text":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions By default, any -XX: options that you specify on the command line are ignored if they are not recognized, which prevents an application failing to start. However, if you want to determine whether any of your -XX: options are unrecognized, you can turn off the behavior with this option. You might want to do this, for example, if you are switching to OpenJ9 from an alternative VM implementation where you are using -XX: options to tune the runtime environment. Syntax -XX:[+|-]IgnoreUnrecognizedXXColonOptions Setting Effect Default -XX:+IgnoreUnrecognizedXXColonOptions Enable yes -XX:-IgnoreUnrecognizedXXColonOptions Disable When you specify -XX:-IgnoreUnrecognizedXXColonOptions , if you also specify a -XX: option that is not recognized, that option is reported and the VM does not start. For example: JVMJ9VM007E Command-line option unrecognised: -XX:InvalidOption Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.","title":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions"},{"location":"xxignoreunrecognizedxxcolonoptions/#-xx91-93ignoreunrecognizedxxcolonoptions","text":"By default, any -XX: options that you specify on the command line are ignored if they are not recognized, which prevents an application failing to start. However, if you want to determine whether any of your -XX: options are unrecognized, you can turn off the behavior with this option. You might want to do this, for example, if you are switching to OpenJ9 from an alternative VM implementation where you are using -XX: options to tune the runtime environment.","title":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions"},{"location":"xxignoreunrecognizedxxcolonoptions/#syntax","text":"-XX:[+|-]IgnoreUnrecognizedXXColonOptions Setting Effect Default -XX:+IgnoreUnrecognizedXXColonOptions Enable yes -XX:-IgnoreUnrecognizedXXColonOptions Disable When you specify -XX:-IgnoreUnrecognizedXXColonOptions , if you also specify a -XX: option that is not recognized, that option is reported and the VM does not start. For example: JVMJ9VM007E Command-line option unrecognised: -XX:InvalidOption Error: Could not create the Java Virtual Machine. Error: A fatal exception has occurred. Program will exit.","title":"Syntax"},{"location":"xxinitialheapsize/","text":"-XX:InitialHeapSize / -XX:MaxHeapSize These HotSpot options for specifying heap size are recognized by OpenJ9 for compatibility. See -Xms / -Xmx for details. Syntax Setting Effect -XX:InitialHeapSize<size> Set initial heap size -XX:MaxHeapSize<size> Set maximum heap size","title":"-XX:MaxHeapSize"},{"location":"xxinitialheapsize/#-xxinitialheapsize-xxmaxheapsize","text":"These HotSpot options for specifying heap size are recognized by OpenJ9 for compatibility. See -Xms / -Xmx for details.","title":"-XX:InitialHeapSize / -XX:MaxHeapSize"},{"location":"xxinitialheapsize/#syntax","text":"Setting Effect -XX:InitialHeapSize<size> Set initial heap size -XX:MaxHeapSize<size> Set maximum heap size","title":"Syntax"},{"location":"xxinitialrampercentage/","text":"-XX:InitialRAMPercentage / -XX:MaxRAMPercentage These Oracle HotSpot options can be used to specify the initial and maximum size of the Java heap as a percentage of the total memory available to the VM. The options are recognized by OpenJ9 and provided for compatibility. Syntax Setting Effect -XX:InitialRAMPercentage=N Set initial heap size as a percentage of total memory -XX:MaxRAMPercentage=N Set maximum heap size as a percentage of total memory Where N is a value between 0 and 100, which can be of type \"double\". For example, 12.3456. Note: If you set a value for -Xms , these options are ignored. If your application is running in a container and you have specified -XX:+UseContainerSupport , both the default heap size for containers, the -XX:InitialRAMPercentage option, and the -XX:MaxRAMPercentage option are based on the available container memory.","title":"-XX:MaxRAMPercentage"},{"location":"xxinitialrampercentage/#-xxinitialrampercentage-xxmaxrampercentage","text":"These Oracle HotSpot options can be used to specify the initial and maximum size of the Java heap as a percentage of the total memory available to the VM. The options are recognized by OpenJ9 and provided for compatibility.","title":"-XX:InitialRAMPercentage / -XX:MaxRAMPercentage"},{"location":"xxinitialrampercentage/#syntax","text":"Setting Effect -XX:InitialRAMPercentage=N Set initial heap size as a percentage of total memory -XX:MaxRAMPercentage=N Set maximum heap size as a percentage of total memory Where N is a value between 0 and 100, which can be of type \"double\". For example, 12.3456. Note: If you set a value for -Xms , these options are ignored. If your application is running in a container and you have specified -XX:+UseContainerSupport , both the default heap size for containers, the -XX:InitialRAMPercentage option, and the -XX:MaxRAMPercentage option are based on the available container memory.","title":"Syntax"},{"location":"xxinterleavememory/","text":"-XX:[+|-]InterleaveMemory (AIX\u00ae, Linux\u00ae, and Windows\u2122 only, but not Linux on IBM Z\u00ae) Use the -XX:+InterleaveMemory option to enable the interleaving of allocated memory across NUMA nodes. Syntax -XX:[+|-]InterleaveMemory Setting Effect Default -XX:+InterleaveMemory Enable -XX:-InterleaveMemory Disable yes","title":"-XX:[+|-]InterleaveMemory"},{"location":"xxinterleavememory/#-xx91-93interleavememory","text":"(AIX\u00ae, Linux\u00ae, and Windows\u2122 only, but not Linux on IBM Z\u00ae) Use the -XX:+InterleaveMemory option to enable the interleaving of allocated memory across NUMA nodes.","title":"-XX:[+|-]InterleaveMemory"},{"location":"xxinterleavememory/#syntax","text":"-XX:[+|-]InterleaveMemory Setting Effect Default -XX:+InterleaveMemory Enable -XX:-InterleaveMemory Disable yes","title":"Syntax"},{"location":"xxjitinlinewatches/","text":"-XX:[+|-]JITInlineWatches This option controls JIT operations that relate to JVMTI watched fields. Syntax -XX:[+|-]JITInlineWatches Setting Effect Default -XX:+JITInlineWatches Enable yes -XX:-JITInlineWatches Disable This option enables performance improvements relating to JVMTI watched fields.","title":"-XX:[+|-]JITInlineWatches"},{"location":"xxjitinlinewatches/#-xx91-93jitinlinewatches","text":"This option controls JIT operations that relate to JVMTI watched fields.","title":"-XX:[+|-]JITInlineWatches"},{"location":"xxjitinlinewatches/#syntax","text":"-XX:[+|-]JITInlineWatches Setting Effect Default -XX:+JITInlineWatches Enable yes -XX:-JITInlineWatches Disable This option enables performance improvements relating to JVMTI watched fields.","title":"Syntax"},{"location":"xxlazysymbolresolution/","text":"-XX:[+|-]LazySymbolResolution (Linux\u00ae and macOS\u00ae only) This option affects the timing of symbol resolution for functions in user native libraries. Syntax -XX:[+|-]LazySymbolResolution Setting Effect Default -XX:+LazySymbolResolution Enable yes -XX:-LazySymbolResolution Disable Explanation Enabling this option forces the VM to delay symbol resolution for each function in a user native library, until the function is called. The -XX:-LazySymbolResolution option forces the VM to immediately resolve symbols for all functions in a user native library when the library is loaded. These options apply only to functions; variable symbols are always resolved immediately when loaded. If you attempt to use these options on an operating system other than Linux or macOS, the options are accepted, but ignored.","title":"-XX:[+|-]LazySymbolResolution"},{"location":"xxlazysymbolresolution/#-xx91-93lazysymbolresolution","text":"(Linux\u00ae and macOS\u00ae only) This option affects the timing of symbol resolution for functions in user native libraries.","title":"-XX:[+|-]LazySymbolResolution"},{"location":"xxlazysymbolresolution/#syntax","text":"-XX:[+|-]LazySymbolResolution Setting Effect Default -XX:+LazySymbolResolution Enable yes -XX:-LazySymbolResolution Disable","title":"Syntax"},{"location":"xxlazysymbolresolution/#explanation","text":"Enabling this option forces the VM to delay symbol resolution for each function in a user native library, until the function is called. The -XX:-LazySymbolResolution option forces the VM to immediately resolve symbols for all functions in a user native library when the library is loaded. These options apply only to functions; variable symbols are always resolved immediately when loaded. If you attempt to use these options on an operating system other than Linux or macOS, the options are accepted, but ignored.","title":"Explanation"},{"location":"xxmaxdirectmemorysize/","text":"-XX:MaxDirectMemorySize This Oracle HotSpot option sets a limit on the amount of memory that can be reserved for all Direct Byte Buffers. Syntax -XX:MaxDirectMemorySize=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] Depends on maximum heap size The value you choose is the limit on memory that can be reserved for all Direct Byte Buffers. If a value is set for this option, the sum of all Direct Byte Buffer sizes cannot exceed the limit. After the limit is reached, a new Direct Byte Buffer can be allocated only when enough old buffers are freed to provide enough space to allocate the new buffer. By default, the VM limits the amount of heap memory used for Direct Byte Buffers to approximately 85% of the maximum heap size.","title":"-XX:MaxDirectMemorySize"},{"location":"xxmaxdirectmemorysize/#-xxmaxdirectmemorysize","text":"This Oracle HotSpot option sets a limit on the amount of memory that can be reserved for all Direct Byte Buffers.","title":"-XX:MaxDirectMemorySize"},{"location":"xxmaxdirectmemorysize/#syntax","text":"-XX:MaxDirectMemorySize=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] Depends on maximum heap size The value you choose is the limit on memory that can be reserved for all Direct Byte Buffers. If a value is set for this option, the sum of all Direct Byte Buffer sizes cannot exceed the limit. After the limit is reached, a new Direct Byte Buffer can be allocated only when enough old buffers are freed to provide enough space to allocate the new buffer. By default, the VM limits the amount of heap memory used for Direct Byte Buffers to approximately 85% of the maximum heap size.","title":"Syntax"},{"location":"xxnosuballoc32bitmem/","text":"-XXnosuballoc32bitmem (z/OS\u00ae only) When compressed references are used with a 64-bit OpenJ9 VM on z/OS\u00ae, this option forces the VM to use 31-bit memory allocation functions provided by z/OS. Syntax -XXnosuballoc32bitmem Setting Effect Default -XXnosuballoc32bitmem Enable No setting Disable yes Explanation This option is provided as a workaround for customers who need to use fewer pages of 31-bit virtual storage per VM invocation. Using this option might result in a small increase in the number of frames of central storage used by the VM. However, the option frees 31-bit pages for use by native code or other applications in the same address space. If this option is not specified, the VM uses an allocation strategy for 31-bit memory that reserves a region of 31-bit virtual memory.","title":"-XXnosuballoc32bitmem"},{"location":"xxnosuballoc32bitmem/#-xxnosuballoc32bitmem","text":"(z/OS\u00ae only) When compressed references are used with a 64-bit OpenJ9 VM on z/OS\u00ae, this option forces the VM to use 31-bit memory allocation functions provided by z/OS.","title":"-XXnosuballoc32bitmem"},{"location":"xxnosuballoc32bitmem/#syntax","text":"-XXnosuballoc32bitmem Setting Effect Default -XXnosuballoc32bitmem Enable No setting Disable yes","title":"Syntax"},{"location":"xxnosuballoc32bitmem/#explanation","text":"This option is provided as a workaround for customers who need to use fewer pages of 31-bit virtual storage per VM invocation. Using this option might result in a small increase in the number of frames of central storage used by the VM. However, the option frees 31-bit pages for use by native code or other applications in the same address space. If this option is not specified, the VM uses an allocation strategy for 31-bit memory that reserves a region of 31-bit virtual memory.","title":"Explanation"},{"location":"xxonoutofmemoryerror/","text":"-XX:OnOutOfMemoryError You can use this Oracle HotSpot option to run commands when a java.lang.OutOfMemoryError is thrown. This option is recognized by OpenJ9 and provided for compatibility. Syntax -XX:OnOutOfMemoryError=\"<command_string>\" where <command_string> is a command or list of commands to run when a java.lang.OutOfMemoryError occurs. For example, the following command specifies that the java -version command is run if the Test application throws a java.lang.OutOfMemoryError exception: java -XX:OnOutOfMemoryError=\"java -version\" Test If you want to run multiple commands, use semicolons to separate them within <command_string> . For example: -XX:OnOutOfMemoryError=\"<java_path> <java_program>; cat file.txt\" The -XX:OnOutOfMemoryError option is equivalent to the following -Xdump option: -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec=<command_string> For more information, see -Xdump .","title":"-XX:OnOutOfMemoryError"},{"location":"xxonoutofmemoryerror/#-xxonoutofmemoryerror","text":"You can use this Oracle HotSpot option to run commands when a java.lang.OutOfMemoryError is thrown. This option is recognized by OpenJ9 and provided for compatibility.","title":"-XX:OnOutOfMemoryError"},{"location":"xxonoutofmemoryerror/#syntax","text":"-XX:OnOutOfMemoryError=\"<command_string>\" where <command_string> is a command or list of commands to run when a java.lang.OutOfMemoryError occurs. For example, the following command specifies that the java -version command is run if the Test application throws a java.lang.OutOfMemoryError exception: java -XX:OnOutOfMemoryError=\"java -version\" Test If you want to run multiple commands, use semicolons to separate them within <command_string> . For example: -XX:OnOutOfMemoryError=\"<java_path> <java_program>; cat file.txt\" The -XX:OnOutOfMemoryError option is equivalent to the following -Xdump option: -Xdump:tool:events=systhrow,filter=java/lang/OutOfMemoryError,exec=<command_string> For more information, see -Xdump .","title":"Syntax"},{"location":"xxoriginaljdk8heapsizecompatibilitymode/","text":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode The default value for the maximum heap size ( -Xmx ) is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. In OpenJ9 0.18.0 and earlier releases the default is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Enable this option to revert to the earlier default value. Restriction: This option is supported only on Java\u2122 8. It is ignored on Java 11 and later versions. Syntax -XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode Setting Effect Default -XX:+OriginalJDK8HeapSizeCompatibilityMode Enable -XX:-OriginalJDK8HeapSizeCompatibilityMode Disable yes","title":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode"},{"location":"xxoriginaljdk8heapsizecompatibilitymode/#-xx91-93originaljdk8heapsizecompatibilitymode","text":"The default value for the maximum heap size ( -Xmx ) is 25% of the available memory with a maximum of 25 GB. However, where there is 2 GB or less of physical memory, the value set is 50% of available memory with a minimum value of 16 MB and a maximum value of 512 MB. In OpenJ9 0.18.0 and earlier releases the default is half the available memory with a minimum of 16 MB and a maximum of 512 MB. Enable this option to revert to the earlier default value. Restriction: This option is supported only on Java\u2122 8. It is ignored on Java 11 and later versions.","title":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode"},{"location":"xxoriginaljdk8heapsizecompatibilitymode/#syntax","text":"-XX:[+|-]OriginalJDK8HeapSizeCompatibilityMode Setting Effect Default -XX:+OriginalJDK8HeapSizeCompatibilityMode Enable -XX:-OriginalJDK8HeapSizeCompatibilityMode Disable yes","title":"Syntax"},{"location":"xxpagealigndirectmemory/","text":"-XX:[+|-]PageAlignDirectMemory This Oracle HotSpot option affects the alignment of direct byte buffer allocation and is implemented by the OpenJ9 VM for compatibility. Syntax -XX:[+|-]PageAlignDirectMemory Setting Effect Default -XX:+PageAlignDirectMemory Enable -XX:-PageAlignDirectMemory Disable yes As discussed in the Oracle documentation, before Java\u2122 SE 7, direct buffers that were allocated using java.nio.ByteBuffer.allocateDirect(int) were aligned on a page boundary. This behavior changed in Java SE 7 and the -XX:+PageAlignDirectMemory option is provided to revert to the previous behavior. For more information about the changes, see RFE 4837564 , which was introduced in the Java SE 7 release notes .","title":"-XX:[+|-]PageAlignDirectMemory"},{"location":"xxpagealigndirectmemory/#-xx91-93pagealigndirectmemory","text":"This Oracle HotSpot option affects the alignment of direct byte buffer allocation and is implemented by the OpenJ9 VM for compatibility.","title":"-XX:[+|-]PageAlignDirectMemory"},{"location":"xxpagealigndirectmemory/#syntax","text":"-XX:[+|-]PageAlignDirectMemory Setting Effect Default -XX:+PageAlignDirectMemory Enable -XX:-PageAlignDirectMemory Disable yes As discussed in the Oracle documentation, before Java\u2122 SE 7, direct buffers that were allocated using java.nio.ByteBuffer.allocateDirect(int) were aligned on a page boundary. This behavior changed in Java SE 7 and the -XX:+PageAlignDirectMemory option is provided to revert to the previous behavior. For more information about the changes, see RFE 4837564 , which was introduced in the Java SE 7 release notes .","title":"Syntax"},{"location":"xxparallelcmsthreads/","text":"-XX:ParallelCMSThreads This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by OpenJ9 and provided for compatibility. Syntax -XX:ParallelCMSThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"-XX:ParallelCMSThreads"},{"location":"xxparallelcmsthreads/#-xxparallelcmsthreads","text":"This Oracle HotSpot option affects the number of threads used by the concurrent garbage collector. This option is recognized by OpenJ9 and provided for compatibility.","title":"-XX:ParallelCMSThreads"},{"location":"xxparallelcmsthreads/#syntax","text":"-XX:ParallelCMSThreads=<number> Where <number> is the number of low-priority background threads that are attached to assist the mutator threads in concurrent mark. Within OpenJ9 this option is directly mapped to -Xconcurrentbackground .","title":"Syntax"},{"location":"xxparallelgcthreads/","text":"-XX:ParallelGCThread This Oracle HotSpot option specifies the number of threads that are used during parallel operations of the default garbage collector. This option is recognized by OpenJ9 and provided for compatibility. Syntax -XX:ParallelGCThreads=<number> Where <number> is the number of threads that are used for parallel operations. Within OpenJ9 this option is directly mapped to -Xgcthreads .","title":"-XX:ParallelGCThreads"},{"location":"xxparallelgcthreads/#-xxparallelgcthread","text":"This Oracle HotSpot option specifies the number of threads that are used during parallel operations of the default garbage collector. This option is recognized by OpenJ9 and provided for compatibility.","title":"-XX:ParallelGCThread"},{"location":"xxparallelgcthreads/#syntax","text":"-XX:ParallelGCThreads=<number> Where <number> is the number of threads that are used for parallel operations. Within OpenJ9 this option is directly mapped to -Xgcthreads .","title":"Syntax"},{"location":"xxpositiveidentityhash/","text":"-XX:[+|-]PositiveIdentityHash OpenJ9 allows both positive and negative identity hashcodes ( System.identityHashCode / Object.hashCode ). This is problematic for programs that incorrectly assume hashcodes can only be positive. When enabled, this option limits identity hash codes to non-negative values. Because limiting identity hash codes to non-negative values can have an impact on the performance of hash-intensive operations, this option is not enabled by default. Syntax -XX:[+|-]PositiveIdentityHash Setting Effect Default -XX:+PositiveIdentityHash Enable -XX:-PositiveIdentityHash Disable yes","title":"-XX:[+|-]PositiveIdentityHash"},{"location":"xxpositiveidentityhash/#-xx91-93positiveidentityhash","text":"OpenJ9 allows both positive and negative identity hashcodes ( System.identityHashCode / Object.hashCode ). This is problematic for programs that incorrectly assume hashcodes can only be positive. When enabled, this option limits identity hash codes to non-negative values. Because limiting identity hash codes to non-negative values can have an impact on the performance of hash-intensive operations, this option is not enabled by default.","title":"-XX:[+|-]PositiveIdentityHash"},{"location":"xxpositiveidentityhash/#syntax","text":"-XX:[+|-]PositiveIdentityHash Setting Effect Default -XX:+PositiveIdentityHash Enable -XX:-PositiveIdentityHash Disable yes","title":"Syntax"},{"location":"xxprintcodecache/","text":"-XX:[+|-]PrintCodeCache This Oracle HotSpot option prints the code cache memory usage when the application exits. This option is recognized by OpenJ9 and provided for compatibility. Syntax -XX:[+|-]PrintCodeCache Setting Effect Default -XX:+PrintCodeCache Enable -XX:-PrintCodeCache Disable yes As discussed in the Oracle documentation, the code cache usage can be shown when the application exits, by specifying \u2013XX:+PrintCodeCache on the Java launcher command line. The output looks similar to the following: CodeCache: size=262144Kb used=454Kb max_used=457Kb free=261690Kb size : The maximum size of the code cache. used : The amount of code cache memory actually in use. max_used : The high water mark for code cache usage. free : size minus used .","title":"-XX:[+|-]PrintCodeCache"},{"location":"xxprintcodecache/#-xx91-93printcodecache","text":"This Oracle HotSpot option prints the code cache memory usage when the application exits. This option is recognized by OpenJ9 and provided for compatibility.","title":"-XX:[+|-]PrintCodeCache"},{"location":"xxprintcodecache/#syntax","text":"-XX:[+|-]PrintCodeCache Setting Effect Default -XX:+PrintCodeCache Enable -XX:-PrintCodeCache Disable yes As discussed in the Oracle documentation, the code cache usage can be shown when the application exits, by specifying \u2013XX:+PrintCodeCache on the Java launcher command line. The output looks similar to the following: CodeCache: size=262144Kb used=454Kb max_used=457Kb free=261690Kb size : The maximum size of the code cache. used : The amount of code cache memory actually in use. max_used : The high water mark for code cache usage. free : size minus used .","title":"Syntax"},{"location":"xxprintflagsfinal/","text":"-XX:[+|-]PrintFlagsFinal When enabled, this option outputs the values of a subset of configuration parameters in a format compatible with that produced by HotSpot. The parameters currently output are those expected by various software projects and packages. Syntax -XX:[+|-]PrintFlagsFinal Setting Effect Default -XX:+PrintFlagsFinal Enable -XX:-PrintFlagsFinal Disable yes Example Here is an example of typical output from -XX:+PrintFlagsFinal : [Global flags] size_t MaxHeapSize = 4294967296 {product} {ergonomic} uint64_t MaxDirectMemorySize = 3758096384 {product} {ergonomic}","title":"-XX:[+|-]PrintFlagsFinal"},{"location":"xxprintflagsfinal/#-xx91-93printflagsfinal","text":"When enabled, this option outputs the values of a subset of configuration parameters in a format compatible with that produced by HotSpot. The parameters currently output are those expected by various software projects and packages.","title":"-XX:[+|-]PrintFlagsFinal"},{"location":"xxprintflagsfinal/#syntax","text":"-XX:[+|-]PrintFlagsFinal Setting Effect Default -XX:+PrintFlagsFinal Enable -XX:-PrintFlagsFinal Disable yes","title":"Syntax"},{"location":"xxprintflagsfinal/#example","text":"Here is an example of typical output from -XX:+PrintFlagsFinal : [Global flags] size_t MaxHeapSize = 4294967296 {product} {ergonomic} uint64_t MaxDirectMemorySize = 3758096384 {product} {ergonomic}","title":"Example"},{"location":"xxreadipinfoforras/","text":"-XX:[+|-]ReadIPInfoForRAS Use this command-line option to enable and disable network queries from being used to determine the host name and IP address for RAS (reliability, availability, and serviceability) troubleshooting purposes. Syntax -XX:[+|-]ReadIPInfoForRAS Setting Effect Default -XX:+ReadIPInfoForRAS Enable yes -XX:-ReadIPInfoForRAS Disable OpenJ9 captures the host name and IP address by default, for use in diagnosing problems. But if a nameserver cannot be contacted when a network query is made, the program will wait until the resolver times out. You can avoid this situation by using the -XX:-ReadIPInfoForRAS command-line option to prevent the query from being performed.","title":"-XX:[+|-]ReadIPInfoForRAS"},{"location":"xxreadipinfoforras/#-xx91-93readipinfoforras","text":"Use this command-line option to enable and disable network queries from being used to determine the host name and IP address for RAS (reliability, availability, and serviceability) troubleshooting purposes.","title":"-XX:[+|-]ReadIPInfoForRAS"},{"location":"xxreadipinfoforras/#syntax","text":"-XX:[+|-]ReadIPInfoForRAS Setting Effect Default -XX:+ReadIPInfoForRAS Enable yes -XX:-ReadIPInfoForRAS Disable OpenJ9 captures the host name and IP address by default, for use in diagnosing problems. But if a nameserver cannot be contacted when a network query is made, the program will wait until the resolver times out. You can avoid this situation by using the -XX:-ReadIPInfoForRAS command-line option to prevent the query from being performed.","title":"Syntax"},{"location":"xxreducecpumonitoroverhead/","text":"-XX:[+|-]ReduceCPUMonitorOverhead (AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) This option relates to the CPU usage of thread categories that can be obtained with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. This option affects the way that the VM records the amount of CPU usage of non-Garbage Collection (GC) threads that do work on behalf of GC. Most GC policies require non-GC threads to do some GC housekeeping work in proportion to the amount of memory allocation that they do. Ideally the exact amount of CPU time that the thread spends doing this housekeeping work should be accounted for in the GC thread category. However there is an overhead that is associated with maintaining the CPU usage data in the correct thread category. Restriction: This option is not supported on z/OS\u00ae. If you attempt to use this option, the following message is generated: JVMJ9VM145E -XX:-ReduceCPUMonitorOverhead is unsupported on z/OS. Error: Could not create the Java Virtual Machine. Syntax -XX:[+|-]ReduceCPUMonitorOverhead Setting Effect Default -XX:+ReduceCPUMonitorOverhead Enable yes -XX:-ReduceCPUMonitorOverhead Disable When you enable this option, the VM does not maintain information on the amount of CPU usage that non-GC threads spend in doing work on behalf of GC. If you set -XX:-ReduceCPUMonitorOverhead , the OpenJ9 VM monitors the amount of GC work that a non-GC thread does and accounts for it in the GC category. This information is made available in the com.ibm.lang.management.JvmCpuMonitorMXBean . Setting this option results in a small increase in application startup time, which varies according to platform. See also -XX:[+|-]EnableCPUMonitor","title":"-XX:[+|-]ReduceCPUMonitorOverhead"},{"location":"xxreducecpumonitoroverhead/#-xx91-93reducecpumonitoroverhead","text":"(AIX\u00ae, Linux\u00ae, macOS\u00ae, and Windows\u2122 only) This option relates to the CPU usage of thread categories that can be obtained with the com.ibm.lang.management.JvmCpuMonitorMXBean application programming interface. This option affects the way that the VM records the amount of CPU usage of non-Garbage Collection (GC) threads that do work on behalf of GC. Most GC policies require non-GC threads to do some GC housekeeping work in proportion to the amount of memory allocation that they do. Ideally the exact amount of CPU time that the thread spends doing this housekeeping work should be accounted for in the GC thread category. However there is an overhead that is associated with maintaining the CPU usage data in the correct thread category. Restriction: This option is not supported on z/OS\u00ae. If you attempt to use this option, the following message is generated: JVMJ9VM145E -XX:-ReduceCPUMonitorOverhead is unsupported on z/OS. Error: Could not create the Java Virtual Machine.","title":"-XX:[+|-]ReduceCPUMonitorOverhead"},{"location":"xxreducecpumonitoroverhead/#syntax","text":"-XX:[+|-]ReduceCPUMonitorOverhead Setting Effect Default -XX:+ReduceCPUMonitorOverhead Enable yes -XX:-ReduceCPUMonitorOverhead Disable When you enable this option, the VM does not maintain information on the amount of CPU usage that non-GC threads spend in doing work on behalf of GC. If you set -XX:-ReduceCPUMonitorOverhead , the OpenJ9 VM monitors the amount of GC work that a non-GC thread does and accounts for it in the GC category. This information is made available in the com.ibm.lang.management.JvmCpuMonitorMXBean . Setting this option results in a small increase in application startup time, which varies according to platform.","title":"Syntax"},{"location":"xxreducecpumonitoroverhead/#see-also","text":"-XX:[+|-]EnableCPUMonitor","title":"See also"},{"location":"xxruntimeinstrumentation/","text":"-XX:[+|-]RuntimeInstrumentation (AIX\u00ae, Linux\u00ae, and z/OS\u00ae only) This option controls the use of the Runtime Instrumentation (RI) facility in the virtual machines that support it. The RI facility is a feature that is available in POWER8\u00ae, zEC12, and later processors that offers hardware support for collecting profiling information at run time. The process uses minimal resources. The use of the RI facility is not enabled by default. Syntax -XX:[+|-]RuntimeInstrumentation Setting Effect Default -XX:+RuntimeInstrumentation Enable -XX:-RuntimeInstrumentation Disable yes Note: On Linux, the RI facility on Power 8 and later processors uses the Performance Monitoring Unit (PMU) inside the processor. However, the PMU is also used by system profilers like oprofile or perf . Due to the current Linux kernel implementation, a user cannot reliably profile a Java\u2122 application when RI is enabled. Although this limitation might be addressed in future Linux kernels, for reliable profiling on Power systems that use Linux, the -XX:-RuntimeInstrumentation option must be used.","title":"-XX:[+|-]RuntimeInstrumentation"},{"location":"xxruntimeinstrumentation/#-xx91-93runtimeinstrumentation","text":"(AIX\u00ae, Linux\u00ae, and z/OS\u00ae only) This option controls the use of the Runtime Instrumentation (RI) facility in the virtual machines that support it. The RI facility is a feature that is available in POWER8\u00ae, zEC12, and later processors that offers hardware support for collecting profiling information at run time. The process uses minimal resources. The use of the RI facility is not enabled by default.","title":"-XX:[+|-]RuntimeInstrumentation"},{"location":"xxruntimeinstrumentation/#syntax","text":"-XX:[+|-]RuntimeInstrumentation Setting Effect Default -XX:+RuntimeInstrumentation Enable -XX:-RuntimeInstrumentation Disable yes Note: On Linux, the RI facility on Power 8 and later processors uses the Performance Monitoring Unit (PMU) inside the processor. However, the PMU is also used by system profilers like oprofile or perf . Due to the current Linux kernel implementation, a user cannot reliably profile a Java\u2122 application when RI is enabled. Although this limitation might be addressed in future Linux kernels, for reliable profiling on Power systems that use Linux, the -XX:-RuntimeInstrumentation option must be used.","title":"Syntax"},{"location":"xxsethwprefetch/","text":"-XXsetHWPrefetch (AIX\u00ae only) This option enables or disables hardware prefetch. Hardware prefetch can improve the performance of applications by prefetching memory. However, because of the workload characteristics of many Java\u2122 applications, prefetching often has an adverse effect on performance. Syntax -XXsetHWPrefetch=[none|os-default] Setting Effect Default none Disable yes os-default Enable The -XXsetHWPrefetch:none option disables hardware prefetch. Although you can disable hardware prefetch on AIX by issuing the command dscrctl -n -s 1 , this command disables hardware prefetch for all processes, and for all future processes, which might not be desirable in a mixed workload environment. The -XXsetHWPrefetch:none option allows hardware prefetch to be disabled for individual VMs. To enable hardware prefetch with the default value for the operating system, specify -XXsetHWPrefetch:os-default . Use this option only for applications that can obtain a performance gain from hardware prefetch.","title":"-XXsetHWPrefetch"},{"location":"xxsethwprefetch/#-xxsethwprefetch","text":"(AIX\u00ae only) This option enables or disables hardware prefetch. Hardware prefetch can improve the performance of applications by prefetching memory. However, because of the workload characteristics of many Java\u2122 applications, prefetching often has an adverse effect on performance.","title":"-XXsetHWPrefetch"},{"location":"xxsethwprefetch/#syntax","text":"-XXsetHWPrefetch=[none|os-default] Setting Effect Default none Disable yes os-default Enable The -XXsetHWPrefetch:none option disables hardware prefetch. Although you can disable hardware prefetch on AIX by issuing the command dscrctl -n -s 1 , this command disables hardware prefetch for all processes, and for all future processes, which might not be desirable in a mixed workload environment. The -XXsetHWPrefetch:none option allows hardware prefetch to be disabled for individual VMs. To enable hardware prefetch with the default value for the operating system, specify -XXsetHWPrefetch:os-default . Use this option only for applications that can obtain a performance gain from hardware prefetch.","title":"Syntax"},{"location":"xxshareanonymousclasses/","text":"-XX:[+|-]ShareAnonymousClasses This option enables and disables the storage of VM anonymous classes, those created by Unsafe.defineAnonymousClass , in the shared classes cache. The option is enabled by default, which means that anonymous classes are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance. Syntax -XX:[+|-]ShareAnonymousClasses Setting Effect Default -XX:+ShareAnonymousClasses Enable yes -XX:-ShareAnonymousClasses Disable See also AOT compiler Class data sharing -Xshareclasses -XX:[+|-]ShareUnsafeClasses","title":"-XX:[+|-]ShareAnonymousClasses"},{"location":"xxshareanonymousclasses/#-xx-shareanonymousclasses","text":"This option enables and disables the storage of VM anonymous classes, those created by Unsafe.defineAnonymousClass , in the shared classes cache. The option is enabled by default, which means that anonymous classes are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance.","title":"-XX:[+|-]ShareAnonymousClasses"},{"location":"xxshareanonymousclasses/#syntax","text":"-XX:[+|-]ShareAnonymousClasses Setting Effect Default -XX:+ShareAnonymousClasses Enable yes -XX:-ShareAnonymousClasses Disable","title":"Syntax"},{"location":"xxshareanonymousclasses/#see-also","text":"AOT compiler Class data sharing -Xshareclasses -XX:[+|-]ShareUnsafeClasses","title":"See also"},{"location":"xxshareclassesenablebci/","text":"-XX:ShareClassesDisableBCI / -XX:ShareClassesEnableBCI The option -Xshareclasses:enableBCI improves startup performance without using a modification context, when using JVMTI class modification. This suboption allows classes loaded from the shared cache to be modified using a JVMTI ClassFileLoadHook , or a java.lang.instrument agent, and prevents modified classes being stored in the shared classes cache. You can turn off this option by specifying -XX:ShareClassesDisableBCI when you start your Java\u2122 application. Syntax -XX:ShareClassesDisableBCI|ShareClassesEnableBCI Setting Effect Default -XX:ShareClassesDisableBCI Disable -XX:ShareClassesEnableBCI Enable yes These options are equivalent to -Xshareclasses:disableBCI and -Xshareclasses:enableBCI . For more information, see -Xshareclasses . See also Runtime bytecode modification","title":"-XX:ShareClassesEnableBCI"},{"location":"xxshareclassesenablebci/#-xxshareclassesdisablebci-xxshareclassesenablebci","text":"The option -Xshareclasses:enableBCI improves startup performance without using a modification context, when using JVMTI class modification. This suboption allows classes loaded from the shared cache to be modified using a JVMTI ClassFileLoadHook , or a java.lang.instrument agent, and prevents modified classes being stored in the shared classes cache. You can turn off this option by specifying -XX:ShareClassesDisableBCI when you start your Java\u2122 application.","title":"-XX:ShareClassesDisableBCI /  -XX:ShareClassesEnableBCI"},{"location":"xxshareclassesenablebci/#syntax","text":"-XX:ShareClassesDisableBCI|ShareClassesEnableBCI Setting Effect Default -XX:ShareClassesDisableBCI Disable -XX:ShareClassesEnableBCI Enable yes These options are equivalent to -Xshareclasses:disableBCI and -Xshareclasses:enableBCI . For more information, see -Xshareclasses .","title":"Syntax"},{"location":"xxshareclassesenablebci/#see-also","text":"Runtime bytecode modification","title":"See also"},{"location":"xxsharedcachehardlimit/","text":"-XX:SharedCacheHardLimit Specifies the size for a new shared classes cache. Use this option together with the -Xscmx option to set actual and soft maximum size limits respectively. Syntax -XX:SharedCacheHardLimit=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] See Using -X command-line options for more information about the <size> parameter. When you use this option with the -Xscmx option, the -Xscmx option sets the soft maximum size, and the -XX:SharedCacheHardLimit option sets the actual size, of a new shared classes cache. For more information, see -Xscmx . If you use this option without the -Xscmx option, the behavior is the same as using the -Xscmx option by itself; both options set the actual size of the shared classes cache. For more information about cache sizes, see Cache size limits . Example The following settings, when used together, set the soft maximum size of the shared classes cache to 16 MB and the actual maximum cache size to 64 MB. -XX:SharedCacheHardLimit=64m -Xscmx16m See also -Xscmx","title":"-XX:SharedCacheHardLimit"},{"location":"xxsharedcachehardlimit/#-xxsharedcachehardlimit","text":"Specifies the size for a new shared classes cache. Use this option together with the -Xscmx option to set actual and soft maximum size limits respectively.","title":"-XX:SharedCacheHardLimit"},{"location":"xxsharedcachehardlimit/#syntax","text":"-XX:SharedCacheHardLimit=<size> Setting Value Default <size> [1[k|K|m|M|g|G] or greater] See Using -X command-line options for more information about the <size> parameter. When you use this option with the -Xscmx option, the -Xscmx option sets the soft maximum size, and the -XX:SharedCacheHardLimit option sets the actual size, of a new shared classes cache. For more information, see -Xscmx . If you use this option without the -Xscmx option, the behavior is the same as using the -Xscmx option by itself; both options set the actual size of the shared classes cache. For more information about cache sizes, see Cache size limits .","title":"Syntax"},{"location":"xxsharedcachehardlimit/#example","text":"The following settings, when used together, set the soft maximum size of the shared classes cache to 16 MB and the actual maximum cache size to 64 MB. -XX:SharedCacheHardLimit=64m -Xscmx16m","title":"Example"},{"location":"xxsharedcachehardlimit/#see-also","text":"-Xscmx","title":"See also"},{"location":"xxshareunsafeclasses/","text":"-XX:[+|-]ShareUnsafeClasses This option enables and disables the storage of VM classes created through Unsafe.defineClass in the shared classes cache. The option is enabled by default, which means that unsafe classes are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance. Syntax -XX:[+|-]ShareUnsafeClasses Setting Effect Default -XX:+ShareUnsafeClasses Enable yes -XX:-ShareUnsafeClasses Disable See also AOT compiler Class data sharing -Xshareclasses -XX:[+|-]ShareAnonymousClasses","title":"-XX:[+|-]ShareUnsafeClasses"},{"location":"xxshareunsafeclasses/#-xx-shareunsafeclasses","text":"This option enables and disables the storage of VM classes created through Unsafe.defineClass in the shared classes cache. The option is enabled by default, which means that unsafe classes are stored in the shared classes cache and are therefore available for ahead-of-time (AOT) compilation, potentially improving startup performance.","title":"-XX:[+|-]ShareUnsafeClasses"},{"location":"xxshareunsafeclasses/#syntax","text":"-XX:[+|-]ShareUnsafeClasses Setting Effect Default -XX:+ShareUnsafeClasses Enable yes -XX:-ShareUnsafeClasses Disable","title":"Syntax"},{"location":"xxshareunsafeclasses/#see-also","text":"AOT compiler Class data sharing -Xshareclasses -XX:[+|-]ShareAnonymousClasses","title":"See also"},{"location":"xxstacktraceinthrowable/","text":"-XX:-StackTraceInThrowable This option removes stack traces from exceptions. Syntax -XX:-StackTraceInThrowable Setting Effect Default -XX:-StackTraceInThrowable Disable No While stack traces are included in exceptions by default, recording them can have a negative impact on performance. Use this option if you want to remove stack traces, although this might cause difficulties with problem determination. When this option is enabled, Throwable.getStackTrace() returns an empty array and the stack trace is displayed when an uncaught exception occurs. Thread.getStackTrace() and Thread.getAllStackTraces() are not affected by this option.","title":"-XX:-StackTraceInThrowable"},{"location":"xxstacktraceinthrowable/#-xx-stacktraceinthrowable","text":"This option removes stack traces from exceptions.","title":"-XX:-StackTraceInThrowable"},{"location":"xxstacktraceinthrowable/#syntax","text":"-XX:-StackTraceInThrowable Setting Effect Default -XX:-StackTraceInThrowable Disable No While stack traces are included in exceptions by default, recording them can have a negative impact on performance. Use this option if you want to remove stack traces, although this might cause difficulties with problem determination. When this option is enabled, Throwable.getStackTrace() returns an empty array and the stack trace is displayed when an uncaught exception occurs. Thread.getStackTrace() and Thread.getAllStackTraces() are not affected by this option.","title":"Syntax"},{"location":"xxtransparenthugepage/","text":"-XX:[+|-]TransparentHugePage (Linux\u00ae systems only: x86, POWER\u00ae, and IBM Z\u00ae) If Transparent Huge Pages (THP) is set to madvise on your system, this option, when enabled, promotes all memory allocated to huge pages. On systems without THP, or if THP is set to always or never on your system, this option is ignored. When transparent huge pages are used, your application footprint might increase. Syntax Setting Effect Default -XX:+TransparentHugePage Enable yes -XX:-TransparentHugePage Disable","title":"-XX:[+|-]TransparentHugePage"},{"location":"xxtransparenthugepage/#-xx-transparenthugepage","text":"(Linux\u00ae systems only: x86, POWER\u00ae, and IBM Z\u00ae) If Transparent Huge Pages (THP) is set to madvise on your system, this option, when enabled, promotes all memory allocated to huge pages. On systems without THP, or if THP is set to always or never on your system, this option is ignored. When transparent huge pages are used, your application footprint might increase.","title":"-XX:[+|-]TransparentHugePage"},{"location":"xxtransparenthugepage/#syntax","text":"Setting Effect Default -XX:+TransparentHugePage Enable yes -XX:-TransparentHugePage Disable","title":"Syntax"},{"location":"xxusecompressedoops/","text":"-XX:[+|-]UseCompressedOops (64-bit only) This Oracle HotSpot option enables or disables compressed references in 64-bit JVMs. The option is recognized by the OpenJ9 VM and is provided to help when porting applications from the HotSpot JVM to the OpenJ9 VM. This option might not be supported in subsequent releases. Syntax -XX:[+|-]UseCompressedOops Setting Effect Default -XX:+UseCompressedOops Enable -XX:-UseCompressedOops Disable The -XX:+UseCompressedOops option is similar to specifying -Xcompressedrefs . Compressed references are used by default when the maximum memory size for an application is set above a platform-specific value. For more information, see -Xcompressedrefs .","title":"-XX:[+|-]UseCompressedOops"},{"location":"xxusecompressedoops/#-xx91-93usecompressedoops","text":"(64-bit only) This Oracle HotSpot option enables or disables compressed references in 64-bit JVMs. The option is recognized by the OpenJ9 VM and is provided to help when porting applications from the HotSpot JVM to the OpenJ9 VM. This option might not be supported in subsequent releases.","title":"-XX:[+|-]UseCompressedOops"},{"location":"xxusecompressedoops/#syntax","text":"-XX:[+|-]UseCompressedOops Setting Effect Default -XX:+UseCompressedOops Enable -XX:-UseCompressedOops Disable The -XX:+UseCompressedOops option is similar to specifying -Xcompressedrefs . Compressed references are used by default when the maximum memory size for an application is set above a platform-specific value. For more information, see -Xcompressedrefs .","title":"Syntax"},{"location":"xxusecontainersupport/","text":"-XX:[+|-]UseContainerSupport (Linux\u00ae only) If your application is running in a container that imposes a memory limit, the VM allocates a larger fraction of memory to the Java heap. To turn off this behavior, set the -XX:-UseContainerSupport option on the command line. Syntax -XX:[+|-]UseContainerSupport Setting Effect Default -XX:-UseContainerSupport Disable -XX:+UseContainerSupport Enable yes When using container technology, applications are typically run on their own and do not need to compete for memory. The OpenJ9 VM detects when it is running inside a container that imposes a memory limit, and adjusts the maximum Java heap size appropriately. The following table shows the values that are used when -XX:+UseContainerSupport is set: Container memory limit <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512 MB Greater than 2 GB 75% <size> The default heap size for containers takes affect only when the following conditions are met: The application is running in a container environment. The memory limit for the container is set. The -XX:+UseContainerSupport option is set, which is the default behavior. To prevent the VM adjusting the maximum heap size when running in a container, set -XX:-UseContainerSupport . When -XX:MaxRAMPercentage / -XX:InitialRAMPercentage are used with -XX:+UseContainerSupport , the corresponding heap setting is determined based on the memory limit of the container. For example, to set the maximum heap size to 80% of the container memory, specify the following options: -XX:+UseContainerSupport -XX:MaxRAMPercentage=80","title":"-XX:[+|-]UseContainerSupport"},{"location":"xxusecontainersupport/#-xx-usecontainersupport","text":"(Linux\u00ae only) If your application is running in a container that imposes a memory limit, the VM allocates a larger fraction of memory to the Java heap. To turn off this behavior, set the -XX:-UseContainerSupport option on the command line.","title":"-XX:[+|-]UseContainerSupport"},{"location":"xxusecontainersupport/#syntax","text":"-XX:[+|-]UseContainerSupport Setting Effect Default -XX:-UseContainerSupport Disable -XX:+UseContainerSupport Enable yes When using container technology, applications are typically run on their own and do not need to compete for memory. The OpenJ9 VM detects when it is running inside a container that imposes a memory limit, and adjusts the maximum Java heap size appropriately. The following table shows the values that are used when -XX:+UseContainerSupport is set: Container memory limit <size> Maximum Java heap size Less than 1 GB 50% <size> 1 GB - 2 GB <size> - 512 MB Greater than 2 GB 75% <size> The default heap size for containers takes affect only when the following conditions are met: The application is running in a container environment. The memory limit for the container is set. The -XX:+UseContainerSupport option is set, which is the default behavior. To prevent the VM adjusting the maximum heap size when running in a container, set -XX:-UseContainerSupport . When -XX:MaxRAMPercentage / -XX:InitialRAMPercentage are used with -XX:+UseContainerSupport , the corresponding heap setting is determined based on the memory limit of the container. For example, to set the maximum heap size to 80% of the container memory, specify the following options: -XX:+UseContainerSupport -XX:MaxRAMPercentage=80","title":"Syntax"},{"location":"xxusegcstartuphints/","text":"-XX:[+|-]UseGCStartupHints When this option is enabled, the VM calculates, over several application restarts, an appropriate startup heap size for your application. You can therefore use this option instead of calculating and setting an -Xms value yourself. Setting an initial size for the heap that is larger than the default helps to avoid frequent garbage collections during the startup phase of an application. Syntax -XX:[+|-]UseGCStartupHints Setting Effect Default -XX:+UseGCStartupHints Enable yes -XX:-UseGCStartupHints Disable When enabled, the VM records the heap size when a startup complete event occurs, storing the value into the shared classes cache. On subsequent restarts, the garbage collector (GC) reads this value early in startup processing and expands the heap to an appropriate value. For accuracy and stability, averages are taken over a few restarts to stabilize the value used. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. You can check the value used by the garbage collector for heap expansion by inspecting verbose GC output. The following example shows heap expansion based on hints from the previous run when using the gencon policy: <heap-resize id=\"2\" type=\"expand\" space=\"nursery\" amount=\"205258752\" count=\"1\" timems=\"0.328\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.021\" /> <heap-resize id=\"3\" type=\"expand\" space=\"tenure\" amount=\"692649984\" count=\"1\" timems=\"0.326\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.022\" /> The final value stored to the shared cache is not recorded in the verbose GC output. Notes: When enabled, this option overrides any initial heap size that is specified on the command line, for example by using the -Xms option. Because the shared classes cache is used to store heap size information, this option does not work if shared classes are disabled. Restriction: This feature is not currently available with the Balanced GC policy.","title":"-XX:[+|-]UseGCStartupHints"},{"location":"xxusegcstartuphints/#-xx91-93usegcstartuphints","text":"When this option is enabled, the VM calculates, over several application restarts, an appropriate startup heap size for your application. You can therefore use this option instead of calculating and setting an -Xms value yourself. Setting an initial size for the heap that is larger than the default helps to avoid frequent garbage collections during the startup phase of an application.","title":"-XX:[+|-]UseGCStartupHints"},{"location":"xxusegcstartuphints/#syntax","text":"-XX:[+|-]UseGCStartupHints Setting Effect Default -XX:+UseGCStartupHints Enable yes -XX:-UseGCStartupHints Disable When enabled, the VM records the heap size when a startup complete event occurs, storing the value into the shared classes cache. On subsequent restarts, the garbage collector (GC) reads this value early in startup processing and expands the heap to an appropriate value. For accuracy and stability, averages are taken over a few restarts to stabilize the value used. The heap size recorded is specific to the application command line, therefore a different hint is stored for every unique command line. You can check the value used by the garbage collector for heap expansion by inspecting verbose GC output. The following example shows heap expansion based on hints from the previous run when using the gencon policy: <heap-resize id=\"2\" type=\"expand\" space=\"nursery\" amount=\"205258752\" count=\"1\" timems=\"0.328\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.021\" /> <heap-resize id=\"3\" type=\"expand\" space=\"tenure\" amount=\"692649984\" count=\"1\" timems=\"0.326\" reason=\"hint from previous runs\" timestamp=\"2019-06-05T13:26:32.022\" /> The final value stored to the shared cache is not recorded in the verbose GC output. Notes: When enabled, this option overrides any initial heap size that is specified on the command line, for example by using the -Xms option. Because the shared classes cache is used to store heap size information, this option does not work if shared classes are disabled. Restriction: This feature is not currently available with the Balanced GC policy.","title":"Syntax"},{"location":"xxusenogc/","text":"-XX:[+|-]UseNoGC The -XX:+UseNoGC option enables a garbage collection policy that expands the Java object heap in the normal way until the limit is reached, but memory is not reclaimed through garbage collection. Syntax -XX:[+|-]UseNoGC Setting Effect Default -XX:+UseNoGC Enable -XX:-UseNoGC Disable yes Explanation This policy can be useful for test purposes and for short-lived applications. When the limit is reached an OutOfMemory error is generated and the VM shuts down. The -XX:-UseNoGC option turns off a previously enabled -XX:+UseNoGC option. This policy can also be enabled with the -Xgcpolicy:nogc option. See -Xgcpolicy:nogc for more details about this policy and when it is appropriate to use it.","title":"-XX:[+|-]UseNoGC"},{"location":"xxusenogc/#-xx91-93usenogc","text":"The -XX:+UseNoGC option enables a garbage collection policy that expands the Java object heap in the normal way until the limit is reached, but memory is not reclaimed through garbage collection.","title":"-XX:[+|-]UseNoGC"},{"location":"xxusenogc/#syntax","text":"-XX:[+|-]UseNoGC Setting Effect Default -XX:+UseNoGC Enable -XX:-UseNoGC Disable yes","title":"Syntax"},{"location":"xxusenogc/#explanation","text":"This policy can be useful for test purposes and for short-lived applications. When the limit is reached an OutOfMemory error is generated and the VM shuts down. The -XX:-UseNoGC option turns off a previously enabled -XX:+UseNoGC option. This policy can also be enabled with the -Xgcpolicy:nogc option. See -Xgcpolicy:nogc for more details about this policy and when it is appropriate to use it.","title":"Explanation"},{"location":"xxverboseverification/","text":"-XX:[+|-]VerboseVerification You can use this option to control the output of verbose diagnostic data that relates to verification. The Oracle documentation to support this option is no longer available, because it is no longer used by the HotSpot VM. An explanation is provided here. Syntax -XX:[+|-]VerboseVerification Setting Effect Default -XX:-VerboseVerification Disable yes -XX:+VerboseVerification Enable Use -XX:-VerboseVerification to enable the output of verbose diagnostic data to stderr that is generated during verification from the class file StackMapTable attribute. The data provides extra contextual information about bytecode verification, which helps diagnose bytecode or stackmap deficiencies in the field. Class files that have StackMapTable attributes (that is, class files that conform to version 50.0 or later of the class file format specification), are introduced in Java\u2122 V6. Class files with StackMapTable attributes are marked as new format in the verbose output, as shown in the example. Class files without the StackMapTable attributes are marked as old format . The StackMapTable diagnostic information is available only to classes verified with the new format. Here is an example of StackMapTable diagnostic output: Verifying class java.example.ibm.com with new format Verifying method java.example.ibm.com.foo(Ljava/lang/String;Ljava/lang/Class;[Ljava/lang/String;Ljava/io/PrintStream;)I StackMapTable: frame_count = 3 table = { bci: @37 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/ThreadDeath' } bci: @42 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/Throwable' } bci: @79 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class', 'java/lang/Throwable' } stack: { } } End class verification for: java.example.ibm.com","title":"-XX:[+|-]VerboseVerification"},{"location":"xxverboseverification/#-xx91-93verboseverification","text":"You can use this option to control the output of verbose diagnostic data that relates to verification. The Oracle documentation to support this option is no longer available, because it is no longer used by the HotSpot VM. An explanation is provided here.","title":"-XX:[+|-]VerboseVerification"},{"location":"xxverboseverification/#syntax","text":"-XX:[+|-]VerboseVerification Setting Effect Default -XX:-VerboseVerification Disable yes -XX:+VerboseVerification Enable Use -XX:-VerboseVerification to enable the output of verbose diagnostic data to stderr that is generated during verification from the class file StackMapTable attribute. The data provides extra contextual information about bytecode verification, which helps diagnose bytecode or stackmap deficiencies in the field. Class files that have StackMapTable attributes (that is, class files that conform to version 50.0 or later of the class file format specification), are introduced in Java\u2122 V6. Class files with StackMapTable attributes are marked as new format in the verbose output, as shown in the example. Class files without the StackMapTable attributes are marked as old format . The StackMapTable diagnostic information is available only to classes verified with the new format. Here is an example of StackMapTable diagnostic output: Verifying class java.example.ibm.com with new format Verifying method java.example.ibm.com.foo(Ljava/lang/String;Ljava/lang/Class;[Ljava/lang/String;Ljava/io/PrintStream;)I StackMapTable: frame_count = 3 table = { bci: @37 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/ThreadDeath' } bci: @42 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class' } stack: { 'java/lang/Throwable' } bci: @79 flags: { } locals: { 'java/lang/String', 'java/lang/Class', '[Ljava/lang/String;', 'java/io/PrintStream', 'java/lang/Class', 'java/lang/Throwable' } stack: { } } End class verification for: java.example.ibm.com","title":"Syntax"},{"location":"xxvmlockclassloader/","text":"-XX:[+|-]VMLockClassLoader This option affects synchronization on class loaders that are not parallel-capable class loaders, during class loading. Syntax -XX:[+|-]VMLockClassLoader Setting Effect Default -XX:+VMLockClassLoader Enable yes -XX:-VMLockClassLoader Disable The option, -XX:+VMLockClassLoader , causes the VM to force synchronization on a class loader that is not a parallel capable class loader during class loading. This action occurs even if the loadClass() method for that class loader is not synchronized. For information about parallel capable class loaders, see java.lang.ClassLoader.registerAsParallelCapable() . Note that this option might cause a deadlock if class loaders use non-hierarchical delegation. For example, setting the system property osgi.classloader.lock=classname with Equinox is known to cause a deadlock. This is the default option. When specifying the -XX:-VMLockClassLoader option, the VM does not force synchronization on a class loader during class loading. The class loader still conforms to class library synchronization, such as a synchronized loadClass() method.","title":"-XX:[+|-]VMLockClassLoader"},{"location":"xxvmlockclassloader/#-xx91-93vmlockclassloader","text":"This option affects synchronization on class loaders that are not parallel-capable class loaders, during class loading.","title":"-XX:[+|-]VMLockClassLoader"},{"location":"xxvmlockclassloader/#syntax","text":"-XX:[+|-]VMLockClassLoader Setting Effect Default -XX:+VMLockClassLoader Enable yes -XX:-VMLockClassLoader Disable The option, -XX:+VMLockClassLoader , causes the VM to force synchronization on a class loader that is not a parallel capable class loader during class loading. This action occurs even if the loadClass() method for that class loader is not synchronized. For information about parallel capable class loaders, see java.lang.ClassLoader.registerAsParallelCapable() . Note that this option might cause a deadlock if class loaders use non-hierarchical delegation. For example, setting the system property osgi.classloader.lock=classname with Equinox is known to cause a deadlock. This is the default option. When specifying the -XX:-VMLockClassLoader option, the VM does not force synchronization on a class loader during class loading. The class loader still conforms to class library synchronization, such as a synchronized loadClass() method.","title":"Syntax"},{"location":"xzero/","text":"-Xzero Enables reduction of the memory footprint of the Java\u2122 runtime environment when concurrently running multiple Java invocations. This option is deprecated and will be removed in a future release. This option can be used only with Java SE version 8 runtime environments. -Xzero might not be appropriate for all types of applications because it changes the implementation of java.util.ZipFile , which might cause extra memory usage. Syntax Setting Effect -Xzero:none Disable all sub options -Xzero:describe Prints the sub options in effect -Xzero:sharebootzip Enables the sharebootzip sub option -Xzero:nosharebootzip Disables the sharebootzip sub option The following parameters are no longer supported. The options are parsed but do nothing: Setting Effect -Xzero:j9zip Enables the j9zip sub option -Xzero:noj9zip Disables the j9zip sub option -Xzero:sharezip Enables the sharezip sub option -Xzero:nosharezip Disables the sharezip sub option","title":"-Xzero"},{"location":"xzero/#-xzero","text":"Enables reduction of the memory footprint of the Java\u2122 runtime environment when concurrently running multiple Java invocations. This option is deprecated and will be removed in a future release. This option can be used only with Java SE version 8 runtime environments. -Xzero might not be appropriate for all types of applications because it changes the implementation of java.util.ZipFile , which might cause extra memory usage.","title":"-Xzero"},{"location":"xzero/#syntax","text":"Setting Effect -Xzero:none Disable all sub options -Xzero:describe Prints the sub options in effect -Xzero:sharebootzip Enables the sharebootzip sub option -Xzero:nosharebootzip Disables the sharebootzip sub option The following parameters are no longer supported. The options are parsed but do nothing: Setting Effect -Xzero:j9zip Enables the j9zip sub option -Xzero:noj9zip Disables the j9zip sub option -Xzero:sharezip Enables the sharezip sub option -Xzero:nosharezip Disables the sharezip sub option","title":"Syntax"}]}